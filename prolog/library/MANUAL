
 VU University Amsterdam                          University of Amsterdam

~  De1Boelelaan01081a,81 HV  Amsterdam              KruislaanV419,A1098Amsterdam
     The Netherlands                                  The Netherlands

                             SWI-Prolog 7.7
                            Reference Manual
                 _U_p_d_a_t_e_d _f_o_r _v_e_r_s_i_o_n _7_._7_-_1_8_, _J_u_l_y _2_0_1_8

                             _J_a_n _W_i_e_l_e_m_a_k_e_r
                           J.Wielemaker@vu.nl
                       http://www.swi-prolog.org

    SWI-Prolog  is a  comprehensive and portable  implementation of
    the  Prolog  programming language.    SWI-Prolog  aims to  be a
    robust  and scalable implementation supporting  a wide range of
    applications.   In  particular, it  ships with a  wide range of
    interface  libraries, providing interfaces  to other languages,
    databases,  graphics  and networking.    It  provides extensive
    support  for  managing HTML/SGML/XML  and RDF  documents.   The
    system  is particularly suited  for server  applications due to
    robust support for multithreading and HTTP server libraries.

    SWI-Prolog  is  designed  in the  `Edinburgh  tradition'.    In
    addition  to the ISO  Prolog standard it  is largely compatible
    to  Quintus, SICStus  and YAP  Prolog.   SWI-Prolog  provides a
    compatibility  framework developed in cooperation  with YAP and
    instantiated for YAP, SICStus and IF/Prolog.

    SWI-Prolog  aims at  providing a good  development environment,
    including  extensive  editor  support,  graphical  source-level
    debugger,   autoloading  and `make'  facility  and  much  more.
    SWI-Prolog  editor  and  the  PDT  plugin  for Eclipse  provide
    alternative environments.

    This  document gives an overview of the features, system limits
    and built-in predicates.


~

    This  work is licensed under  the Creative Commons Attribution-
    ShareAlike  3.0  Unported License.    To  view a  copy  of this
    license,  visit  http://creativecommons.org/licenses/by-sa/3.0/
    or  send a letter to Creative Commons, 444 Castro Street, Suite
    900, Mountain View, California, 94041, USA.


CChhaapptteerr 11..  IINNTTRROODDUUCCTTIIOONN

This document is a  _r_e_f_e_r_e_n_c_e _m_a_n_u_a_l.  That means that it  documents the
system, but it  does not explain the  basics of the Prolog language  and
it leaves many details of the syntax, semantics  and built-in primitives
undefined  where SWI-Prolog  follows  the standards.    This  manual  is
intended  for people  that are  familiar with  Prolog.    For those  not
familiar with Prolog, we recommend to start with  a Prolog textbook such
as [??], [??] or [??].  For more advanced Prolog usage we recommend [??].


11..11 PPoossiittiioonniinngg SSWWII--PPrroolloogg

Most implementations  of the  Prolog language  are designed  to serve  a
limited set  of use cases.    SWI-Prolog is no  exception to this  rule.
SWI-Prolog  positions  itself  primarily as  a  Prolog  environment  for
`programming in the large'  and use cases where it plays a  central role
in an  application, i.e.,  where it acts  as `glue' between  components.
At  the same  time,  SWI-Prolog aims  at  providing a  productive  rapid
prototyping environment.    Its orientation towards  programming in  the
large is backed  up by scalability, compiler speed,  program structuring
(modules), support  for multithreading  to accommodate servers,  Unicode
and interfaces  to a  large number  of document  formats, protocols  and
programming languages.   Prototyping is facilitated by good  development
tools,  both  for  command  line  usage  as  for  usage  with  graphical
development tools.   Demand loading of  predicates from the library  and
a  `make' facility  avoids the  _r_e_q_u_i_r_e_m_e_n_t for  using declarations  and
reduces typing.

SWI-Prolog is traditionally  strong in education because it is  free and
portable, but also  because of its compatibility with textbooks  and its
easy-to-use environment.

Note that these  positions do not imply  that the system cannot be  used
with other scenarios.  SWI-Prolog is used as  an embedded language where
it serves as a small rule subsystem in a large application.   It is also
used as a  deductive database.  In  some cases this is the right  choice
because SWI-Prolog  has features that are  required in the  application,
such as threading or  Unicode support.  In general though,  for example,
GNU-Prolog is  more suited  for embedding  because it is  small and  can
compile to  native code, XSB is  better for deductive databases  because
it provides  advanced resolution  techniques (tabling),  and ECLiPSe  is
better at constraint handling.

The  syntax  and  set  of  built-in  predicates  is  based  on  the  ISO
standard [??].   Most extensions follow the `Edinburgh  tradition' (DEC10
Prolog  and  C-Prolog) and  Quintus  Prolog  [??].    The  infrastructure
for constraint  programming is  based on  hProlog [??].   Some  libraries
are  copied from  the YAP  system.   Together  with YAP  we developed  a
portability framework (see section ????).  This framework  has been filled
for  SICStus Prolog,  YAP, IF/Prolog  and Ciao.    SWI-Prolog version  7
introduces various extensions  to the Prolog language (see section  ????).
The _s_t_r_i_n_g data  type and its supporting  set of built-in predicates  is
compatibility with ECLiPSe.


11..22 SSttaattuuss aanndd rreelleeaasseess

This manual describes version  7.7 of SWI-Prolog.  SWI-Prolog  is widely
considered to  be a  robust and  scalable implementation  of the  Prolog
language.   It is widely used in  education and research.  In  addition,
it  is in  use for  247* mission  critical commercial  server processes.
The site http://www.swi-prolog.org  is hosted using the SWI-Prolog  HTTP
server  infrastructure.    It receives  approximately 2.3  million  hits
and serves  approximately 300 Gbytes on  manual data and downloads  each
month.    SWI-Prolog  applications  range from  student  assignments  to
commercial  applications that  count  more  than one  million  lines  of
Prolog code.

SWI-Prolog has  two development tracks.   _S_t_a_b_l_e  releases have an  even
_m_i_n_o_r version  number (e.g., 6.2.1)  and are released  as a branch  from
the  development version  when  the  development version  is  considered
stable and  there is sufficient  new functionality  to justify a  stable
release.   Stable releases often  get a few  patch updates to deal  with
installation  issues or  major flaws.    A  new _D_e_v_e_l_o_p_m_e_n_t  version  is
typically released  every couple of  weeks as a  snapshot of the  public
git  repository.    `Extra  editions'  of the  development  version  may
be released  after problems  that severely  hindered the  user in  their
progress have been fixed.

Known  bugs that  are  not likely  to be  fixed  soon are  described  as
footnotes in this manual.


11..33 SShhoouulldd II bbee uussiinngg SSWWII--PPrroolloogg??

There  are a  number of  reasons  why it  might be  better  to choose  a
commercial, or another free, Prolog system:

  o _S_W_I_-_P_r_o_l_o_g _c_o_m_e_s _w_i_t_h _n_o _w_a_r_r_a_n_t_i_e_s
    Although   the  developers   or  the  community   often  provide   a
    work-around or a fix for  a bug, there is no place you can go to for
    guaranteed  support.  However, the full source archive  is available
    and can be used  to compile and debug SWI-Prolog using free tools on
    all  major platforms.   Users requiring  more support should  ensure
    access to knowledgeable developers.

  o _P_e_r_f_o_r_m_a_n_c_e _i_s _y_o_u_r _f_i_r_s_t _c_o_n_c_e_r_n
    Various  free and commercial systems have better performance.   But,
    `standard'  Prolog benchmarks disregard many factors that  are often
    critical  to the performance of  large applications.  SWI-Prolog  is
    not  good  at fast  calling of  simple predicates,  but  it is  fast
    with  dynamic code, meta-calling  and predicates that contain  large
    numbers of clauses  or require more advanced clauses indexing.  Many
    of  SWI-Prolog's  built-in  predicates are  written  in C  and  have
    excellent performance.

  o _Y_o_u _n_e_e_d _f_e_a_t_u_r_e_s _n_o_t _o_f_f_e_r_e_d _b_y _S_W_I_-_P_r_o_l_o_g
    Todays  SWI-Prolog  supports  most  features  available  from  other
    Prolog  systems.  Still, there  are features that are not  or poorly
    supported.    Examples  are  tabling which,  although  provided,  is
    rather  slow  and does  not support  e.g.,  _i_n_c_r_e_m_e_n_t_a_l _t_a_b_l_i_n_g  and
    _w_e_l_l  _f_o_r_m_e_d _s_e_m_a_n_t_i_c_s.  If you require additional features  and you
    have  resources, be  it financial or  expertise, please contact  the
    developers.

On the  other hand,  SWI-Prolog offers some  facilities that are  widely
appreciated by users:

  o _N_i_c_e _e_n_v_i_r_o_n_m_e_n_t
    SWI-Prolog  provides a good command line environment,  including `Do
    What I Mean',  autocompletion, history and a tracer that operates on
    single  key strokes.   The system automatically recompiles  modified
    parts  of the source code using the make/0 command.  The  system can
    be  instructed to  open an arbitrary  editor on  the right file  and
    line based on its  source database.  It ships with various graphical
    tools  and can be combined with the SWI-Prolog editor,  PDT (Eclipse
    plugin for Prolog), VScode or GNU-Emacs.

  o _F_a_s_t _c_o_m_p_i_l_e_r
    Even  very  large applications  can  be loaded  in seconds  on  most
    machines.   If this is not  enough, there is the Quick  Load Format.
    See qcompile/1 and qsave_program/2.

  o _T_r_a_n_s_p_a_r_e_n_t _c_o_m_p_i_l_e_d _c_o_d_e
    SWI-Prolog  compiled code can be  treated just as interpreted  code:
    you  can list it, trace  it, etc.  This  implies you do not have  to
    decide  beforehand whether a module  should be loaded for  debugging
    or  not, and the  performance of debugged code  is close to that  of
    normal operation.

  o _S_o_u_r_c_e _l_e_v_e_l _d_e_b_u_g_g_e_r
    The  source  level   debugger  provides  a  good  overview  of  your
    current  location  in  the  search  tree,  variable  bindings,  your
    source  code  and  open choice  points.    Choice  point  inspection
    provides  meaningful insight to both novices and  experienced users.
    Avoiding unintended choice  points often provides a huge increase in
    performance and a huge saving in memory usage.

  o _P_r_o_f_i_l_i_n_g
    SWI-Prolog  offers an execution profiler with either  textual output
    or  graphical output.   Finding and  improving hotspots in a  Prolog
    program may result in huge speedups.

  o _F_l_e_x_i_b_i_l_i_t_y
    SWI-Prolog  can  easily   be  integrated  with  C,  supporting  non-
    determinism  in Prolog calling  C as well  as C calling Prolog  (see
    section  ????).   It can  also be _e_m_b_e_d_d_e_d  in external programs  (see
    section ????).   System predicates can be redefined locally to provide
    compatibility with other Prolog systems.

  o _T_h_r_e_a_d_s
    Robust  support for multiple threads may improve performance  and is
    a key enabling factor for deploying Prolog in server applications.

  o _I_n_t_e_r_f_a_c_e_s
    SWI-Prolog   ships  with  many   extension  packages  that   provide
    robust  interfaces  to processes,  encryption,  TCP/IP, TIPC,  ODBC,
    SGML/XML/HTML, RDF, JSON, YAML, HTTP, graphics and much more.


11..44 SSuuppppoorrtt tthhee SSWWII--PPrroolloogg pprroojjeecctt

You  can support  the SWI-Prolog  project in  several ways.    Academics
are  invited to  cite one  of the  publications on  SWI-Prolog.    Users
can  help  by  identifying and/or  fixing  problems  with  the  code  or
its  documentation..    Users  can  contribute  new  features  or,  more
lightweight,   contribute  packs.      Commercial  users  may   consider
contacting the  developers to  sponsor the development  of new  features
or seek  for opportunities  to cooperate  with the  developers or  other
commercial users.


11..55 IImmpplleemmeennttaattiioonn hhiissttoorryy

SWI-Prolog started back in  1986 with the requirement for a  Prolog that
could handle recursive interaction with the C-language:   Prolog calling
C and C calling  Prolog recursively.  In those days Prolog  systems were
not very  aware of  their environment  and we  needed such  a system  to
support interactive applications.  Since then,  SWI-Prolog's development
has  been  guided  by  requests  from  the  user  community,  especially
focussing  on (in  arbitrary order)  interaction  with the  environment,
scalability, (I/O)  performance, standard  compliance, teaching and  the
program development environment.

SWI-Prolog  is based  on  a simple  Prolog  virtual machine  called  ZIP
[??,  ??] which  defines  only  7 instructions.     Prolog can  easily  be
compiled into  this language,  and the abstract  machine code is  easily
decompiled  back into  Prolog.    As  it  is  also possible  to  wire  a
standard 4-port debugger in the virtual machine, there is  no need for a
distinction between compiled and interpreted code.   Besides simplifying
the design  of the Prolog  system itself,  this approach has  advantages
for program  development:   the compiler is  simple and  fast, the  user
does  not have  to  decide in  advance  whether debugging  is  required,
and  the system  only runs  slightly slower  in debug  mode compared  to
normal  execution.    The  price we  have  to  pay is  some  performance
degradation (taking  out the debugger from  the VM interpreter  improves
performance by about  20%) and somewhat additional memory usage  to help
the decompiler and debugger.

SWI-Prolog  extends  the  minimal  set  of   instructions  described  in
[??]  to  improve performance.     While extending  this  set,  care  has
been  taken to  maintain  the advantages  of decompilation  and  tracing
of  compiled code.    The  extensions include  specialised  instructions
for unification,  predicate  invocation, some  frequently used  built-in
predicates,  arithmetic,  and control  (;/2,  |/2), if-then  (->/2)  and
negation-by-failure (\+/1).


11..66 AAcckknnoowwlleeddggeemmeennttss

Some small parts of the Prolog code of SWI-Prolog  are modified versions
of the corresponding Edinburgh C-Prolog code:   grammar rule compilation
and  writef/2.    Also some  of  the  C-code originates  from  C-Prolog:
finding the  path of the  currently running executable  and some of  the
code underlying  absolute_file_name/2.   Ideas  on programming style  and
techniques originate from  C-Prolog and Richard O'Keefe's _t_h_i_e_f  editor.
An  important  source  of inspiration  are  the  programming  techniques
introduced by Anjo Anjewierden in PCE version 1 and 2.

Our special  thanks go  to those  who had the  fate of  using the  early
versions of this system,  suggested extensions or reported bugs.   Among
them are Anjo Anjewierden, Huub Knops, Bob  Wielinga, Wouter Jansweijer,
Luc Peerdeman, Eric Nombden, Frank van Harmelen, Bert Rengel.

Martin Jansche  (jansche@novell1.gs.uni-heidelberg.de) has been so  kind
to reorganise the sources  for version 2.1.3 of this manual.   Horst von
Brand has been so kind to fix many typos in the  2.7.14 manual.  Thanks!
Randy Sharp fixed many issues in the 6.0.x version of the manual.

Bart  Demoen and  Tom  Schrijvers  have helped  me  adding  coroutining,
constraints,  global  variables and  support  for  cyclic terms  to  the
kernel.  Tom Schrijvers has provided a first  clp(fd) constraint solver,
the CHR compiler and some of the coroutining predicates.   Markus Triska
contributed the  current clp(fd)  implementation as well  as the  clp(b)
implementation.

Tom  Schrijvers  and   Bart  Demoen  initiated  the  implementation   of
_d_e_l_i_m_i_t_e_d _c_o_n_t_i_n_u_a_t_i_o_n_s (section ????), which was used  by Benoit Desouter
and  Tom Schrijvers  to implement  _t_a_b_l_i_n_g (section  ????)  as a  library.
Fabrizio Riguzzi added a first implementation for  _m_o_d_e _d_i_r_e_c_t_e_d _t_a_b_l_i_n_g
(section ????).

The  SWI-Prolog 7  extensions (section  ????)  are the  result of  a  long
heated discussion on  the mailinglist.   Nicos Angelopoulos' wish for  a
smooth integration with  the R language triggered the overall  intend of
these extensions to  enable a smoother integration of Prolog  with other
languages.    Michael Hendrix  suggested and  helped shaping  SWI-Prolog
_q_u_a_s_i _q_u_o_t_a_t_i_o_n_s.

Paul Singleton has integrated Fred Dushin's  Java-calls-Prolog side with
his Prolog-calls-Java side into the current  bidirectional JPL interface
package.

Richard O'Keefe  is gratefully acknowledged for  his efforts to  educate
beginners as well as valuable comments on proposed new developments.

Scientific  Software and  Systems Limited,  www.sss.co.nz has  sponsored
the  development of  the SSL  library,  unbounded integer  and  rational
number arithmetic and many enhancements to the memory  management of the
system.

Leslie de Koninck has made clp(QR) available to SWI-Prolog.

Jeff  Rosenwald contributed  the TIPC  networking  library and  Google's
protocol buffer handling.

Paulo  Moura's  great   experience  in  maintaining  Logtalk  for   many
Prolog systems  including SWI-Prolog  has helped in  many places  fixing
compatibility issues.   He also worked on the MacOS port and  fixed many
typos in the 5.6.9 release of the documentation.

Kyndi  (https://kyndi.com/) sponsored  the  development of  the  _e_n_g_i_n_e_s
interface (chapter ????).  The final API was  established after discussion
with the founding father of engines, Paul Tarau and Paulo  Moura.  Kyndi
also sponsored JIT indexing on multiple arguments.


CChhaapptteerr 22..  OOVVEERRVVIIEEWW


22..11 GGeettttiinngg ssttaarrtteedd qquuiicckkllyy


22..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg


22..11..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg oonn UUnniixx

By  default, SWI-Prolog  is  installed as  `swipl'.   The  command  line
arguments of SWI-Prolog  itself and its utility programs are  documented
using standard Unix  man pages.   SWI-Prolog is normally operated as  an
interactive application simply by starting the program:

________________________________________________________________________|                                                                        |
|$ swipl                                                                 |

|Welcome to SWI-Prolog ...                                               |
|...                                                                     |
|                                                                        |
|1|?-___________________________________________________________________ | |

After  starting   Prolog,  one   normally  loads   a  program  into   it
using   consult/1,   which   may   be   abbreviated   by   putting   the
name   of   the  program   file   between   square  brackets.        The
following  goal loads  the  file  https://raw.githubusercontent.com/SWI-
Prolog/swipl-devel/master/demo/likes.pllikes.pl  containing clauses  for
the predicates likes/2:

________________________________________________________________________|                                                                        |
|?- [likes].                                                             |
|true.                                                                   |

|                                                                        |
|?-|____________________________________________________________________ |  |

Alternatively, the source file may be given as command line arguments:

________________________________________________________________________|                                                                        |
|$ swipl likes.pl                                                        |
|Welcome to SWI-Prolog ...                                               |
|...                                                                     |
|                                                                        |

|1|?-___________________________________________________________________ | |

After this  point, Unix  and Windows users  unite, so  if you are  using
Unix please continue at section ????.


22..11..11..22 SSttaarrttiinngg SSWWII--PPrroolloogg oonn WWiinnddoowwss

After SWI-Prolog has been  installed on a Windows system,  the following
important new things are available to the user:

  o A  folder  (called  _d_i_r_e_c_t_o_r_y in  the  remainder of  this  document)
    called  swipl containing  the executables, libraries,  etc., of  the
    system.  No files are installed outside this directory.

  o A  program swipl-win.exe,  providing a  window for interaction  with
    Prolog.  The  program swipl.exe is a version of SWI-Prolog that runs
    in a console window.

  o The  file  extension  .pl  is associated  with  the  program  swipl-
    win.exe.    Opening a .pl  file will  cause swipl-win.exe to  start,
    change  directory  to  the  directory  in which  the  file  to  open
    resides, and load this file.

The normal way to start the likes.pl file mentioned in  section ???? is by
simply double-clicking this file in the Windows explorer.


22..11..22 AAddddiinngg rruulleess ffrroomm tthhee ccoonnssoollee

Although we strongly  advice to put your  program in a file,  optionally
edit it and use make/0 to reload it (see section ????),  it is possible to
manage facts and  rules from the terminal.   The most conveniant way  to
add a few clauses is  by consulting the pseudo file user.  The  input is
ended using the system end-of-file character.

________________________________________________________________________|                                                                        |
|?- [user].                                                              |

||: hello :- format('Hello world~n').                                    |
||: ^D                                                                   |
|true.                                                                   |
|                                                                        |
|?- hello.                                                               |
|Hello world                                                             |
|true.|_________________________________________________________________ |     |

The  predicates assertz/1  and  retract/1 are  alternatives to  add  and
remove rules and facts.


22..11..33 EExxeeccuuttiinngg aa qquueerryy

After loading a program,  one can ask Prolog queries about  the program.
The query below asks Prolog what food `sam' likes.   The system responds
with X = <_v_a_l_u_e> if it can prove the goal for a certain _X. The  user can
type the  semi-colon (;)  or spacebar if  (s)he wants another  solution.
Use the return key if  you do not want to see the more answers.   Prolog
completes the output with a  full stop (.)  if the user uses  the return
key or Prolog  _k_n_o_w_s there are no more  answers.  If Prolog cannot  find
(more) answers,  it  writes ffaallssee..    Finally, Prolog  answers using  an
error message to indicate the query or program contains an error.

________________________________________________________________________|                                                                        |
|?- likes(sam, X).                                                       |

|X = dahl ;                                                              |
|X = tandoori ;                                                          |
|...                                                                     |
|X = chips.                                                              |
|                                                                        |
|?-|____________________________________________________________________ |  |

Note  that the  answer  written by  Prolog  is  a valid  Prolog  program
that, when  executed, produces the same  set of answers as the  original
program.


22..11..44 EExxaammiinniinngg aanndd mmooddiiffyyiinngg yyoouurr pprrooggrraamm

If  properly configured,  the predicate  edit/1 starts  the built-in  or
user configured editor  on the argument.   The argument can be  anything
that can be linked to  a location:  a file name, predicate  name, module
name, etc.  If the argument resolves to only one  location the editor is
started on this location, otherwise the user is presented a choice.

If a graphical user interface is available, the  editor normally creates
a new  window and the  system prompts for  the next command.   The  user
may edit the source file, save it and run make/0  to update any modified
source file.   If the editor  cannot be opened in  a window it the  same
console and leaving  the editor runs make/0  to reload any source  files
that have been modified.

________________________________________________________________________|                                                                        |
|?- edit(likes).                                                         |
|                                                                        |
|true.                                                                   |

|?- make.                                                                |
|% /home/jan/src/pl-devel/linux/likes compiled 0.00 sec, 0 clauses       |
|                                                                        |
|?- likes(sam, X).                                                       |
|...|___________________________________________________________________ |   |

The  program can  also be  _d_e_c_o_m_p_i_l_e_d using  listing/1 as  below.    The
argument is  listing/1 is just a  predicate name, a predicate  _i_n_d_i_c_a_t_o_r
of  the form  _N_a_m_e_/_A_r_i_t_y, e.g.,  ?- listing(mild/1).  or a  _h_e_a_d,  e.g.,
?- listing(likes(sam, _)., listing all _m_a_t_c_h_i_n_g clauses.   The predicate
listing/0, i.e., without arguments lists the entire program.

________________________________________________________________________|                                                                        |
|?- listing(mild).                                                       |

|mild(dahl).                                                             |
|mild(tandoori).                                                         |
|mild(kurma).                                                            |
|                                                                        |
|true.|_________________________________________________________________ |     |


22..11..55 SSttooppppiinngg PPrroolloogg

The interactive toplevel can  be stopped in two ways:  enter  the system
end-of-file character (typically  _C_o_n_t_r_o_l_-_D) or by executing the  halt/0
predicate:

________________________________________________________________________|                                                                        |
|?- halt.                                                                |

|$|_____________________________________________________________________ | |


22..22 TThhee uusseerr''ss iinniittiiaalliissaattiioonn ffiillee

After the  system initialisation,  the system  consults (see  consult/1)
the user's startup file.  The basename of  this file follows conventions
of  the operating  system.   On  MS-Windows,  it is  the file  swipl.ini
and  on  Unix  systems  .swiplrc.    The  file  is  searched  using  the
file_search_path/2 clauses for user_profile.  The table below  shows the
default value for this search  path.  The phrase <_a_p_p_d_a_t_a> refers to the
Windows CSIDL  name for  the folder.   The  actual name  depends on  the
Windows language.  English versions typically use ApplicationData.   See
also win_folder/2

                   __________________________________
                   |____________|UUnniixx__||WWiinnddoowwss__________________________ ||
                   ||_hhoommee_||~___|<_a_p_p_d_a_t_a>/SWI-Prolog_|

After the  first startup  file is found  it is  loaded and Prolog  stops
looking for further startup files.  The name of the  startup file can be
changed with the  `-f file' option.   If _F_i_l_e denotes an absolute  path,
this file is loaded,  otherwise the file is searched for using  the same
conventions as for the default startup file.  Finally,  if _f_i_l_e is none,
no file is loaded.

The installation provides  a file customize/dotswiplrc with  (commented)
commands that are often used to customize the behaviour  of Prolog, such
as interfacing  to the  editor, color selection  or history  parameters.
Many  of the  development tools  provide menu  entries  for editing  the
startup  file  and  starting  a  fresh  startup  file  from  the  system
skeleton.

See  also  the  -s  (script)  and  -F  (system-wide  initialisation)  in
section ???? and section ????.


22..33 IInniittiiaalliissaattiioonn ffiilleess aanndd ggooaallss

Using  command  line arguments  (see  section  ????),  SWI-Prolog  can  be
forced to load files and execute queries for  initialisation purposes or
non-interactive operation.   The most commonly used options  are -f file
or -s file to make Prolog load a file,  -g goal to define initialisation
goals and  -t goal to define  the _t_o_p_-_l_e_v_e_l  _g_o_a_l.   The following is  a
typical example  for starting an application  directly from the  command
line.

________________________________________________________________________|                                                                        |
|machine%|swipl_-s_load.pl_-g_go_-t_halt________________________________ |        |

It  tells  SWI-Prolog to  load  load.pl,  start  the  application  using
the _e_n_t_r_y  _p_o_i_n_t go/0  and ---instead  of entering  the interactive  top
level--- exit after completing go/0.

The command line may  have multiple -g goal occurrences.  The  goals are
executed  in order.    Possible choice  points of  individual goals  are
pruned.  If a _g_o_a_l fails execution stops with exit status 1.   If a _g_o_a_l
raises an  exception, the  exception is  printed and  the process  stops
with exit code 2.

The -q  may be used  to suppress all informational  messages as well  as
the error  message that is  normally printed  if an initialisation  goal
_f_a_i_l_s.

In  MS-Windows,  the  same  can  be  achieved  using  a  short-cut  with
appropriately  defined  command  line  arguments.     A  typically  seen
alternative  is to  write  a file  run.pl  with content  as  illustrated
below.  Double-clicking run.pl will start the application.

________________________________________________________________________|                                                                        |

|:- [load].                      % load program                          |
|:- go.                          % run it                                |
|:-|halt.________________________%_and_exit_____________________________ |  |

Section  ????  discusses   further  scripting  options,  and   chapter  ????
discusses the  generation of runtime executables.   Runtime  executables
are  a means  to deliver  executables  that do  not require  the  Prolog
system.


22..44 CCoommmmaanndd lliinnee ooppttiioonnss

SWI-Prolog can be executed in one of the following modes:

swipl --help
swipl --version
swipl --arch
swipl --dump-runtime-variables
    These  options must appear  as only  option.   They cause Prolog  to
    print an informational message and exit.  See section ????.

swipl [[_o_p_t_i_o_n ......]]  _s_c_r_i_p_t_-_f_i_l_e [[_a_r_g ......]]
    These arguments are  passed on Unix systems if file that starts with
    #!/path/to/executable [_o_p_t_i_o_n ...]  is  executed.   Arguments  after
    the script file are made available in the Prolog flag argv.

swipl [[_o_p_t_i_o_n ......]]  _p_r_o_l_o_g_-_f_i_l_e ......  [[[[--]] _a_r_g ......]]
    This  is the normal way to start Prolog.  The options  are described
    in  section ????, section  ???? and section  ????.   The Prolog flag  argv
    provides  access  to  _a_r_g  ...    If  the _o_p_t_i_o_n_s  are  followed  by
    one  or more  Prolog file  names  (i.e., names  with extension  .pl,
    .prolog  or (on  Windows)  the user  preferred extension  registered
    during  installation),  these files  are  loaded.   The  first  file
    is  registered in  the Prolog  flag associated_file.   In  addition,
    pl-win[.exe] switches to  the directory in which this primary source
    file is located using working_directory/2.

swipl --oo _o_u_t_p_u_t --cc _p_r_o_l_o_g_-_f_i_l_e ......
    The  -c option  is used to  compile a  set of Prolog  files into  an
    executable.  See section ????.

swipl --oo _o_u_t_p_u_t --bb _b_o_o_t_f_i_l_e _p_r_o_l_o_g_-_f_i_l_e ......
    Bootstrap compilation.  See section ????.


22..44..11 IInnffoorrmmaattiioonnaall ccoommmmaanndd lliinnee ooppttiioonnss

--arch
    When   given  as  the  only  option,  it  prints   the  architecture
    identifier   (see  Prolog  flag   arch)  and  exits.      See   also
    -dump-runtime-variables.  Also available as -arch.

--dump-runtime-variables _[_=_f_o_r_m_a_t_]
    When  given as  the only option,  it prints  a sequence of  variable
    settings   that  can  be  used   in  shell  scripts  to  deal   with
    Prolog  parameters.   This  feature is  also used  by swipl-ld  (see
    section ????).  Below is a typical example of using this feature.

    ____________________________________________________________________|                                                                    |
    | eval `swipl --dump-runtime-variables`                              |

    ||cc_-I$PLBASE/include_-L$PLBASE/lib/$PLARCH_...____________________ ||

    The  option can be  followed by  =sh to dump  in POSIX shell  format
    (default) or =cmd to dump in MS-Windows cmd.exe compatible format.

--help
    When  given as  the only  option, it summarises  the most  important
    options.  Also available as -h and -help.

--version
    When  given as the  only option, it  summarises the version and  the
    architecture identifier.  Also available as -v.


22..44..22 CCoommmmaanndd lliinnee ooppttiioonnss ffoorr rruunnnniinngg PPrroolloogg

--home=DIR
    Use DIR as home directory.  See section ???? for details.

--quiet
    Set  the Prolog  flag verbose to  silent, suppressing  informational
    and banner messages.  Also available as -q.

--nodebug
    Disable   debugging.        See   the   current_prolog_flag/2   flag
    generate_debug_info for details.

--nosignals
    Inhibit any signal  handling by Prolog, a property that is sometimes
    desirable  for embedded  applications.   This option  sets the  flag
    signals  to false.    See section  ???? for details.    Note that  the
    handler  to unblock system  calls is still installed.   This can  be
    prevented using --sigalert=0 additionally.  See --sigalert.

--pldoc _[_=_p_o_r_t_]
    Start  the PlDoc  documentation system  on a free  network port  and
    launch  the user's  browser on  http://localhost:_p_o_r_t.   If _p_o_r_t  is
    specified,  the server is started at the given port and  the browser
    is _n_o_t launched.

--sigalert=NUM
    Use  signal _N_U_M  (1...31) for  alerting a thread.    This is  needed
    to  make  thread_signal/2,  and derived  Prolog  signal handling  act
    immediately  when the target thread  is blocked on an  interruptable
    system  call  (e.g., sleep/1,  read/write  to most  devices).    The
    default is to use SIGUSR2.   If _N_U_M is 0 (zero), this handler is not
    installed.   See prolog_alert_signal/2to query or  modify this value
    at runtime.

-tty
    Unix  only.      Switches  controlling  the  terminal  for  allowing
    single-character  commands to the tracer and  get_single_char/1.   By
    default,  manipulating  the terminal  is enabled  unless the  system
    detects  it is not  connected to a  terminal or it  is running as  a
    GNU-Emacs inferior process.  See also tty_control.

--win_app
    This  option  is   available  only  in  swipl-win.exe  and  is  used
    for  the  start-menu  item.     If causes  plwin  to  start  in  the
    folder  ...\My Documents\Prolog  or  local equivalent  thereof  (see
    win_folder/2).   The Prolog subdirectory  is created if it does  not
    exist.

-O
    Optimised  compilation.  See current_prolog_flag/2flag  optimise for
    details.

-l _f_i_l_e
    Load  _f_i_l_e.    This  flag  provides  compatibility with  some  other
    Prolog  systems.    It is  used in  SWI-Prolog to  skip the  program
    initialization  specified using  initialization/2 directives.    See
    also section ????, and initialize/0.

-s _f_i_l_e
    Use  _f_i_l_e as a  script file.   The script file  is loaded after  the
    initialisation  file  specified with  the -f file  option.    Unlike
    -f file,  using -s does  not stop Prolog  from loading the  personal
    initialisation file.

-f _f_i_l_e
    Use  _f_i_l_e as  initialisation file  instead of  the default  .swiplrc
    (Unix)  or swipl.ini  (Windows).   `-f none'  stops SWI-Prolog  from
    searching  for  a startup  file.   This  option can  be  used as  an
    alternative  to -s file that stops Prolog from loading  the personal
    initialisation file.  See also section ????.

-F _s_c_r_i_p_t
    Select  a startup script  from the SWI-Prolog  home directory.   The
    script  file  is named  <_s_c_r_i_p_t>.rc.    The  default _s_c_r_i_p_t  name  is
    deduced  from  the  executable,  taking the  leading  alphanumerical
    characters  (letters, digits and underscore) from the  program name.
    -F none stops looking  for a script.  Intended for simple management
    of  slightly different  versions.   One  could,  for example,  write
    a  script  iso.rc  and  then select  ISO  compatibility  mode  using
    pl -F iso or make a link from iso-pl to pl.

-x _b_o_o_t_f_i_l_e
    Boot  from _b_o_o_t_f_i_l_e instead  of the system's default  boot file.   A
    boot  file is a file resulting  from a Prolog compilation using  the
    -b or -c option or a program saved using qsave_program/[1,2].

-p _a_l_i_a_s_=_p_a_t_h_1_[_:_p_a_t_h_2 _._._._]
    Define  a  path  alias  for file_search_path.    _a_l_i_a_s  is  the  name
    of  the  alias, and  argpath1 ...    is  a list  of  values for  the
    alias.    On Windows  the list  separator is ;.    On other  systems
    it  is :.   A  value is either  a term of  the form alias(value)  or
    pathname.    The  computed aliases  are added  to file_search_path/2
    using  asserta/1, so they precede  predefined values for the  alias.
    See  file_search_path/2 for  details  on  using this  file  location
    mechanism.

--traditional
    This  flag  disables the  most  important extensions  of  SWI-Prolog
    version  7 (see  section ????) that  introduce incompatibilities  with
    earlier  versions.   In  particular,  lists are  represented in  the
    traditional  way,  double  quoted  text  is represented  by  a  list
    of  character codes  and  the functional  notation on  dicts is  not
    supported.   Dicts  as a syntactic entity,  and the predicates  that
    act on them, are still supported if this flag is present.

--
    Stops  scanning for more  arguments, so you  can pass arguments  for
    your  application after this  one.   See current_prolog_flag/2 using
    the flag argv for obtaining the command line arguments.


22..44..33 CCoonnttrroolllliinngg tthhee ssttaacckk ssiizzeess

As of  version 7.7.14  the stacks  are no  longer limited  individually.
Instead, only the  combined size is limited.   Note that 32 bit  systems
still pose a  128Mb limit.   See section ????.   The combined limit is  by
deault 1Gb on 64 bit machines and 512Mb on 32 bit machines.

For example, to  limit the stacks to 32Gb  use the command below.   Note
that the  stack limits  apply _p_e_r  _t_h_r_e_a_d.   Individual  threads may  be
controlled using  the stack_limit(_+_B_y_t_e_s) option of thread_create.   Any
thread can call set_prolog_flag(_s_t_a_c_k___l_i_m_i_t_, _L_i_m_i_t)  (see stack_limit) to
adjust the  stack limit.   This  limit is  inherited by threads  created
from this thread.

________________________________________________________________________|                                                                        |
|$|swipl_--stack_limit=32g______________________________________________ | |

--stack_limit_s_i_z_e_[_b_k_m_g_]
    Limit the combined  size of the Prolog stacks to the indicated size.
    The suffix specifies the value as _b_y_t_e_s, _K_b_y_t_e_s, _M_b_y_t_e_s or _G_b_y_t_e_s.

-table_space_s_i_z_e_[_b_k_m_g_]
    Limit  for the _t_a_b_l_e  _s_p_a_c_e.  This  is where tries holding  memoized
    answers  for _t_a_b_l_i_n_g  are stored.    The default  is 1Gb  on 64  bit
    machines  and  512Mb on  32  bit  machines.    See the  Prolog  flag
    table_space


22..44..44 RRuunnnniinngg ggooaallss ffrroomm tthhee ccoommmmaanndd lliinnee

-g _g_o_a_l
    _G_o_a_l  is executed just before entering  the top level.  This  option
    may  appear multiple  times.   See section ????  for details.   If  no
    initialization  goal is present the system calls version/0  to print
    the  welcome message.   The welcome  message can be suppressed  with
    --quiet,  but also with -g true.   _g_o_a_l can be  a complex term.   In
    this  case  quotes are  normally  needed to  protect it  from  being
    expanded  by the shell.  A safe way to run a  goal non-interactively
    is below.   If go/0/succeeds -g halt causes the process to stop with
    exit  code 0.  If it fails, the exit code is 1; and if  it raises an
    exception, the exit code is 2.

    ____________________________________________________________________|                                                                    |
    ||%_swipl_<options>_-g_go_-g_halt___________________________________ ||

-t _g_o_a_l
    Use  _g_o_a_l  as interactive  top  level instead  of the  default  goal
    prolog/0.   The _g_o_a_l can be a  complex term.  If the  top-level goal
    succeeds  SWI-Prolog exits  with status  0.   If it  fails the  exit
    status is 1.   If the top level raises an exception, this is printed
    as  an uncaught error  and the top  level is _r_e_s_t_a_r_t_e_d.   This  flag
    also  determines the goal  started by break/0 and  abort/0.  If  you
    want  to prevent the user from entering interactive mode,  start the
    application with `-g goal -t halt'.


22..44..55 CCoommppiillaattiioonn ooppttiioonnss

-c _f_i_l_e _._._.
    Compile files into an `intermediate code file'.  See section ????.

-o _o_u_t_p_u_t
    Used  in combination  with -c  or -b  to determine  output file  for
    compilation.


22..44..66 MMaaiinntteennaannccee ooppttiioonnss

The following options  are for system maintenance.   They are given  for
reference only.

-b _i_n_i_t_f_i_l_e _._._.-c _f_i_l_e _._._.
    Boot  compilation.   _i_n_i_t_f_i_l_e  _._._.   are compiled  by the  C-written
    bootstrap  compiler,  _f_i_l_e  _._._.    by  the normal  Prolog  compiler.
    System maintenance only.

-d _t_o_k_e_n_1_,_t_o_k_e_n_2_,_._._.
    Print  debug messages for  DEBUG statements tagged  with one of  the
    indicated  tokens.  Only has  effect if the system is compiled  with
    the -DO_DEBUG flag.  System maintenance only.


22..55 GGNNUU EEmmaaccss IInntteerrffaaccee

Unfortunately the  default Prolog mode  of GNU Emacs  is not very  good.
There are several alternatives though:

  o https://bruda.ca/emacs/prolog_mode_for_emacs
    Prolog mode for Emacs and XEmacs maintained by Stefan Bruda.

  o https://www.metalevel.at/pceprolog/
    Recommended  configuration  options  for editing  Prolog  code  with
    Emacs.

  o https://www.metalevel.at/ediprolog/
    Interact with SWI-Prolog directly in Emacs buffers.

  o https://www.metalevel.at/etrace/
    Trace Prolog code with Emacs.


22..66 OOnnlliinnee HHeellpp

SWI-Prolog  provides an  online  help system  that covers  this  manual.
If  the  XPCE  graphics  system  is  available,   online  help  opens  a
graphical  window.     Otherwise  the  documentation  is  shown  in  the
Prolog  console.    The help  system  is  controlled by  the  predicates
below.   Note  that this  help system  only covers  the core  SWI-Prolog
manual.  The website provides an integrated manual  that covers the core
system as  well as  all standard  extension packages.    It is  possible
to  install  the  SWI-Prolog website  locally  by  cloning  the  website
repository git://www.swi-prolog.org/home/pl/git/plweb.git and  following
the instructions in the README file.


hheellpp
    Equivalent to help(help/1).


hheellpp((_+_W_h_a_t))
    Show specified part of the manual.  _W_h_a_t is one of:

          <_N_a_m_e>/<_A_r_i_t_y> Give help on specified predicate
          <_N_a_m_e>         Give  help on  named  predicate with  any
                         arity or  C interface function  with that
                         name
          <_S_e_c_t_i_o_n>      Display  specified  section.      Section
                         numbers are dash-separated  numbers:  2-3
                         refers  to  section 2.3  of  the  manual.

                         Section   numbers  are   obtained   using
                         apropos/1.

    Examples:

       ?- help(assert).     Give help on predicate assert
       ?- help(3-4).        Display section 3.4 of the manual
       ?- help('PL_retry'). Give    help   on    interface   function
                            PL_retry()

    See   also  apropos/1  and  the   SWI-Prolog  home  page  at   http:
    //www.swi-prolog.org,  which  provides a  FAQ,  an HTML  version  of
    the  manual  for online  browsing,  and HTML  and PDF  versions  for
    downloading.


aapprrooppooss((_+_P_a_t_t_e_r_n))
    Display all predicates,  functions and sections that have _P_a_t_t_e_r_n in
    their  name or summary  description.   Lowercase letters in  _P_a_t_t_e_r_n
    also match a corresponding uppercase letter.  Example:

            ?- apropos(file).  Display   predicates,   functions
                               and  sections  that  have  `file'
                               (or  `File',  etc.)     in  their
                               summary description.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n))
    Give an explanation on  the given `object'.  The argument may be any
    Prolog  data object.   If  the argument is  an atom,  a term of  the
    form  _N_a_m_e_/_A_r_i_t_y or a term of the form  _M_o_d_u_l_e_:_N_a_m_e_/_A_r_i_t_y, explain/1
    describes  the predicate as well as possible references to it.   See
    also gxref/0.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n_, _-_E_x_p_l_a_n_a_t_i_o_n))
    Unify  _E_x_p_l_a_n_a_t_i_o_n with an explanation for _T_o_E_x_p_l_a_i_n.   Backtracking
    yields further explanations.


22..77 CCoommmmaanndd lliinnee hhiissttoorryy

SWI-Prolog  offers a  query substitution  mechanism similar  to what  is
seen in Unix shells.  The availability of this  feature is controlled by
set_prolog_flag/2,  using the history Prolog  flag.  By default,  history
is available  if no interactive  command line editor is  available.   To
enable history,  remembering  the last  50 commands,  put the  following
into your startup file (see section ????):

________________________________________________________________________|                                                                        |
|:-|set_prolog_flag(history,_50)._______________________________________ |  |

The history  system allows the  user to compose  new queries from  those
typed  before and  remembered by  the  system.   The  available  history
commands are shown in table ????.  History expansion is  not done if these
sequences appear in quoted atoms or strings.
             ______________________________________________
             | !!.   |Repeat last query                     |
             | !nr.  |Repeat query numbered <_n_r>            |

             | !str. |Repeat last query starting with <_s_t_r> |
             | h.    |Show history of commands              |
             |_!h.___|Show_this_list_______________________ |

                      Table 2.1:  History commands


22..88 RReeuussee ooff ttoopp--lleevveell bbiinnddiinnggss

Bindings resulting  from the  successful execution of  a top-level  goal
are asserted in a database _i_f _t_h_e_y _a_r_e _n_o_t _t_o_o _l_a_r_g_e.   These values may
be reused in  further top-level queries as $Var.   If the same  variable
name is used  in a subsequent query  the system associates the  variable
with the latest binding.  Example:
________________________________________________________________________|                                                                        |
|1 ?- maplist(plus(1), "hello", X).                                      |
|X = [105,102,109,109,112].                                              |
|                                                                        |

|2 ?- format('~s~n', [$X]).                                              |
|ifmmp                                                                   |
|true.                                                                   |
|                                                                        |
|3|?-___________________________________________________________________ | |

                Figure 2.1:  Reusing top-level bindings

Note that variables may be set by executing =/2:

________________________________________________________________________|                                                                        |
|6 ?- X = statistics.                                                    |

|X = statistics.                                                         |
|                                                                        |
|7 ?- $X.                                                                |
|28.00 seconds cpu time for 183,128 inferences                           |
|4,016 atoms, 1,904 functors, 2,042 predicates, 52 modules               |
|55,915 byte codes; 11,239 external references                           |
|                                                                        |
|                      Limit    Allocated       In use                   |

|Heap         :                                624,820 Bytes             |
|Local  stack :    2,048,000        8,192          404 Bytes             |
|Global stack :    4,096,000       16,384          968 Bytes             |
|Trail  stack :    4,096,000        8,192          432 Bytes             |
|true.|_________________________________________________________________ |     |


22..99 OOvveerrvviieeww ooff tthhee DDeebbuuggggeerr

SWI-Prolog has  a 6-port  tracer, extending the  standard 4-port  tracer
[??,  ??] with  two additional  ports.   The  optional  _u_n_i_f_y port  allows
the user  to inspect  the result  after unification of  the head.    The
_e_x_c_e_p_t_i_o_n  port  shows  exceptions raised  by  throw/1  or  one  of  the
built-in predicates.  See section ????.

The standard  ports are called call,  exit, redo, fail  and unify.   The
tracer is started  by the trace/0 command,  when a spy point is  reached
and the system is in debugging mode (see spy/1 and  debug/0), or when an
exception is raised that is not caught.

The interactive top-level  goal trace/0 means ``trace the next  query''.
The tracer shows the  port, displaying the port name, the  current depth
of the  recursion and the goal.   The goal  is printed using the  Prolog
predicate  write_term/2.     The style  is  defined  by the  Prolog  flag
debugger_write_options and can be modified using this flag or  using the
w, p and d commands of the tracer.
________________________________________________________________________|                                                                        |
|min_numlist([H|T], Min) :-                                              |
|        min_numlist(T, H, Min).                                         |
|                                                                        |

|min_numlist([], Min, Min).                                              |
|min_numlist([H|T], Min0, Min) :-                                        |
|        Min1 is min(H, Min0),                                           |
||_______min_numlist(T,_Min1,_Min)._____________________________________ ||

________________________________________________________________________|                                                                        |

|1 ?- visible(+all), leash(-exit).                                       |
|true.                                                                   |
|                                                                        |
|2 ?- trace, min_numlist([3, 2], X).                                     |
|   Call: (7) min_numlist([3, 2], _G0) ? creep                           |

|   Unify: (7) min_numlist([3, 2], _G0)                                  |
|   Call: (8) min_numlist([2], 3, _G0) ? creep                           |
|   Unify: (8) min_numlist([2], 3, _G0)                                  |
|^  Call: (9) _G54 is min(2, 3) ? creep                                  |
|^  Exit: (9) 2 is min(2, 3)                                             |
|   Call: (9) min_numlist([], 2, _G0) ? creep                            |
|   Unify: (9) min_numlist([], 2, 2)                                     |
|   Exit: (9) min_numlist([], 2, 2)                                      |

|   Exit: (8) min_numlist([2], 3, 2)                                     |
|   Exit: (7) min_numlist([3, 2], 2)                                     |
|X|=_2._________________________________________________________________ | |

Figure  2.2:   Example trace  of the  program above  showing all  ports.
The  lines marked  ^ indicate  calls  to _t_r_a_n_s_p_a_r_e_n_t  predicates.    See
section ????.

On _l_e_a_s_h_e_d  _p_o_r_t_s (set  with the  predicate leash/1,  default are  call,
exit, redo and  fail) the user is prompted  for an action.  All  actions
are single-character commands  which are executed wwiitthhoouutt waiting for  a
return, unless the command line option -tty is active.  Tracer options:

+ ((SSppyy))
    Set a spy point (see spy/1) on the current predicate.

- ((NNoo ssppyy))
    Remove the spy point (see nospy/1) from the current predicate.

/ ((FFiinndd))
    Search  for a port.   After the  `/', the user  can enter a line  to
    specify  the port to  search for.   This line consists  of a set  of
    letters  indicating the  port type,  followed by  an optional  term,
    that  should unify with  the goal run by  the port.   If no term  is
    specified  it is taken as a variable, searching for any port  of the
    specified  type.  If an atom is given, any goal whose  functor has a
    name equal to that atom matches.  Examples:

            /f               Search for any fail port

            /fe solve        Search for a  fail or exit  port of
                             any goal with name solve
            /c solve(a, _)   Search for a call to  solve/2 whose
                             first argument is a variable or the
                             atom a
            /a member(_, _)  Search for  any  port on  member/2.
                             This is equivalent to setting a spy

                             point on member/2.

. ((RReeppeeaatt ffiinndd))
    Repeat the last find command (see `/').

A ((AAlltteerrnnaattiivveess))
    Show all goals that have alternatives.

C ((CCoonntteexxtt))
    Toggle  `Show Context'.   If on, the context  module of the goal  is
    displayed  between square  brackets (see  section ????).   Default  is
    off.

L ((LLiissttiinngg))
    List the current predicate with listing/1.

a ((AAbboorrtt))
    Abort Prolog execution (see abort/0).

b ((BBrreeaakk))
    Enter a Prolog break environment (see break/0).

c ((CCrreeeepp))
    Continue execution, stop at next port.  (Also return, space).

d ((DDiissppllaayy))
    Set  the max_depth(_D_e_p_t_h) option of debugger_write_options,  limiting
    the  depth  to which  terms are  printed.    See also  the  w and  p
    options.

e ((EExxiitt))
    Terminate Prolog (see halt/0).

f ((FFaaiill))
    Force failure of the current goal.

g ((GGooaallss))
    Show the list of  parent goals (the execution stack).  Note that due
    to  tail recursion optimization a  number of parent goals might  not
    exist any more.

h ((HHeellpp))
    Show available options (also `?').

i ((IIggnnoorree))
    Ignore the current goal, pretending it succeeded.

l ((LLeeaapp))
    Continue execution, stop at next spy point.

n ((NNoo ddeebbuugg))
    Continue execution in `no debug' mode.

p ((PPrriinntt))
    Set  the Prolog  flag debugger_write_options to  [quoted(true), por-
    tray(true), max_depth(10), priority(699)].  This is the default.

r ((RReettrryy))
    Undo  all actions (except for database and I/O actions) back  to the
    call  port of  the current  goal and  resume execution  at the  call
    port.

s ((SSkkiipp))
    Continue  execution,  stop  at the  next  port  of tthhiiss  goal  (thus
    skipping all calls to children of this goal).

u ((UUpp))
    Continue  execution, stop at the next port of tthhee ppaarreenntt  goal (thus
    skipping  this goal and all calls to  children of this goal).   This
    option is useful to stop tracing a failure driven loop.

w ((WWrriittee))
    Set  the  Prolog flag  debugger_write_options to  [quoted(true), at-
    tributes(write), priority(699)], bypassing portray/1, etc.

The ideal  4-port model  [??] as described  in many  Prolog books [??]  is
not visible  in many  Prolog implementations  because code  optimisation
removes  part  of  the  choice  and  exit  points.     Backtrack  points
are not  shown if  either the  goal succeeded  deterministically or  its
alternatives were  removed using the  cut.  When  running in debug  mode
(debug/0) choice points are only destroyed when removed by the  cut.  In
debug mode, last call optimisation is switched off.

Reference information to  all predicates available for manipulating  the
debugger is in section ????.


22..1100 CCoommppiillaattiioonn


22..1100..11 DDuurriinngg pprrooggrraamm ddeevveellooppmmeenntt

During  program development,  programs  are  normally loaded  using  the
list abbreviation  (?- [load].).   It is common  practice to organise  a
project as a collection  of source files and a _l_o_a_d _f_i_l_e, a  Prolog file
containing only use_module/[1,2] or ensure_loaded/1 directives, possibly
with a definition of the _e_n_t_r_y _p_o_i_n_t of the  program, the predicate that
is  normally used  to start  the program.    This file  is often  called
load.pl.  If the entry point is called _g_o, a typical session starts as:

________________________________________________________________________|                                                                        |
|% swipl                                                                 |

|<banner>                                                                |
|                                                                        |
|1 ?- [load].                                                            |
|<compilation messages>                                                  |
|true.                                                                   |
|                                                                        |
|2 ?- go.                                                                |
|<program|interaction>__________________________________________________ |        |

When  using  Windows,  the  user  may  open  load.pl  from  the  Windows
explorer, which will cause swipl-win.exe to be started  in the directory
holding load.pl.   Prolog loads load.pl  before entering the top  level.
If Prolog is started from an interactive shell, one  may choose the type
swipl -s load.pl.


22..1100..22 FFoorr rruunnnniinngg tthhee rreessuulltt

There are  various options if  you want to make  your program ready  for
real usage.   The best  choice depends on whether  the program is to  be
used only  on machines  holding the SWI-Prolog  development system,  the
size of the program, and the operating system (Unix vs. Windows).


22..1100..22..11 UUssiinngg PPrroollooggSSccrriipptt

A Prolog source  file can be used directly  as a Unix program using  the
Unix #! magic start.  The Unix #! magic is  allowed because if the first
letter of a  Prolog file is #, the  first line is treated as a  comment.
To create  a Prolog  script, use one  of the  two alternatives below  as
first line.    The first  can be  used to bind  a script  to a  specific
Prolog installation, while the latter uses the  default prolog installed
in $PATH.

________________________________________________________________________|                                                                        |
|#!/path/to/swipl                                                        |
|#!/usr/bin/env|swipl___________________________________________________ |              |

The interpretation of  arguments to the executable in the  _H_a_s_h_B_a_n_g line
differs between  Unix-derived systems.    For portability,  the #!  must
be followed  immediately with  an absolute  path to  the executable  and
should have none or one argument.  Neither the  executable path, nor the
argument shall use quotes or spaces.  When started  this way, the Prolog
flag argv  contains the command  line arguments  that follow the  script
invocation.

Starting with version  7.5.8, initialization/2 support the _W_h_e_n  options
program and  main, allowing  for the  following definition  of a  Prolog
script  that evaluates  an arithmetic  expression on  the command  line.
Note that main/0 is defined lib the library main.   It calls main/1 with
the command line arguments after disabling signal handling.

________________________________________________________________________|                                                                        |

|#!/usr/bin/env swipl                                                    |
|                                                                        |
|:- initialization(main, main).                                          |
|                                                                        |
|main(Argv) :-                                                           |
|        concat_atom(Argv, ' ', SingleArg),                              |

|        term_to_atom(Term, SingleArg),                                  |
|        Val is Term,                                                    |
||_______format('~w~n',_[Val])._________________________________________ ||

And here are two example runs:

________________________________________________________________________|                                                                        |
|% ./eval 1+2                                                            |
|3                                                                       |
|% ./eval foo                                                            |

|ERROR:|is/2:_Arithmetic:_`foo/0'_is_not_a_function_____________________ |      |

Prolog script may be lauched for debugging or  inspection purposes using
the -l or  -t.  For example,  -l merely loads the script, ignoring  main
and program initialization.

________________________________________________________________________|                                                                        |
|swipl -l eval 1+1                                                       |
|<banner>                                                                |
|                                                                        |
|?- main.                                                                |

|2                                                                       |
|true.                                                                   |
|                                                                        |
|?-|____________________________________________________________________ |  |

We can also  force the program to  enter the interactive toplevel  after
the application is completed using -t prolog:

________________________________________________________________________|                                                                        |
|swipl -t prolog eval 1+1                                                |
|2                                                                       |

|?-|____________________________________________________________________ |  |

The Windows version simply ignores the #! line.


22..1100..22..22 CCrreeaattiinngg aa sshheellll ssccrriipptt

With  the introduction  of _P_r_o_l_o_g_S_c_r_i_p_t  (see section  ????), using  shell
scripts  as explained  in this  section has  become  redundant for  most
applications.

Especially on  Unix systems  and not-too-large  applications, writing  a
shell script  that simply  loads your  application and  calls the  entry
point is  often a  good choice.    A skeleton  for the  script is  given
below, followed by the Prolog code to obtain the program arguments.

________________________________________________________________________|                                                                        |
|#!/bin/sh                                                               |

|                                                                        |
|base=<absolute-path-to-source>                                          |
|PL=swipl                                                                |
|                                                                        |
|exec|$PL_-q_-f_"$base/load"_--_________________________________________ |    |

________________________________________________________________________|                                                                        |
|:- initialization go.                                                   |
|                                                                        |
|go :-                                                                   |
|        current_prolog_flag(argv, Arguments),                           |
|        go(Arguments).                                                  |

|                                                                        |
|go(Args) :-                                                             |
||_______...____________________________________________________________ ||

On Windows  systems, similar  behaviour can  be achieved  by creating  a
shortcut to Prolog, passing the proper options or writing a .bat file.


22..1100..22..33 CCrreeaattiinngg aa ssaavveedd ssttaattee

For  larger programs,  as  well as  for programs  that are  required  to
run  on systems  that  do not  have  the SWI-Prolog  development  system
installed,  creating a  saved  state is  the  best solution.    A  saved
state  is  created using  qsave_program/[1,2]  or the  -c  command  line
option.     A saved  state  is  a  file  containing  machine-independent
intermediate code in a  format dedicated for fast loading.   Optionally,
the emulator  may be integrated  in the saved  state, creating a  single
file, but machine-dependent,  executable.  This process is  described in
chapter ????.


22..1100..22..44 CCoommppiillaattiioonn uussiinngg tthhee --cc ccoommmmaanndd lliinnee ooppttiioonn

This mechanism loads a series of Prolog source files  and then creates a
saved state as qsave_program/2 does.  The command syntax is:

________________________________________________________________________|                                                                        |
|%|swipl_[option_...]_[-o_output]_-c_file.pl_...________________________ | |

The  _o_p_t_i_o_n_s argument  are  options to  qsave_program/2 written  in  the
format below.    The option names  and their  values are described  with
qsave_program/2.

    --_o_p_t_i_o_n_-_n_a_m_e=_o_p_t_i_o_n_-_v_a_l_u_e

For  example,  to  create  a  stand-alone   executable  that  starts  by
executing main/0  and for which  the source  is loaded through  load.pl,
use the command

________________________________________________________________________|                                                                        |
|%|swipl_--goal=main_--stand_alone=true_-o_myprog_-c_load.pl____________ | |

This performs exactly the same as executing

________________________________________________________________________|                                                                        |
|% swipl                                                                 |

|<banner>                                                                |
|                                                                        |
|?- [load].                                                              |
|?- qsave_program(myprog,                                                |
|                 [ goal(main),                                          |
|                   stand_alone(true)                                    |
|                 ]).                                                    |
|?-|halt._______________________________________________________________ |  |


22..1111 EEnnvviirroonnmmeenntt CCoonnttrrooll ((PPrroolloogg ffllaaggss))

The  predicates  current_prolog_flag/2 and  set_prolog_flag/2 allow  the
user  to examine  and modify  the execution  environment.   It  provides
access  to whether  optional  features are  available on  this  version,
operating  system, foreign  code  environment, command  line  arguments,
version,  as well  as runtime  flags to  control  the runtime  behaviour
of  certain  predicates  to  achieve  compatibility  with  other  Prolog
environments.


ccuurrrreenntt__pprroolloogg__ffllaagg((_?_K_e_y_, _-_V_a_l_u_e))                                  _[_I_S_O_]
    The  predicate current_prolog_flag/2defines an interface  to instal-
    lation  features:  options  compiled in, version,  home, etc.   With
    both  arguments unbound, it will generate all defined  Prolog flags.
    With  _K_e_y  instantiated, it  unifies  _V_a_l_u_e with  the value  of  the
    Prolog flag or fails if the _K_e_y is not a Prolog flag.

    Flags   marked   rrww    can   be   modified   by   the   user   using
    set_prolog_flag/2.     Flag   values  are  typed.      Flags  marked
    as  bool  can  have  the  values  true or  false.     The  predicate
    create_prolog_flag/3 may be  used to create  flags that describe  or
    control  behaviour  of  libraries and  applications.    The  library
    settings  provides  an alternative  interface for  managing  notably
    application parameters.

    Some  Prolog  flags  are  not defined  in  all  versions,  which  is
    normally  indicated in the documentation  below as _`_`_i_f _p_r_e_s_e_n_t  _a_n_d
    _t_r_u_e_'_'.    A boolean  Prolog flag  is true  iff the  Prolog flag  is
    present  aanndd the  _V_a_l_u_e is  the atom  true.   Tests  for such  flags
    should be written as below:

    ____________________________________________________________________|                                                                    |
    |         (   current_prolog_flag(windows, true)                     |
    |         ->  <Do MS-Windows things>                                 |
    |         ;   <Do normal things>                                     |

    ||________)_________________________________________________________ ||

    Some  Prolog  flags are  scoped to  a  source file.    This  implies
    that  if they  are set  using a directive  inside a  file, the  flag
    value encountered when  loading of the file started is restored when
    loading  of the file is completed.   Currently, the following  flags
    are scoped to the source file:  generate_debug_info and optimise.

    A new thread (see  section ????) _c_o_p_i_e_s all flags from the thread that
    created the new thread  (its _p_a_r_e_n_t).  As a consequence, modifying a
    flag inside a thread does not affect other threads.

    aacccceessss__lleevveell _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This flag  defines  a normal  `user'  view (user,  default)  or
         a `system'  view.   In  system view  all system  code is  fully
         accessible as  if  it was  normal user  code.    In user  view,
         certain operations are not permitted and some  details are kept
         invisible.   We  leave the exact  consequences undefined,  but,
         for example, system code can be traced using  system access and
         system predicates can be redefined.

    aaddddrreessss__bbiittss _(_i_n_t_e_g_e_r_)
         Address size  of the  hosting  machine.   Typically  32 or  64.
         Except for the maximum  stack limit, this has few  implications
         to the user.  See also the Prolog flag arch.

    aaggcc__mmaarrggiinn _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If this amount  of atoms possible  garbage atoms exist  perform
         atom garbage  collection at  the  first opportunity.    Initial
         value is  10,000.    May  be changed.    A  value of  0  (zero)
         disables atom garbage collection.  See also PL_register_atom().

    aappppllee _(_b_o_o_l_)
         If present and  true, the operating  system is MacOSX.  Defined
         if the C  compiler used to  compile this version of  SWI-Prolog
         defines __APPLE__.    Note that the  unix is  also defined  for
         MacOSX.

    aallllooww__ddoott__iinn__aattoomm _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true (default  false),  dots  may be  embedded  into  atoms
         that are  not quoted and  start with  a letter.   The  embedded
         dot _m_u_s_t  be followed by  an identifier continuation  character
         (i.e.,  letter, digit  or  underscore).    The dot  is  allowed
         in  identifiers  in many  languages,  which  can  make  this  a
         useful flag for defining  DSLs.  Note that this  conflicts with
         cascading functional notation.   For example,  Post.meta.author
         is read as .(Post, 'meta.author' if this flag is set to true.

    aallllooww__vvaarriiaabbllee__nnaammee__aass__ffuunnccttoorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default  is false),  Functor(arg) is  read  as if  it
         were written 'Functor'(arg).  Some applications  use the Prolog
         read/1  predicate for  reading  an  application-defined  script
         language.   In these  cases, it is  often difficult to  explain
         to  non-Prolog users  of  the  application that  constants  and
         functions can only  start with a  lowercase letter.   Variables
         can be  turned into atoms  starting with  an uppercase atom  by
         calling read_term/2 using the option variable_names and binding
         the variables to their name.   Using this feature, F(x)  can be
         turned into valid syntax for such script languages.   Suggested
         by Robert van Engelen.  SWI-Prolog specific.

    aarrggvv _(_l_i_s_t_, _c_h_a_n_g_e_a_b_l_e_)
         List is a  list of atoms  representing the application  command
         line  arguments.     Application  command  line  arguments  are
         those  that  have _n_o_t  been  processed  by  Prolog  during  its
         initialization.   Note that Prolog's argument processing  stops
         at -- or the first non-option argument.  See also os_argv.

    aarrcchh _(_a_t_o_m_)
         Identifier for  the  hardware and  operating system  SWI-Prolog
         is running  on.   Used to  select foreign files  for the  right
         architecture.  See also section ???? and file_search_path/2.

    aassssoocciiaatteedd__ffiillee _(_a_t_o_m_)
         Set if  Prolog  was started  with a  prolog  file as  argument.
         Used by e.g., edit/0 to edit the initial file.

    aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default) autoloading of library functions is enabled.

    bbaacckk__qquuootteess _(_c_o_d_e_s_,_c_h_a_r_s_,_s_t_r_i_n_g_,_s_y_m_b_o_l___c_h_a_r_, _c_h_a_n_g_e_a_b_l_e_)
         Defines the term-representation for back-quoted material.   The
         default is  codes.    If --traditional  is given,  the  default
         is symbol_char, which allows  using ` in operators composed  of
         symbols..  See also section ????.

    bbaacckkttrraaccee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default), print a backtrace on an uncaught exception.

    bbaacckkttrraaccee__ddeepptthh _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If backtraces  on errors  are enabled,  this  flag defines  the
         maximum number of frames that is printed (default 20).

    bbaacckkttrraaccee__ggooaall__ddeepptthh _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         The frame  of a  backtrace is  printed after  making a  shallow
         copy of the goal.  This flag determines the depth  to which the
         goal term is copied.  Default is `3'.

    bbaacckkttrraaccee__sshhooww__lliinneess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default), try to reconstruct the line  number at which
         the exception happened.

    bboouunnddeedd _(_b_o_o_l_)
         ISO Prolog  flag.   If  true, integer  representation is  bound
         by  min_integer and max_integer.    If  false integers  can  be
         arbitrarily large and  the min_integer and max_integer are  not
         present.  See section ????.

    bbrreeaakk__lleevveell _(_i_n_t_e_g_e_r_)
         Current break-level.   The initial top level (started  with -t)
         has value 0.   See break/0.   This flag is absent from  threads
         that are not running a top-level loop.

    cc__cccc _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Name of the  C compiler used to  compile SWI-Prolog.   Normally
         either gcc or cc.  See section ????.

    cc__ccffllaaggss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         CFLAGS used to compile SWI-Prolog.  See section ????.

    cc__llddffllaaggss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         LDFLAGS used to link SWI-Prolog.  See section ????.

    cc__lliibbss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Libraries needed  to  link executables  that embed  SWI-Prolog.
         Typically -lswipl if the  SWI-Prolog kernel is a shared  (DLL).
         If the  SWI-Prolog kernel  is in  a static  library, this  flag
         also contains the dependencies.

    cc__lliibbppllssoo _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Libraries needed  to link  extensions (shared  object, DLL)  to
         SWI-Prolog.   Typically  empty on  ELF systems  and -lswipl  on
         COFF-based systems.  See section ????.

    cchhaarr__ccoonnvveerrssiioonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  whether  character  conversion  takes  place  while
         reading terms.  See also char_conversion/2.

    cchhaarraacctteerr__eessccaappeess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default),  read/1 interprets  \  escape sequences  in
         quoted atoms and strings.  May be changed.   This flag is local
         to the module in which it is changed.  See section ????.

    ccoolloonn__sseettss__ccaalllliinngg__ccoonntteexxtt _(_b_o_o_l_)
         Using the construct <_m_o_d_u_l_e>:<_g_o_a_l> sets the _c_a_l_l_i_n_g _c_o_n_t_e_x_t for
         executing <_g_o_a_l>.    This  flag is  defined by  ISO/IEC 13211-2
         (Prolog modules standard).  See section ????.

    ccoolloorr__tteerrmm _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         This flag is managed  by library ansi_term, which is loaded  at
         startup if the two conditions  below are both true.   Note that
         this implies that  setting this flag  to false from the  system
         or  personal  initialization  file  (see  section  ????  disables
         colored output.   The predicate message_property/2 can be  used
         to control  the actual  color scheme depending  in the  message
         type passed to print_message/2.

           o stream_property(current_output, tty(true))

           o \+ current_prolog_flag(color_term, false)

    ccoommppiillee__mmeettaa__aarrgguummeennttss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Experimental  flag  that  controls  compilation   of  arguments
         passed to meta-calls marked `0'  or `^' (see meta_predicate/1).
         Supported values are:

         ffaallssee
             (default).  Meta-arguments are passed verbatim.

         ccoonnttrrooll
             Compile  meta-arguments  that  contain  control  structures
             ((A,B),  (A;B),  (A->B;C),  etc.).    If  not  compiled  at
             compile  time, such arguments  are compiled to a  temporary
             clause  before  execution.    Using  this  option  enhances
             performance  of  processing  complex  meta-goals  that  are
             known at compile time.

         ttrruuee
             Also  compile references to normal  user predicates.   This
             harms  performance (a  little), but enhances  the power  of
             poor-mens consistency check used  by make/0 and implemented
             by list_undefined/0.

         aallwwaayyss
             Always  create  an  intermediate clause,  even  for  system
             predicates.     This  prepares  for  replacing  the  normal
             head  of the generated predicate  with a special  reference
             (similar   to  database  references  as   used  by,   e.g.,
             assert/2)  that provides  direct access  to the  executable
             code,  thus  avoiding  runtime  lookup  of  predicates  for
             meta-calling.

    ccoommppiilleedd__aatt _(_a_t_o_m_)
         Describes when the  system has been  compiled.  Only  available
         if  the C  compiler used  to  compile SWI-Prolog  provides  the
         __DATE__and __TIME__macros.

    ccoonnssoollee__mmeennuu _(_b_o_o_l_)
         Set  to true  in swipl-win.exe  to  indicate that  the  console
         supports menus.  See also section ????.

    ccppuu__ccoouunntt _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         Number of physical  CPUs or cores in the  system.  The flag  is
         marked read-write both to allow pretending the  system has more
         or less processors.   See also thread_setconcurrency/2 and  the
         library thread.   This flag is  not available on systems  where
         we do not  know how to get  the number of CPUs.   This flag  is
         not included in a saved state (see qsave_program/1).

    ddddee _(_b_o_o_l_)
         Set  to  true  if this  instance  of  Prolog  supports  DDE  as
         described in section ????.

    ddeebbuugg _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Switch debugging  mode  on/off.   If  debug  mode is  activated
         the system traps encountered  spy points (see spy/1) and  trace
         points (see  trace/1).    In addition,  last-call  optimisation
         is disabled and the  system is more conservative in  destroying
         choice points to simplify debugging.

         Disabling these optimisations can  cause the system to run  out
         of memory on  programs that behave  correctly if debug mode  is
         off.

    ddeebbuugg__oonn__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  start  the  tracer  after   an  error  is  detected.
         Otherwise  just continue  execution.    The  goal  that  raised
         the  error will  normally  fail.    See  also the  Prolog  flag
         report_error.  Default is true.

    ddeebbuuggggeerr__wwrriittee__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument is  given  as  option-list to  write_term/2  for
         printing goals by the debugger.   Modified by the `w',  `p' and
         `<N> d' commands  of the debugger.   Default is  [quoted(true),
         portray(true), max_depth(10), attributes(portray)].

    ddeebbuuggggeerr__sshhooww__ccoonntteexxtt _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, show  the context module while printing a  stack-frame
         in the  tracer.   Normally controlled using  the `C' option  of
         the tracer.

    ddiiaalleecctt _(_a_t_o_m_)
         Fixed to swi.   The code below  is a reliable and portable  way
         to detect SWI-Prolog.

         _______________________________________________________________|                                                               |
         |is_dialect(swi) :-                                             |
         ||_______catch(current_prolog_flag(dialect,_swi),__,_fail).____ ||

    ddoouubbllee__qquuootteess _(_c_o_d_e_s_,_c_h_a_r_s_,_a_t_o_m_,_s_t_r_i_n_g_, _c_h_a_n_g_e_a_b_l_e_)
         This flag  determines how  double  quoted strings  are read  by
         Prolog  and  is  ---like character_escapes  and  back_quotes---
         maintained  for  each   module.      The  default  is   string,
         which  produces a  string  as described  in  section  ????.    If
         --traditional is  given, the default  is codes, which  produces
         a list of  character codes, integers  that represent a  Unicode
         code-point.  The  value chars produces a list  of one-character
         atoms  and the  value  atom makes  double  quotes the  same  as
         single quotes, creating a atom.  See also section ????.

    eeddiittoorr _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines the  editor used  by  edit/1.   See  section ????  for
         details on selecting the editor used.

    eemmaaccss__iinnffeerriioorr__pprroocceessss _(_b_o_o_l_)
         If  true,  SWI-Prolog is  running  as an  _i_n_f_e_r_i_o_r  _p_r_o_c_e_s_s  of
         (GNU/X-)Emacs.   SWI-Prolog  assumes this  is the  case if  the
         environment variable EMACS is t and INFERIOR is yes.

    eennccooddiinngg _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Default encoding  used for  opening files in  text mode.    The
         initial value is deduced from the environment.   See section ????
         for details.

    eexxeeccuuttaabbllee _(_a_t_o_m_)
         Pathname of the running executable.  Used by qsave_program/2 as
         default emulator.

    eexxiitt__ssttaattuuss _(_i_n_t_e_g_e_r_)
         Set  by  halt/1  to  its  argument,   making  the  exit  status
         available to hooks registered with at_halt/1.

    ffiillee__nnaammee__ccaassee__hhaannddlliinngg _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This flag defines  how Prolog handles  the case of file  names.
         The  flag is  used  for  case normalization  and  to  determine
         whether two names refer  to the same file.   It has one of  the
         following values:

         ccaassee__sseennssiittiivvee
             The  filesystem  is fully  case  sensitive.    Prolog  does
             not  perform  any  case modification  or  case  insensitive
             matching.  This is the default on Unix systems.

         ccaassee__pprreesseerrvviinngg
             The  filesystem is case insensitive,  but it preserves  the
             case with  which the user jas created a file.  This  is the
             default on Windows systems.

         ccaassee__iinnsseennssiittiivvee
             The  filesystem  doesn't store  or match  case.    In  this
             scenario Prolog maps all file names to lower case.

    ffiillee__nnaammee__vvaarriiaabblleess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (default  false),  expand  $_v_a_r_n_a_m_e   and  ~  in  ar-
         guments  of  built-in  predicates  that  accept  a   file  name
         (open/3, exists_file/1,  access_file/2,  etc.).   The  predicate
         expand_file_name/2 can be used to expand environment  variables
         and  wildcard patterns.    This  Prolog  flag is  intended  for
         backward compatibility with older versions of SWI-Prolog.

    ffiillee__sseeaarrcchh__ccaacchhee__ttiimmee _(_n_u_m_b_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         Time   in    seconds    for   which    search   results    from
         absolute_file_name/3  are   cached.        Within   this   time
         limit, the system will  first check that the old  search result
         satisfies  the  conditions.    Default  is  10  seconds,  which
         typically avoids most  repetitive searches for (library)  files
         during compilation.   Setting this  value to 0 (zero)  disables
         the cache.

    ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default), the garbage collector is active.   If false,
         neither garbage collection,  nor stack shifts will take  place,
         even not on explicit request.  May be changed.

    ggcc__tthhrreeaadd _(_b_o_o_l_)
         If true  (default if  threading is  enabled),  atom and  clause
         garbage collection are executed  in a seperate thread with  the
         _a_l_i_a_s  gc.    Otherwise  the thread  that  detected  sufficient
         garbage  executes the  garbage collector.    As  running  these
         global collectors  may take relatively  long, using a  seperate
         thread improves  real time  behaviour.   The gc  thread can  be
         controlled using set_prolog_gc_thread/1.

    ggeenneerraattee__ddeebbuugg__iinnffoo _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default) generate  code  that can  be debugged  using
         trace/0, spy/1, etc.   Can be set to false using  the -nodebug.
         This  flag is  scoped  within  a source  file.    Many  of  the
         libraries  have  :- set_prolog_flag(generate_debug_info, false)
         to hide their details from a normal trace.

    ggmmpp__vveerrssiioonn _(_i_n_t_e_g_e_r_)
         If  Prolog is  linked  with  GMP,  this flag  gives  the  major
         version of the GMP library used.  See also section ????.

    gguuii _(_b_o_o_l_)
         Set to true if XPCE is around and can be used for graphics.

    hhiissttoorryy _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If _i_n_t_e_g_e_r >0,  support Unix csh(1)-like  history as described
         in  section ????.     Otherwise, only  support  reusing  commands
         through the command  line editor.   The default is to set  this
         Prolog flag  to 0  if a command  line editor  is provided  (see
         Prolog flag readline) and 15 otherwise.

    hhoommee _(_a_t_o_m_)
         SWI-Prolog's  notion  of  the  home  directory.      SWI-Prolog
         uses  its  home   directory  to  find   its  startup  file   as
         <_h_o_m_e>/boot32.prc(32-bit machines) or <_h_o_m_e>/boot64.prc (64-bit
         machines) and to find its library as <_h_o_m_e>/library.

    hhwwnndd _(_i_n_t_e_g_e_r_)
         In swipl-win.exe, this  refers to the MS-Windows window  handle
         of the console window.

    iinntteeggeerr__rroouunnddiinngg__ffuunnccttiioonn _(_d_o_w_n_,_t_o_w_a_r_d___z_e_r_o_)
         ISO Prolog flag  describing rounding by  // and rem  arithmetic
         functions.  Value depends on the C compiler used.

    iissoo _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Include some weird ISO compatibility that is  incompatible with
         normal SWI-Prolog behaviour.   Currently  it has the  following
         effect:

           o The  //2 (float division) _a_l_w_a_y_s  returns a float, even  if
             applied to integers that can be divided.

           o In  the  standard order  of  terms (see  section  ????),  all
             floats are before all integers.

           o atom_length/2 yields a type error if the  first argument is
             a number.

           o clause/[2,3]  raises  a  permission  error  when  accessing
             static predicates.

           o abolish/[1,2]  raises  a permission  error  when  accessing
             static predicates.

           o Syntax is closer to the ISO standard:

               {{  Unquoted commas and  bars appearing  as atoms are  not
                  allowed.    Instead  of  f(,,a)  now  write  f(',',a).
                  Unquoted  commas   can  only  be   used  to   separate
                  arguments in  functional notation  and list  notation,
                  and  as  a  conjunction  operator.      Unquoted  bars
                  can only  appear  within lists  to separate  head  and
                  tail,  like [Head|Tail],  and  as infix  operator  for
                  alternation in grammar rules, like a --> b | c.

               {{  Within functional  notation  and list  notation  terms
                  must  have priority  below  1000.    That  means  that
                  rules and  control constructs  appearing as  arguments
                  need  bracketing.    A  term  like  [a :- b, c].  must
                  now  be  disambiguated   to  mean  [(a :- b), c].   or
                  [(a :- b, c)].

               {{  Operators appearing  as  operands must  be  bracketed.
                  Instead   of   X == -, true.   write   X == (-), true.
                  Currently, this is not entirely enforced.

               {{  Backslash-escaped newlines  are interpreted  according
                  to the ISO standard.  See section ????.

    llaarrggee__ffiilleess _(_b_o_o_l_)
         If present and  true, SWI-Prolog has  been compiled with  _l_a_r_g_e
         _f_i_l_e _s_u_p_p_o_r_t  (LFS) and  is capable of  accessing files  larger
         than 2GB on 32-bit hardware.  Large file support  is default on
         installations built using configure that support it  and may be
         switched off using the configure option --disable-largefile.

    llaasstt__ccaallll__ooppttiimmiissaattiioonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines whether  or not last-call  optimisation is  enabled.
         Normally  the  value  of this  flag  is  the  negation  of  the
         debug flag.   As  programs may  run out of  stack if  last-call
         optimisation is  omitted, it is  sometimes necessary to  enable
         it during debugging.

    mmaaxx__aarriittyy _(_u_n_b_o_u_n_d_e_d_)
         ISO  Prolog  flag describing  there  is  no  maximum  arity  to
         compound terms.

    mmaaxx__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum integer value  if integers are _b_o_u_n_d_e_d.   See also  the
         flag bounded and section ????.

    mmaaxx__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum integer value represented as a `tagged' value.   Tagged
         integers  require  one word  storage.     Larger  integers  are
         represented as `indirect  data' and require significantly  more
         space.

    mmeessssaaggee__ccoonntteexxtt _(_l_i_s_t_(_a_t_o_m_)_, _c_h_a_n_g_e_a_b_l_e_)
         Context information to add to messages of the  levels error and
         warning.   The  list  may contain  the elements  thread to  add
         the thread that generates  the message to the message,  time or
         time(_F_o_r_m_a_t) to add a time  stamp.  The default time  format is
         %T.%3f.  The  default is [thread].  See  also format_time/3 and
         print_message/2.

    mmiinn__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Minimum integer value  if integers are _b_o_u_n_d_e_d.   See also  the
         flag bounded and section ????.

    mmiinn__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Start of the tagged-integer value range.

    mmiittiiggaattee__ssppeeccttrree _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         When  true (default  false),  enforce  mitigation  against  the
         https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)Spectre
         timing-based security  vulnerability.    Spectre based  attacks
         can  extract  information from  memory  owned  by  the  process
         that  should  remain  invisible,  such  as   passwords  or  the
         private key  of a  web server.    The attacks  work by  causing
         speculative access  to  sensitive data,  and  leaking the  data
         via  side-channels  such as  differences  in  the  duration  of
         successive  instructions.      An  example  of  a   potentially
         vulnerable  application  is  https://swish.swi-prolog.orgSWISH.
         SWISH allows users  to run Prolog  code while the swish  server
         must protect the  privacy of other users  as well as its  HTTPS
         private keys, cookies and passwords.

         Currently,  enabling  this  flag  reduces   the  resolution  of
         get_time/1 and statistics/2 CPU time to 20=s.

         WWAARRNNIINNGG: Although a coarser timer makes a  successful attack of
         this type  harder, it  does not reliably  prevent such  attacks
         in general.   Full mitigation  may require compiler support  to
         disable speculative access to sensitive data.

    ooccccuurrss__cchheecckk _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  flag  controls  unification  that  creates   an  infinite
         tree  (also called  _c_y_c_l_i_c _t_e_r_m)  and  can have  three  values.
         Using  false  (default),  unification  succeeds,   creating  an
         infinite  tree.       Using   true,   unification  behaves   as
         unify_with_occurs_check/2, failing  silently.   Using error,  an
         attempt to  create  a cyclic  term results  in an  occurs_check
         exception.  The latter is intended  for debugging unintentional
         creations of  cyclic terms.   Note that this  flag is a  global
         flag modifying fundamental behaviour  of Prolog.  Changing  the
         flag from its default  may cause libraries to stop  functioning
         properly.

    ooppeenn__sshhaarreedd__oobbjjeecctt _(_b_o_o_l_)
         If  true,  open_shared_object/2 and  friends  are  implemented,
         providing access  to shared  libraries (.so  files) or  dynamic
         link libraries (.DLL files).

    ooppttiimmiissee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, compile in optimised mode.  The initial  value is true
         if Prolog  was started with the  -O command line  option.   The
         optimise flag is scoped to a source file.

         Currently   optimised  compilation   implies   compilation   of
         arithmetic, and  deletion of redundant  true/0 that may  result
         from expand_goal/2.

         Later versions might imply various other optimisations  such as
         integrating small  predicates into  their callers,  eliminating
         constant expressions and other predictable constructs.   Source
         code  optimisation is  never  applied  to predicates  that  are
         declared dynamic (see dynamic/1).

    ooss__aarrggvv _(_l_i_s_t_, _c_h_a_n_g_e_a_b_l_e_)
         List  is  a  list  of  atoms  representing   the  command  line
         arguments used  to invoke  SWI-Prolog.   Please  note that  aallll
         arguments are included in the  list returned.  See argv  to get
         the application options.

    ppiidd _(_i_n_t_)
         Process identifier of  the running Prolog  process.   Existence
         of this flag is implementation-defined.

    ppiippee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  open(pipe(command), mode, Stream),   etc.  are  sup-
         ported.    Can  be  changed to  disable  the use  of  pipes  in
         applications testing this feature.  Not recommended.

    pprriinntt__wwrriittee__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         Specifies  the options  for write_term/2  used by  print/1  and
         print/2.

    pprroommpptt__aalltteerrnnaattiivveess__oonn _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines prompting for alternatives in the Prolog  top level.
         Default  is  determinism,  which  implies  the  system  prompts
         for alternatives  if the  goal succeeded  while leaving  choice
         points.   Many classical Prolog  systems behave as  groundness:
         they prompt for alternatives if and only if  the query contains
         variables.

    pprrootteecctt__ssttaattiicc__ccooddee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default  false), clause/2 does  not operate on  static
         code, providing  some basic protection  from hackers that  wish
         to list the static code of your Prolog program.   Once the flag
         is true,  it cannot be  changed back to false.   Protection  is
         default in  ISO mode (see  Prolog flag  iso).   Note that  many
         parts of the  development environment require clause/2 to  work
         on static  code, and  enabling this  flag should  thus only  be
         used for production code.

    qqccoommppiillee _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  option  provides  the  default  for  the  qcompile(_+_A_t_o_m)
         option of load_files/2.

    rreeaaddlliinnee _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Specifies  which form  of  command  line editing  is  provided.
         Possible values  are  below.   The  flag may  be  set from  the
         user's init file (see section ????) to one of  false, readline or
         editline.  This causes the toplevel not to load  a command line
         editor (false)  or load the  specified one.   If loading  fails
         the flag is set to false.

         ffaallssee
             No command line editing is available.

         rreeaaddlliinnee
             The  library  readline is  loaded, providing  line  editing
             based on the GNU readline library.

         eeddiittlliinnee
             The  library  editline is  loaded, providing  line  editing
             based on the BSD libedit.   This is the default if editline
             is available and can be loaded.

         sswwiippll__wwiinn
             SWI-Prolog uses its own  console (swipl-win.exe on Windows,
             the  Qt  based  swipl-win on  MacOS)  which  provides  line
             editing.

    rreessoouurrccee__ddaattaabbaassee _(_a_t_o_m_)
         Set to the absolute filename of the attached state.   Typically
         this is the file boot32.prc, the file specified with  -x or the
         running executable.  See also resource/3.

    rreeppoorrtt__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, print  error messages; otherwise  suppress them.   May
         be changed.  See also  the debug_on_errorProlog flag.   Default
         is true, except for the runtime version.

    rruunnttiimmee _(_b_o_o_l_)
         If present and  true, SWI-Prolog is  compiled with -DO_RUNTIME,
         disabling various  useful development  features (currently  the
         tracer and profiler).

    ssaannddbbooxxeedd__llooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default  false), load_files/2  calls hooks  to  allow
         library(sandbox) to verify the safety of directives.

    ssaavveedd__pprrooggrraamm _(_b_o_o_l_)
         If present  and  true, Prolog  has been  started  from a  state
         saved with qsave_program/[1,2].

    sshhaarreedd__oobbjjeecctt__eexxtteennssiioonn _(_a_t_o_m_)
         Extension used  by  the operating  system for  shared  objects.
         .so for  most Unix  systems and  .dll for  Windows.   Used  for
         locating  files using  the  file_type  executable.    See  also
         absolute_file_name/3.

    sshhaarreedd__oobbjjeecctt__sseeaarrcchh__ppaatthh _(_a_t_o_m_)
         Name of the environment  variable used by the system  to search
         for shared objects.

    ssiiggnnaallss _(_b_o_o_l_)
         Determine  whether Prolog  is  handling signals  (software  in-
         terrupts).   This  flag is  false if  the hosting  OS does  not
         support signal handling  or the command line option  -nosignals
         is active.  See section ???? for details.

    ssttaacckk__lliimmiitt _(_i_n_t_, _c_h_a_n_g_e_a_b_l_e_)
         Limits the combined sizes of the Prolog stacks  for the current
         thread.  See alse --stack and section ????.

    ssttrreeaamm__ttyyppee__cchheecckk _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Defines whether  and  how strictly  the system  validates  that
         byte I/O  should not be  applied to text  streams and text  I/O
         should not be applied to binary streams.  Values  are false (no
         checking),  true (full  checking) and  loose.   Using  checking
         mode loose  (default), the  system accepts byte  I/O from  text
         stream that use ISO  Latin-1 encoding and accepts writing  text
         to binary streams.

    ssyysstteemm__tthhrreeaadd__iidd _(_i_n_t_)
         Available  in  multithreaded version  (see  section  ????)  where
         the  operating  system  provides  system-wide   integer  thread
         identifiers.    The  integer  is  the  thread  identifier  used
         by the  operating system  for  the calling  thread.   See  also
         thread_self/1.

    ttaabbllee__ssppaaccee _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         Space reserved for storing answer tables for  _t_a_b_l_e_d _p_r_e_d_i_c_a_t_e_s
         (see  table/1).    When exceeded  a  resource_error(_t_a_b_l_e___s_p_a_c_e)
         exception is raised.

    ttiimmeezzoonnee _(_i_n_t_e_g_e_r_)
         Offset in seconds  west of GMT of the  current time zone.   Set
         at initialization  time from the  timezone variable  associated
         with the POSIX tzset() function.  See also format_time/3.

    ttoopplleevveell__ggooaall _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         Defines  the goal  that  is  executed after  running  the  ini-
         tialization goals  and entry  point (see  -g,  initialization/2
         and section  ????.   The  initial value  is  default, starting  a
         normal interactive session.   This  value may be changed  using
         the command  line option  -t.    The explicit  value prolog  is
         equavalent to  default.   If initialization(_G_o_a_l_,_m_a_i_n) is  used
         and the toplevel is  default, the toplevel is set to  halt (see
         halt/0).

    ttoopplleevveell__mmooddee _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         If  backtracking  (default),  the   toplevel  backtracks  after
         completing a query.  If recursive, the  toplevel is implemented
         as a recursive  loop.  This  implies that global variables  set
         using b_setval/2 are maintained between queries.   In _r_e_c_u_r_s_i_v_e
         mode, answers to  toplevel variables (see section ????) are  kept
         in backtrackable  global variables  and thus  nnoott ccooppiieedd.    In
         _b_a_c_k_t_r_a_c_k_i_n_g mode  answers to  toplevel variables  are kept  in
         the recorded database (see section ????).

         The recursive mode has been added for interactive  usage of CHR
         (see section ????),  which maintains the global constraint  store
         in backtrackable global variables.

    ttoopplleevveell__pprriinntt__aannoonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true,  top-level variables starting  with an  underscore (_)
         are printed normally.   If false they are hidden.  This  may be
         used to hide bindings in complex queries from the top level.

    ttoopplleevveell__pprriinntt__ffaaccttoorriizzeedd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default false)  show the internal sharing of  subterms
         in  the  answer  substitution.     The  example  below  reveals
         internal  sharing   of  leaf  nodes   in  _r_e_d_-_b_l_a_c_k  _t_r_e_e_s   as
         implemented by the rbtrees predicate rb_new/1:

         _______________________________________________________________|                                                               |

         |?- set_prolog_flag(toplevel_print_factorized, true).           |
         |?- rb_new(X).                                                  |
         |X = t(_S1, _S1), % where                                       |
         ||____S1_=_black('',__G387,__G388,_'').________________________ ||

         If this flag  is false, the % where  notation is still used  to
         indicate cycles as illustrated below.  This  example also shows
         that the implementation reveals the internal cycle  length, and
         _n_o_t the minimal cycle  length.  Cycles of different  length are
         indistinguishable in Prolog (as illustrated by S == R).

         _______________________________________________________________|                                                               |
         |?- S = s(S), R = s(s(R)), S == R.                              |

         |S = s(S),                                                      |
         |R|=_s(s(R)).__________________________________________________ | |

    aannsswweerr__wwrriittee__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument is  given  as  option-list to  write_term/2  for
         printing  results  of  queries.     Default  is  [quoted(true),
         portray(true), max_depth(10), attributes(portray)].

    ttoopplleevveell__pprroommpptt _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Define the prompt  that is used  by the interactive top  level.
         The following ~ (tilde) sequences are replaced:

         _____________________________________________________________________~m_T_y_p_e _i_n module if not user (see module/1)

          ~l  _B_r_e_a_k _l_e_v_e_l if not 0 (see break/0)
          ~d  _D_e_b_u_g_g_i_n_g _s_t_a_t_e if not normal execution (see debug/0, trace/0)
         _~!___H_i_s_t_o_r_y__e_v_e_n_t_if_history_is_enabled_(see_flag_history)__________

    ttoopplleevveell__vvaarr__ssiizzee _(_i_n_t_, _c_h_a_n_g_e_a_b_l_e_)
         Maximum  size counted  in  literals of  a  term returned  as  a
         binding for a variable  in a top-level query that is  saved for
         re-use using the $ variable reference.  See section ????.

    ttrraaccee__ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default  false), garbage collections and  stack-shifts
         will be reported on the terminal.  May be changed.   Values are
         reported in bytes  as G+T, where G  is the global stack  value
         and T  the trail stack  value.   `Gained' describes the  number
         of bytes reclaimed.   `used' the  number of bytes on the  stack
         after GC and `free'  the number of bytes allocated, but  not in
         use.  Below is an example output.

         _______________________________________________________________|                                                               |
         |% GC: gained 236,416+163,424 in 0.00 sec;                      |
         ||_____used_13,448+5,808;_free_72,568+47,440___________________ ||

    ttrraaddiittiioonnaall _(_b_o_o_l_)
         Available in  SWI-Prolog version  7.    If true,  `traditional'
         mode has been selected  using --traditional.  Notice  that some
         SWI7 features,  like the functional notation  on dicts, do  not
         work in this mode.  See also section ????.

    ttttyy__ccoonnttrrooll _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines whether  the terminal  is switched to  raw mode  for
         get_single_char/1,  which also  reads the user  actions for  the
         trace.  May be set.  If this flag is  false at startup, command
         line editing  is disabled.   See also  the +/-tty command  line
         option.

    uunniixx _(_b_o_o_l_)
         If present  and  true,  the operating  system is  some  version
         of Unix.    Defined  if the  C compiler  used  to compile  this
         version of  SWI-Prolog either  defines __unix__  or unix.    On
         other systems this flag is  not available.  See also  apple and
         windows.

    uunnkknnoowwnn _(_f_a_i_l_,_w_a_r_n_i_n_g_,_e_r_r_o_r_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  the behaviour  if  an  undefined procedure  is  en-
         countered.    If  fail,  the  predicate  fails silently.     If
         warn,  a warning  is printed,  and  execution continues  as  if
         the predicate  was  not defined,  and  if error  (default),  an
         existence_error exception is  raised.   This flag  is local  to
         each  module and  inherited  from the  module's  _i_m_p_o_r_t_-_m_o_d_u_l_e.
         Using default setup,  this implies that normal modules  inherit
         the flag  from  user, which  in turn  inherit  the value  error
         from system.   The  user may  change the flag  for module  user
         to  change the  default  for  all application  modules  or  for
         a  specific module.     It  is strongly  advised  to  keep  the
         error default and  use dynamic/1 and/or multifile/1 to  specify
         possible non-existence of a predicate.

    uunnllooaadd__ffoorreeiiggnn__lliibbrraarriieess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default  false), unload all loaded foreign  libraries.
         Default is  false  because modern  OSes reclaim  the  resources
         anyway and  unloading  the foreign  code may  cause  registered
         hooks to point to no longer existing data or code.

    uusseerr__ffllaaggss _(_A_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Define  the  behaviour  of  set_prolog_flag/2 if  the  flag  is
         not  known.    Values are  silent,  warning  and  error.    The
         first two  create  the flag  on-the-fly,  where warning  prints
         a  message.    The  value  error is  consistent  with  ISO:  it
         raises an existence  error and does not  create the flag.   See
         also create_prolog_flag/3.  The  default is silent, but  future
         versions may  change that.   Developers  are encouraged to  use
         another value and ensure  proper use of create_prolog_flag/3 to
         create flags for their library.

    vvaarr__pprreeffiixx _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default  false), variables must  start with an  under-
         score (_).  May be changed.   This flag is local to  the module
         in which it is changed.  See section ????.

    vveerrbboossee _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This flag is used by print_message/2.  If its  value is silent,
         messages of type informational and banner are suppressed.   The
         -q switches the value from the initial normal to silent.

    vveerrbboossee__aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true the  normal  consult  message  will be  printed  if  a
         library is autoloaded.  By default this  message is suppressed.
         Intended to be used for debugging purposes.

    vveerrbboossee__llooaadd _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  messages printed  for  loading  (compiling)  Prolog
         files.    Current  values are  full  (print  a message  at  the
         start and  end of each  file loaded),  normal (print a  message
         at the  end of  each file loaded),  brief (print  a message  at
         end of  loading the  toplevel file),  and  silent (no  messages
         are printed,  default).   The  value of this  flag is  normally
         controlled by the option silent(_B_o_o_l) provided by load_files/2.

    vveerrbboossee__ffiillee__sseeaarrcchh _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (default   false),  print  messages  indicating   the
         progress   of  absolute_file_name/[2,3]  in   locating   files.
         Intended for  debugging  complicated file-search  paths.    See
         also file_search_path/2.

    vveerrssiioonn _(_i_n_t_e_g_e_r_)
         The version identifier is an integer with value:

                          10000_*Major+ 100_*Minor+_P_a_t_c_h

    vveerrssiioonn__ddaattaa _(_s_w_i_(_M_a_j_o_r_, _M_i_n_o_r_, _P_a_t_c_h_, _E_x_t_r_a_)_)
         Part of the  dialect compatibility layer;  see also the  Prolog
         flag dialect and section ????.   _E_x_t_r_a provides platform-specific
         version information  as  a list.    _E_x_t_r_a  is used  for  _t_a_g_g_e_d
         _v_e_r_s_i_o_n_s such as ``7.4.0-rc1'', in which case  _E_x_t_r_a contains a
         term tag(_r_c_1).

    vveerrssiioonn__ggiitt _(_a_t_o_m_)
         Available if created from  a git repository.   See git-describe
         for details.

    wwaarrnn__oovveerrrriiddee__iimmpplliicciitt__iimmppoorrtt _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true (default),  a  warning  is printed  if  an  implicitly
         imported predicate  is clobbered by  a local  definition.   See
         use_module/1 for details.

    wwiinn__ffiillee__aacccceessss__cchheecckk _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Controls the behaviour  or access_file/2 under Windows.   There
         is no  reliable way to  check access  to files and  directories
         on Windows.    This  flag allows  for  switching between  three
         alternative approximations.

         aacccceessss
             Use Windows _waccess() function.  This ignores ACLs (Access
             Control List) and thus may  indicate that access is allowed
             while it is not.

         ffiilleesseeccuurriittyy
             Use the Windows GetFileSecurity() function.   This does not
             work on  all file systems, but is probably the  best choice
             on  file systems  that do  support it,  notably local  NTFS
             volumes.

         ooppeenncclloossee
             Try  to open the file  and close it.   This works  reliable
             for files, but not for  directories.  Currently directories
             are checked using _waccess().  This is the default.

    wwiinnddoowwss _(_b_o_o_l_)
         If present and true, the operating system  is an implementation
         of  Microsoft  Windows.     This  flag  is  only  available  on
         MS-Windows based versions.  See also unix.

    wwrriittee__aattttrriibbuutteess _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Defines how  write/1  and friends  write attributed  variables.
         The option values are  described with the attributes option  of
         write_term/3.  Default is ignore.

    wwrriittee__hheellpp__wwiitthh__oovveerrssttrriikkee _(_b_o_o_l_)
         Internal flag used  by help/1 when writing  to a terminal.   If
         present  and true  it prints  bold  and underlined  text  using
         _o_v_e_r_s_t_r_i_k_e.

    xxppccee _(_b_o_o_l_)
         Available  and set  to  true if  the  XPCE graphics  system  is
         loaded.

    xxppccee__vveerrssiioonn _(_a_t_o_m_)
         Available and set to the version of the loaded XPCE system.

    xxrreeff _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, source code  is being read for _a_n_a_l_y_s_i_s  purposes such
         as cross-referencing.    Otherwise (default) it  is being  read
         to  be compiled.    This  flag is  used  at several  places  by
         term_expansion/2 and goal_expansion/2 hooks,  notably if  these
         hooks use side effects.   See also  the libraries prolog_source
         and prolog_xref.


sseett__pprroolloogg__ffllaagg((_:_K_e_y_, _+_V_a_l_u_e))                                      _[_I_S_O_]
    Define  a new  Prolog flag or  change its value.    _K_e_y is an  atom.
    If  the flag is a system-defined flag that is not  marked _c_h_a_n_g_e_a_b_l_e
    above,  an  attempt to  modify the flag  yields a  permission_error.
    If  the  provided _V_a_l_u_e  does not  match  the type  of the  flag,  a
    type_error is raised.

    Some  flags (e.g.,  unknown) are maintained  on a per-module  basis.
    The addressed module is determined by the _K_e_y argument.

    In  addition  to  ISO,  SWI-Prolog allows  for  user-defined  Prolog
    flags.   The type of the  flag is determined from the  initial value
    and  cannot be changed  afterwards.   Defined types are boolean  (if
    the  initial value is one  of false, true, on  or off), atom if  the
    initial value is any  other atom, integer if the value is an integer
    that  can be expressed as a 64-bit signed value.  Any  other initial
    value  results  in an  untyped  flag that  can represent  any  valid
    Prolog term.

    The  behaviour when _K_e_y  denotes a non-existent  key depends on  the
    Prolog  flag user_flags.   The default is  to define them  silently.
    New code is encouraged to use create_prolog_flag/3 for portability.


ccrreeaattee__pprroolloogg__ffllaagg((_+_K_e_y_, _+_V_a_l_u_e_, _+_O_p_t_i_o_n_s))                         _[_Y_A_P_]
    Create  a  new Prolog  flag.    The ISO  standard does  not  foresee
    creation  of  new flags,  but many  libraries  introduce new  flags.
    _O_p_t_i_o_n_s is a list of the options below.  See also user_flags.

    aacccceessss((_+_A_c_c_e_s_s))
         Define access rights for  the flag.  Values  are read_write  and
         read_only.  The default is read_write.

    ttyyppee((_+_A_t_o_m))
         Define a type restriction.  Possible values  are boolean, atom,
         integer,  float and  term.    The  default is  determined  from
         the initial  value.  Note  that term restricts  the term to  be
         ground.

    kkeeeepp((_+_B_o_o_l_e_a_n))
         If true, do not modify  the flag if it already exists.   Other-
         wise (default), this predicate  behaves as set_prolog_flag/2 if
         the flag already exists.


22..1122 AAnn oovveerrvviieeww ooff hhooookk pprreeddiiccaatteess

SWI-Prolog provides a large number of hooks, mainly  to control handling
messages, debugging,  startup, shut-down, macro-expansion,  etc.   Below
is  a  summary  of  all  defined  hooks  with  an  indication  of  their
portability.

  o _p_o_r_t_r_a_y_/_1
    Hook into write_term/3 to alter the way terms are printed (ISO).

  o _m_e_s_s_a_g_e___h_o_o_k_/_3
    Hook  into  print_message/2 to  alter the  way system  messages  are
    printed (Quintus/SICStus).

  o _m_e_s_s_a_g_e___p_r_o_p_e_r_t_y_/_2
    Hook  into  print_message/2  that  defines  prefix,  output  stream,
    color, etc.

  o _m_e_s_s_a_g_e___p_r_e_f_i_x___h_o_o_k_/_2
    Hook into  print_message/2to add additional  prefixes to the message
    such as the time and thread.

  o _l_i_b_r_a_r_y___d_i_r_e_c_t_o_r_y_/_1
    Hook  into  absolute_file_name/3 to define  new library  directories
    (most Prolog systems).

  o _f_i_l_e___s_e_a_r_c_h___p_a_t_h_/_2
    Hook   into   absolute_file_name/3  to  define   new  search   paths
    (Quintus/SICStus).

  o _t_e_r_m___e_x_p_a_n_s_i_o_n_/_2
    Hook  into  load_files/2  to  modify  read  terms  before  they  are
    compiled (macro-processing) (most Prolog systems).

  o _g_o_a_l___e_x_p_a_n_s_i_o_n_/_2
    Same as term_expansion/2 for individual goals (SICStus).

  o _p_r_o_l_o_g___l_o_a_d___f_i_l_e_/_2
    Hook  into  load_files/2  to  load other  data  formats  for  Prolog
    sources  from `non-file' resources.   The load_files/2 predicate  is
    the ancestor of consult/1, use_module/1, etc.

  o _q_p_r_e_d_r_e_f_p_r_o_l_o_g___e_d_i_t_l_o_c_a_t_e_3
    Hook into edit/1 to locate objects (SWI).

  o _q_p_r_e_d_r_e_f_p_r_o_l_o_g___e_d_i_t_e_d_i_t___s_o_u_r_c_e_1
    Hook into edit/1 to call an internal editor (SWI).

  o _p_r_o_l_o_g___e_d_i_t_:_e_d_i_t___c_o_m_m_a_n_d_/_2
    Hook into edit/1 to define the external editor to use (SWI).

  o _p_r_o_l_o_g___l_i_s_t___g_o_a_l_/_1
    Hook  into the tracer  to list the  code associated to a  particular
    goal (SWI).

  o _p_r_o_l_o_g___t_r_a_c_e___i_n_t_e_r_c_e_p_t_i_o_n_/_4
    Hook into the tracer to handle trace events (SWI).

  o _q_p_r_e_d_r_e_f_p_r_o_l_o_g_d_e_b_u_g___c_o_n_t_r_o_l___h_o_o_k_1
    Hook  in spy/1, nospy/1, nospyall/0 and debugging/0 to  extend these
    control predicates to higher-level libraries.

  o _q_p_r_e_d_r_e_f_p_r_o_l_o_g_h_e_l_p___h_o_o_k_1
    Hook in help/0, help/1 and apropos/1 to extend the help system.

  o _r_e_s_o_u_r_c_e_/_3
    Define a new resource (not really a hook, but similar) (SWI).

  o _e_x_c_e_p_t_i_o_n_/_3
    Old  attempt  to  a  generic  hook mechanism.     Handles  undefined
    predicates (SWI).

  o _a_t_t_r___u_n_i_f_y___h_o_o_k_/_2
    Unification  hook for attributed variables.   Can be defined in  any
    module.  See section ???? for details.


22..1133 AAuuttoommaattiicc llooaaddiinngg ooff lliibbrraarriieess

If ---at runtime--- an  undefined predicate is trapped, the  system will
first try to import the predicate from the module's  default module (see
section ????.    If this fails  the _a_u_t_o _l_o_a_d_e_r  is activated.   On  first
activation an  index to  all library  files in  all library  directories
is  loaded  in  core  (see library_directory/1,  file_search_path/2  and
reload_library_index/0).   If the  undefined predicate can be located  in
one of the libraries, that library file is  automatically loaded and the
call to the (previously  undefined) predicate is restarted.   By default
this mechanism loads  the file silently.   The current_prolog_flag/2 key
verbose_autoload is provided  to get verbose loading.   The Prolog  flag
autoload can be used to enable/disable the autoload system.

Autoloading  only handles  (library) source  files that  use the  module
mechanism  described  in  chapter  ????.     The  files  are  loaded  with
use_module/2 and only the  trapped undefined predicate is imported  into
the  module where  the undefined  predicate was  called.   Each  library
directory  must hold  a file  INDEX.pl  that contains  an index  to  all
library files  in the directory.    This file consists  of lines of  the
following format:

________________________________________________________________________|                                                                        |
|index(Name,|Arity,_Module,_File).______________________________________ |           |

The  predicate make/0  updates the  autoload  index.   It  searches  for
all library directories (see library_directory/1 and file_search_path/2)
holding the file MKINDEX.pl or INDEX.pl.  If the  current user can write
or create the file INDEX.pl  and it does not exist or is older  than the
directory or one of its files, the index for  this directory is updated.
If the  file MKINDEX.pl  exists, updating  is achieved  by loading  this
file,  normally  containing  a  directive calling  make_library_index/2.
Otherwise make_library_index/1is  called, creating an index for all *.pl
files containing a module.

Below is an example creating an indexed library directory.

________________________________________________________________________|                                                                        |

|% mkdir ~/lib/prolog                                                    |
|% cd ~/lib/prolog                                                       |
|%|swipl_-g_true_-t_'make_library_index(.)'_____________________________ | |

If  there  is  more  than  one  library  file   containing  the  desired
predicate, the following search schema is followed:

 1. If  there is a  library file  that defines the  module in which  the
    undefined predicate is trapped, this file is used.

 2. Otherwise  library files  are considered  in the  order they  appear
    in  the  library_directory/1  predicate  and  within  the  directory
    alphabetically.


aauuttoollooaadd__ppaatthh((_+_D_i_r_A_l_i_a_s))
    Add  _D_i_r_A_l_i_a_s to  the  libraries that  are used  by the  autoloader.
    This  extends  the  search path  autoload  and reloads  the  library
    index.  For example:

    ____________________________________________________________________|                                                                    |
    ||:-_autoload_path(library(http)).__________________________________ ||

    If   this  call  appears  as   a  directive,  it  is   term-expanded
    into  a clause  for user:file_search_path/2 and  a directive  calling
    reload_library_index/0.   This keeps  source information and  allows
    for removing this directive.


mmaakkee__lliibbrraarryy__iinnddeexx((_+_D_i_r_e_c_t_o_r_y))
    Create  an index for this  directory.  The  index is written to  the
    file  'INDEX.pl' in the specified directory.   Fails with a  warning
    if the directory does not exist or is write protected.


mmaakkee__lliibbrraarryy__iinnddeexx((_+_D_i_r_e_c_t_o_r_y_, _+_L_i_s_t_O_f_P_a_t_t_e_r_n_s))
    Normally  used in  MKINDEX.pl, this  predicate creates INDEX.pl  for
    _D_i_r_e_c_t_o_r_y,  indexing all files that  match one of the file  patterns
    in _L_i_s_t_O_f_P_a_t_t_e_r_n_s.

    Sometimes  library packages consist  of one public  load file and  a
    number  of files used by  this load file, exporting predicates  that
    should not be used  directly by the end user.  Such a library can be
    placed  in a sub-directory of  the library and the files  containing
    public  functionality can  be  added to  the index  of the  library.
    As  an  example we  give the  XPCE library's  MKINDEX.pl,  including
    the  public  functionality of  trace/browse.pl to  the  autoloadable
    predicates for the XPCE package.

    ____________________________________________________________________|                                                                    |
    | :- make_library_index('.',                                         |

    |                       [ '*.pl',                                    |
    |                         'trace/browse.pl'                          |
    ||______________________])._________________________________________ ||


rreellooaadd__lliibbrraarryy__iinnddeexx
    Force  reloading  the  index  after modifying  the  set  of  library
    directories   by   changing  the   rules  for   library_directory/1,
    file_search_path/2,  adding  or  deleting  INDEX.pl  files.     This
    predicate   does   _n_o_t   update  the   INDEX.pl   files.       Check
    make_library_index/[1,2] and make/0 for updating the index files.

    Normally, the index  is reloaded automatically if a predicate cannot
    be  found  in the  index  and the  set  of library  directories  has
    changed.   Using reload_library_index/0 is necessary if  directories
    are removed or the order of the library directories is changed.

When  creating an  executable  using either  qsave_program/2 or  the  -c
command  line options,  it is  necessarry to  load  all predicates  that
would  normally  be  autoloaded  explicitly.     This  is  discussed  in
section ????.  See autoload/0.


22..1144 PPaacckkss::  ccoommmmuunniittyy aadddd--oonnss

SWI-Prolog  has  a   mechanism  for  easy  incorporation  of   community
extensions.    See the  http://www.swi-prolog.org/pack/listpack  landing
page  for  details  and  available  packs.      This  section  documents
the  built-in predicates  to attach  packs.    Predicates for  creating,
registering  and   installing  packs   are  provided   by  the   library
prolog_pack.


aattttaacchh__ppaacckkss
    Attaches  all  packs  in  subdirectories  of  directories  that  are
    accessible  through the _f_i_l_e _s_e_a_r_c_h  _p_a_t_h (see absolute_file_name/3)
    pack.  The default for this search path is:

    ____________________________________________________________________|                                                                    |
    | user:file_search_path(pack, app_data(pack)).                       |

    ||user:file_search_path(pack,_swi(pack)).___________________________ ||

    The predicate attach_packs/0 is called on startup of SWI-Prolog.


aattttaacchh__ppaacckkss((_+_D_i_r_e_c_t_o_r_y))
    Attach  all  packs   in  subdirectories  of  _D_i_r_e_c_t_o_r_y.     Same  as
    attach_packs(_D_i_r_e_c_t_o_r_y_, _[_]).


aattttaacchh__ppaacckkss((_+_D_i_r_e_c_t_o_r_y_, _+_O_p_t_i_o_n_s))
    Attach  all packs in  subdirectories of _D_i_r_e_c_t_o_r_y.   Options is  one
    of:

    sseeaarrcchh((_+_W_h_e_r_e))
         Determines the  order  in which  pack library  directories  are
         searched.   Default is to add  new packages at the end  (last).
         Using first, new packages are added at the start.

    dduupplliiccaattee((_+_A_c_t_i_o_n))
         Determines  what happens  if  a  pack  with the  same  name  is
         already attached.   Default is warning, which prints  a warning
         and ignores the  new pack.   Other options  are keep, which  is
         like warning but operates silently and replace,  which detaches
         the old pack and attaches the new.

    The  predicate attach_packs/2 can  be used  to attach packages  that
    are bundled with an application.


22..1155 GGaarrbbaaggee CCoolllleeccttiioonn

SWI-Prolog provides garbage collection, last-call optimization  and atom
garbage collection.   These features  are controlled using Prolog  flags
(see current_prolog_flag/2).


22..1166 TThhee SSWWII--PPrroolloogg ssyynnttaaxx

SWI-Prolog  syntax  is  close  to  ISO-Prolog  standard  syntax,   which
is  based  on  the  Edinburgh Prolog  syntax.     A  formal  description
can  be  found  in  the  ISO  standard  document.      For  an  informal
introduction  we  refer  to Prolog  text  books  (see  section  ????)  and
http://www.swi-prolog.org/Links.htmlonline tutorials.    In addition  to
the  differences  from the  ISO  standard  documented  here,  SWI-Prolog
offers several extensions,  some of which also  extend the syntax.   See
section ???? for more information.


22..1166..11 IISSOO SSyynnttaaxx SSuuppppoorrtt

This section lists various extensions w.r.t. the ISO Prolog syntax.


22..1166..11..11 PPrroocceessssoorr CChhaarraacctteerr SSeett

The processor character  set specifies the class of each  character used
for parsing Prolog  source text.   Character classification is fixed  to
http://www.unicode.org/Unicode.  See also section ????.


22..1166..11..22 NNeesstteedd ccoommmmeennttss

SWI-Prolog  allows  for  nesting /* ...*/  comments.     Where  the  ISO
standard accepts  /* .../* ...*/ as  a comment,  SWI-Prolog will  search
for  a terminating  */.    This is  useful if  some  code with  /* ...*/
comment statements  in it should  be commented out.   This  modification
also  avoids unintended  commenting  in  the example  below,  where  the
closing */ of the first comment has been forgotten.

________________________________________________________________________|                                                                        |
|/* comment                                                              |

|                                                                        |
|code                                                                    |
|                                                                        |
|/* second comment */                                                    |
|                                                                        |
|code                                                                    |
||______________________________________________________________________ ||


22..1166..11..33 CChhaarraacctteerr EEssccaappee SSyynnttaaxx

Within quoted atoms (using single quotes:   '<atom>') special characters
are  represented using  escape sequences.    An escape  sequence is  led
in  by the  backslash  (\) character.    The  list of  escape  sequences
is compatible  with the ISO standard  but contains some extensions,  and
the interpretation of numerically specified characters  is slightly more
flexible to improve compatibility.  Undefined escape  characters raise a
syntax_error exception.

\a
    Alert character.  Normally the ASCII character 7 (beep).

\b
    Backspace character.

\c
    No  output.    All input  characters  up to  but not  including  the
    first  non-layout  character  are skipped.     This allows  for  the
    specification  of pretty-looking long lines.  Not supported  by ISO.
    Example:

    ____________________________________________________________________|                                                                    |
    | format('This is a long line that looks better if it was \c         |

    ||_______split_across_multiple_physical_lines_in_the_input')________ ||

\<NEWLINE>
    When  in  ISO  mode  (see  the Prolog  flag  iso),  only  skip  this
    sequence.    In native mode,  white space  that follows the  newline
    is  skipped as well and a  warning is printed, indicating that  this
    construct  is deprecated and  advising to use \c.   We advise  using
    \c  or putting  the layout  _b_e_f_o_r_e the  \, as  shown below.    Using
    \c  is supported  by various other  Prolog implementations and  will
    remain  supported by SWI-Prolog.  The style shown below is  the most
    compatible solution.

    ____________________________________________________________________|                                                                    |

    | format('This is a long line that looks better if it was \          |
    ||split_across_multiple_physical_lines_in_the_input')_______________ ||

    instead of

    ____________________________________________________________________|                                                                    |
    | format('This is a long line that looks better if it was\           |
    ||_split_across_multiple_physical_lines_in_the_input')______________ ||

    Note  that SWI-Prolog  also allows unescaped  newlines to appear  in
    quoted material.   This is not allowed be the ISO standard, but used
    to be common practice before.

\e
    Escape character (ASCII 27).  Not ISO, but widely supported.

\f
    Form-feed character.

\n
    Next-line character.

\r
    Carriage-return only (i.e., go back to the start of the line).

\s
    Space  character.    Intended  to  allow  writing 0'\s  to  get  the
    character code of the space character.  Not ISO.

\t
    Horizontal tab character.

\v
    Vertical tab character (ASCII 11).

\xXX..\
    Hexadecimal  specification  of  a  character.    The  closing  \  is
    obligatory   according  to  the  ISO   standard,  but  optional   in
    SWI-Prolog  to   enhance  compatibility  with  the  older  Edinburgh
    standard.   The code \xa\3 emits the character 10  (hexadecimal `a')
    followed  by `3'.  Characters specified this way are  interpreted as
    Unicode characters.  See also \u.

\uXXXX
    Unicode  character specification  where the  character is  specified
    using  _e_x_a_c_t_l_y 4 hexadecimal  digits.  This  is an extension to  the
    ISO  standard,  fixing two  problems.   First,  where  \x defines  a
    numeric  character code,  it doesn't  specify the  character set  in
    which  the  character should  be interpreted.    Second,  it is  not
    needed to use the idiosyncratic closing \ ISO Prolog syntax.

\UXXXXXXXX
    Same as \uXXXX, but using 8 digits to cover the whole Unicode set.

\40
    Octal   character  specification.     The  rules  and   remarks  for
    hexadecimal specifications apply to octal specifications as well.

\\
    Escapes  the backslash itself.  Thus, '\\' is an atom  consisting of
    a single \.

\'
    Single  quote.  Note that '\'' and '''' both describe the  atom with
    a single ', i.e., '\'' == '''' is true.

\"
    Double quote.

\`
    Back quote.

Character        escaping       is        only       available        if
current_prolog_flag(character_escapes, true) is active (default).    See
current_prolog_flag/2.    Character  escapes  conflict with  writef/2  in
two  ways:   \40  is  interpreted as  decimal  40 by  writef/2,  but  as
octal  40 (decimal  32) by  read.   Also,  the writef/2  sequence \l  is
illegal.   It is advised to  use the more widely supported  format/[2,3]
predicate instead.   If  you insist upon  using writef/2, either  switch
character_escapes to false, or use double \\, as in writef('\\l').


22..1166..11..44 SSyynnttaaxx ffoorr nnoonn--ddeecciimmaall nnuummbbeerrss

SWI-Prolog  implements  both  Edinburgh  and  ISO   representations  for
non-decimal numbers.   According to  Edinburgh syntax, such numbers  are
written as <_r_a_d_i_x>'<number>, where <_r_a_d_i_x> is a number between 2 and 36.
ISO defines binary,  octal and hexadecimal numbers using 0[bxo]<_n_u_m_b_e_r>.
For example:  A is 0b100 \/ 0xf00  is a valid expression.   Such numbers
are always unsigned.


22..1166..11..55 UUssiinngg ddiiggiitt ggrroouuppss iinn llaarrggee iinntteeggeerrss

SWI-Prolog  supports   splitting  long   integers  into  _d_i_g_i_t   _g_r_o_u_p_s.
Digit  groups   can  be   separated  with  the   sequence  <_u_n_d_e_r_s_c_o_r_e>,
<_o_p_t_i_o_n_a_l _w_h_i_t_e _s_p_a_c_e>.   If the  <_r_a_d_i_x> is 10  or lower, they  may also
be separated  with exactly  one space.   The  following all express  the
integer 1 million:

________________________________________________________________________|                                                                        |
|1_000_000                                                               |

|1 000 000                                                               |
|1_000_/*more*/000|_____________________________________________________ |                 |

Integers can be printed using this notation with format/2,  using the ~I
format specifier.  For example:

________________________________________________________________________|                                                                        |
|?- format('~I', [1000000]).                                             |
|1_000_000|_____________________________________________________________ |         |

The  current  syntax  has been  proposed  by  Ulrich  Neumerkel  on  the
SWI-Prolog mailinglist.


22..1166..11..66 NNaaNN aanndd IInnffiinniittyy ffllooaattss aanndd tthheeiirr ssyynnttaaxx

SWI-Prolog      supports      reading      and       printing      `spe-
cial'       floating        point       values       according        to
http://eclipseclp.org/Specs/core_update_float.htmlProposal   for   Prolog
Standard core  update wrt floating point  arithmetic by Joachim  Schimpf
and available in ECLiPSe Prolog.  In particular,

  o Infinity  is printed as  1.0Inf or -1.0Inf.   Any sequence  matching
    the  regular expression  [+-]?\sd+[.]\sd+Inf  is mapped  to plus  or
    minus infinity.

  o NaN  (Not  a Number)  is printed  as 1.xxxNaN,  where  _1_._x_x_x is  the
    float  after replacing the exponent by `1'.  Such numbers  are read,
    resulting  in the same  NaN. The NaN  constant can also be  produced
    using the function nan/0, e.g.,

    ____________________________________________________________________|                                                                    |

    | ?- A is nan.                                                       |
    ||A_=_1.5NaN._______________________________________________________ ||

Note that, compliant  with the ISO standard, SWI-Prolog  arithmetic (see
section ????) never returns one of the above values  but instead raises an
_e_x_c_e_p_t_i_o_n, e.g.,

________________________________________________________________________|                                                                        |
|?- A is 1/0.                                                            |

|ERROR:|//2:_Arithmetic:_evaluation_error:_`zero_divisor'_______________ |      |

There is one  exception to this rule.   For compatibility the  functions
inf/0 and nan/0  return 1.0Inf and the  default system NaN. The  ability
to create, read and write such values is  primarily provided to exchange
data with languages that can represent the full range of IEEE doubles.


22..1166..11..77 FFoorrccee oonnllyy uunnddeerrssccoorree ttoo iinnttrroodduuccee aa vvaarriiaabbllee

According to the ISO standard and most Prolog  systems, identifiers that
start with  an uppercase  letter or  an underscore  are variables.    In
the  past, _P_r_o_l_o_g  _b_y _B_I_M  provided an  alternative syntax,  where  only
the  underscore (_) introduces  a variable.    As  of SWI-Prolog  7.3.27
SWI-Prolog supports  this alternative syntax,  controlled by the  Prolog
flag var_prefix.  As the character_escapes flag, this flag is maintained
per module, where the default is false, supporting standard syntax.

Having only the  underscore introduce a variable is particularly  useful
if  code contains  identifiers for  case  sensitive external  languages.
Examples are  the RDF library where  code frequently specifies  property
and  class  names  and the  R  interface  for  specifying  functions  or
variables that  start with an  uppercase character.   Lexical  databases
were  part of  the  terms start  with  an  uppercase letter  is  another
category were the readability of the code improves using this option.


22..1166..11..88 UUnniiccooddee PPrroolloogg ssoouurrccee

The ISO standard  specifies the Prolog syntax  in ASCII characters.   As
SWI-Prolog supports Unicode  in source files we must extend  the syntax.
This  section describes  the implication  for  the source  files,  while
writing international source files is described in section ????.

The  SWI-Prolog Unicode  character classification  is  based on  version
6.0.0  of the  Unicode  standard.    Please  note  that char_type/2  and
friends, intended  to be used with all  text except Prolog source  code,
is based on the C library locale-based classification routines.

  o _Q_u_o_t_e_d _a_t_o_m_s _a_n_d _s_t_r_i_n_g_s
    Any  character  of  any script  can  be  used in  quoted  atoms  and
    strings.      The  escape  sequences  \uXXXX  and   \UXXXXXXXX  (see
    section ????) were  introduced to specify Unicode code points in ASCII
    files.

  o _A_t_o_m_s _a_n_d _V_a_r_i_a_b_l_e_s
    We  handle  them in  one item  as they  are closely  related.    The
    Unicode  standard  defines  a  syntax for  identifiers  in  computer
    languages.   In this syntax identifiers start with ID_Start followed
    by  a sequence of ID_Continue codes.  Such sequences are  handled as
    a  single token  in SWI-Prolog.    The token  is a  _v_a_r_i_a_b_l_e iff  it
    starts with  an uppercase character or an underscore (_).  Otherwise
    it  is an atom.   Note  that many languages do  not have the  notion
    of  character case.  In such languages variables _m_u_s_t be  written as
    _name.

  o _W_h_i_t_e _s_p_a_c_e
    All  characters marked as separators (Z*) in the Unicode  tables are
    handled as layout characters.

  o _C_o_n_t_r_o_l _a_n_d _u_n_a_s_s_i_g_n_e_d _c_h_a_r_a_c_t_e_r_s
    Control  and unassigned  (C*) characters produce  a syntax error  if
    encountered outside quoted atoms/strings and outside comments.

  o _O_t_h_e_r _c_h_a_r_a_c_t_e_r_s
    The  first 128 characters follow the  ISO Prolog standard.   Unicode
    symbol  and punctuation characters (general category S* and  P*) act
    as  glueing symbol  characters (i.e.,  just  like ==:   an  unquoted
    sequence of symbol characters are combined into an atom).

    Other  characters (this is mainly No:  _a _n_u_m_e_r_i_c _c_h_a_r_a_c_t_e_r  _o_f _o_t_h_e_r
    _t_y_p_e) are currently handled as `solo'.


22..1166..11..99 SSiinngglleettoonn vvaarriiaabbllee cchheecckkiinngg

A _s_i_n_g_l_e_t_o_n  _v_a_r_i_a_b_l_e is  a variable  that appears  only one  time in  a
clause.   It can always be  replaced by _, the  _a_n_o_n_y_m_o_u_s variable.   In
some cases,  however, people  prefer to give  the variable a  name.   As
mistyping a variable is a common mistake, Prolog  systems generally give
a  warning (controlled  by style_check/1)  if a  variable is  used  only
once.   The system can  be informed that a  variable is meant to  appear
once by _s_t_a_r_t_i_n_g it with  an underscore, e.g., _Name.  Please  note that
any variable,  except plain _, shares  with variables of the same  name.
The term  t(_X, _X) is equivalent  to t(X, X),  which is _d_i_f_f_e_r_e_n_t  from
t(_, _).

As  Unicode requires  variables  to start  with  an underscore  in  many
languages, this schema  needs to be extended.   First we define the  two
classes of named variables.

  o _N_a_m_e_d _s_i_n_g_l_e_t_o_n _v_a_r_i_a_b_l_e_s
    Named  singletons start with  a double underscore  (__) or a  single
    underscore followed by an uppercase letter, e.g., __var or _Var.

  o _N_o_r_m_a_l _v_a_r_i_a_b_l_e_s
    All other variables are  `normal' variables.  Note this makes _var a
    normal variable.

Any normal variable appearing  exactly once in the clause _a_n_d  any named
singleton variables appearing  more than once are  reported.  Below  are
some examples  with warnings in  the right column.   Singleton  messages
can be suppressed using the style_check/1 directive.

___________________________________________________________________________
| test(_).      |                                                         |

| test(_a).     |Singleton variables:  [_a]                                 |
| test(_12).    |Singleton variables:  [_12]                                |
| test(A).     |Singleton variables:  [A]                                 |
| test(_A).     |                                                         |
| test(__a).    |                                                         |
| test(_, _).   |                                                         |
| test(_a, _a). |                                                         |

| test(__a, __a).S|ingleton-marked variables appearing more than once:  [__a] |
| test(_A, _A). |Singleton-marked variables appearing more than once:  [_A] |
|_test(A,_A).__|__________________________________________________________|_

SSeemmaannttiicc ssiinngglleettoonnss

Starting with  version 6.5.1,  SWI-Prolog has  _s_y_n_t_a_c_t_i_c _s_i_n_g_l_e_t_o_n_s  and
_s_e_m_a_n_t_i_c  _s_i_n_g_l_e_t_o_n_s.    The first  are  checked  by read_clause/3  (and
read_term/3 using  the  option singletons(_w_a_r_n_i_n_g)).    The  latter  are
generated by the compiler  for variables that appear alone in  a _b_r_a_n_c_h.
For  example, in  the  code below  the  variable _X  is not  a  _s_y_n_t_a_c_t_i_c
singleton,  but the variable  _X does  not communicate  any bindings  and
replacing _X with _does not change the semantics.

________________________________________________________________________|                                                                        |

|test :-                                                                 |
|        (   test_1(X)                                                   |
|        ;   test_2(X)                                                   |
||_______)._____________________________________________________________ ||


22..1177 RRaattiioonnaall ttrreeeess ((ccyycclliicc tteerrmmss))

SWI-Prolog  supports  rational  trees,  also   known  as  cyclic  terms.
`Supports'  is  so  defined  that  most   relevant  built-in  predicates
terminate  when faced  with rational  trees.    Almost all  SWI-Prolog's
built-in term  manipulation predicates process terms  in a time that  is
linear to the amount of memory used to represent the  term on the stack.
The following set  of predicates safely handles rational trees:   =../2,
==/2,  =@=/2,  =/2, @</2 , @=</2,  @>=/2,  @>/2,  \==/2,  \=@=/2,  \=/2,
acyclic_term/1, bagof/3,  compare/3, copy_term/2, cyclic_term/1,  dif/2,
duplicate_term/2,   findall/3,  ground/1,   term_hash/2,   numbervars/3,
numbervars/4,    recorda/3,   recordz/3,    setof/3,    subsumes_term/2,
term_variables/2,   throw/1,   unify_with_occurs_check/2,    unifiable/3,
when/2, write/1 (and related predicates) .

In  addition,  some built-ins  recognise  rational  trees and  raise  an
appropriate exception.    Arithmetic evaluation belongs  to this  group.
The  compiler (asserta/1,  etc.)   also  raises  an exception.    Future
versions may  support rational  trees.   Predicates  that could  provide
meaningful processing  of rational  trees raise  a representation_error.
Predicates for  which rational trees  have no meaningful  interpretation
raise a type_error.  For example:

________________________________________________________________________|                                                                        |
|1 ?- A = f(A), asserta(a(A)).                                           |

|ERROR: asserta/1: Cannot represent due to `cyclic_term'                 |
|2 ?- A = 1+A, B is A.                                                   |
|ERROR: is/2: Type error: `expression' expected, found                   |
||____________`@(S_1,[S_1=1+S_1])'_(cyclic_term)________________________ ||


22..1188 JJuusstt--iinn--ttiimmee ccllaauussee iinnddeexxiinngg

SWI-Prolog  provides `just-in-time'  indexing over  multiple  arguments.
`Just-in-time' means that  clause indexes are not built by  the compiler
(or asserta/1  for dynamic predicates),  but on the  first call to  such
a predicate  where an  index might  help (i.e.,  a call  where at  least
one argument is  instantiated).  This  section describes the rules  used
by the  indexing logic.   Note that  this logic is  not `set in  stone'.
The indexing  capabilities of  the system  will change.   Although  this
inevitably leads  to some regressing  on some  particular use cases,  we
strive to avoid significant slowdowns.

The  list below  describes  the  clause selection  process  for  various
predicates and  calls.   The  alternatives are considered  in the  order
they are presented.

  o _S_p_e_c_i_a_l _p_u_r_p_o_s_e _c_o_d_e
    Currently two special  cases are recognised by the compiler:  static
    code  with exactly one clause and static code with two  clauses, one
    where  the first argument is the  empty list ([]) and one where  the
    first argument is a non-empty list ([_|_]).

  o _L_i_n_e_a_r _s_c_a_n _o_n _f_i_r_s_t _a_r_g_u_m_e_n_t
    The  principal clause list maintains  a _k_e_y for the first  argument.
    An  indexing  key is  either  a constant  or a  functor  (name/arity
    reference).    Calls with  an instantiated first  argument and  less
    than  10  clauses perform  a  linear scan  for a  possible  matching
    clause  using this index key.  If the result is deterministic  it is
    used.  Otherwise the system looks for better indexes..

  o _H_a_s_h _l_o_o_k_u_p
    If  none of the  above applies, the  system considers the  available
    hash  tables for which  the corresponding argument is  instantiated.
    If  a table is  found with acceptable  characteristics, it is  used.
    Otherwise  it assesses  the clauses for  all instantiated  arguments
    and  selects  the best  candidate  for creating  a new  hash  table.
    If  there is  no single  argument that provides  an acceptable  hash
    quality  it will search for a  combination of arguments.   Searching
    for index candidates is only performed on the first 254 arguments.

    If  a single-argument  index contains multiple  compound terms  with
    the  same name and arity and  at least one non-variable argument,  a
    _l_i_s_t  _i_n_d_e_x is created.   A subsequent query where this argument  is
    bound  to a compound causes jiti indexing to be  applied _r_e_c_u_r_s_i_v_e_l_y
    on  the arguments of the term.   This is called _d_e_e_p _i_n_d_e_x_i_n_g.   See
    also section ????

    Clauses  that have  a variable  at an  otherwise indexable  argument
    must  be linked into all hash  buckets.  Currently, predicates  that
    have  more than  10% such clauses  for a  specific argument are  not
    considered for indexing on that argument.

    Disregarding  variables, the suitability of an argument  for hashing
    is  expressed as the  number of unique  indexable values divided  by
    the  standard deviation of the  number of duplicate values for  each
    value plus one.

    The  indexes of  dynamic  predicates are  deleted if  the number  of
    clauses  is doubled since its creation or reduced below 1/4th.   The
    JIT  approach  will recreate  a  suitable index  on the  next  call.
    Indexes  of running predicates  cannot be deleted.   They are  added
    to  a `removed index  list' associated to  the predicate.   Outdated
    indexes  of predicates  are reclaimed  by garbage_collect_clauses/0.
    The  clause garbage collector  is scheduled automatically, based  on
    time  and space based heuristics.  See garbage_collect_clauses/0 for
    details.

The library prolog_jiti provides jiti_list/0,1 to list  the characteris-
tics of all or some of the created hash tables.

DDyynnaammiicc  pprreeddiiccaatteess are   indexed  using  the   same  rules  as   static
predicates, except that  the _s_p_e_c_i_a_l _p_u_r_p_o_s_e schemes are  never applied.
In addition, the  JITI index is discarded  if the number of clauses  has
doubled  since the  predicate was  last assessed  or  shrinks below  one
fourth.   A  subsequent call  reassesses the statistics  of the  dynamic
predicate and, when applicable, creates a new index.


22..1188..11 DDeeeepp iinnddeexxiinngg

As  introduced  in  section  ????,  _d_e_e_p   _i_n_d_e_x_i_n_g  creates  hash  tables
distinguish clauses that share a compound with the same  name and arity.
Deep indexes  allow for efficient  lookup of arbitrary  terms.   Without
it is advised  to _f_l_a_t_t_e_n the term,  i.e., turn F(_X) into two  arguments
for the  fact, one argument  denoting the functor _F  and the second  the
argument X.  This works fine  as long as  the arity of  the each of  the
terms is the same.   Alternatively we can use term_hash/2 or term_hash/4
to  add a  column holding  the hash  of the  term.    That approach  can
deal with arbitrary  arities, but requires us  to know that the term  is
ground (term_hash/2) or up to which depth we get  sufficient selectivity
(term_hash/4).

Deep indexing  does not require  this knowledge  and leads to  efficient
lookup regardless  of the  instantiation of  the query  and term.    The
current version does come with some limitations:

  o The  decision which  index  to use  is taken  independently at  each
    level.  Future versions may be smarter on this.

  o Deep  indexing only  applies to  a _s_i_n_g_l_e _a_r_g_u_m_e_n_t  indexes (on  any
    argument).

  o Currently, the depth of indexing is limited to 7 levels.

Note that, when compiling DCGs (see section ????) and  the first body term
is a _l_i_t_e_r_a_l, it is included into the clause head.   See for example the
grammar and its plain Prolog representation below.

________________________________________________________________________|                                                                        |

|det(det(a), sg)  --> "a".                                               |
|det(det(an), pl) --> "an".                                              |
|det(det(the),|_)_-->_"the".____________________________________________ |             |

________________________________________________________________________|                                                                        |
|?- listing(det).                                                        |
|det(det(a), sg, [97|A], A).                                             |
|det(det(an), pl, [97, 110|A], A).                                       |
|det(det(the),|_,_[116,_104,_101|A],_A).________________________________ |             |

Deep argument  indexing will create indexes  for the 3rd list  argument,
providing  speedup and  making  clause  selection deterministic  if  all
rules start with  a literal and all literals  are unique in the first  6
elements.  Note that deep index creation stops as  soon as a determistic
choice  can be  made or  there are  no two  clauses that  have the  same
name/arity combination.


22..1188..22 FFuuttuurree ddiirreeccttiioonnss

  o The  `special cases' can  be extended.   This is notably  attractive
    for  static predicates  with a  relatively small  number of  clauses
    where a hash lookup is too costly.

  o Create  an  efficient decision  diagram  for selecting  between  low
    numbers of static clauses.

  o Implement  a better judgements for selecting between deep  and plain
    indexes.


22..1188..33 IInnddeexxiinngg aanndd ppoorrttaabbiilliittyy

The base-line functionality of Prolog implementations  provides indexing
on constants and functor (name/arity) on the first argument.   This must
be your  assumption if wide  portability of  your program is  important.
This can typically be  achieved by exploiting term_hash/2 or term_hash/4
and/or  maintaining  multiple  copies  of  a  predicate  with  reordered
arguments and wrappers that update all  implementations (assert/retract)
and selects the appropriate implementation (query).

YAP  provides  full  JIT  indexing,   including  indexing  arguments  of
compound terms.   YAP's indexing has been the inspiration  for enhancing
SWI-Prolog's indexing capabilities.


22..1199 WWiiddee cchhaarraacctteerr ssuuppppoorrtt

SWI-Prolog  supports _w_i_d_e  _c_h_a_r_a_c_t_e_r_s, characters  with character  codes
above  255 that  cannot be  represented in  a single  _b_y_t_e.    _U_n_i_v_e_r_s_a_l
_C_h_a_r_a_c_t_e_r  _S_e_t (UCS)  is the  ISO/IEC 10646  standard  that specifies  a
unique 31-bit unsigned  integer for any character  in any language.   It
is  a superset  of  16-bit  Unicode, which  in  turn  is a  superset  of
ISO  8859-1 (ISO  Latin-1),  a  superset  of US-ASCII.  UCS  can  handle
strings  holding  characters  from  multiple  languages,  and  character
classification (uppercase, lowercase, digit, etc.)   and operations such
as case conversion are unambiguously defined.

For this reason SWI-Prolog has two representations for  atoms and string
objects (see  section ????).    If the  text fits  in ISO  Latin-1, it  is
represented as  an array  of 8-bit characters.    Otherwise the text  is
represented as an array of 32-bit numbers.   This representational issue
is completely  transparent to  the Prolog user.    Users of the  foreign
language  interface as  described in  chapter ????  sometimes  need to  be
aware of these issues though.

Character coding comes into  view when characters of strings need  to be
read from  or written to file  or when they  have to be communicated  to
other software  components using  the foreign  language interface.    In
this section we only deal with I/O through streams,  which includes file
I/O as well as I/O through network sockets.


22..1199..11 WWiiddee cchhaarraacctteerr eennccooddiinnggss oonn ssttrreeaammss

Although  characters   are  uniquely  coded   using  the  UCS   standard
internally, streams  and files are byte  (8-bit) oriented and there  are
a variety of  ways to represent the larger  UCS codes in an 8-bit  octet
stream.   The most popular  one, especially in  the context of the  web,
is UTF-8.   Bytes 0 ... 127 represent simply the  corresponding US-ASCII
character, while bytes 128  ... 255 are used for multi-byte  encoding of
characters placed  higher in the  UCS space.   Especially on  MS-Windows
the 16-bit  Unicode standard,  represented by  pairs of  bytes, is  also
popular.

Prolog I/O streams  have a property called _e_n_c_o_d_i_n_g which  specifies the
used encoding that  influences get_code/2 and put_code/2 as well as  all
the other text I/O predicates.

The  default  encoding  for  files  is  derived  from  the  Prolog  flag
encoding,  which   is  initialised  from  the  environment.      If  the
environment variable  LANG ends  in "UTF-8", this  encoding is  assumed.
Otherwise  the  default   is  text  and  the  translation  is   left  to
the  wide-character functions  of  the C  library.    The  encoding  can
be  specified  explicitly  in load_files/2  for  loading  Prolog  source
with  an  alternative encoding,   open/4 when  opening  files  or  using
set_stream/2  on  any  open  stream.     For  Prolog   source  files  we
also  provide  the encoding/1  directive  that  can be  used  to  switch
between encodings that are compatible with US-ASCII (ascii, iso_latin_1,
utf8  and many  locales).    See  also  section  ???? for  writing  Prolog
files with  non-US-ASCII characters  and section ????  for syntax  issues.
For  additional   information  and  Unicode   resources,  please   visit
http://www.unicode.org/.

SWI-Prolog currently defines and supports the following encodings:

oocctteett
    Default  encoding for binary streams.  This causes the stream  to be
    read and written fully untranslated.

aasscciiii
    7-bit  encoding  in 8-bit  bytes.   Equivalent  to  iso_latin_1,  but
    generates errors and warnings on encountering values above 127.

iissoo__llaattiinn__11
    8-bit  encoding supporting many Western languages.  This  causes the
    stream to be read and written fully untranslated.

tteexxtt
    C  library default locale encoding for  text files.  Files are  read
    and  written using the C library functions mbrtowc()  and wcrtomb().
    This may be the  same as one of the other locales, notably it may be
    the  same as iso_latin_1 for Western languages  and utf8 in a  UTF-8
    context.

uuttff88
    Multi-byte encoding of full UCS, compatible with ascii.  See above.

uunniiccooddee__bbee
    Unicode  _B_i_g  _E_n_d_i_a_n.     Reads  input  in  pairs  of  bytes,   most
    significant byte first.  Can only represent 16-bit characters.

uunniiccooddee__llee
    Unicode  _L_i_t_t_l_e  _E_n_d_i_a_n.    Reads input  in  pairs of  bytes,  least
    significant byte first.  Can only represent 16-bit characters.

Note that not all encodings can represent all characters.   This implies
that  writing text  to a  stream  may cause  errors because  the  stream
cannot represent these characters.   The behaviour of a stream  on these
errors can  be controlled  using set_stream/2.   Initially the  terminal
stream writes the  characters using Prolog escape sequences while  other
streams generate an I/O exception.


22..1199..11..11 BBOOMM:: BByyttee OOrrddeerr MMaarrkk

From  section ????,  you  may  have got  the  impression that  text  files
are  complicated.   This  section  deals with  a related  topic,  making
life  often easier  for the  user, but  providing another  worry to  the
programmer.   BBOOMM or  _B_y_t_e _O_r_d_e_r _M_a_r_k_e_r is  a technique for  identifying
Unicode text files as well  as the encoding they use.  Such  files start
with  the Unicode  character 0xFEFF,  a non-breaking,  zero-width  space
character.   This is a pretty unique  sequence that is not likely to  be
the start of  a non-Unicode file and uniquely distinguishes  the various
Unicode file  formats.   As it is  a zero-width  blank, it even  doesn't
produce any output.  This solves all problems, or ...

Some formats start  off as US-ASCII and  may contain some encoding  mark
to  switch to  UTF-8, such  as the  encoding="UTF-8" in  an XML  header.
Such formats often  explicitly forbid the use  of a UTF-8 BOM. In  other
cases there  is additional  information revealing  the encoding,  making
the use of a BOM redundant or even illegal.

The BOM  is handled by  SWI-Prolog open/4 predicate.   By default,  text
files are  probed for  the BOM when  opened for reading.    If a BOM  is
found, the  encoding is  set accordingly and  the property bom(_t_r_u_e)  is
available through stream_property/2.   When opening a file for  writing,
writing a BOM can be requested using the option bom(_t_r_u_e) with open/4.


22..2200 SSyysstteemm lliimmiittss


22..2200..11 LLiimmiittss oonn mmeemmoorryy aarreeaass

The  SWI-Prolog  engine   uses  three  _s_t_a_c_k_s  the  _l_o_c_a_l  _s_t_a_c_k   (also
called _e_n_v_i_r_o_n_m_e_n_t  _s_t_a_c_k) stores  the environment frames  used to  call
predicates  as  well  as  choice  points.     The   _g_l_o_b_a_l  _s_t_a_c_k  (also
called  _h_e_a_p)  contains  terms,  floats,  strings  and  large  integers.
Finally,  the  _t_r_a_i_l _s_t_a_c_k  records  variable bindings  and  assignments
to  support _b_a_c_k_t_r_a_c_k_i_n_g.     The internal  data  representation  limits
these stacks  to 128  MB (each) on  32-bit processors.   More  generally
to  2 to the power bits-per-pointer - 5 bytes,  which  implies they  are
virtually unlimited on 64-bit machines.

As of version  7.7.14, the stacks are  restricted by the writeable  flag
stack_limit or the command line option --stack_limit.  This  flag limits
the combined  size of the three  stacks per thread.   The default  limit
is currently 512 Mbytes on 32-bit machines, which  imposes no additional
limit considering the  128 Mbytes hard limit  on 32-bit and 1 Gbytes  on
64-bit machines.

Considering portability,  applications that need  to modify the  default
limits are advised to do so using the Prolog flag stack_limit.
            ________________________________________________
            |_Option_|Area_name____|Description____________|_||-L||llooccaallTssttaacckkhe||||local|stack|is used

            |        |             to   store  the  execu- |                    ||
            |        |             tion   environments  of |                    ||
            |        |             procedure  invocations. |                    ||
            |        |             The  space  for  an en- |                    ||
            |        |             vironment  is reclaimed |                    ||
            |        |             when  it  fails,  exits |                    ||
            |        |             without  leaving choice |                    ||
            |        |             points,   the  alterna- |                    ||
            |        |             tives  are cut off with |                    ||
            |        |                                     |                    ||

            |        |             the  !/0  predicate  or |                    ||
            |        |             no  choice  points have |                    ||
            |        |             been  created since the |                    ||
            |        |             invocation and the last |                    ||
            |        |             subclause   is  started |                    ||
            |        |             (last   call  optimisa- |                    ||
            ||       ||            tion).||                 ||                   ||

            |   -G   |gglloobbaall ssttaacckk ||Theuseglobald stacktoisstore| terms
            |        |             ||created during Prolog's|
            |        |             ||execution.     Terms on|
            |        |             ||                       |
            |        |             ||this  stack will be re-|
            |        |             ||claimed by backtracking|
            |        |             ||to  a point  before the|
            |        |             ||term   was  created  or|
            |        |             ||by  garbage  collection|

            |        |             ||(provided  the  term is|
            ||| -T   |||ttrraaiill ssttaacckk||no||longer||referenced).T|he|| trail   stack  is
            |        |             us||ed   to   store   as-|

            |        |             si||gnments during execu-|
            |        |             ti||on.   Entries on this|
            |        |             st||ack  remain alive un-|
            |        |             ti||l backtracking before|
            |        |             th||e  point  of creation|
            |        |             or|| the garbage collec- |
            |        |             to||r determines they are|
            |        |             no||longer needed.       |
            |        |             As||the trail and global |
            |        |             st||acks are garbage col-|

            |        |             le||cted    together,   a|
            |        |             sm||all  trail  can cause|
            |        |               ||                     |
            |        |             an||  excessive   amount |
            |        |             of||garbage collections. |
            |        |             To||  avoid  this,   the |
            |        |             tr||ail  is automatically|
            |        |             re||sized  to be at least|
            |        |             1/||6th  of  the  size of|
            |________|_____________th||e_global_stack.______|_

                        Table 2.2:  Memory areas


22..2200..11..11 TThhee hheeaapp

With  the heap,  we  refer  to the  memory  area  used by  malloc()  and
friends.  SWI-Prolog uses the area to store  atoms, functors, predicates
and  their clauses,  records and  other dynamic  data.    No limits  are
imposed on the addresses returned by malloc() and friends.


22..2200..22 OOtthheerr LLiimmiittss

CCllaauusseess  The only  limit  on  clauses  is their  arity  (the  number  of
    arguments  to the head),  which is  limited to 1024.   Raising  this
    limit is easy and relatively cheap; removing it is harder.

AAttoommss aanndd SSttrriinnggss  SWI-Prolog has no limits  on the length of atoms  and
    strings.    The  number of  atoms is  limited to  16777216 (16M)  on
    32-bit  machines.  On  64-bit machines this is virtually  unlimited.
    See also section ????.

MMeemmoorryy aarreeaass  On 32-bit hardware, SWI-Prolog data is packed in  a 32-bit
    word,  which contains  both type and  value information.   The  size
    of  the various memory areas  is limited to 128  MB for each of  the
    areas,  except  for the  program heap,  which is  not limited.    On
    64-bit hardware there are no meaningful limits.

NNeessttiinngg ooff tteerrmmss  Most built-in  predicates  that process  Prolog  terms
    create  an explicitly  managed  stack and  perform optimization  for
    processing  the last  argument of  a term.   This  implies they  can
    process  deeply nested  terms at  constant and  low usage  of the  C
    stack,  and the  system raises  a resource  error if  no more  stack
    can  be  allocated.   Currently  only read/1  and  write/1 (and  all
    variations  thereof) still use the C stack and may cause  the system
    to  crash  in an  uncontrolled way  (i.e., not  mapped  to a  Prolog
    exception that can be caught).

IInntteeggeerrss  On  most systems  SWI-Prolog  is  compiled  with  support  for
    unbounded  integers by means  of the GNU GMP  library.  In  practice
    this  means that integers are bound by  the global stack size.   Too
    large  integers cause a resource_error.   On systems that lack  GMP,
    integers are 64-bit on 32- as well as 64-bit machines.

    Integers  up to the value of  the max_tagged_integerProlog  flag are
    represented  more  efficiently on  the  stack.   For  integers  that
    appear  in clauses, the value (below  max_tagged_integeror not)  has
    little impact on the size of the clause.

FFllooaattiinngg ppooiinntt nnuummbbeerrss  Floating  point  numbers   are  represented   as
    C-native double precision floats, 64-bit IEEE on most machines.


22..2200..33 RReesseerrvveedd NNaammeess

The boot compiler  (see -b option) does  not support the module  system.
As large parts of  the system are written in Prolog itself we  need some
way to  avoid name clashes  with the  user's predicates, database  keys,
etc.  Like  Edinburgh C-Prolog [??] all predicates, database  keys, etc.,
that should be hidden from the user start with a dollar ($) sign.


22..2211 SSWWII--PPrroolloogg aanndd 6644--bbiitt mmaacchhiinneess

Most of  today's 64-bit  platforms are  capable of  running both  32-bit
and  64-bit applications.    This asks  for some  clarifications on  the
advantages and drawbacks of 64-bit addressing for (SWI-)Prolog.


22..2211..11 SSuuppppoorrtteedd ppllaattffoorrmmss

SWI-Prolog can  be compiled  for a 32-  or 64-bit  address space on  any
system with a suitable  C compiler.  Pointer arithmetic is based  on the
type (u)intptr_t from stdint.h, with suitable emulation on MS-Windows.


22..2211..22 CCoommppaarriinngg 3322-- aanndd 6644--bbiittss PPrroolloogg

Most of Prolog's memory usage consists of pointers.   This indicates the
primary drawback:   Prolog memory  usage almost  doubles when using  the
64-bit addressing  model.   Using  more memory means  copying more  data
between CPU and main memory, slowing down the system.

What then  are the advantages?   First  of all, SWI-Prolog's  addressing
of the  Prolog stacks  does not  cover the  whole address  space due  to
the  use of  _t_y_p_e _t_a_g  _b_i_t_s and  _g_a_r_b_a_g_e _c_o_l_l_e_c_t_i_o_n  _f_l_a_g_s.   On  32-bit
hardware the stacks  are limited to 128 MB each.   This tends to  be too
low for demanding applications  on modern hardware.  On  64-bit hardware
the limit is 232 times higher, exceeding the  addressing capabilities of
today's CPUs and operating systems.  This implies  Prolog can be started
with stack sizes that use the full capabilities of your hardware.

Multi-threaded applications  profit much more  because every thread  has
its  own  set of  stacks.     The  Prolog stacks  start  small  and  are
dynamically expanded (see section ????).  The C  stack is also dynamically
expanded, but  the maximum size  is _r_e_s_e_r_v_e_d when  a thread is  started.
Using 100 threads  at the maximum default  C stack of 8Mb (Linux)  costs
800Mb virtual memory!

The  implications  of  theoretical performance  loss  due  to  increased
memory  bandwidth implied  by exchanging  wider pointers  depend on  the
design of  the hardware.   We only  have data for  the popular IA32  vs.
AMD64 architectures.  Here, it appears that the  loss is compensated for
by an  instruction set that has  been optimized for modern  programming.
In particular, the AMD64 has more registers and  the relative addressing
capabilities  have been  improved.    Where  we  see a  10%  performance
degradation when placing the SWI-Prolog kernel in a  Unix shared object,
we cannot find a measurable difference on AMD64.


22..2211..33 CChhoooossiinngg bbeettwweeeenn 3322-- aanndd 6644--bbiitt PPrroolloogg

For those  cases where  we can  choose between  32 and  64 bits,  either
because the hardware and OS support both or because  we can still choose
the hardware and OS, we give guidelines for this decision.

First of  all, if SWI-Prolog  needs to be linked  against 32- or  64-bit
native libraries,  there  is no choice  as it  is not  possible to  link
32- and  64-bit code into  a single  executable.   Only if all  required
libraries are available  in both sizes and  there is no clear reason  to
use either do the different characteristics of Prolog become important.

Prolog  applications that  require  more than  the  128 MB  stack  limit
provided in 32-bit  addressing mode must use  the 64-bit edition.   Note
however that the limits  must be doubled to accommodate the  same Prolog
application.

If the system is  tight on physical memory, 32-bit Prolog has  the clear
advantage of using only slightly more than half of  the memory of 64-bit
Prolog.   This argument applies as long  as the application fits in  the
_v_i_r_t_u_a_l _a_d_d_r_e_s_s  _s_p_a_c_e of  the machine.   The  virtual address space  of
32-bit hardware is 4GB, but in many cases the  operating system provides
less to user applications.

The  only  standard  SWI-Prolog library  adding  significantly  to  this
calculation is  the RDF  database provided by  the _s_e_m_w_e_b  package.   It
uses approximately 80 bytes per triple on 32-bit hardware  and 150 bytes
on 64-bit hardware.  Details depend on how  many different resources and
literals appear  in the dataset  as well  as desired additional  literal
indexes.

Summarizing,  if applications  are small  enough to  fit comfortably  in
virtual  and physical  memory, simply  take the  model used  by most  of
the applications  on the OS.  If applications require  more than 128  MB
per  stack,  use the  64-bit  edition.    If applications  approach  the
size  of physical  memory, fit  in the  128 MB  stack limit  and fit  in
virtual memory, the 32-bit version has clear advantages.   For demanding
applications  on 64-bit  hardware  with  more than  about  6GB  physical
memory the 64-bit model is the model of choice.


CChhaapptteerr 33..  IINNIITTIIAALLIISSIINNGG AANNDD MMAANNAAGGIINNGG AA PPRROOLLOOGG PPRROOJJEECCTT

Prolog text-books  give you  an overview of  the Prolog  language.   The
manual tells  you what predicates  are provided in  the system and  what
they do.   This  chapter explains how  to run  a project.   There is  no
ultimate `right'  way to  do this.   Over  the years  we developed  some
practice in  this area and  SWI-Prolog's commands  are there to  support
this practice.   This chapter  describes the conventions and  supporting
commands.

The first two  sections (section ???? and  section ????) only require  plain
Prolog.    The remainder  discusses the  use of  the built-in  graphical
tools that require the XPCE graphical library installed on your system.


33..11 TThhee pprroojjeecctt ssoouurrccee ffiilleess

Organisation  of  source files  depends  largely  on the  size  of  your
project.    If  you  are doing  exercises  for  a Prolog  course  you'll
normally use one  file for each exercise.   If you have a small  project
you'll work with one directory holding a couple of  files and some files
to link  it all together.    Even bigger projects  will be organised  in
sub-projects, each using its own directory.


33..11..11 FFiillee NNaammeess aanndd LLooccaattiioonnss


33..11..11..11 FFiillee NNaammee EExxtteennssiioonnss

The  first  consideration  is what  extension  to  use  for  the  source
files.   Tradition  calls for  .pl, but  conflicts with  Perl force  the
use  of  another  extension on  systems  where  extensions  have  global
meaning,  such as  MS-Windows.    On  such systems  .pro is  the  common
alternative.    On  MS-Windows,  the  alternative  extension  is  stored
in the  registry key HKEY_CURRENT_USER/Software/SWI/Prolog/fileExtension
or HKEY_LOCAL_MACHINE/Software/SWI/Prolog/fileExtension.   All  versions
of  SWI-Prolog  load files  with  the  extension  .pl as  well  as  with
the  registered  alternative  extension  without  explicitly  specifying
the  extension.    For  portability  reasons we  propose  the  following
convention:

IIff tthheerree iiss nnoo ccoonnfflliicctt  because  you   do   not   use   a   conflicting
    application  or the system does not force a unique  relation between
    extension and application, use .pl.

WWiitthh aa ccoonnfflliicctt  choose .pro and  use this extension  for the files  you
    want  to load  through your file  manager.   Use .pl  for all  other
    files for maximal portability.


33..11..11..22 PPrroojjeecctt DDiirreeccttoorriieess

Large projects  are generally composed of  sub-projects, each using  its
own directory or  directory structure.   If nobody else will ever  touch
your files  and you  use only  one computer,  there is  little to  worry
about, but this is rarely the case with a large project.

To   improve   portability,   SWI-Prolog   uses   the   POSIX   notation
for  filenames,   which  uses   the  forward   slash  (/)  to   separate
directories.   Just  before reaching  the file  system, SWI-Prolog  uses
prolog_to_os_filename/2to  convert the filename to the conventions  used
by  the hosting  operating system.    It is  _s_t_r_o_n_g_l_y  advised to  write
paths using the  /, especially on systems  using the \ for this  purpose
(MS-Windows).  Using  \ violates the portability rules and  requires you
to _d_o_u_b_l_e the \ due to the Prolog quoted-atom escape rules.

Portable  code should  use  prolog_to_os_filename/2to  convert  computed
paths  into system  paths  when constructing  commands for  shell/1  and
friends.


33..11..11..33 SSuubb--pprroojjeeccttss uussiinngg sseeaarrcchh ppaatthhss

Thanks to Quintus, Prolog adapted an extensible  mechanism for searching
files using file_search_path/2.   This mechanism allows for  comfortable
and readable specifications.

Suppose  you  have  extensive  library  packages  on  graph  algorithms,
set  operations and  GUI  primitives.    These sub-projects  are  likely
candidates for re-use in future projects.  A good choice  is to create a
directory with sub-directories for each of these sub-projects.

Next,  there are  three options.    One is  to add  the sub-projects  to
the directory  hierarchy of the current  project.   Another is to use  a
completely dislocated  directory.  Third,  the sub-project can be  added
to  the SWI-Prolog  hierarchy.    Using  local installation,  a  typical
file_search_path/2is:

________________________________________________________________________|                                                                        |
|:- prolog_load_context(directory, Dir),                                 |

|   asserta(user:file_search_path(myapp, Dir)).                          |
|                                                                        |
|user:file_search_path(graph, myapp(graph)).                             |
|user:file_search_path(ui,|___myapp(ui))._______________________________ |                         |

When  using sub-projects  in the  SWI-Prolog hierarchy,  one should  use
the path  alias swi as basis.   For  a system-wide installation, use  an
absolute path.

Extensive sub-projects  with a  small well-defined API  should define  a
load  file with  calls to  use_module/1 to  import the  various  library
components and export the API.


33..11..22 PPrroojjeecctt SSppeecciiaall FFiilleess

There are  a number of  tasks you typically carry  out on your  project,
such as  loading it, creating a  saved state, debugging  it, etc.   Good
practice  on large  projects is  to  define small  files that  hold  the
commands to execute such a task, name this file after  the task and give
it a  file extension that  makes starting  easy (see section  ????).   The
task _l_o_a_d  is generally central  to these  tasks.   Here is a  tentative
list:

  o load.pl
    Use  this file  to set  up the  environment (Prolog  flags and  file
    search  paths) and load the sources.  Quite commonly this  file also
    provides  convenient predicates  to parse command  line options  and
    start the application.

  o run.pl
    Use  this file to start the application.  Normally it  loads load.pl
    in  silent-mode,  and  calls one  of  the starting  predicates  from
    load.pl.

  o save.pl
    Use this file to  create a saved state of the application by loading
    load.pl  and calling qsave_program/2 to generate a saved  state with
    the proper options.

  o debug.pl
    Loads  the program for  debugging.   In addition to loading  load.pl
    this  file defines rules for portray/1 to modify printing  rules for
    complex  terms and customisation rules for the debugger  and editing
    environment.  It may start some of these tools.


33..11..33 IInntteerrnnaattiioonnaall ssoouurrccee ffiilleess

As discussed in section ????, SWI-Prolog  supports international character
handling.    Its  internal  encoding  is UNICODE.  I/O  streams  convert
to/from this internal  format.  This  section discusses the options  for
source files not in US-ASCII.

SWI-Prolog  can  read  files  in  any  of  the  encodings  described  in
section  ????.   Two  encodings  are of  particular interest.    The  text
encoding  deals with  the  current  _l_o_c_a_l_e,  the default  used  by  this
computer for  representing text files.   The encodings  utf8, unicode_le
and unicode_be are _U_N_I_C_O_D_E encodings:  they can represent---in  the same
file---characters of  virtually any known language.   In addition,  they
do so unambiguously.

If one wants to represent non US-ASCII text as Prolog  terms in a source
file, there are several options:

  o _U_s_e _e_s_c_a_p_e _s_e_q_u_e_n_c_e_s
    This approach describes  NON-ASCII as sequences of the form \_o_c_t_a_l\.
    The  numerical argument is interpreted as a UNICODE character.   The
    resulting  Prolog file is  strict 7-bit US-ASCII,  but if there  are
    many NON-ASCII characters it becomes very unreadable.

  o _U_s_e _l_o_c_a_l _c_o_n_v_e_n_t_i_o_n_s
    Alternatively  the file  may be specified  using local  conventions,
    such  as the EUC  encoding for Japanese text.   The disadvantage  is
    portability.  If  the file is moved to another machine, this machine
    must  use the same _l_o_c_a_l_e  or the file is  unreadable.  There is  no
    elegant  way if files  from multiple locales  must be united in  one
    application  using this technique.   In other words, it is  fine for
    local projects in countries with uniform locale conventions.

  o _U_s_i_n_g _U_T_F_-_8 _f_i_l_e_s
    The best way  to specify source files with many NON-ASCII characters
    is  definitely the use  of UTF-8 encoding.   Prolog can be  notified
    of  this encoding in two  ways, using a  UTF-8 _B_O_M (see section  ????)
    or  using  the directive  :- encoding(utf8).  Many of  today's  text
    editors,  including PceEmacs,  are capable  of editing UTF-8  files.
    Projects  that were started using local conventions can  be re-coded
    using  the Unix iconv  tool or often  using commands offered by  the
    editor.


33..22 UUssiinngg mmoodduulleess

Modules have  been debated fiercely  in the Prolog world.   Despite  all
counter-arguments we feel they are extremely useful because:

  o _T_h_e_y _h_i_d_e _l_o_c_a_l _p_r_e_d_i_c_a_t_e_s
    This  is the reason they were invented  in the first place.   Hiding
    provides  two  features.    They  allow  for short  predicate  names
    without  worrying  about  conflicts.    Given  the  flat  name-space
    introduced  by modules, they  still require meaningful module  names
    as well as meaningful names for exported predicates.

  o _T_h_e_y _d_o_c_u_m_e_n_t _t_h_e _i_n_t_e_r_f_a_c_e
    Possibly  more important than avoiding name conflicts is  their role
    in  documenting  which part  of the  file is  for  public usage  and
    which  is  private.    When  editing a  module  you may  assume  you
    can  reorganise anything except  the name and  the semantics of  the
    exported predicates without worrying.

  o _T_h_e_y _h_e_l_p _t_h_e _e_d_i_t_o_r
    The  PceEmacs built-in editor  does on-the-fly cross-referencing  of
    the  current module, colouring predicates based on their  origin and
    usage.    Using modules,  the editor  can quickly find  out what  is
    provided  by the imported  modules by reading  just the first  term.
    This  allows it to  indicate in real-time  which predicates are  not
    used or not defined.

Using modules  is generally  easy.   Only if  you write  meta-predicates
(predicates reasoning about  other predicates) that are exported from  a
module is a  good understanding required of  the resolution of terms  to
predicates inside a module.  Here is a typical example from readutil.

________________________________________________________________________|                                                                        |

|:- module(read_util,                                                    |
|          [ read_line_to_codes/2,       % +Fd, -Codes                   |
|            read_line_to_codes/3,       % +Fd, -Codes, ?Tail            |
|            read_stream_to_codes/2,     % +Fd, -Codes                   |
|            read_stream_to_codes/3,     % +Fd, -Codes, ?Tail            |

|            read_file_to_codes/3,       % +File, -Codes, +Options       |
|            read_file_to_terms/3        % +File, -Terms, +Options       |
||_________]).__________________________________________________________ ||


33..33 TThhee tteesstt--eeddiitt--rreellooaadd ccyyccllee

SWI-Prolog  does  not  enforce  the  use  of  a  particular  editor  for
writing  Prolog source  code.   Editors  are  complicated programs  that
must  be  mastered in  detail  for  real  productive programming.     If
you  are familiar  with  a specific  editor  you  should not  be  forced
to change.    You may  specify your  favourite editor  using the  Prolog
flag editor,  the environment variable EDITOR  or by defining rules  for
prolog_edit:edit_source/1.

The use of  a built-in editor, which  is selected by setting the  Prolog
flag  editor to  pce_emacs,  has  advantages.   The  XPCE _e_d_i_t_o_r  object,
around which the built-in  PceEmacs is built, can be opened as  a Prolog
stream allowing analysis of your source by the real Prolog system.


33..33..11 LLooccaattiinngg tthhiinnggss ttoo eeddiitt

The central  predicate for  editing something is  edit/1, an  extensible
front-end  that searches  for objects  (files, predicates,  modules,  as
well as XPCE classes  and methods) in the Prolog database.   If multiple
matches are  found it  provides a choice.    Together with the  built-in
completion on atoms  bound to the TAB key  this provides a quick way  to
edit objects:

________________________________________________________________________|                                                                        |
|?- edit(country).                                                       |

|Please select item to edit:                                             |
|                                                                        |
|  1 chat:country/10      '/staff/jan/lib/prolog/chat/countr.pl':16      |
|  2 chat:country/1       '/staff/jan/lib/prolog/chat/world0.pl':72      |
|                                                                        |
|Your|choice?___________________________________________________________ |    |


33..33..22 EEddiittiinngg aanndd iinnccrreemmeennttaall ccoommppiillaattiioonn

One of  the nice features  of Prolog  is that the  code can be  modified
while  the program  is running.    Using  pure Prolog  you  can trace  a
program,  find it  is misbehaving,  enter  a _b_r_e_a_k  _e_n_v_i_r_o_n_m_e_n_t,  modify
the  source code,  reload it  and finally  do _r_e_t_r_y  on the  misbehaving
predicate  and  try  again.      This  sequence  is  not   uncommon  for
long-running programs.    For faster  programs one  will normally  abort
after understanding  the misbehaviour,  edit the source,  reload it  and
try again.

One of the nice features of SWI-Prolog is the  availability of make/0, a
simple predicate that checks  all loaded source files to see  which ones
you have modified.  It then reloads these  files, considering the module
from which  the file  was loaded  originally.   This greatly  simplifies
the trace-edit-verify development cycle.  For example,  after the tracer
reveals there is something wrong with prove/3, you do:

________________________________________________________________________|                                                                        |
|?-|edit(prove).________________________________________________________ |  |

Now  edit the  source,  possibly switching  to  other files  and  making
multiple changes.   After finishing,  invoke make/0, either through  the
editor UI (Compile/Make (Control-C Control-M)) or on the  top level, and
watch the files being reloaded.

________________________________________________________________________|                                                                        |

|?- make.                                                                |
|%|show_compiled_into_photo_gallery_0.03_sec,_3,360_bytes_______________ | |


33..44 UUssiinngg tthhee PPcceeEEmmaaccss bbuuiilltt--iinn eeddiittoorr


33..44..11 AAccttiivvaattiinngg PPcceeEEmmaaccss

Initially edit/1  uses the  editor specified in  the EDITOR  environment
variable.   There are two ways to  force it to use the built-in  editor.
One is to  set the Prolog flag editor  to pce_emacs and the other is  by
starting the editor explicitly using the emacs/[0,1] predicates.


33..44..22 BBlluuffffiinngg tthhrroouugghh PPcceeEEmmaaccss

PceEmacs closely  mimics Richard Stallman's  GNU-Emacs commands,  adding
features from  modern window-based  editors to make  it more  acceptable
for beginners.

At the  basis, PceEmacs  maps keyboard sequences  to methods defined  on
the extended  _e_d_i_t_o_r object.   Some frequently  used commands are,  with
their key-binding, presented  in the menu bar above each  editor window.
A complete  overview of the  bindings for the  current _m_o_d_e is  provided
through Help/Show key bindings (Control-h Control-b).


33..44..22..11 EEddiitt mmooddeess

Modes  are the  heart of  (Pce)Emacs.   Modes  define dedicated  editing
support for  a particular kind  of (source)  text.   For our purpose  we
want _P_r_o_l_o_g _m_o_d_e.   There are various  ways to make PceEmacs use  Prolog
mode for a file.

  o _U_s_i_n_g _t_h_e _p_r_o_p_e_r _e_x_t_e_n_s_i_o_n
    If  the file  ends in .pl  or the  selected alternative (e.g.  .pro)
    extension, Prolog mode is selected.

  o _U_s_i_n_g #!/path/to/.../swipl
    If  the  file  is a  _P_r_o_l_o_g  _S_c_r_i_p_t  file, starting  with  the  line
    #!/path/to/swipl _o_p_t_i_o_n_s, Prolog  mode is selected regardless of the
    extension.

  o _U_s_i_n_g -*- Prolog -*-
    If the above sequence  appears in the first line of the file (inside
    a Prolog comment) Prolog mode is selected.

  o _E_x_p_l_i_c_i_t _s_e_l_e_c_t_i_o_n
    Finally,  using  File/Mode/Prolog  you  can switch  to  Prolog  mode
    explicitly.


33..44..22..22 FFrreeqquueennttllyy uusseedd eeddiittoorr ccoommmmaannddss

Below we list a few important commands and how to activate them.

  o _C_u_t_/_C_o_p_y_/_P_a_s_t_e
    These  commands  follow Unix/X11  traditions.    You're best  suited
    with  a three-button mouse.   After  selecting using the  left-mouse
    (double-click  uses word-mode  and triple  line-mode), the  selected
    text   is  _a_u_t_o_m_a_t_i_c_a_l_l_y  copied  to  the  clipboard   (X11  primary
    selection  on  Unix).   _C_u_t  is achieved  using the  DEL  key or  by
    typing something else at  the location.  _P_a_s_t_e is achieved using the
    middle-mouse  (or wheel) button.   If you don't have a  middle-mouse
    button,  pressing the  left- and  right-button at the  same time  is
    interpreted  as a middle-button click.   If nothing helps, there  is
    the Edit/Paste menu entry.  Text is pasted at the caret location.

  o _U_n_d_o
    Undo  is bound to the GNU-Emacs Control-_ as well as  the MS-Windows
    Control-Z sequence.

  o _A_b_o_r_t
    Multi-key sequences can be aborted at any stage using Control-G.

  o _F_i_n_d
    Find  (Search) is  started  using Control-S  (forward) or  Control-R
    (backward).    PceEmacs  implements  _i_n_c_r_e_m_e_n_t_a_l _s_e_a_r_c_h.    This  is
    difficult  to use for  novices, but very  powerful once you get  the
    clue.    After one  of the above  start keys,  the system  indicates
    search  mode in  the status  line.   As  you are  typing the  search
    string, the system  searches for it, extending the search with every
    character you type.   It illustrates the current match using a green
    background.

    If  the target  cannot be found,  PceEmacs warns  you and no  longer
    extends  the search  string.   During search,  some characters  have
    special  meaning.  Typing anything but these characters  commits the
    search, re-starting normal edit mode.  Special commands are:

    Control-S
         Search forwards for next.

    Control-R
         Search backwards for next.

    Control-W
         Extend search to next word boundary.

    Control-G
         Cancel search, go back to where it started.

    ESC
         Commit search, leaving caret at found location.

    Backspace
         Remove a character from the search string.

  o _D_y_n_a_m_i_c _A_b_b_r_e_v_i_a_t_i_o_n
    Also  called _d_a_b_b_r_e_v, dynamic  abbreviation is an important  feature
    of Emacs clones to  support programming.  After typing the first few
    letters  of an identifier, you may press Alt-/, causing  PceEmacs to
    search  backwards for  identifiers that  start the same  and use  it
    to  complete the text  you typed.   A second Alt-/ searches  further
    backwards.    If  there are  no  hits before  the caret,  it  starts
    searching  forwards.   With  some practice, this  system allows  for
    entering  code  very fast  with nice  and  readable identifiers  (or
    other difficult long words).

  o _O_p_e_n _(_a _f_i_l_e_)
    Is  called File/Find  file (Control-x Control-f).    By default  the
    file  is loaded into the current window.   If you want to  keep this
    window,  press Alt-s or click the little icon at the bottom  left to
    make the window _s_t_i_c_k_y.

  o _S_p_l_i_t _v_i_e_w
    Sometimes  you want to look at two places  in the same file.   To do
    this,  use Control-x 2 to create  a new window pointing to  the same
    file.   Do not worry, you  can edit as well as move around  in both.
    Control-x 1 kills all other windows running on the same file.

These are  the most commonly used  commands.   In section ???? we  discuss
specific support for dealing with Prolog source code.


33..44..33 PPrroolloogg MMooddee

In  the  previous  section (section  ????)  we  explained  the  basics  of
PceEmacs.     Here  we  continue   with  Prolog-specific  functionality.
Possibly  the most  interesting is  _S_y_n_t_a_x _h_i_g_h_l_i_g_h_t_i_n_g.    Unlike  most
editors  where  this  is  based  on  simple  patterns,  PceEmacs  syntax
highlighting  is  achieved   by  Prolog  itself  actually  reading   and
interpreting the  source as you  type it.   There  are three moments  at
which PceEmacs checks (part of) the syntax.

  o _A_f_t_e_r _t_y_p_i_n_g _a .
    After  typing a . that  is not preceded  by a _s_y_m_b_o_l character,  the
    system  assumes you completed a clause,  tries to find the start  of
    this  clause and verifies the syntax.   If this process succeeds  it
    colours  the elements  of the  clause according to  the rules  given
    below.    Colouring is  done using  information from  the last  full
    check  on this file.  If it fails, the syntax error  is displayed in
    the status line and the clause is not coloured.

  o _A_f_t_e_r _t_h_e _c_o_m_m_a_n_d Control-c Control-s
    Acronym  for CCheck SSyntax, it performs the same checks as  above for
    the  clause surrounding the caret.  On a syntax error,  however, the
    caret is moved to the expected location of the error.

  o _A_f_t_e_r _p_a_u_s_i_n_g _f_o_r _t_w_o _s_e_c_o_n_d_s
    After  a short  pause (2  seconds), PceEmacs opens  the edit  buffer
    and  reads it  as a  whole, creating  an index  of defined,  called,
    dynamic,  imported and exported predicates.  After  completing this,
    it  re-reads the file and colours  all clauses and calls with  valid
    syntax.

  o _A_f_t_e_r _t_y_p_i_n_g Control-l Control-l
    The  Control-l command re-centers the window (scrolls the  window to
    make  the caret  the center  of the window).    Typing this  command
    twice starts the same process as above.

TThhee ccoolloouurr sscchheemmaa

itself  is  defined  in  emacs/prolog_colour.     The  colouring  can  be
extended and  modified using multifile  predicates.   Please check  this
source file for  details.  In  general, underlined objects have a  popup
(right-mouse button)  associated with  common commands  such as  viewing
the  documentation or  source.    BBoolldd  text  is  used to  indicate  the
definition of  objects (typically predicates  when using plain  Prolog).
Other colours follow intuitive conventions.  See table ????.
          _____________________________________________________
          |______________________Clauses_______________________|
          | Blue bold  |Head of an exported predicate          |
          | Red bold   |Head of a predicate that is not called |

          |_Black_bold_|Head_of_remaining_predicates___________|
          |______________Calls_in_the_clause_body______________|
          | Blue       |Call to built-in or imported predicate |
          | Red        |Call to undefined predicate            |
          |_Purple_____|Call_to_dynamic_predicate______________|
          |___________________Other_entities___________________|

          | Dark green |Comment                                |
          | Dark blue  |Quoted atom or string                  |
          |_Brown______|Variable_______________________________|

                     Table 3.1:  Colour conventions

LLaayyoouutt ssuuppppoorrtt Layout  is not `just nice',  it is _e_s_s_e_n_t_i_a_l for  writing
readable code.   There is  much debate on  the proper layout of  Prolog.
PceEmacs, being  a rather  small project,  supports only one  particular
style for layout.  Below are examples of typical constructs.

________________________________________________________________________|                                                                        |
|head(arg1, arg2).                                                       |

|                                                                        |
|head(arg1, arg2) :- !.                                                  |
|                                                                        |
|head(Arg1, arg2) :- !,                                                  |
|        call1(Arg1).                                                    |
|                                                                        |
|head(Arg1, arg2) :-                                                     |

|        (   if(Arg1)                                                    |
|        ->  then                                                        |
|        ;   else                                                        |
|        ).                                                              |
|                                                                        |
|head(Arg1) :-                                                           |
|        (   a                                                           |
|        ;   b                                                           |

|        ).                                                              |
|                                                                        |
|head :-                                                                 |
|        a(many,                                                         |
|          long,                                                         |
|          arguments(with,                                               |
|                    many,                                               |

|                    more),                                              |
|          and([ a,                                                      |
|                long,                                                   |
|                list,                                                   |
|                with,                                                   |
|                a,                                                      |
|              | tail                                                    |
||_____________]))._____________________________________________________ ||

PceEmacs uses the  same conventions as GNU-Emacs.   The TAB key  indents
the current  line according  to the  syntax rules.    Alt-q indents  all
lines  of the  current clause.    It provides  support for  head,  calls
(indented 1  tab), if-then-else, disjunction  and argument lists  broken
across multiple lines as illustrated above.


33..44..33..11 FFiinnddiinngg yyoouurr wwaayy aarroouunndd

The command Alt-.   extracts name and arity from the caret  location and
jumps (after conformation  or edit) to the definition of  the predicate.
It does  so based on the  source-location database of loaded  predicates
also used  by edit/1.   This makes locating  predicates reliable if  all
sources are loaded and up-to-date (see make/0).

In addition,  references to files  in use_module/[1,2], consult/1,  etc.
are red if the file cannot be found and underlined blue  if the file can
be loaded.  A popup allows for opening the referenced file.


33..55 TThhee GGrraapphhiiccaall DDeebbuuggggeerr

SWI-Prolog  offers  two  debuggers.     One  is   the  traditional  text
console-based  4-port Prolog  tracer  and the  other is  a  window-based
source  level  debugger.     The  window-based  debugger  requires  XPCE
installed.   It operates  based on  the prolog_trace_interception/4 hook
and other low-level functionality described in chapter ????.

Window-based tracing provides a much better overview due  to the eminent
relation to your source code, a clear list of  named variables and their
bindings as well  as a graphical overview  of the call and choice  point
stack.  There are  some drawbacks though.  Using a textual trace  on the
console, one can scroll  back and examine the past, while  the graphical
debugger just presents a (much better) overview of the current state.


33..55..11 IInnvvookkiinngg tthhee wwiinnddooww--bbaasseedd ddeebbuuggggeerr

Whether the  text-based or window-based debugger  is used is  controlled
using  the predicates  guitracer/0 and  noguitracer/0.   Entering  debug
mode  is controlled  using  the normal  predicates  for this:    trace/0
and  spy/1.   In  addition, PceEmacs  prolog mode  provides the  command
Prolog/Break  at (Control-c b)  to insert  a break-point  at a  specific
location in the source code.

The graphical tracer is  particulary useful for debugging threads.   The
tracer must be loaded from the main thread before it can  be used from a
background thread.


gguuiittrraacceerr
    This  predicate  installs the  above-mentioned hooks  that  redirect
    tracing  to  the  window-based  environment.    No  window  appears.
    The  debugger window  appears as actual  tracing is started  through
    trace/0,  by hitting a spy point  defined by spy/1 or a  break point
    defined using the PceEmacs command Prolog/Break at (Control-c b).


nnoogguuiittrraacceerr
    Disable  the hooks  installed by  guitracer/0,  reverting to  normal
    text console-based tracing.


ggttrraaccee
    Utility defined as guitracer,trace.


ggddeebbuugg
    Utility defined as guitracer,debug.


ggssppyy((_+_P_r_e_d_i_c_a_t_e))
    Utility defined as guitracer,spy(Predicate).


33..66 TThhee PPrroolloogg NNaavviiggaattoorr

Another  tool is  the  _P_r_o_l_o_g  _N_a_v_i_g_a_t_o_r.    This  tool can  be  started
from  PceEmacs  using the  command  Browse/Prolog  navigator,  from  the
GUI  debugger or  using  the  programmatic IDE  interface  described  in
section ????.


33..77 CCrroossss--rreeffeerreenncceerr

A cross-referencer  is a tool that  examines the caller-callee  relation
between predicates, and, using this information  to explicate dependency
relations between source  files, finds calls to non-existing  predicates
and predicates  for which no  callers can be  found.   Cross-referencing
is useful during program development, reorganisation,  clean-up, porting
and  other program  maintenance tasks.    The dynamic  nature of  Prolog
makes the  task non-trivial.    Goals can be  created dynamically  using
call/1  after construction  of a  goal term.    Abstract  interpretation
can find  some of  these calls,  but they  can also  come from  external
communication,  making  it  impossible  to  predict  the  callee.     In
other  words, the  cross-referencer has  only  partial understanding  of
the program,  and its  results are  necessarily incomplete.   Still,  it
provides valuable information to the developer.

SWI-Prolog's cross-referencer  is split into  two parts.   The  standard
Prolog  library prolog_xref  is an  extensible library  for  information
gathering  described  in  section ????,   and the  XPCE  library  pce_xref
provides a graphical front-end for the  cross-referencer described here.
We  demonstrate the  tool on  CHAT80, a  natural  language question  and
answer system by Fernando C.N. Pereira and David H.D. Warren.


ggxxrreeff
    Run  cross-referencer on  all currently loaded  files and present  a
    graphical  overview of  the result.   As  the predicate operates  on
    the  currently loaded application it  must be run after loading  the
    application.

The lleefftt wwiinnddooww (see  figure ????) provides browsers for loaded  files and
predicates.   To  avoid long file  paths, the  file hierarchy has  three
main branches.  The first is the current  directory holding the sources.
The  second is  marked  alias, and  below  it are  the  file-search-path
aliases  (see file_search_path/2 and  absolute_file_name/3).    Here  you
find files  loaded from  the system as  well as  modules of the  program
loaded from  other locations  using the file  search path.   All  loaded
files  that fall  outside these  categories are  below  the last  branch
called /.    Files where  the system found  suspicious dependencies  are
marked  with an  exclamation mark.    This  also holds  for  directories
holding such files.  Clicking on a file opens a  _F_i_l_e _i_n_f_o window in the
right pane.

The FFiillee iinnffoo  window shows a file,  its main properties, its  undefined
and not-called predicates  and its import and export relations  to other
files  in the  project.   Both  predicates and  files can  be opened  by
clicking  on them.    The number  of callers  in a  file  for a  certain
predicate is  indicated with  a blue  underlined number.   A  left-click
will open a list and allow editing the calling predicate.

The DDeeppeennddeenncciieess  (see figure ????) window  displays a graphical  overview
of dependencies  between files.   Using the  background menu a  complete
graph of the project can be created.  It is  also possible to drag files
onto the  graph window and  use the menu on  the nodes to  incrementally
expand the  graph.   The underlined  blue text  indicates the number  of
predicates used in the destination file.  Left-clicking  opens a menu to
open the definition or select one of the callers.

MMoodduullee  aanndd nnoonn--mmoodduullee  ffiilleess The  cross-referencer threads  module  and
non-module  project files  differently.    Module  files  have  explicit
import  and  export   relations  and  the  tool  shows  the   usage  and
consistency of the relations.   Using the Header menu command,  the tool
creates a  consistent import list  for the module  that can be  included
in the  file.   The tool computes the  dependency relations between  the
non-module files.   If  the user  wishes to convert  the project into  a
module-based one,  the Header  command generates  an appropriate  module
header and import list.  Note that the  cross-referencer may have missed
dependencies  and does  not  deal with  meta-predicates defined  in  one
module and called in another.  Such problems must be resolved manually.

SSeettttiinnggss The  following settings  can be  controlled  from the  settings
menu:

WWaarrnn aauuttoollooaadd
    By  default disabled.   If enabled, modules that require  predicates
    to  be  autoloaded are  flagged with  a warning  and  the file  info
    window of a module shows the required autoload predicates.

WWaarrnn nnoott ccaalllleedd
    If  enabled (default),  the file  overview shows an  alert icon  for
    files that have predicates that are not called.


33..88 AAcccceessssiinngg tthhee IIDDEE ffrroomm yyoouurr pprrooggrraamm

Over the years a collection of IDE components have  been developed, each
with its own interface.   In addition, some of these  components require
each  other, and  loading  IDE components  must be  on demand  to  avoid
the IDE  being part of  a saved state (see  qsave_program/2).   For  this
reason, access to the  IDE is concentrated on a single  interface called
prolog_ide/1:


pprroolloogg__iiddee((_+_A_c_t_i_o_n))
    This  predicate ensures the  IDE-enabling XPCE component is  loaded,
    creates  the XPCE class _p_r_o_l_o_g___i_d_e and sends  _A_c_t_i_o_n to its one  and
    only instance @prolog_ide.  _A_c_t_i_o_n is one of the following:

    ooppeenn__nnaavviiggaattoorr((_+_D_i_r_e_c_t_o_r_y))
         Open  the  Prolog Navigator  (see  section  ????)  in  the  given
         _D_i_r_e_c_t_o_r_y.

    ooppeenn__ddeebbuugg__ssttaattuuss
         Open a window to edit spy and trace points.

    ooppeenn__qquueerryy__wwiinnddooww
         Open  a  little  window  to  run  Prolog  queries  from  a  GUI
         component.

    tthhrreeaadd__mmoonniittoorr
         Open a graphical  window indicating existing threads and  their
         status.

    ddeebbuugg__mmoonniittoorr
         Open a graphical front-end for the debug  library that provides
         an overview of the topics and catches messages.

    xxrreeff
         Open  a  graphical  front-end  for  the  cross-referencer  that
         provides an overview of predicates and their callers.


33..99 SSuummmmaarryy ooff tthhee IIDDEE

The  SWI-Prolog  development   environment  consists  of  a  number   of
interrelated but  not (yet) integrated  tools.   Here is  a list of  the
most important features and tips.

  o _A_t_o_m _c_o_m_p_l_e_t_i_o_n
    The  console  completes a  partial atom  on the  TAB  key and  shows
    alternatives on the command Alt-?.

  o _U_s_e edit/1 _f_o_r _f_i_n_d_i_n_g _l_o_c_a_t_i_o_n_s
    The  command edit/1 takes the name  of a file, module, predicate  or
    other  entity registered  through extensions and  starts the  user's
    preferred editor at the right location.

  o _S_e_l_e_c_t _e_d_i_t_o_r
    External   editors  are  selected   using  the  EDITOR   environment
    variable,  by setting  the Prolog  flag editor, or  by defining  the
    hook qpredrefprolog_editedit_source1.

  o _U_p_d_a_t_e _P_r_o_l_o_g _a_f_t_e_r _e_d_i_t_i_n_g
    Using make/0, all files you have edited are re-loaded.

  o _P_c_e_E_m_a_c_s
    Offers  syntax highlighting and checking based on  real-time parsing
    of the editor's buffer, layout support and navigation support.

  o _U_s_i_n_g _t_h_e _g_r_a_p_h_i_c_a_l _d_e_b_u_g_g_e_r
    The   predicates  guitracer/0   and  noguitracer/0  switch   between
    traditional  text-based and window-based debugging.   The tracer  is
    activated  using the trace/0, spy/1  or menu items from PceEmacs  or
    the Prolog Navigator.

  o _T_h_e _P_r_o_l_o_g _N_a_v_i_g_a_t_o_r
    Shows  the file structure and structure inside the file.   It allows
    for loading files, editing, setting spy points, etc.


CChhaapptteerr 44..  BBUUIILLTT--IINN PPRREEDDIICCAATTEESS


44..11 NNoottaattiioonn ooff PPrreeddiiccaattee DDeessccrriippttiioonnss

We have  tried to  keep the  predicate descriptions  clear and  concise.
First,  the predicate  name is  printed in  bold face,  followed by  the
arguments  in italics.    Arguments are  preceded by  a mode  indicator.
There  is  no  complete agreement  on  mode  indicators  in  the  Prolog
community.  We use the following definitions:

        _________________________________________________________++Argument must  be ground,  i.e., the  argument may

             not contain a variable anywhere.
         +   Argument must  be  fully  instantiated to  a  term
             that satisfies the type.   This is not necessarily
             _g_r_o_u_n_d, e.g., the term [_] is a _l_i_s_t, although its

             only member is unbound.
         -   Argument  is   an   _o_u_t_p_u_t  argument.       Unless
             specified  otherwise,  output arguments  need  not
             to  be   unbound.       For  example,   the   goal
             findall(X, Goal, [T]) is good style and equivalent
             to  findall(X, Goal, Xs), Xs = [T] Note  that  the
             _d_e_t_e_r_m_i_n_i_s_m  specification,  e.g.,   ``det''  only
             applies if this argument is unbound.

         --  Argument  must be  unbound.    Typically  used  by
             predicates that  create `something'  and return  a
             handle to the created object, such as open/3 which
             creates a _s_t_r_e_a_m.
         ?   Argument  must   be  bound   to  a  _p_a_r_t_i_a_l   _t_e_r_m
             of   the   indicated  type.        Note   that   a
             variable  is   a  partial   term  for  any   type.

             Think  of   the  argument   as  either  _i_n_p_u_t   or
             _o_u_t_p_u_t  or   _b_o_t_h   input  and   output.       For
             example,  in stream_property(S, reposition(Bool)),
             the reposition part of  the term is input  and the
             uninstantiated _B_o_o_l is output.
         :   Argument  is   a  meta-argument.      Implies   +.
             See chapter  ????  for  more information  on  module
             handling.

         @   Argument is not  further instantiated.   Typically
             used for type tests.
         !   Argument contains a mutable structure  that may be
        _____modified_using_setarg/3_or_nb_setarg/3._____________

Referring  to a  predicate in  running text  is done  using a  _p_r_e_d_i_c_a_t_e
_i_n_d_i_c_a_t_o_r.     The  canonical and  most  generic  form  of  a  predicate
indicator is a term <_m_o_d_u_l_e>:<_n_a_m_e>/<_a_r_i_t_y>.  If the module is  irrelevant
(built-in predicate)  or can be  inferred from the  context it is  often
omitted.  Compliant  to the ISO standard draft on DCG (see  section ????),
SWI-Prolog  also  allows for  [<_m_o_d_u_l_e>]:<_n_a_m_e>//<_a_r_i_t_y>  to  refer  to  a
grammar  rule.    For  all  non-negative arity,  <_n_a_m_e>//<_a_r_i_t_y>  is  the
same as  <_n_a_m_e>/<_a_r_i_t_y>+2, regardless  of whether  or not  the referenced
predicate is defined or can be used as a grammar rule.   The //-notation
can  be used  in all  places that  traditionally allow  for a  predicate
indicator, e.g., the module declaration, spy/1, and dynamic/1.


44..22 CChhaarraacctteerr rreepprreesseennttaattiioonn

In  traditional (Edinburgh)  Prolog,  characters are  represented  using
_c_h_a_r_a_c_t_e_r _c_o_d_e_s.   Character codes are  integer indices into a  specific
character set.    Traditionally the  character set  was 7-bit  US-ASCII.
8-bit  character sets  have  been allowed  for  a long  time,  providing
support for national  character sets, of which iso-latin-1  (ISO 8859-1)
is applicable to many Western languages.

ISO Prolog introduces three types, two of which  are used for characters
and one for accessing binary streams (see open/4).  These types are:

  o _c_o_d_e
    A  _c_h_a_r_a_c_t_e_r _c_o_d_e  is an  integer representing  a single  character.
    As  files  may  use  multi-byte encoding  for  supporting  different
    character  sets (utf-8 encoding for example), reading a code  from a
    text file is in general not the same as reading a byte.

  o _c_h_a_r
    Alternatively,   characters  may  be  represented  as  _o_n_e_-_c_h_a_r_a_c_t_e_r
    _a_t_o_m_s.   This is a natural representation, hiding  encoding problems
    from the programmer as well as providing much easier debugging.

  o _b_y_t_e
    Bytes are used for accessing binary streams.

In SWI-Prolog, character codes are _a_l_w_a_y_s the Unicode  equivalent of the
encoding.  That is, if get_code/1 reads from a stream  encoded as KOI8-R
(used for the  Cyrillic alphabet), it returns the  corresponding Unicode
code  points.    Similarly,  assembling  or  disassembling  atoms  using
atom_codes/2 interprets the  codes as  Unicode points.   See section  ????
for details.

To ease the pain  of the two character representations (code  and char),
SWI-Prolog's built-in  predicates dealing  with character  data work  as
flexible as  possible:   they accept  data in  any of  these formats  as
long as  the interpretation  is unambiguous.   In  addition, for  output
arguments  that are  instantiated,  the  character is  extracted  before
unification.  This  implies that the following two calls  are identical,
both testing whether the next input character is an a.

________________________________________________________________________|                                                                        |

|peek_code(Stream, a).                                                   |
|peek_code(Stream,|97)._________________________________________________ |                 |

The  two character  representations are  handled by  a  large number  of
built-in predicates,  all of which are  ISO-compatible.  For  converting
between  code  and  character  there  is  char_code/2.     For  breaking
atoms and numbers into  characters there are atom_chars/2, atom_codes/2,
number_chars/2 and number_codes/2.   For character I/O on streams  there
are  get_char/[1,2],  get_code/[1,2],  get_byte/[1,2],  peek_char/[1,2],
peek_code/[1,2],  peek_byte/[1,2],  put_code/[1,2],  put_char/[1,2]  and
put_byte/[1,2].  The Prolog flag double_quotes controls how text between
double quotes is interpreted.


44..33 LLooaaddiinngg PPrroolloogg ssoouurrccee ffiilleess

This section deals  with loading Prolog source  files.  A Prolog  source
file is a plain  text file containing a Prolog program or  part thereof.
Prolog source files come in three flavours:

 AA ttrraaddiittiioonnaall   Prolog  source   file  contains   Prolog  clauses   and
    directives,  but no  _m_o_d_u_l_e _d_e_c_l_a_r_a_t_i_o_n  (see module/1).   They  are
    normally  loaded using consult/1  or ensure_loaded/1.  Currently,  a
    non-module file can only be loaded into a single module.

 AA mmoodduullee   Prolog source file  starts with a module  declaration.   The
    subsequent  Prolog code  is loaded  into the  specified module,  and
    only  the  _e_x_p_o_r_t_e_d predicates  are made  available  to the  context
    loading  the  module.     Module  files  are  normally  loaded  with
    use_module/[1,2].  See chapter ???? for details.

 AAnn iinncclluuddee   Prolog  source  file   is  loaded   using  the   include/1
    directive,  textually  including  Prolog  text into  another  Prolog
    source.   A file may be  included into multiple source files  and is
    typically  used to share _d_e_c_l_a_r_a_t_i_o_n_s  such as multifile or  dynamic
    between source files.

Prolog  source files  are  located using  absolute_file_name/3 with  the
following options:

________________________________________________________________________|                                                                        |

|locate_prolog_file(Spec, Path) :-                                       |
|        absolute_file_name(Spec,                                        |
|                           [ file_type(prolog),                         |
|                             access(read)                               |
|                           ],                                           |

||__________________________Path).______________________________________ ||

The file_type(_p_r_o_l_o_g) option is  used to determine the extension of  the
file using  prolog_file_type/2.    The default extension  is .pl.    _S_p_e_c
allows  for the  _p_a_t_h _a_l_i_a_s  construct defined  by absolute_file_name/3.
The most commonly used path alias is library(_L_i_b_r_a_r_y_F_i_l_e).   The example
below  loads the  library  file  ordsets.pl (containing  predicates  for
manipulating ordered sets).

________________________________________________________________________|                                                                        |
|:-|use_module(library(ordsets))._______________________________________ |  |

SWI-Prolog  recognises grammar  rules (DCG)  as  defined in  [??].    The
user may  define additional compilation of  the source file by  defining
the  dynamic  multifile predicates  term_expansion/2,  term_expansion/4,
goal_expansion/2  and goal_expansion/4.     It is  not  allowed  to  use
assert/1, retract/1 or any other  database predicate in term_expansion/2
other  than  for  local  computational  purposes.      Code  that  needs
to  create  additional clauses  must  use  compile_aux_clauses/1.     See
library(apply_macros) for an example.

A  _d_i_r_e_c_t_i_v_e  is  an  instruction to  the  compiler.     Directives  are
used to  set (predicate)  properties (see  section ????),  set flags  (see
set_prolog_flag/2)  and load files (this section).  Directives  are terms
of the form :- <_t_e_r_m>..  Here are some examples:

________________________________________________________________________|                                                                        |
|:- use_module(library(lists)).                                          |
|:- dynamic                                                              |

||_______store/2.________________%_Name,_Value__________________________ ||

The  directive initialization/1  can  be used  to run  arbitrary  Prolog
goals.   The specified goal is started  _a_f_t_e_r loading the file in  which
it appears has completed.

SWI-Prolog compiles  code as it  is read from  the file, and  directives
are  executed as  _g_o_a_l_s.   This  implies that  directives  may call  any
predicate that  has been defined  before the  point where the  directive
appears.  It also accepts ?- <_t_e_r_m>.as a synonym.

SWI-Prolog   does   not   have   a   separate   reconsult/1   predicate.
Reconsulting  is  implied automatically  by  the  fact that  a  file  is
consulted which is already loaded.

Advanced topics are handled in subsequent sections:   mutually dependent
files (section  ????), multithreaded  loading (section  ????) and  reloading
running code (section ????).

The core  of the  family of  loading predicates  is load_files/2.    The
predicates  consult/1, ensure_loaded/1,  use_module/1, use_module/2  and
reexport/1  pass the  file argument  directly to  load_files/2 and  pass
additional options as expressed in the table ????:
         _______________________________________________________PPrreeddiiccaatteeiiffmmuusstt__bbee__mmoodduulleeiimmppoorrtt

         ______________________________________________________________________________________________________________consult/1truefalseall
          ensure_loaded/1 not_loaded      false         all

          use_module/1    not_loaded       true         all
          use_module/2    not_loaded       true      specified
          reexport/1      not_loaded       true         all
         _reexport/2______not_loaded_______true______specified__

Table  4.1:   Properties of  the file-loading  predicates.   The  _i_m_p_o_r_t
column specifies what is imported if the loaded file is a module file.


llooaadd__ffiilleess((_:_F_i_l_e_s))
    Equivalent  to  load_files(_F_i_l_e_s_,  _[_]).    Same  as  consult/1,  See
    load_files/2 for supported options.


llooaadd__ffiilleess((_:_F_i_l_e_s_, _+_O_p_t_i_o_n_s))
    The  predicate load_files/2 is the parent  of all the other  loading
    predicates  except for include/1.   It  currently supports a  subset
    of  the options of Quintus load_files/2.   _F_i_l_e_s is either a  single
    source  file or a  list of source  files.   The specification for  a
    source  file is handed to absolute_file_name/2.  See  this predicate
    for  the supported expansions.   _O_p_t_i_o_n_s is a list of options  using
    the format _O_p_t_i_o_n_N_a_m_e(_O_p_t_i_o_n_V_a_l_u_e).

    The following options are currently supported:

    aauuttoollooaadd((_B_o_o_l))
         If true (default  false), indicate that  this load is a  _d_e_m_a_n_d
         load.   This  implies that,  depending  on the  setting of  the
         Prolog flag  verbose_autoload, the  load action  is printed  at
         level informational  or silent.   See also  print_message/2 and
         current_prolog_flag/2.

    cchheecckk__ssccrriipptt((_B_o_o_l))
         If false (default  true), do not  check the first character  to
         be # and skip the first line when found.

    ddeerriivveedd__ffrroomm((_F_i_l_e))
         Indicate that the  loaded file is derived  from _F_i_l_e.  Used  by
         make/0 to  time-check and  load the original  file rather  than
         the derived file.

    ddiiaalleecctt((_+_D_i_a_l_e_c_t))
         Load _F_i_l_e_s with  enhanced compatibility with the target  Prolog
         system  identified  by  _D_i_a_l_e_c_t.    See  expects_dialect/1  and
         section ???? for details.

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Specify the way  characters are encoded in  the file.   Default
         is taken  from the Prolog flag  encoding.   See section ????  for
         details.

    eexxppaanndd((_B_o_o_l))
         If true, run the  filenames through expand_file_name/2 and load
         the returned  files.   Default is false,  except for  consult/1
         which is intended  for interactive use.   Flexible location  of
         files is defined by file_search_path/2.

    ffoorrmmaatt((_+_F_o_r_m_a_t))
         Used to  specify  the file  format  if data  is loaded  from  a
         stream using  the stream(_S_t_r_e_a_m)  option.   Default is  source,
         loading  Prolog source  text.    If  qlf,  load QLF  data  (see
         qcompile/1).

    iiff((_C_o_n_d_i_t_i_o_n))
         Load the  file only  if the specified  condition is  satisfied.
         The value  true loads the  file unconditionally, changed  loads
         the file  if it  was  not loaded  before or  has been  modified
         since it  was loaded the  last time,  and not_loaded loads  the
         file if it was not loaded before.

    iimmppoorrttss((_I_m_p_o_r_t))
         Specify what  to import from  the loaded module.   The  default
         for use_module/1  is all.   _I_m_p_o_r_t  is passed  from the  second
         argument  of use_module/2.    Traditionally  it  is a  list  of
         predicate indicators to import.  As part  of the SWI-Prolog/YAP
         integration,  we  also  support  _P_r_e_d  as   _N_a_m_e  to  import  a
         predicate under another name.  Finally, _I_m_p_o_r_t can  be the term
         except(_E_x_c_e_p_t_i_o_n_s),  where _E_x_c_e_p_t_i_o_n_s  is a  list of  predicate
         indicators that  specify predicates  that are  _n_o_t imported  or
         _P_r_e_d as  _N_a_m_e terms  to denote renamed  predicates.   See  also
         reexport/2 and use_module/2.

         If _I_m_p_o_r_t  equals  all,  all operators  are imported  as  well.
         Otherwise,  operators  are _n_o_t  imported.    Operators  can  be
         imported selectively by adding terms op(_P_r_i_,_A_s_s_o_c_,_N_a_m_e)  to the
         _I_m_p_o_r_t list.    If such  a term  is  encountered, all  exported
         operators that unify with  this term are imported.   Typically,
         this  construct will  be used  with  all arguments  unbound  to
         import  all operators  or  with only  _N_a_m_e  bound to  import  a
         particular operator.

    mmooddiiffiieedd((_T_i_m_e_S_t_a_m_p))
         Claim that the source was loaded at  _T_i_m_e_S_t_a_m_p without checking
         the source.  This  option is intended to be used  together with
         the  stream(_I_n_p_u_t) option,  for  example after  extracting  the
         time from an HTTP server or database.

    mmoodduullee((_+_M_o_d_u_l_e))
         Load the indicated file  into the given module, overruling  the
         module name  specified in  the :- module(Name, ...)  directive.
         This currently  serves two  purposes:   (1)  allow loading  two
         module  files  that specify  the  same  module  into  the  same
         process and  force and  (2):  force  loading source  code in  a
         specific module,  even  if  the code  provides its  own  module
         name.  Experimental.

    mmuusstt__bbee__mmoodduullee((_B_o_o_l))
         If true,  raise an  error if  the file  is not  a module  file.
         Used by use_module/[1,2].

    qqccoommppiillee((_A_t_o_m))
         How to  deal  with quick-load-file  compilation by  qcompile/1.
         Values are:

         nneevveerr
             Default.  Do not use qcompile unless called explicitly.

         aauuttoo
             Use qcompile for all writeable files.  See comment below.

         llaarrggee
             Use  qcompile if  the file is  `large'.   Currently,  files
             larger than 100 Kbytes are considered large.

         ppaarrtt
             If  load_files/2 appears  in  a directive  of a  file  that
             is  compiled into Quick Load  Format using qcompile/1,  the
             contents  of the argument  files are  included in the  .qlf
             file instead of the loading directive.

         If this option is not present, it uses the value  of the Prolog
         flag qcompile as default.

    ooppttiimmiissee((_+_B_o_o_l_e_a_n))
         Explicitly  set the  optimization  for compiling  this  module.
         See optimise.

    rreeddeeffiinnee__mmoodduullee((_+_A_c_t_i_o_n))
         Defines what to do if  a file is loaded that provides  a module
         that is  already loaded from another  file.   _A_c_t_i_o_n is one  of
         false (default), which prints an error and refuses  to load the
         file, or  true, which  uses unload_file/1 on  the old file  and
         then proceeds  loading the new  file.   Finally, there is  ask,
         which starts interaction with  the user.  ask is  only provided
         if the stream user_input is associated with a terminal.

    rreeeexxppoorrtt((_B_o_o_l))
         If true re-export the  imported predicate.  Used  by reexport/1
         and reexport/2.

    rreeggiisstteerr((_B_o_o_l))
         If false, do not register the load location and options.   This
         option is used by make/0 and load_hotfixes/1 to avoid polluting
         the load-context database.  See source_file_property/2.

    ssaannddbbooxxeedd((_B_o_o_l))
         Load the  file in  _s_a_n_d_b_o_x_e_d mode.   This  option controls  the
         flag sandboxed_load.   The  only meaningful value  for _B_o_o_l  is
         true.  Using false while the Prolog flag is set  to true raises
         a permission error.

    ssccooppee__sseettttiinnggss((_B_o_o_l))
         Scope style_check/1 and expects_dialect/1to  the file and files
         loaded from  the file after  the directive.   Default is  true.
         The system and  user initialization files  (see -f and -F)  are
         loading with scope_settings(_f_a_l_s_e).

    ssiilleenntt((_B_o_o_l))
         If  true, load  the  file  without printing  a  message.    The
         specified  value is  the  default for  all  files loaded  as  a
         result of loading the specified files.  This  option writes the
         Prolog flag verbose_load with the negation of _B_o_o_l.

    ssttrreeaamm((_I_n_p_u_t))
         This SWI-Prolog  extension compiles  the data  from the  stream
         _I_n_p_u_t.   If this option  is used, _F_i_l_e_s  must be a single  atom
         which is  used to identify  the source  location of the  loaded
         clauses  as well  as  to remove  all  clauses  if the  data  is
         reconsulted.

         This  option  is   added  to  allow  compiling  from   non-file
         locations such as databases, the web, the  _u_s_e_r (see consult/1)
         or other servers.  It can be combined with  format(_q_l_f) to load
         QLF data from a stream.

    The  load_files/2 predicate  can be  hooked to  load  other data  or
    data  from objects  other than  files.   See  prolog_load_file/2 for
    a  description and  http/http_load  for an  example.   All hooks  for
    load_files/2 are documented in section ????.


ccoonnssuulltt((_:_F_i_l_e))
    Read  _F_i_l_e  as  a  Prolog source  file.    Calls  to  consult/1  may
    be  abbreviated by  just typing  a number  of filenames  in a  list.
    Examples:

            ?- consult(load).     % consult load or load.pl
            ?- [library(lists)].  % load library lists
            ?- [user].            % Type program on the terminal

    The  predicate  consult/1  is  equivalent  to  load_files(File, []),
    except for handling  the special file user, which reads clauses from
    the  terminal.  See  also the stream(_I_n_p_u_t) option  of load_files/2.
    Abbreviation  using ?- [file1,file2].  does _n_o_t work  for the  empty
    list  ([]).    This facility  is implemented  by  defining the  list
    as  a predicate.    Applications  may only  rely on  using the  list
    abbreviation at the Prolog toplevel and in directives.


eennssuurree__llooaaddeedd((_:_F_i_l_e))
    If the file  is not already loaded, this is equivalent to consult/1.
    Otherwise,   if  the  file  defines  a  module,  import  all  public
    predicates.    Finally,  if the  file is  already loaded,  is not  a
    module  file, and the context module is not the global  user module,
    ensure_loaded/1 will call consult/1.

    With  this  semantics,  we  hope to  get  as close  as  possible  to
    the  clear  semantics  without  the presence  of  a  module  system.
    Applications using modules should consider using use_module/[1,2].

    Equivalent to load_files(Files, [if(not_loaded)]).


iinncclluuddee((_+_F_i_l_e))                                                    _[_I_S_O_]
    Textually  include the  content of  _F_i_l_e at the  position where  the
    _d_i_r_e_c_t_i_v_e :- include(File). appears.   The include construct is only
    honoured  if it appears as  a directive in a  source file.   _T_e_x_t_u_a_l
    include (similar to  C/C++ #include) is obviously useful for sharing
    declarations  such as dynamic/1 or  multifile/1 by including a  file
    with directives from multiple files that use these predicates.

    Textually  including files  that  contain _c_l_a_u_s_e_s  is less  obvious.
    Normally,  in SWI-Prolog,  clauses are  _o_w_n_e_d by the  file in  which
    they  are defined.    This information is  used to  _r_e_p_l_a_c_e the  old
    definition  after the  file has  been modified and  is reloaded  by,
    e.g.,  make/0.    As  we understand  it,  include/1 is  intended  to
    include  the same  file multiple times.    Including a file  holding
    clauses  multiple times into the  same module is rather  meaningless
    as  it  just  duplicates  the  same  clauses.     Including  a  file
    holding  clauses  in  multiple modules  does  not suffer  from  this
    problem,  but  leads to  multiple equivalent  _c_o_p_i_e_s of  predicates.
    Using  use_module/1 can achieve  the same  result while _s_h_a_r_i_n_g  the
    predicates.

    If  include/1 is used  to load files holding  clauses, and if  these
    files  are loaded only once, then these include/1 directives  can be
    replaced  by other predicates (such  as consult/1).  However,  there
    are  several cases  where either  include/1 has  no alternative,  or
    using  any alternative also requires other  changes.  An example  of
    the  former is  using include/1  to share  directives.   An  example
    of  the latter are cases  where clauses of different predicates  are
    distributed  over multiple files:   If these  files are loaded  with
    include/1, the  directive discontiguous/1 is appropriate, whereas if
    they are consulted, one must use the directive multifile/1.

    To   accommodate   included  files   holding   clauses,   SWI-Prolog
    distinguishes  between  the source  location of  a  clause (in  this
    case  the included file)  and the _o_w_n_e_r of  a clause (the file  that
    includes  the file  holding the  clause).   The  source location  is
    used  by,  e.g.,  edit/1,  the  graphical tracer,  etc.,  while  the
    owner  is used to  determine which clauses  are removed if the  file
    is  modified.    Relevant information  is found  with the  following
    predicates:

      o  source_file/2 describes the owner relation.

      o  predicate_property/2 describes  the  source  location  (of  the
         first clause).

      o  clause_property/2 provides access to both source and ownership.

      o  source_file_property/2 can be used  to query include  relation-
         ships between files.


rreeqquuiirree((_+_L_i_s_t_O_f_N_a_m_e_A_n_d_A_r_i_t_y))
    Declare  that  this file/module  requires the  specified  predicates
    to  be defined ``with  their commonly accepted  definition''.   This
    predicate  originates from  the Prolog portability  layer for  XPCE.
    It  is intended to provide a portable mechanism for  specifying that
    this module requires the specified predicates.

    The implementation normally  first verifies whether the predicate is
    already defined.   If not, it will search the libraries and load the
    required library.

    SWI-Prolog, having autoloading,  does nnoott load the library.  Instead
    it  creates a  procedure header  for the  predicate if  it does  not
    exist.    This will flag  the predicate  as `undefined'.   See  also
    check/0 and autoload/0.


eennccooddiinngg((_+_E_n_c_o_d_i_n_g))
    This  directive can appear anywhere in  a source file to define  how
    characters  are  encoded in  the remainder  of  the file.    It  can
    be  used in  files that  are encoded  with a  superset of  US-ASCII,
    currently UTF-8 and ISO Latin-1.  See also section ????.


mmaakkee
    Consult  all source  files that  have been changed  since they  were
    consulted.   It checks _a_l_l  loaded source files:  files loaded  into
    a  compiled state using pl -c ...  and files loaded using  consult/1
    or  one  of  its  derivatives.    The  predicate  make/0  is  called
    after  edit/1, automatically reloading all  modified files.  If  the
    user  uses an  external editor  (in  a separate  window), make/0  is
    normally  used to update  the program after  editing.  In  addition,
    make/0  updates  the  autoload indices  (see  section ????)  and  runs
    list_undefined/0  from  the check  library  to report  on  undefined
    predicates.


lliibbrraarryy__ddiirreeccttoorryy((_?_A_t_o_m))
    Dynamic  predicate used  to specify  library directories.    Default
    ./lib,  ~/lib/prolog and  the system's library  (in this order)  are
    defined.    The user  may add library  directories using  assertz/1,
    asserta/1  or remove system defaults  using retract/1.   Deprecated.
    New code should use file_search_path/2.


ffiillee__sseeaarrcchh__ppaatthh((_+_A_l_i_a_s_, _-_P_a_t_h))
    Dynamic  multifile hook  predicate used to  specify `path  aliases'.
    This   hook  is  called  by  absolute_file_name/3 to   search  files
    specified  as Alias(_N_a_m_e),  e.g., library(_l_i_s_t_s).   This feature  is
    best described using an example.  Given the definition:

    ____________________________________________________________________|                                                                    |
    ||file_search_path(demo,_'/usr/lib/prolog/demo').___________________ ||

    the  file specification demo(myfile)  will be expanded to  /usr/lib/
    prolog/demo/myfile.   The second  argument of file_search_path/2 may
    be another alias.

    Below  is the  initial definition  of the file  search path.    This
    path  implies swi(<_P_a_t_h>) and  refers to  a file  in the  SWI-Prolog
    home   directory.     The  alias  foreign(<_P_a_t_h>) is   intended  for
    storing   shared  libraries  (.so  or   .DLL  files).     See   also
    use_foreign_library/1.

    ____________________________________________________________________|                                                                    |

    | user:file_search_path(library, X) :-                               |
    |         library_directory(X).                                      |
    | user:file_search_path(swi, Home) :-                                |
    |         current_prolog_flag(home, Home).                           |
    | user:file_search_path(foreign, swi(ArchLib)) :-                    |
    |         current_prolog_flag(arch, Arch),                           |

    |         atom_concat('lib/', Arch, ArchLib).                        |
    | user:file_search_path(foreign, swi(lib)).                          |
    | user:file_search_path(path, Dir) :-                                |
    |         getenv('PATH', Path),                                      |
    |         (   current_prolog_flag(windows, true)                     |
    |         ->  atomic_list_concat(Dirs, (;), Path)                    |
    |         ;   atomic_list_concat(Dirs, :, Path)                      |
    |         ),                                                         |

    ||________member(Dir,_Dirs).________________________________________ ||

    The  file_search_path/2expansion  is used by all loading  predicates
    as well as by absolute_file_name/[2,3].

    The  Prolog  flag verbose_file_search can  be set  to  true to  help
    debugging Prolog's search for files.


eexxppaanndd__ffiillee__sseeaarrcchh__ppaatthh((_+_S_p_e_c_, _-_P_a_t_h))                            _[_n_o_n_d_e_t_]
    Unifies  _P_a_t_h with all possible expansions of the  filename specifi-
    cation _S_p_e_c.  See also absolute_file_name/3.


pprroolloogg__ffiillee__ttyyppee((_?_E_x_t_e_n_s_i_o_n_, _?_T_y_p_e))
    This  dynamic multifile predicate defined in module  user determines
    the  extensions considered by file_search_path/2.  _E_x_t_e_n_s_i_o_n is  the
    filename  extension without the  leading dot,  and _T_y_p_e denotes  the
    type  as used  by the file_type(_T_y_p_e) option  of file_search_path/2.
    Here is the initial definition of prolog_file_type/2:

    ____________________________________________________________________|                                                                    |
    | user:prolog_file_type(pl,       prolog).                           |

    | user:prolog_file_type(Ext,      prolog) :-                         |
    |         current_prolog_flag(associate, Ext),                       |
    |         Ext \== pl.                                                |
    | user:prolog_file_type(qlf,      qlf).                              |
    | user:prolog_file_type(Ext,      executable) :-                     |
    ||________current_prolog_flag(shared_object_extension,_Ext).________ ||

    Users can add  extensions for Prolog source files to avoid conflicts
    (for  example with perl)  as well as  to be compatible with  another
    Prolog  implementation.      We  suggest  using  .pro  for  avoiding
    conflicts  with perl.   Overriding the  system definitions can  stop
    the system from finding libraries.


ssoouurrccee__ffiillee((_?_F_i_l_e))
    True  if _F_i_l_e is a loaded Prolog source file.  _F_i_l_e  is the absolute
    and canonical path to the source file.


ssoouurrccee__ffiillee((_:_P_r_e_d_, _?_F_i_l_e))
    True  if the  predicate specified  by _P_r_e_d  is owned  by file  _F_i_l_e,
    where  _F_i_l_e  is an  absolute path  name  (see absolute_file_name/2).
    Can  be used with any  instantiation pattern, but the database  only
    maintains  the  source file  for  each  predicate.    If _P_r_e_d  is  a
    _m_u_l_t_i_f_i_l_e  predicate  this predicate  succeeds  for all  files  that
    contribute  clauses to  _P_r_e_d.   See  also clause_property/2.    Note
    that  the relation between files and predicates is  more complicated
    if  include/1 is used.    The predicate describes  the _o_w_n_e_r of  the
    predicate.  See include/1 for details.


ssoouurrccee__ffiillee__pprrooppeerrttyy((_?_F_i_l_e_, _?_P_r_o_p_e_r_t_y))
    True  when _P_r_o_p_e_r_t_y  is a  property of  the loaded  file _F_i_l_e.    If
    _F_i_l_e  is non-var, it can be  a file specification that is  valid for
    load_files/2.  Defined properties are:

    ddeerriivveedd__ffrroomm((_O_r_i_g_i_n_a_l_, _O_r_i_g_i_n_a_l_M_o_d_i_f_i_e_d))
         _F_i_l_e was  generated  from the  file  _O_r_i_g_i_n_a_l, which  was  last
         modified at time  _O_r_i_g_i_n_a_l_M_o_d_i_f_i_e_d at the  time it was  loaded.
         This  property  is available  if  _F_i_l_e  was  loaded  using  the
         derived_from(_O_r_i_g_i_n_a_l) option to load_files/2.

    iinncclluuddeess((_I_n_c_l_u_d_e_d_F_i_l_e_, _I_n_c_l_u_d_e_d_F_i_l_e_M_o_d_i_f_i_e_d))
         _F_i_l_e  used  include/1  to  include  _I_n_c_l_u_d_e_d_F_i_l_e.     The  last
         modified time of  _I_n_c_l_u_d_e_d_F_i_l_e was _I_n_c_l_u_d_e_d_F_i_l_e_M_o_d_i_f_i_e_d at  the
         time it was included.

    iinncclluuddeedd__iinn((_M_a_s_t_e_r_F_i_l_e_, _L_i_n_e))
         _F_i_l_e was included into _M_a_s_t_e_r_F_i_l_e from line _L_i_n_e.   This is the
         inverse of the includes property.

    llooaadd__ccoonntteexxtt((_M_o_d_u_l_e_, _L_o_c_a_t_i_o_n_, _O_p_t_i_o_n_s))
         _M_o_d_u_l_e is the module into  which the file was loaded.   If _F_i_l_e
         is a  module, this  is the  module into which  the exports  are
         imported.   Otherwise it is the  module into which the  clauses
         of the  non-module file  are loaded.    _L_o_c_a_t_i_o_n describes  the
         file location  from which the file  was loaded.   It is  either
         a term  <_f_i_l_e>:<_l_i_n_e> or the  atom user if  the file  was loaded
         from the terminal or  another unknown source.  _O_p_t_i_o_n_s  are the
         options  passed to  load_files/2.    Note that  all  predicates
         to load  files  are mapped  to load_files/2,  using the  option
         argument to specify the exact behaviour.

    llooaadd__ccoouunntt((_-_C_o_u_n_t))
         _C_o_u_n_t is the number  of times the file have been loaded,  i.e.,
         1 (one) if the file has been loaded once.

    mmooddiiffiieedd((_S_t_a_m_p))
         File modification time when _F_i_l_e  was loaded.  This is  used by
         make/0 to find files whose modification time  is different from
         when it was loaded.

    ssoouurrccee((_S_o_u_r_c_e))
         One of file if the  source was loaded from a file,  resource if
         the source was loaded from a resource or state if  the file was
         included in the saved state.

    mmoodduullee((_M_o_d_u_l_e))
         _F_i_l_e is a module file that declares the module _M_o_d_u_l_e.

    nnuummbbeerr__ooff__ccllaauusseess((_C_o_u_n_t))
         _C_o_u_n_t is  the number  of clauses associated  with _F_i_l_e.    Note
         that clauses loaded from included files are counted  as part of
         the main file.

    rreellooaaddiinngg
         Present if the file is currently being rreeloaded.


uunnllooaadd__ffiillee((_+_F_i_l_e))
    Remove  all clauses  loaded from  _F_i_l_e.   If _F_i_l_e  loaded a  module,
    clear  the module's export list  and disassociate it from the  file.
    _F_i_l_e  is a canonical filename or a file indicator that is  valid for
    load_files/2.

    This  predicate should be used with care.  The  multithreaded nature
    of  SWI-Prolog makes removing  static code unsafe.   Attempts to  do
    this  should be  reserved for  development or  situations where  the
    application  can guarantee  that none of  the clauses associated  to
    _F_i_l_e are active.


pprroolloogg__llooaadd__ccoonntteexxtt((_?_K_e_y_, _?_V_a_l_u_e))
    Obtain  context  information during  compilation.    This  predicate
    can  be  used   from  directives  appearing  in  a  source  file  to
    get  information  about   the  file  being  loaded  as  well  as  by
    the   term_expansion/2  and  goal_expansion/2  hooks.     See   also
    source_location/2 and if/1.  The following keys are defined:

    ______________________________________________________________________
    |__KKeeyy________________________||DDeessccrriippttiioonn________________________________________________________________________________||__
    || directory      |Directory in which source lives                    |
    | dialect        |Compatibility mode.  See expects_dialect/1.        |
    | file           |Similar  to  source,  but  returns  the  file being|

    |                |included when called while an include file is being|
    |                |processed                                          |
    | module         |Module into which file is loaded                   |
    | reload         |true if the file is being rreeloaded.  Not present on|
    |                |first load                                         |
    | script         |Boolean  that indicates whether the  file is loaded|
    |                |as a script file (see -s)                          |

    | source         |File being  loaded.  If the system is processing an|
    |                |included file, the value is the _m_a_i_n file.  Returns|
    |                |the original Prolog file when loading a .qlf file. |
    | stream         |Stream identifier (see current_input/1)            |
    | term_position  |Start   position   of  last   term  read.       See|
    |                |also   stream_property/2  (position   property  and|
    |                |stream_position_data/3.                            |
    | term           |Term being expanded by expand_term/2.              |

    | variable_names |A list of  `_N_a_m_e = _V_a_r' of the last term read.  See|
    |________________|read_term/2for_details.____________________________|_

    The  directory is commonly used to  add rules to file_search_path/2,
    setting    up   a    search    path   for    finding   files    with
    absolute_file_name/3.  For example:

    ____________________________________________________________________|                                                                    |

    | :- dynamic user:file_search_path/2.                                |
    | :- multifile user:file_search_path/2.                              |
    |                                                                    |
    | :- prolog_load_context(directory, Dir),                            |
    |    asserta(user:file_search_path(my_program_home, Dir)).           |
    |                                                                    |
    |     ...                                                            |

    |     absolute_file_name(my_program_home('README.TXT'), ReadMe,      |
    |                        [ access(read) ]),                          |
    ||____...___________________________________________________________ ||


ssoouurrccee__llooccaattiioonn((_-_F_i_l_e_, _-_L_i_n_e))
    If the last term  has been read from a physical file (i.e., not from
    the file user or  a string), unify _F_i_l_e with an absolute path to the
    file  and _L_i_n_e with the  line number in the  file.  New code  should
    use prolog_load_context/2.


aatt__hhaalltt((_:_G_o_a_l))
    Register  _G_o_a_l to  be run  from PL_cleanup(), which  is called  when
    the  system  halts.     The  hooks are  run  in  the  reverse  order
    they  were registered  (FIFO). Success or  failure executing a  hook
    is  ignored.    If the  hook  raises an  exception this  is  printed
    using  print_message/2.   An attempt  to call halt/[0,1] from a  hook
    is  ignored.    Hooks  may call  cancel_halt/1, causing  halt/0  and
    PL_halt(_0)  to print a  message indicating  that halting the  system
    has been cancelled.


ccaanncceell__hhaalltt((_+_R_e_a_s_o_n))
    If  this predicate is called from a  hook registered with at_halt/1,
    halting Prolog is  cancelled and an informational message is printed
    that  includes _R_e_a_s_o_n.   This  is used by  the development tools  to
    cancel  halting the system  if the editor  has unsafed data and  the
    user decides to cancel.


::-- iinniittiiaalliizzaattiioonn((_:_G_o_a_l))                                          _[_I_S_O_]
    Call  _G_o_a_l _a_f_t_e_r  loading the  source file in  which this  directive
    appears  has been completed.    In addition, _G_o_a_l  is executed if  a
    saved state created using qsave_program/1 is restored.

    The  ISO  standard  only allows  for  using  :- Term if  _T_e_r_m  is  a
    _d_i_r_e_c_t_i_v_e.  This  means that arbitrary goals can only be called from
    a directive by  means of the initialization/1 directive.  SWI-Prolog
    does not enforce this rule.

    The   initialization/1  directive  must   be  used  to  do   program
    initialization  in  saved states  (see  qsave_program/1).    A  saved
    state  contains the predicates,  Prolog flags and operators  present
    at  the moment  the state was  created.   Other resources  (records,
    foreign  resources, etc.)  must be recreated  using initialization/1
    directives or from the entry goal of the saved state.

    Up  to SWI-Prolog 5.7.11, _G_o_a_l was executed immediately  rather than
    after  loading  the  program text  in  which the  directive  appears
    as  dictated  by  the  ISO  standard.    In  many  cases  the  exact
    moment  of  execution  is  irrelevant,  but  there  are  exceptions.
    For  example,  load_foreign_library/1 must be  executed  immediately
    to  make  the loaded  foreign  predicates available  for  exporting.
    SWI-Prolog  now  provides  the  directive  use_foreign_library/1  to
    ensure  immediate  loading   as  well  as  loading  after  restoring
    a   saved  state.       If   the  system   encounters  a   directive
    :- initialization(load_foreign_library(...)),   it  will  load   the
    foreign  library  immediately and  issue a  warning  to update  your
    code.    This behaviour  can be  extended by  providing clauses  for
    the  multifile hook  predicate prolog:initialize_now(_T_e_r_m_,  _A_d_v_i_c_e),
    where  _A_d_v_i_c_e is an  atom that  gives advice on  how to resolve  the
    compatibility issue.


iinniittiiaalliizzaattiioonn((_:_G_o_a_l_, _+_W_h_e_n))
    Similar to initialization/1,  but allows for specifying when _G_o_a_l is
    executed while loading the program text:

    nnooww
         Execute _G_o_a_l immediately.

    aafftteerr__llooaadd
         Execute  _G_o_a_l after  loading  the  program text  in  which  the
         directive appears.  This is the same as initialization/1.

    pprreeppaarree__ssttaattee
         Execute _G_o_a_l as part of qsave_program/2.  This hook can be used
         for example to eagerly execute initialization that  is normally
         done lazily on first usage.

    rreessttoorree__ssttaattee
         Do not execute  _G_o_a_l while loading  the program, but _o_n_l_y  when
         restoring a saved state.

    pprrooggrraamm
         Execute  _G_o_a_l once  after executing  the  -g goals  at  program
         startup.     Registered   goals  are  executed  in  the   order
         encountered and  a failure  or exception causes  the Prolog  to
         exit with non-zero exit  status.  These goals are  _n_o_t executed
         if the -l  is given to  merely _l_o_a_d files.   In that case  they
         may  be executed  explicitly  using  initialize/0.    See  also
         section ????.

    mmaaiinn
         When Prolog starts, the last goal registered  using initializa-
         tion(_G_o_a_l_, _m_a_i_n) is  executed as main goal.   If _G_o_a_l fails  or
         raises an exception, the process terminates with  non-zero exit
         code.   If not explicitly specified  using the -t the  _t_o_p_l_e_v_e_l
         _g_o_a_l is set to halt/0, causing the process to  exit with status
         0.   An  explicitly  specified toplevel  is executed  normally.
         This implies  that -t prolog  causes the  application to  start
         the normal  interactive toplevel  after completing _G_o_a_l.    See
         also the Prolog flag toplevel_goal and section ????.


iinniittiiaalliizzaattiioonn                                                    _[_d_e_t_]
    Run  all initialization goals registered using  initialization(_G_o_a_l_,
    _p_r_o_g_r_a_m).     Raises  an  error  initialization_error(_R_e_a_s_o_n_,  _G_o_a_l_,
    _F_i_l_e_:_L_i_n_e)  if _G_o_a_l fails or raises an exception.  _R_e_a_s_o_n  is failed
    or the exception raised.


ccoommppiilliinngg
    True  if the system is compiling source files with the -c  option or
    qcompile/1  into an intermediate code file.  Can be used  to perform
    conditional code  optimisations in term_expansion/2(see  also the -O
    option) or to omit execution of directives during compilation.


44..33..11 CCoonnddiittiioonnaall ccoommppiillaattiioonn aanndd pprrooggrraamm ttrraannssffoorrmmaattiioonn

ISO  Prolog  defines   no  way  for  program  transformations  such   as
macro  expansion  or   conditional  compilation.     Expansion   through
term_expansion/2 and expand_term/2 can be  seen as part of the  de-facto
standard.   This mechanism  can do  arbitrary translation between  valid
Prolog terms  read from the  source file to Prolog  terms handed to  the
compiler.   As  term_expansion/2 can return a  list, the  transformation
does not need to be term-to-term.

Various  Prolog  dialects  provide the  analogous  goal_expansion/2  and
expand_goal/2 that  allow  for  translation of  individual  body  terms,
freeing the user of the task to disassemble each clause.


tteerrmm__eexxppaannssiioonn((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    Dynamic  and  multifile  predicate,  normally  not defined.     When
    defined  by the user all terms  read during consulting are given  to
    this predicate.   If the predicate succeeds Prolog will assert _T_e_r_m_2
    in  the database rather than the read term (_T_e_r_m_1).  _T_e_r_m_2  may be a
    term  of the form ?- Goal.  or :- Goal.   _G_o_a_l is then treated as  a
    directive.   If _T_e_r_m_2  is a list, all  terms of the list are  stored
    in  the database or  called (for directives).   If  _T_e_r_m_2 is of  the
    form  below, the system will assert _C_l_a_u_s_e and record  the indicated
    source location with it:

         '$source_location'(<_F_i_l_e>, <_L_i_n_e>):<_C_l_a_u_s_e>

    When   compiling  a  module  (see  chapter  ????  and   the  directive
    module/2),  expand_term/2  will first  try  term_expansion/2 in  the
    module  being compiled to  allow for term  expansion rules that  are
    local  to a module.  If  there is no local definition, or  the local
    definition  fails  to translate  the  term,  expand_term/2 will  try
    term_expansion/2  in module user.    For compatibility with  SICStus
    and  Quintus Prolog,  this feature  should not  be used.   See  also
    expand_term/2, goal_expansion/2 and expand_goal/2.


eexxppaanndd__tteerrmm((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    This  predicate is  normally called  by the compiler  on terms  read
    from  the  input to  perform preprocessing.    It  consists of  four
    steps, where each step processes the output of the previous step.

     1.  Test  conditional  compilation  directives  and  translate  all
         input to []  if we are in  a `false branch' of the  conditional
         compilation.  See section ????.

     2.  Call term_expansion/2.   This predicate is  first tried in  the
         module that is being compiled and then in the module user.

     3.  Call DCG expansion (dcg_translate_rule/2).

     4.  Call expand_goal/2 on each body term that appears in the output
         of the previous steps.


ggooaall__eexxppaannssiioonn((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    Like  term_expansion/2,  goal_expansion/2  provides  for  macro  ex-
    pansion  of  Prolog source  code.    Between  expand_term/2 and  the
    actual  compilation, the body of clauses analysed and the  goals are
    handed  to expand_goal/2, which  uses the goal_expansion/2 hook to do
    user-defined expansion.

    The  predicate goal_expansion/2 is first  called in the module  that
    is  being compiled,  and then  follows the  module inheritance  path
    as  defined by default_module/2, i.e.,  by default user and  system.
    If  _G_o_a_l is of  the form _M_o_d_u_l_e:_G_o_a_l  where _M_o_d_u_l_e is  instantiated,
    goal_expansion/2 is  called on _G_o_a_l  using rules from module  _M_o_d_u_l_e
    followed by default modules for _M_o_d_u_l_e.

    Only  goals  appearing  in  the  body  of  clauses  when  reading  a
    source  file are  expanded using  this mechanism, and  only if  they
    appear  literally in  the clause,  or as  an argument  to a  defined
    meta-predicate  that is annotated using  `0' (see meta_predicate/1).
    Other cases need a real predicate definition.

    The   expansion  hook   can  use  prolog_load_context/2  to   obtain
    information  about the context in which the goal is exanded  such as
    the module, variable names or the encapsulating term.


eexxppaanndd__ggooaall((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    This  predicate  is  normally  called by  the  compiler  to  perform
    preprocessing  using  goal_expansion/2.    The  predicate computes  a
    fixed-point  by applying  transformations  until there  are no  more
    changes.     If  optimisation  is enabled  (see  -O  and  optimise),
    expand_goal/2 simplifies  the result by  removing unneeded calls  to
    true/0 and fail/0 as well as unreachable branches.


ccoommppiillee__aauuxx__ccllaauusseess((_+_C_l_a_u_s_e_s))
    Compile  clauses  on behalf  of  goal_expansion/2.    This  predicate
    compiles  the argument clauses  into static predicates,  associating
    the predicates with  the current file but avoids changing the notion
    of current predicate and therefore discontiguous warnings.

    Note  that in some  cases multiple expansions  of similar goals  can
    share  the  same  compiled auxiliary  predicate.    In  such  cases,
    the  implementation of goal_expansion/2 can use predicate_property/2
    using the property  defined to test whether the predicate is already
    defined in the current context.


ddccgg__ttrraannssllaattee__rruullee((_+_I_n_, _-_O_u_t))
    This  predicate performs the translation of a term  Head-->Body into
    a  normal Prolog  clause.    Normally this  functionality should  be
    accessed using expand_term/2.


vvaarr__pprrooppeerrttyy((_+_V_a_r_, _?_P_r_o_p_e_r_t_y))
    True  when _P_r_o_p_e_r_t_y  is a  property of _V_a_r.    These properties  are
    available  during goal- and term-expansion.  Defined  properties are
    below.    Future  versions are  likely to  provide more  properties,
    such  as  whether  the  variable  is  a  singleton  or  whether  the
    variable  is referenced  in the  remainder of the  term.   See  also
    goal_expansion/2.

    ffrreesshh((_B_o_o_l))
         Bool has  the value _t_r_u_e  if the variable  is guaranteed to  be
         unbound at  entry of the  goal, otherwise  its value is  _f_a_l_s_e.
         This implies that  the variable first  appears in this goal  or
         a previous appearance was  in a negation (\+/1) or  a different
         branch of a disjunction.

    nnaammee((_N_a_m_e))
         True when variable appears with the given name in the source.


44..33..11..11 PPrrooggrraamm ttrraannssffoorrmmaattiioonn wwiitthh ssoouurrccee llaayyoouutt iinnffoo

This sections documents extended versions of  the program transformation
predicates that also transform the source layout information.   Extended
layout information is currently processed, but unused.   Future versions
will use for the following enhancements:

  o More precise locations of warnings and errors

  o More reliable setting of breakpoints

  o More reliable source layout information in the graphical debugger.


eexxppaanndd__ggooaall((_+_G_o_a_l_1_, _?_L_a_y_o_u_t_1_, _-_G_o_a_l_2_, _-_L_a_y_o_u_t_2))


ggooaall__eexxppaannssiioonn((_+_G_o_a_l_1_, _?_L_a_y_o_u_t_1_, _-_G_o_a_l_2_, _-_L_a_y_o_u_t_2))


eexxppaanndd__tteerrmm((_+_T_e_r_m_1_, _?_L_a_y_o_u_t_1_, _-_T_e_r_m_2_, _-_L_a_y_o_u_t_2))


tteerrmm__eexxppaannssiioonn((_+_T_e_r_m_1_, _?_L_a_y_o_u_t_1_, _-_T_e_r_m_2_, _-_L_a_y_o_u_t_2))


ddccgg__ttrraannssllaattee__rruullee((_+_I_n_, _?_L_a_y_o_u_t_I_n_, _-_O_u_t_, _-_L_a_y_o_u_t_O_u_t))
    These  versions  are called  _b_e_f_o_r_e their  2-argument  counterparts.
    The   input  layout  term  is  either  a  variable  (if   no  layout
    information  is  available)  or  a  term  carrying  detailed  layout
    information as returned by the subterm_positions of read_term/2.


44..33..11..22 CCoonnddiittiioonnaall ccoommppiillaattiioonn

Conditional   compilation    builds   on    the   same   principle    as
term_expansion/2,   goal_expansion/2  and  the   expansion  of   grammar
rules to compile sections of the source code conditionally.   One of the
reasons for introducing  conditional compilation is to simplify  writing
portable code.  See  section ???? for more information.  Here is  a simple
example:

________________________________________________________________________|                                                                        |
|:- if(\+source_exports(library(lists), suffix/2)).                      |

|                                                                        |
|suffix(Suffix, List) :-                                                 |
|        append(_, Suffix, List).                                        |
|                                                                        |
|:-|endif.______________________________________________________________ |  |

Note that  these directives  can only  appear as separate  terms in  the
input.  Typical usage scenarios include:

  o Load different libraries on different dialects.

  o Define a predicate if it is missing as a system predicate.

  o Realise  totally different implementations for a particular  part of
    the code due to different capabilities.

  o Realise different configuration options for your software.


::-- iiff((_:_G_o_a_l))
    Compile  subsequent  code  only if  _G_o_a_l  succeeds.    For  enhanced
    portability,  _G_o_a_l is  processed by expand_goal/2 before  execution.
    If an error  occurs, the error is printed and processing proceeds as
    if _G_o_a_l has failed.


::-- eelliiff((_:_G_o_a_l))
    Equivalent to :- else.  :-if(Goal).  ...  :- endif. In a sequence as
    below,  the section below the first matching elif is processed.   If
    no test succeeds, the else branch is processed.

    ____________________________________________________________________|                                                                    |
    | :- if(test1).                                                      |

    | section_1.                                                         |
    | :- elif(test2).                                                    |
    | section_2.                                                         |
    | :- elif(test3).                                                    |
    | section_3.                                                         |
    | :- else.                                                           |
    | section_else.                                                      |
    ||:-_endif._________________________________________________________ ||


::-- eellssee
    Start `else' branch.


::-- eennddiiff
    End of conditional compilation.


44..33..22 RReellooaaddiinngg ffiilleess,, aaccttiivvee ccooddee aanndd tthhrreeaaddss

Traditionally,  Prolog environments  allow for  reloading files  holding
currently  active code.    In particular,  the following  sequence is  a
valid use of the development environment:

  o Trace a goal

  o Find unexpected behaviour of a predicate

  o Enter a _b_r_e_a_k using the bb command

  o Fix the sources and reload them using make/0

  o Exit the break,  _r_e_t_r_y executing the now fixed predicate using the rr
    command

_R_e_l_o_a_d_i_n_g a previously loaded  file is safe, both in the  debug scenario
above and when the code is being executed by another  _t_h_r_e_a_d.  Executing
threads switch atomically to the new definition  of modified predicates,
while  clauses  that  belong to  the  old  definition  are  (eventually)
reclaimed by  garbage_collect_clauses/0.    Below we  describe the  steps
taken for _r_e_l_o_a_d_i_n_g a file to help understanding the  limitations of the
process.

 1. If  a file is being reloaded, a _r_e_l_o_a_d _c_o_n_t_e_x_t is associated  to the
    file  administration.  This  context includes a table keeping  track
    of predicates and  a table keeping track of the module(s) associated
    with this source.

 2. If  a new  predicate is  found,  an entry  is added  to the  context
    predicate table.  Three options are considered:

    (a)  The predicate is new.   It is handled  the same as if the  file
         was loaded for the first time.

    (b)  The predicate  is  foreign or  thread  local.   These  too  are
         treated as if the file was loaded for the first time.

    (c)  Normal  predicates.    Here  we  initialise a  pointer  to  the
         _c_u_r_r_e_n_t _c_l_a_u_s_e.

 3. New clauses for `normal predicates' are considered as follows:

    (a)  If  the  clause's byte-code  is  the  same  as  the  predicates
         current clause,  discard  the clause  and  advance the  current
         clause pointer.

    (b)  If the clause's  byte-code is the  same as some clause  further
         into the clause list of the predicate, discard  the new clause,
         mark all intermediate clauses for future deletion,  and advance
         the  current clause  pointer  to  the first  clause  after  the
         matched one.

    (c)  If the  clause's byte-code  matches no  clause,  insert it  for
         _f_u_t_u_r_e  _a_c_t_i_v_a_t_i_o_n  before the  current  clause  and  keep  the
         current clause.

 4. _P_r_o_p_e_r_t_i_e_s  such as  dynamic or meta_predicate  are in part  applied
    immediately  and in  part during  the fixup process  after the  file
    completes loading.   Currently, dynamic and thread_local are applied
    immediately.

 5. New   modules  are  recorded  in   the  reload  context.      Export
    declarations (the module's  public list and export/1 calls) are both
    applied and recorded.

 6. When  the  end-of-file is  reached, the  following  fixup steps  are
    taken

    (a)  For each predicate

          i. The  current clause and subsequent  clauses are marked  for
             future deletion.

         ii. All  clauses   marked  for  future  deletion  or   creation
             are   (in)activated   by   changing   their   `erased'   or
             `created'  _g_e_n_e_r_a_t_i_o_n.    Erased clauses  are  (eventually)
             reclaimed   by   the   _c_l_a_u_s_e   _g_a_r_b_a_g_e   _c_o_l_l_e_c_t_o_r,    see
             garbage_collect_clauses/0.

        iii. Pending predicate property changes are applied.

    (b)  For each module

          i. Exported predicates that are not  encountered in the reload
             context are removed from the export list.

The above generally ensures that changes to the _c_o_n_t_e_n_t  of source files
can typically  be activated safely  using make/0.   Global changes  such
as operator  changes,  changes of  module names,  changes to  multi-file
predicates, etc. sometimes require a restart.  In  almost all cases, the
need for restart is indicated by permission or syntax  errors during the
reload or existence errors while running the program.

In some cases the content of a source file refers `to  itself'.  This is
notably the case if local rules for goal_expansion/2 or term_expansion/2
are defined  or goals  are executed using  _d_i_r_e_c_t_i_v_e_s..   Up to  version
7.5.12  it was  typically needed  to  reload the  file _t_w_i_c_e,  once  for
updating  the code  that was  used for  compiling the  remainder of  the
file and once  to effectuate this.   As of version 7.5.13,  conventional
_t_r_a_n_s_a_c_t_i_o_n  _s_e_m_a_n_t_i_c_s  apply.     This  implies  that  for  the  thread
performing the  reload the file's content  is first wiped and  gradually
rebuilt,  while other threads  see an  _a_t_o_m_i_c update from  the old  file
content to the new.


44..33..22..11 CCoommppiillaattiioonn ooff mmuuttuuaallllyy ddeeppeennddeenntt ccooddee

Large  programs are  generally  split into  multiple  files.    If  file
A  accesses  predicates from  file  B  which accesses  predicates  from
file  A,  we  consider  this a  mutual  or  circular  dependency.    If
traditional load predicates  (e.g., consult/1) are used to  include file
B  from A  and  A  from B,  loading  either file  results  in  a loop.
This is  because consult/1  is mapped to  load_files/2 using the  option
if(true)(_.)    Such programs  are  typically loaded  using a  _l_o_a_d  _f_i_l_e
that consults  all required (non-module)  files.   If modules are  used,
the dependencies are  made explicit using use_module/1 statements.   The
use_module/1 predicate,  however, maps to  load_files/2 with the  option
if(not_loaded)(_.)  A use_module/1 on an already loaded file merely makes
the public predicates of the used module available.

Summarizing,  mutual  dependency  of source  files  is  fully  supported
with no  precautions when  using modules.   Modules  can use each  other
in  an arbitrary  dependency graph.    When using  consult/1,  predicate
dependencies  between loaded  files  can  still be  arbitrary,  but  the
consult relations between files must be a proper tree.


44..33..22..22 CCoommppiillaattiioonn wwiitthh mmuullttiippllee tthhrreeaaddss

This  section  discusses compiling  files  for  the  first time.     For
reloading, see section ????.

In older versions, compilation  was thread-safe due to a global  _l_o_c_k in
load_files/2 and  the code dealing  with _a_u_t_o_l_o_a_d_i_n_g  (see section  ????).
Besides  unnecessary  stalling  when  multiple  threads  trap  unrelated
undefined  predicates,  this  easily  leads  to  deadlocks,  notably  if
threads are started from an initialization/1 directive.

Starting with  version 5.11.27, the autoloader  is no longer locked  and
multiple threads can compile files concurrently.   This requires special
precautions  only if  multiple threads  wish to  load the  same file  at
the same  time.   Therefore,  load_files/2 checks automatically  whether
some  other thread  is already  loading the  file.   If  not, it  starts
loading the file.   If another thread  is already loading the file,  the
thread blocks until the  other thread finishes loading the file.   After
waiting,  and if the  file is  a module file,  it will  make the  public
predicates available.

Note that this  schema does not prevent deadlocks under  all situations.
Consider two mutually dependent (see section  ????) module files A and B,
where thread 1  starts loading A and  thread 2 starts loading B  at the
same time.   Both  threads will  deadlock when trying  to load the  used
module.

The current implementation  does not detect such cases and  the involved
threads  will freeze.     This problem  can  be  avoided if  a  mutually
dependent  collection of  files is  always loaded  from  the same  start
file.


44..33..33 QQuuiicckk llooaadd ffiilleess

SWI-Prolog supports compilation of individual or  multiple Prolog source
files into `Quick Load  Files'.  A `Quick Load File' (.qlf  file) stores
the contents of the file in a precompiled format.

These files load considerably faster than source files  and are normally
more compact.   They are machine-independent  and may thus be loaded  on
any  implementation of  SWI-Prolog.   Note,  however,  that clauses  are
stored as virtual  machine instructions.   Changes to the compiler  will
generally make old compiled files unusable.

Quick Load Files  are created using qcompile/1.   They are loaded  using
consult/1  or one  of  the other  file-loading predicates  described  in
section ????.   If consult/1 is given  an explicit .pl file, it will  load
the Prolog  source.   When given  a .qlf  file, it will  load the  file.
When no extension is specified, it will load the  .qlf file when present
and the .pl file otherwise.


qqccoommppiillee((_:_F_i_l_e))
    Takes  a file specification as consult/1, etc., and, in  addition to
    the  normal compilation, creates a _Q_u_i_c_k  _L_o_a_d _F_i_l_e from _F_i_l_e.   The
    file  extension of this  file is .qlf.   The  basename of the  Quick
    Load File is the same as the input file.

    If   the   file  contains   `:- consult(_+_F_i_l_e)',   `:- [_+_F_i_l_e]'   or
    `:- load_files(_+_F_i_l_e, [qcompile(part), ...])'  statements,  the  re-
    ferred  files  are  compiled  into  the  same  .qlf  file.     Other
    directives will be stored  in the .qlf file and executed in the same
    fashion as when loading the .pl file.

    For  term_expansion/2, the  same rules  as described  in section  ????
    apply.

    Conditional  execution   or  optimisation  may  test  the  predicate
    compiling/0.

    Source  references (source_file/2) in the  Quick Load File refer  to
    the Prolog source file from which the compiled code originates.


qqccoommppiillee((_:_F_i_l_e_, _+_O_p_t_i_o_n_s))
    As  qcompile/1,  but  processes  additional options  as  defined  by
    load_files/2.


44..44 EEddiittoorr IInntteerrffaaccee

SWI-Prolog  offers an  extensible  interface which  allows the  user  to
edit objects  of the program:   predicates,  modules, files,  etc.   The
editor interface is  implemented by edit/1 and consists of  three parts:
_l_o_c_a_t_i_n_g, _s_e_l_e_c_t_i_n_g and _s_t_a_r_t_i_n_g the editor.  Any of  these parts may be
customized.  See section ????.

The built-in  edit specifications for  edit/1 (see prolog_edit:locate/3)
are described in the table below:

   ___________________________________________________________________
   |__________________________________________FFuullllyy__ssppeecciiffiieedd__oobbjjeeccttss____________________________________________||
   || <_M_o_d_u_l_e>:<_N_a_m_e>/<_A_r_i_t_y>R|efers to a predicate                   |
   | module(<_M_o_d_u_l_e>)      |Refers to a module                       |
   | file(<_P_a_t_h>)          |Refers to a file                         |

   |_source_file(<_P_a_t_h>)___R|efers_to_a_loaded_source_file___________|_
   |__________________________________________AAmmbbiigguuoouuss__ssppeecciiffiiccaattiioonnss__________________________________________||
   || <_N_a_m_e>/<_A_r_i_t_y>        R|efers to this predicate in any module   |
   | <_N_a_m_e>                |Refers to (1) the  named predicate in any|
   |                       |module  with any  arity,  (2) a  (source)|
   |_______________________|file,_or_(3)_a_module.___________________|_


eeddiitt((_+_S_p_e_c_i_f_i_c_a_t_i_o_n))
    First,  exploit prolog_edit:locate/3to  translate _S_p_e_c_i_f_i_c_a_t_i_o_n into
    a  list  of  _L_o_c_a_t_i_o_n_s.    If there  is  more than  one  `hit',  the
    user  is  asked  to select  from  the  locations found.     Finally,
    prolog_edit:edit_source/1 is  used  to invoke  the user's  preferred
    editor.   Typically, edit/1 can  be handed the name of  a predicate,
    module, basename of a file, XPCE class, XPCE method, etc.


eeddiitt
    Edit the `default' file  using edit/1.  The default file is the file
    loaded  with the  command line option  -s or, in  Windows, the  file
    loaded by double-clicking from the Windows shell.


44..44..11 CCuussttoommiizziinngg tthhee eeddiittoorr iinntteerrffaaccee

The predicates described in  this section are _h_o_o_k_s that can  be defined
to  disambiguate  specifications  given  to  edit/1,  find  the  related
source, and open an editor at the given source location.


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_F_u_l_l_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Where  _S_p_e_c is  the  specification provided  through edit/1.    This
    multifile  predicate is used to enumerate locations where  an object
    satisfying  the given _S_p_e_c can be  found.  _F_u_l_l_S_p_e_c is unified  with
    the  complete specification  for the  object.   This distinction  is
    used  to allow for ambiguous specifications.   For example, if  _S_p_e_c
    is  an atom, which appears as the  basename of a loaded file  and as
    the  name of a  predicate, _F_u_l_l_S_p_e_c will  be bound to file(_P_a_t_h)  or
    _N_a_m_e/_A_r_i_t_y.

    _L_o_c_a_t_i_o_n  is a list of attributes  of the location.  Normally,  this
    list  will contain the term  file(_F_i_l_e) and, if available, the  term
    line(_L_i_n_e).


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Same  as prolog_edit:locate/3,  but only  deals with fully  specified
    objects.


pprroolloogg__eeddiitt::eeddiitt__ssoouurrccee((_+_L_o_c_a_t_i_o_n))
    Start  editor on _L_o_c_a_t_i_o_n.   See prolog_edit:locate/3 for the  format
    of  a  location term.    This multifile  predicate  is normally  not
    defined.  If it succeeds, edit/1 assumes the editor is started.

    If  it fails, edit/1 uses  its internal defaults, which are  defined
    by  the Prolog flag editor  and/or the environment variable  EDITOR.
    The  following  rules apply.     If the  Prolog  flag editor  is  of
    the  format $<_n_a_m_e>,  the  editor is  determined by  the environment
    variable  <_n_a_m_e>.   Else, if this flag  is pce_emacs or built_in _a_n_d
    XPCE  is  loaded or  can  be loaded,  the  built-in Emacs  clone  is
    used.  Else,  if the environment EDITOR is set, this editor is used.
    Finally,  vi  is used  as default  on Unix  systems  and notepad  on
    Windows.

    See  the  default  user  preferences  file  dotfiles/dotswiplrc  for
    examples.


pprroolloogg__eeddiitt::eeddiitt__ccoommmmaanndd((_+_E_d_i_t_o_r_, _-_C_o_m_m_a_n_d))
    Determines  how  _E_d_i_t_o_r is  to be  invoked using  shell/1.    _E_d_i_t_o_r
    is   the  determined  editor  (see  qpredrefprolog_editedit_source1),
    without  the full path specification, and without a  possible (.exe)
    extension.    _C_o_m_m_a_n_d  is  an  atom describing  the  command.    The
    following  %-sequences are replaced in _C_o_m_m_a_n_d before the  result is
    handed to shell/1:

              ________________________________________________
              | %e |Replaced by the (OS) command name of  the |
              |    |editor                                    |
              | %f |Replaced by the  (OS) full  path name  of |
              |    |the file                                  |

              |_%d_|Replaced_by_the_line_number_______________|

    If  the  editor can  deal with  starting at  a specified  line,  two
    clauses  should be provided.   The first pattern invokes the  editor
    with  a line number, while the second is used if the line  number is
    unknown.

    The  default contains definitions for  vi, emacs, emacsclient,  vim,
    notepad* and  wordpad*.   Starred editors do not provide  starting at
    a given line number.

    Please contribute your specifications to bugs@swi-prolog.org.


pprroolloogg__eeddiitt::llooaadd
    Normally  an  undefined multifile  predicate.    This predicate  may
    be  defined to  provide  loading hooks  for user  extensions to  the
    edit  module.   For example,  XPCE provides the  code below to  load
    swi_edit,  containing definitions to locate  classes and methods  as
    well as to bind this package to the PceEmacs built-in editor.

    ____________________________________________________________________|                                                                    |
    | :- multifile prolog_edit:load/0.                                   |

    |                                                                    |
    | prolog_edit:load :-                                                |
    ||________ensure_loaded(library(swi_edit))._________________________ ||


44..55 LLiisstt tthhee pprrooggrraamm,, pprreeddiiccaatteess oorr ccllaauusseess


lliissttiinngg((_:_P_r_e_d))
    List  predicates specified by  _P_r_e_d.  _P_r_e_d  may be a predicate  name
    (atom),  which lists  all predicates with  this name, regardless  of
    their  arity.  It  can also be a predicate  indicator (<_n_a_m_e>/<_a_r_i_t_y>
    or <_n_a_m_e>//<_a_r_i_t_y>),  possibly qualified with a module.  For example:
    ?- listing(lists:member/2)..

    A  listing is produced by  enumerating the clauses of the  predicate
    using  clause/2  and printing  each  clause using  portray_clause/1.
    This implies that the  variable names are generated (_A, _B, ...)  and
    the layout is defined by rules in portray_clause/1.


lliissttiinngg
    List  all predicates from the calling  module using listing/1.   For
    example,  ?- listing. lists clauses in  the default user module  and
    ?- lists:listing. lists the clauses in the module lists.


ppoorrttrraayy__ccllaauussee((_+_C_l_a_u_s_e))
    Pretty  print a  clause.   A clause  should be specified  as a  term
    `<_H_e_a_d> :- <_B_o_d_y>'.    Facts are  represented as  `<_H_e_a_d> :- true'  or
    simply  <_H_e_a_d>.  Variables  in the clause are written as  A, B, ....
    Singleton variables are written as _.  See also portray_clause/2.


ppoorrttrraayy__ccllaauussee((_+_S_t_r_e_a_m_, _+_C_l_a_u_s_e))
    Pretty print a clause to _S_t_r_e_a_m.  See portray_clause/1 for details.


44..66 VVeerriiffyy TTyyppee ooff aa TTeerrmm

Type  tests  are  semi-deterministic  predicates  that  succeed  if  the
argument satisfies  the requested type.    Type-test predicates have  no
error  condition and  do  not instantiate  their  argument.    See  also
library error.


vvaarr((_@_T_e_r_m))                                                        _[_I_S_O_]
    True if _T_e_r_m currently is a free variable.


nnoonnvvaarr((_@_T_e_r_m))                                                     _[_I_S_O_]
    True if _T_e_r_m currently is not a free variable.


iinntteeggeerr((_@_T_e_r_m))                                                    _[_I_S_O_]
    True if _T_e_r_m is bound to an integer.


ffllooaatt((_@_T_e_r_m))                                                      _[_I_S_O_]
    True if _T_e_r_m is bound to a floating point number.


rraattiioonnaall((_@_T_e_r_m))
    True  if _T_e_r_m  is  bound to  a rational  number.   Rational  numbers
    include integers.


rraattiioonnaall((_@_T_e_r_m_, _-_N_u_m_e_r_a_t_o_r_, _-_D_e_n_o_m_i_n_a_t_o_r))
    True  if  _T_e_r_m  is  a  rational  number  with  given  _N_u_m_e_r_a_t_o_r  and
    _D_e_n_o_m_i_n_a_t_o_r.   The _N_u_m_e_r_a_t_o_r and _D_e_n_o_m_i_n_a_t_o_r are in  canonical form,
    which  means _D_e_n_o_m_i_n_a_t_o_r  is  a positive  integer and  there are  no
    common divisors between _N_u_m_e_r_a_t_o_r and _D_e_n_o_m_i_n_a_t_o_r.


nnuummbbeerr((_@_T_e_r_m))                                                     _[_I_S_O_]
    True if _T_e_r_m is bound to an integer or floating point number.


aattoomm((_@_T_e_r_m))                                                       _[_I_S_O_]
    True if _T_e_r_m is bound to an atom.


bblloobb((_@_T_e_r_m_, _?_T_y_p_e))
    True if _T_e_r_m is a _b_l_o_b of type _T_y_p_e.  See section ????.


ssttrriinngg((_@_T_e_r_m))
    True  if _T_e_r_m is bound  to a string.   Note that string here  refers
    to  the built-in  atomic  type string  as described  in section  ????.
    Starting  with version  7, the syntax  for a  string object is  text
    between  double quotes, such as "hello".   See also the  Prolog flag
    double_quotes.


aattoommiicc((_@_T_e_r_m))                                                     _[_I_S_O_]
    True  if _T_e_r_m is bound (i.e.,  not a variable) and is  not compound.
    Thus, atomic acts as if defined by:

    ____________________________________________________________________|                                                                    |
    | atomic(Term) :-                                                    |

    |         nonvar(Term),                                              |
    ||________\+_compound(Term).________________________________________ ||

    SWI-Prolog  defines the following atomic datatypes:   atom (atom/1),
    string  (string/1),   integer  (integer/1),  floating  point  number
    (float/1)  and blob  (blob/2).   In addition,  the symbol []  (empty
    list) is atomic, but not an atom.  See section ????.


ccoommppoouunndd((_@_T_e_r_m))                                                   _[_I_S_O_]
    True  if _T_e_r_m  is bound  to a  compound term.    See also  functor/3
    =../2, compound_name_arity/3 and compound_name_arguments/3.


ccaallllaabbllee((_@_T_e_r_m))                                                   _[_I_S_O_]
    True  if _T_e_r_m is  bound to  an atom or  a compound term.   This  was
    intended  as a type-test for arguments to call/1 and call/2..   Note
    that callable only tests  the _s_u_r_f_a_c_e _t_e_r_m.  Terms such as (22,true)
    are  considered callable, but  cause call/1 to  raise a type  error.
    Module-qualification  of meta-argument (see  meta_predicate/1)  using
    :/2  causes callable to succeed on any meta-argument.   Consider the
    program and query below:

    ____________________________________________________________________|                                                                    |
    | :- meta_predicate p(0).                                            |

    |                                                                    |
    | p(G) :- callable(G), call(G).                                      |
    |                                                                    |
    | ?- p(22).                                                          |
    | ERROR: Type error: `callable' expected, found `22'                 |
    | ERROR: In:                                                         |
    ||ERROR:____[6]_p(user:22)__________________________________________ ||


ggrroouunndd((_@_T_e_r_m))                                                     _[_I_S_O_]
    True  if _T_e_r_m holds  no free  variables.   See also nonground/2  and
    term_variables/2.


ccyycclliicc__tteerrmm((_@_T_e_r_m))
    True  if _T_e_r_m contains cycles, i.e. is  an infinite term.   See also
    acyclic_term/1 and section ????.


aaccyycclliicc__tteerrmm((_@_T_e_r_m))                                                _[_I_S_O_]
    True  if  _T_e_r_m  does  not contain  cycles,  i.e.  can  be  processed
    recursively in finite time.  See also cyclic_term/1 and section ????.


44..77 CCoommppaarriissoonn aanndd UUnniiffiiccaattiioonn ooff TTeerrmmss

Although unification is  mostly done implicitly while matching the  head
of a predicate, it is also provided by the predicate =/2.


_?_T_e_r_m_1 = _?_T_e_r_m_2                                                   _[_I_S_O_]
    Unify  _T_e_r_m_1 with _T_e_r_m_2.   True  if the unification  succeeds.   For
    behaviour  on cyclic  terms see the  Prolog flag  occurs_check.    It
    acts as if defined by the following fact:

    ____________________________________________________________________|                                                                    |
    ||=(Term,_Term).____________________________________________________ ||


_@_T_e_r_m_1 \= _@_T_e_r_m_2                                                  _[_I_S_O_]
    Equivalent to \+Term1 = Term2.

    This predicate is  logically sound if its arguments are sufficiently
    instantiated.   In  other cases, such  as ?- X \= Y., the  predicate
    fails  although there are solutions.  This is due to  the incomplete
    nature of \+/1.

    To  make your programs work  correctly also in situations where  the
    arguments are not yet sufficiently instantiated, use dif/2 instead.


44..77..11 SSttaannddaarrdd OOrrddeerr ooff TTeerrmmss

Comparison and  unification of arbitrary  terms.   Terms are ordered  in
the so-called ``standard order''.  This order is defined as follows:

 1. _V_a_r_i_a_b_l_e_s <_N_u_m_b_e_r_s <_S_t_r_i_n_g_s <_A_t_o_m_s <_C_o_m_p_o_u_n_d _T_e_r_m_s

 2. Variables are sorted by address.

 3. _N_u_m_b_e_r_s are compared  by value.  Mixed integer/float are compared as
    floats.   If the  comparison is equal,  the float is considered  the
    smaller  value.   If the  Prolog flag iso  is defined, all  floating
    point numbers precede all integers.

 4. _S_t_r_i_n_g_s are compared alphabetically.

 5. _A_t_o_m_s are compared alphabetically.

 6. _C_o_m_p_o_u_n_d  terms are  first checked  on  their arity,  then on  their
    functor  name  (alphabetically)  and finally  recursively  on  their
    arguments, leftmost argument first.

Although variables  are ordered,  there are  some unexpected  properties
one  should keep  in  mind when  relying on  variable  ordering.    This
applies to the predicates  below as to predicate such as sort/2  as well
as libraries that  reply on ordering such  as library assoc and  library
ordsets.  Obviously,  an established relation _A @< _B no longer  holds if
_A is unified  with e.g., a number.   Also unifying _A with _B  invalidates
the relation because they become equivalent (==/2) after unification.

As stated  above, variables are  sorted by  address, which implies  that
they are  sorted by `age',  where `older'  variables are ordered  before
`newer' variables.    If two  variables are unified  their `shared'  age
is the  age of  oldest variable.   This  implies we can  examine a  list
of sorted variables with `newer' (fresh)  variables without invalidating
the order.    Attaching an  _a_t_t_r_i_b_u_t_e, see  section ????,  turns an  `old'
variable into  a `new' one as  illustrated below.   Note that the  first
always succeeds as  the first argument of  a term is always the  oldest.
This only  applies for the _f_i_r_s_t  attribute, i.e., further  manipulation
of the attribute list does _n_o_t change the `age'.

________________________________________________________________________|                                                                        |

|?- T = f(A,B), A @< B.                                                  |
|T = f(A, B).                                                            |
|                                                                        |
|?- T = f(A,B), put_attr(A, name, value), A @< B.                        |
|false.|________________________________________________________________ |      |

The  above implies  you _c_a_n  use  e.g., an  assoc (from  library  assoc,
implemented  as an  AVL tree)  to maintain  information about  a set  of
variables.   You must be careful about  what you do with the  attributes
though.  In many  cases it is more robust to use attributes  to register
information about variables.


_@_T_e_r_m_1 == _@_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is  equivalent to _T_e_r_m_2.  A variable is only identical
    to a sharing variable.


_@_T_e_r_m_1 \== _@_T_e_r_m_2                                                 _[_I_S_O_]
    Equivalent to \+Term1 == Term2.


_@_T_e_r_m_1 @< _@_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is before _T_e_r_m_2 in the standard order of terms.


_@_T_e_r_m_1 @=< _@_T_e_r_m_2                                                 _[_I_S_O_]
    True if both terms  are equal (==/2) or _T_e_r_m_1 is before _T_e_r_m_2 in the
    standard order of terms.


_@_T_e_r_m_1 @> _@_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is after _T_e_r_m_2 in the standard order of terms.


_@_T_e_r_m_1 @>= _@_T_e_r_m_2                                                 _[_I_S_O_]
    True  if both terms are equal (==/2) or _T_e_r_m_1 is after _T_e_r_m_2  in the
    standard order of terms.


ccoommppaarree((_?_O_r_d_e_r_, _@_T_e_r_m_1_, _@_T_e_r_m_2))                                   _[_I_S_O_]
    Determine or test  the _O_r_d_e_r between two terms in the standard order
    of terms.  _O_r_d_e_r is one of <, >  or =, with the obvious meaning.


44..77..22 SSppeecciiaall uunniiffiiccaattiioonn aanndd ccoommppaarriissoonn pprreeddiiccaatteess

This   section   describes  special   purpose   variations   on   Prolog
unification.    The  predicate unify_with_occurs_check/2 provides  sound
unification  and  is  part   of  the  ISO  standard.      The  predicate
subsumes_term/2 defines `one-sided unification'  and is part of the  ISO
proposal established  in Edinburgh (2010).    Finally, unifiable/3 is  a
`what-if' version of unification that is often used as  a building block
in constraint reasoners.


uunniiffyy__wwiitthh__ooccccuurrss__cchheecckk((_+_T_e_r_m_1_, _+_T_e_r_m_2))                             _[_I_S_O_]
    As  =/2, but  using _s_o_u_n_d  _u_n_i_f_i_c_a_t_i_o_n.   That is,  a variable  only
    unifies  to  a term  if  this term  does  not contain  the  variable
    itself.  To illustrate this, consider the two queries below.

    ____________________________________________________________________|                                                                    |
    | 1 ?- A = f(A).                                                     |

    | A = f(A).                                                          |
    | 2 ?- unify_with_occurs_check(A, f(A)).                             |
    ||false.____________________________________________________________ ||

    The  first statement creates a  _c_y_c_l_i_c _t_e_r_m, also called a  _r_a_t_i_o_n_a_l
    _t_r_e_e.    The second  executes logically sound  unification and  thus
    fails.   Note that the behaviour of unification through =/2  as well
    as implicit unification  in the head can be changed using the Prolog
    flag occurs_check.

    The   SWI-Prolog  implementation   of  unify_with_occurs_check/2  is
    cycle-safe  and only  guards against  _c_r_e_a_t_i_n_g  cycles, not  against
    cycles  that may already be present in  one of the arguments.   This
    is illustrated in the following two queries:

    ____________________________________________________________________|                                                                    |
    | ?- X = f(X), Y = X, unify_with_occurs_check(X, Y).                 |
    | X = Y, Y = f(Y).                                                   |
    | ?- X = f(X), Y = f(Y), unify_with_occurs_check(X, Y).              |

    ||X_=_Y,_Y_=_f(Y).__________________________________________________ ||

    Some  other  Prolog systems  interpret  unify_with_occurs_check/2 as
    if  defined  by  the clause  below,  causing  failure on  the  above
    two  queries.   Direct use  of acyclic_term/1 is  portable and  more
    appropriate for such applications.

    ____________________________________________________________________|                                                                    |
    ||unify_with_occurs_check(X,X)_:-_acyclic_term(X).__________________ ||


_+_T_e_r_m_1 =@= _+_T_e_r_m_2
    True  if  _T_e_r_m_1 is  a  _v_a_r_i_a_n_t of  (or _s_t_r_u_c_t_u_r_a_l_l_y  _e_q_u_i_v_a_l_e_n_t  to)
    _T_e_r_m_2.   Testing  for a variant  is weaker than equivalence  (==/2),
    but  stronger  than unification  (=/2).    Two terms  A  and B  are
    variants  iff there  exists a renaming  of the variables  in A that
    makes A equivalent (==) to B  and vice versa.  Examples:

          1       a =@= A       false
          2       A =@= B       true
          3  x(A,A) =@= x(B,C)  false
          4  x(A,A) =@= x(B,B)  true
          5  x(A,A) =@= x(A,B)  false

          6  x(A,B) =@= x(C,D)  true
          7  x(A,B) =@= x(B,A)  true
          8  x(A,B) =@= x(C,A)  true

    A term is always  a variant of a copy of itself.  Term copying takes
    place  in, e.g.,  copy_term/2,  findall/3 or  proving a clause  added
    with asserta/1.   In the pure Prolog world (i.e., without attributed
    variables),  =@=/2 behaves  as if  defined below.   With  attributed
    variables,  variant of the attributes  is tested rather than  trying
    to satisfy the constraints.

    ____________________________________________________________________|                                                                    |
    | A =@= B :-                                                         |
    |         copy_term(A, Ac),                                          |
    |         copy_term(B, Bc),                                          |
    |         numbervars(Ac, 0, N),                                      |
    |         numbervars(Bc, 0, N),                                      |

    ||________Ac_==_Bc._________________________________________________ ||

    The  SWI-Prolog  implementation  is  cycle-safe and  can  deal  with
    variables that are shared  between the left and right argument.  Its
    performance  is  comparable to  ==/2, both  on  success and  (early)
    failure.

    This  predicate is known by the name variant/2 in some  other Prolog
    systems.    Be aware  of possible  differences in  semantics if  the
    arguments contain attributed variables or share variables.


_+_T_e_r_m_1 \=@= _+_T_e_r_m_2
    Equivalent to `\+Term1 =@= Term2'.  See =@=/2 for details.


ssuubbssuummeess__tteerrmm((_@_G_e_n_e_r_i_c_, _@_S_p_e_c_i_f_i_c))                                 _[_I_S_O_]
    True  if _G_e_n_e_r_i_c can be made equivalent to _S_p_e_c_i_f_i_c by  only binding
    variables  in  _G_e_n_e_r_i_c.   The  current  implementation performs  the
    unification  and ensures that  the variable set  of _S_p_e_c_i_f_i_c is  not
    changed  by the unification.   On success, the bindings are  undone.
    This predicate respects constraints.


tteerrmm__ssuubbssuummeerr((_+_S_p_e_c_i_a_l_1_, _+_S_p_e_c_i_a_l_2_, _-_G_e_n_e_r_a_l))
    _G_e_n_e_r_a_l  is  the most  specific  term that  is a  generalisation  of
    _S_p_e_c_i_a_l_1 and _S_p_e_c_i_a_l_2.  The implementation can handle cyclic terms.


uunniiffiiaabbllee((_@_X_, _@_Y_, _-_U_n_i_f_i_e_r))
    If  _X and _Y  can unify,  unify _U_n_i_f_i_e_r with  a list of  _V_a_r = _V_a_l_u_e,
    representing  the  bindings required  to make  _X  and _Y  equivalent.
    This  predicate can handle cyclic  terms.  Attributed variables  are
    handled as normal variables.  Associated hooks are _n_o_t executed.


??==((_@_T_e_r_m_1_, _@_T_e_r_m_2))
    Succeeds  if  the  syntactic equality  of  _T_e_r_m_1  and _T_e_r_m_2  can  be
    decided  safely,  i.e.  if the  result  of Term1 == Term2  will  not
    change  due to further instantiation of either term.  It  behaves as
    if defined by ?=(X,Y) :- \+ unifiable(X,Y,[_|_]).


44..88 CCoonnttrrooll PPrreeddiiccaatteess

The predicates of  this section implement control structures.   Normally
the constructs in this  section, except for repeat/0, are  translated by
the compiler.   Please  note that complex goals  passed as arguments  to
meta-predicates such  as findall/3 below cause  the goal to be  compiled
to a  temporary location before  execution.   It is  faster to define  a
sub-predicate (i.e. one_character_atoms/1 in the example below) and make
a call to this simple predicate.

________________________________________________________________________|                                                                        |
|one_character_atoms(As) :-                                              |

||_______findall(A,_(current_atom(A),_atom_length(A,_1)),_As).__________ ||


ffaaiill                                                              _[_I_S_O_]
    Always  fail.   The  predicate fail/0  is translated  into a  single
    virtual machine instruction.


ffaallssee                                                             _[_I_S_O_]
    Same as fail, but the name has a more declarative connotation.


ttrruuee                                                              _[_I_S_O_]
    Always  succeed.  The predicate  true/0 is translated into a  single
    virtual machine instruction.


rreeppeeaatt                                                            _[_I_S_O_]
    Always succeed, provide an infinite number of choice points.


!                                                                 _[_I_S_O_]
    Cut.     Discard  all  choice  points  created  since  entering  the
    predicate  in which the cut appears.  In other words, _c_o_m_m_i_t  to the
    clause  in which  the  cut appears  _a_n_d discard  choice points  that
    have  been created by goals  to the left of  the cut in the  current
    clause.    Meta calling is  opaque to the  cut.   This implies  that
    cuts that appear  in a term that is subject to meta-calling (call/1)
    only  affect choice  points created by  the meta-called  term.   The
    following control structures are transparent to the cut:   ;/2, ->/2
    and *->/2 .  Cuts appearing in the _c_o_n_d_i_t_i_o_n part of ->/2 and  *->/2
    are  opaque to the cut.   The table below explains the scope  of the
    cut  with examples.    _P_r_u_n_e_s  here means  ``prunes X  choice point
    created by X''.

            t0 :- (a, !, b).               % prunes a/0 and t0/0
            t1 :- (a, !, fail ; b).        % prunes a/0 and t1/0
            t2 :- (a -> b, !  ; c).        % prunes b/0 and t2/0
            t3 :- call((a, !, fail ; b)).  % prunes a/0
            t4 :- \+(a, !, fail).          % prunes a/0


_:_G_o_a_l_1 , _:_G_o_a_l_2                                                   _[_I_S_O_]
    Conjunction.   True if both `Goal1'  and `Goal2' can be proved.   It
    is  defined as follows (this definition  does not lead to a loop  as
    the second comma is handled by the compiler):

    ____________________________________________________________________|                                                                    |
    ||Goal1,_Goal2_:-_Goal1,_Goal2._____________________________________ ||


_:_G_o_a_l_1 ; _:_G_o_a_l_2                                                   _[_I_S_O_]
    The `or' predicate is defined as:

    ____________________________________________________________________|                                                                    |
    | Goal1 ; _Goal2 :- Goal1.                                           |
    ||_Goal1_;_Goal2_:-_Goal2.__________________________________________ ||


_:_G_o_a_l_1 | _:_G_o_a_l_2
    Equivalent  to ;/2.    Retained for compatibility  only.   New  code
    should use ;/2.


_:_C_o_n_d_i_t_i_o_n -> _:_A_c_t_i_o_n                                             _[_I_S_O_]
    If-then  and  If-Then-Else.    The  ->/2  construct commits  to  the
    choices  made  at  its  left-hand  side,  destroying  choice  points
    created  inside the  clause (by  ;/2), or  by goals  called by  this
    clause.   Unlike !/0, the choice  point of the predicate as  a whole
    (due  to multiple clauses)  is nnoott destroyed.   The combination  ;/2
    and ->/2  acts as if defined as:

    ____________________________________________________________________|                                                                    |
    | If -> Then; _Else :- If, !, Then.                                  |
    | If -> _Then; Else :- !, Else.                                      |

    ||If_->_Then_:-_If,_!,_Then.________________________________________ ||

    Please  note that (If -> Then) acts  as (If -> Then ; ffaaiill),  making
    the  construct _f_a_i_l if the condition fails.  This  unusual semantics
    is part of the ISO and all de-facto Prolog standards.

    Please  note that (if->then;else)  is read as ((if->then);else)  and
    that  the _c_o_m_b_i_n_e_d semantics of this syntactic construct  as defined
    above  is _d_i_f_f_e_r_e_n_t from  the simple nesting  of the two  individual
    constructs,  i.e., the  semantics of ->/2  _c_h_a_n_g_e_s when embedded  in
    ;/2.  See also once/1.


_:_C_o_n_d_i_t_i_o_n *-> _:_A_c_t_i_o_n _; _:_E_l_s_e
    This  construct implements  the so-called `soft-cut'.   The  control
    is  defined as follows:   If _C_o_n_d_i_t_i_o_n succeeds  at least once,  the
    semantics  is the same as  (call(_C_o_n_d_i_t_i_o_n), _A_c_t_i_o_n).  If  _C_o_n_d_i_t_i_o_n
    does  not succeed, the  semantics is that  of (\+ _C_o_n_d_i_t_i_o_n,  _E_l_s_e).
    In  other words, if _C_o_n_d_i_t_i_o_n succeeds at least once,  simply behave
    as the conjunction  of call(_C_o_n_d_i_t_i_o_n) and _A_c_t_i_o_n, otherwise execute
    _E_l_s_e.   The  construct is known  under the name  if/3 in some  other
    Prolog implementations.

    The  construct _A *-> _B, i.e., without an _E_l_s_e branch,  the semantics
    is the same as (call(_A), _B).

    This  construct  is  rarely  used.    An  example use  case  is  the
    implementation  of  optional  in sparql.    The  optional  construct
    should  preserve all  solutions if  the argument  succeeds as  least
    once but still succeed otherwise.  This is implemented as below.

    ____________________________________________________________________|                                                                    |
    | optional(Goal) :-                                                  |

    |     (   Goal                                                       |
    |     *-> true                                                       |
    |     ;   true                                                       |
    ||____).____________________________________________________________ ||

    Now  calling  e.g.,  optional(member(X, [a,b]))  has  the  solutions
    X = a  and X = b,  while  optional(member(X,[]))  succeeds without
    binding X.


\+ _:_G_o_a_l                                                          _[_I_S_O_]
    True  if `Goal' cannot  be proven (mnemonic:   + refers to  _p_r_o_v_a_b_l_e
    and  the backslash  (\)  is normally  used to  indicate negation  in
    Prolog).


44..99 MMeettaa--CCaallll PPrreeddiiccaatteess

Meta-call predicates  are used to  call terms  constructed at run  time.
The basic meta-call mechanism offered by SWI-Prolog is  to use variables
as a  subclause (which  should of  course be bound  to a  valid goal  at
runtime).   A  meta-call is  slower than a  normal call  as it  involves
actually searching the database at runtime for the  predicate, while for
normal calls this search is done at compile time.


ccaallll((_:_G_o_a_l))                                                       _[_I_S_O_]
    Invoke  _G_o_a_l as a  goal.   Note that clauses  may have variables  as
    subclauses, which is identical to call/1.


ccaallll((_:_G_o_a_l_, _+_E_x_t_r_a_A_r_g_1_, _._._.))                                      _[_I_S_O_]
    Append  _E_x_t_r_a_A_r_g_1_, _E_x_t_r_a_A_r_g_2_,  _._._.   to  the argument  list of  _G_o_a_l
    and  call the result.   For  example, call(plus(1), 2, X) will  call
    plus(1, 2, X), binding _X to 3.

    The  call/[2..]     construct is  handled  by  the compiler.     The
    predicates   call/[2-8]  are   defined  as  real   (meta-)predicates
    and   are  available  to  inspection   through  current_predicate/1,
    predicate_property/2,  etc.    Higher  arities  are handled  by  the
    compiler  and runtime system, but the predicates are  not accessible
    for inspection.


aappppllyy((_:_G_o_a_l_, _+_L_i_s_t))
    Append  the  members of  _L_i_s_t  to the  arguments  of _G_o_a_l  and  call
    the  resulting term.    For example:   apply(plus(1), [2, X])  calls
    plus(1, 2, X).   New code  should use call/[2..]   if the length  of
    _L_i_s_t is fixed.


nnoott((_:_G_o_a_l))
    True  if _G_o_a_l cannot  be proven.   Retained for compatibility  only.
    New code should use \+/1.


oonnccee((_:_G_o_a_l))                                                       _[_I_S_O_]
    Make  a possibly _n_o_n_d_e_t  goal _s_e_m_i_d_e_t, i.e.,  succeed at most  once.
    Defined as:

    ____________________________________________________________________|                                                                    |
    | once(Goal) :-                                                      |
    ||____call(Goal),_!.________________________________________________ ||

    once/1  can  in  many  cases  be replaced  with  ->/2.     The  only
    difference  is how the  cut behaves  (see !/0).   The following  two
    clauses  below are  identical.    Be careful  about the  interaction
    with  ;/2.   The  apply_macros  library defines  an inline  expansion
    of  once/1, mapping it  to (Goal\send{true};fail).   Using the  full
    if-then-else  constructs prevents its  semantics from being  changed
    when embedded in a ;/2 disjunction.

    ____________________________________________________________________|                                                                    |

    | 1) a :- once((b, c)), d.                                           |
    ||2)_a_:-_b,_c_->_d.________________________________________________ ||


iiggnnoorree((_:_G_o_a_l))
    Calls  _G_o_a_l  as once/1,  but succeeds,  regardless  of whether  _G_o_a_l
    succeeded or not.  Defined as:

    ____________________________________________________________________|                                                                    |
    | ignore(Goal) :-                                                    |
    |         Goal, !.                                                   |
    ||ignore(_).________________________________________________________ ||


ccaallll__wwiitthh__ddeepptthh__lliimmiitt((_:_G_o_a_l_, _+_L_i_m_i_t_, _-_R_e_s_u_l_t))
    If  _G_o_a_l can be proven  without recursion deeper than _L_i_m_i_t  levels,
    call_with_depth_limit/3 succeeds,  binding  _R_e_s_u_l_t  to  the  deepest
    recursion  level  used  during the  proof.    Otherwise,  _R_e_s_u_l_t  is
    unified  with depth_limit_exceeded  if the limit was exceeded  during
    the  proof,  or the  entire predicate  fails if  _G_o_a_l fails  without
    exceeding _L_i_m_i_t.

    The  depth  limit  is guarded  by  the  internal machinery.     This
    may  differ from the  depth computed based  on a theoretical  model.
    For  example, true/0  is translated into  an inline virtual  machine
    instruction.   Also, repeat/0 is not implemented as below, but  as a
    non-deterministic foreign predicate.

    ____________________________________________________________________|                                                                    |
    | repeat.                                                            |

    | repeat :-                                                          |
    ||________repeat.___________________________________________________ ||

    As  a result,  call_with_depth_limit/3may  still loop infinitely  on
    programs  that should  theoretically finish  in finite time.    This
    problem  can be cured by  using Prolog equivalents to such  built-in
    predicates.

    This   predicate   may  be   used  for   theorem   provers  to   re-
    alise   techniques   like   _i_t_e_r_a_t_i_v_e   _d_e_e_p_e_n_i_n_g.        See   also
    call_with_inference_limit/3.   It was  implemented after  discussion
    with Steve Moyle smoyle@ermine.ox.ac.uk.


ccaallll__wwiitthh__iinnffeerreennccee__lliimmiitt((_:_G_o_a_l_, _+_L_i_m_i_t_, _-_R_e_s_u_l_t))
    Equivalent  to call(_G_o_a_l), but limits  the number of inferences  _f_o_r
    _e_a_c_h _s_o_l_u_t_i_o_n _o_f _G_o_a_l..  Execution may terminate as follows:

      o  If  _G_o_a_l does  _n_o_t  terminate  before the  inference  limit  is
         exceeded, _G_o_a_l  is aborted  by injecting  the exception  infer-
         ence_limit_exceeded  into its execution.   After termination  of
         _G_o_a_l, _R_e_s_u_l_t is unified with the atom inference_limit_exceeded.
         _O_t_h_e_r_w_i_s_e,

      o  If _G_o_a_l fails, call_with_inference_limit/3fails.

      o  If _G_o_a_l  succeeds _w_i_t_h_o_u_t  _a _c_h_o_i_c_e  _p_o_i_n_t,  _R_e_s_u_l_t is  unified
         with !.

      o  If _G_o_a_l succeeds  _w_i_t_h _a _c_h_o_i_c_e  _p_o_i_n_t, _R_e_s_u_l_t is unified  with
         true.

      o  If  _G_o_a_l   throws  an   exception,   call_with_inference_limit/3
         re-throws the exception.

    An  inference is defined as a call  or redo on a predicate.   Please
    note  that  some  primitive  built-in  predicates  are  compiled  to
    virtual  machine instructions for which inferences are  not counted.
    The  execution of predicates  defined in  other languages (e.g.,  C,
    C++)  count  as  a single  inference.    This  includes  potentially
    expensive built-in predicates such as sort/2.

    Calls  to this predicate  may be nested.   An  inner call that  sets
    the  limit below the current is honoured.  An inner call  that would
    terminate  after the  current limit  does not  change the  effective
    limit.  See also call_with_depth_limit/3 and call_with_time_limit/2.


sseettuupp__ccaallll__cclleeaannuupp((_:_S_e_t_u_p_, _:_G_o_a_l_, _:_C_l_e_a_n_u_p))
    Calls  (once(Setup), Goal).     If  _S_e_t_u_p  succeeds,   _C_l_e_a_n_u_p  will
    be  called  exactly   once  after  _G_o_a_l  is  finished:    either  on
    failure,  deterministic  success,  commit, or  an  exception.    The
    execution  of _S_e_t_u_p is  protected from asynchronous interrupts  like
    call_with_time_limit/2 (package clib) or  thread_signal/2.   In  most
    uses,  _S_e_t_u_p will  perform temporary  side-effects required by  _G_o_a_l
    that are finally undone by _C_l_e_a_n_u_p.

    Success  or failure  of _C_l_e_a_n_u_p  is  ignored, and  choice points  it
    created are destroyed  (as once/1).  If _C_l_e_a_n_u_p throws an exception,
    this is executed as  normal while it was not triggered as the result
    of  an exception the exception is propagated as normal.   If _C_l_e_a_n_u_p
    was triggered by an exception the rules are described in section ????

    Typically, this predicate  is used to cleanup permanent data storage
    required to execute _G_o_a_l,  close file descriptors, etc.  The example
    below  provides a  non-deterministic search  for a term  in a  file,
    closing the stream as needed.

    ____________________________________________________________________|                                                                    |
    | term_in_file(Term, File) :-                                        |

    |         setup_call_cleanup(open(File, read, In),                   |
    |                            term_in_stream(Term, In),               |
    |                            close(In) ).                            |
    |                                                                    |
    | term_in_stream(Term, In) :-                                        |
    |         repeat,                                                    |
    |         read(In, T),                                               |
    |         (   T == end_of_file                                       |

    |         ->  !, fail                                                |
    |         ;   T = Term                                               |
    ||________).________________________________________________________ ||

    Note  that it is impossible  to implement this predicate in  Prolog.
    The  closest approximation would be to  read all terms into a  list,
    close  the  file and  call member/2.    Without setup_call_cleanup/3
    there  is  no way  to  gain  control if  the  choice point  left  by
    repeat/0 is removed by a cut or an exception.

    setup_call_cleanup/3  can also  be used  to  test determinism  of  a
    goal, providing a portable alternative to deterministic/1:

    ____________________________________________________________________|                                                                    |
    | ?- setup_call_cleanup(true,(X=1;X=2), Det=yes).                    |
    |                                                                    |
    | X = 1 ;                                                            |

    |                                                                    |
    | X = 2,                                                             |
    ||Det_=_yes_;_______________________________________________________ ||

    This  predicate is  under consideration for  inclusion into the  ISO
    standard.   For compatibility with other Prolog  implementations see
    call_cleanup/2.


sseettuupp__ccaallll__ccaattcchheerr__cclleeaannuupp((_:_S_e_t_u_p_, _:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_C_l_e_a_n_u_p))
    Similar  to setup_call_cleanup(_S_e_t_u_p_, _G_o_a_l_, _C_l_e_a_n_u_p)  with additional
    information  on the reason  for calling _C_l_e_a_n_u_p.   Prior to  calling
    _C_l_e_a_n_u_p, _C_a_t_c_h_e_r unifies  with the termination code (see below).  If
    this unification fails, _C_l_e_a_n_u_p is _n_o_t called.

    eexxiitt
         _G_o_a_l succeeded without leaving any choice points.

    ffaaiill
         _G_o_a_l failed.

    !
         _G_o_a_l succeeded with choice  points and these are now  discarded
         by the execution of a cut (or other pruning of  the search tree
         such as if-then-else).

    eexxcceeppttiioonn((_E_x_c_e_p_t_i_o_n))
         _G_o_a_l raised the given _E_x_c_e_p_t_i_o_n.

    eexxtteerrnnaall__eexxcceeppttiioonn((_E_x_c_e_p_t_i_o_n))
         _G_o_a_l succeeded with choice  points and these are now  discarded
         due to an exception.  For example:

         _______________________________________________________________|                                                               |

         |?- setup_call_catcher_cleanup(true, (X=1;X=2),                 |
         |                              Catcher, writeln(Catcher)),      |
         |   throw(ball).                                                |
         |external_exception(ball)                                       |
         |ERROR:|Unhandled_exception:_Unknown_message:_ball_____________ |      |


ccaallll__cclleeaannuupp((_:_G_o_a_l_, _:_C_l_e_a_n_u_p))
    Same  as setup_call_cleanup(_t_r_u_e_, _G_o_a_l_,  _C_l_e_a_n_u_p).  This is  provided
    for  compatibility with  a  number of  other Prolog  implementations
    only.     Do not  use  call_cleanup/2 if  you  perform  side-effects
    prior  to calling  that will  be undone by  _C_l_e_a_n_u_p.   Instead,  use
    setup_call_cleanup/3 with an  appropriate first argument to  perform
    those side-effects.


ccaallll__cclleeaannuupp((_:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_C_l_e_a_n_u_p))
    Same  as  setup_call_catcher_cleanup(_t_r_u_e_, _G_o_a_l_,  _C_a_t_c_h_e_r_,  _C_l_e_a_n_u_p).
    The same warning as for call_cleanup/2 applies.


44..1100 DDeelliimmiitteedd ccoonnttiinnuuaattiioonnss

The  predicates reset/3  and shift/1  implement _d_e_l_i_m_i_t_e_d  _c_o_n_t_i_n_u_a_t_i_o_n_s
for Prolog.    Delimited continuation  for Prolog is  described in  [??].
The  mechanism  allows for  proper  _c_o_r_o_u_t_i_n_e_s,  two  or  more  routines
whose  execution  is  interleaved,  while they  exchange  data.     Note
that  coroutines in  this sense  differ from  coroutines realised  using
attributed variables as described in chapter ????.

The  suspension  mechanism   provided  by  delimited  continuations   is
suitable for the implementation of _t_a_b_l_i_n_g [??], see library tabling.


rreesseett((_:_G_o_a_l_, _?_B_a_l_l_, _-_C_o_n_t_i_n_u_a_t_i_o_n))
    Call  _G_o_a_l.  If _G_o_a_l calls  shift/1 and the argument of  shift/1 can
    be  unified with _B_a_l_l,  shift/1 causes  reset/3 to return,  unifying
    _C_o_n_t_i_n_u_a_t_i_o_n  with a  goal  that represents  the _c_o_n_t_i_n_u_a_t_i_o_n  after
    shift/1.   In other  words, meta-calling _C_o_n_t_i_n_u_a_t_i_o_n completes  the
    execution  where shift  left it.   If  _G_o_a_l does  not call  shift/1,
    _C_o_n_t_i_n_u_a_t_i_o_n are unified with the integer 0 (zero).


sshhiifftt((_+_B_a_l_l))
    Abandon  the execution  of the  current goal,  returning control  to
    just  _a_f_t_e_r the matching reset/3 call.   This is similar to  throw/1
    except  that (1)  nothing is `undone'  and (2)  the 3th argument  of
    reset/3  is unified  with the  _c_o_n_t_i_n_u_a_t_i_o_n, which  allows the  code
    calling reset/3 to _r_e_s_u_m_e the current goal.


44..1111 EExxcceeppttiioonn hhaannddlliinngg

The predicates  catch/3 and  throw/1 provide ISO  compliant raising  and
catching of exceptions.


ccaattcchh((_:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_R_e_c_o_v_e_r))                                  _[_I_S_O_]
    Behaves  as call/1 if  no exception is  raised when executing  _G_o_a_l.
    If  an exception is  raised using throw/1  while _G_o_a_l executes,  and
    the  _G_o_a_l is the innermost goal  for which _C_a_t_c_h_e_r unifies with  the
    argument  of throw/1, all choice  points generated by _G_o_a_l are  cut,
    the  system backtracks to the start of catch/3 while  preserving the
    thrown exception term, and _R_e_c_o_v_e_r is called as in call/1.

    The  overhead of  calling a  goal through catch/3  is comparable  to
    call/1.    Recovery from  an  exception is  much slower,  especially
    if  the exception term  is large  due to the  copying thereof or  is
    decorated  with a stack trace using, e.g.,  the library prolog_stack
    based  on  the  prolog_exception_hook/4 hook  predicate  to  rewrite
    exceptions.


tthhrrooww((_+_E_x_c_e_p_t_i_o_n))                                                 _[_I_S_O_]
    Raise  an exception.   The  system looks  for the innermost  catch/3
    ancestor  for which _E_x_c_e_p_t_i_o_n unifies  with the _C_a_t_c_h_e_r argument  of
    the catch/3 call.  See catch/3 for details.

    ISO  demands that  throw/1 make  a copy  of _E_x_c_e_p_t_i_o_n,  walk up  the
    stack  to a catch/3  call, backtrack  and try to  unify the copy  of
    _E_x_c_e_p_t_i_o_n  with _C_a_t_c_h_e_r.   SWI-Prolog  delays backtracking until  it
    actually  finds a  matching catch/3  goal.   The  advantage is  that
    we  can start  the  debugger at  the first  possible location  while
    preserving  the entire  exception context  if there  is no  matching
    catch/3  goal.   This approach  can lead  to different behaviour  if
    _G_o_a_l  and _C_a_t_c_h_e_r of catch/3 call shared variables.  We  assume this
    to  be highly unlikely and could not think of a scenario  where this
    is useful.

    In  addition to explicit calls to throw/1, many  built-in predicates
    throw  exceptions directly from C.  If the _E_x_c_e_p_t_i_o_n term cannot  be
    copied  due to lack of stack space, the following actions  are tried
    in order:

     1.  If  the  exception  is  of  the  form  error(_F_o_r_m_a_l_,  _I_m_p_l_e_m_e_n_-
         _t_a_t_i_o_n_D_e_f_i_n_e_d),  try   to  raise  the  exception  without   the
         _I_m_p_l_e_m_e_n_t_a_t_i_o_n_D_e_f_i_n_e_d part.

     2.  Try to raise error(resource_error_(_s_t_a_c_k_)_, _g_l_o_b_a_l).

     3.  Abort (see abort/0).

    If  an exception is  raised in a call-back  from C (see chapter  ????)
    and  not caught in the same  call-back, PL_next_solution()fails  and
    the exception context can be retrieved using PL_exception().


44..1111..11 UUrrggeennccyy ooff eexxcceeppttiioonnss

Under  some  conditions an  exception  may  be  raised as  a  result  of
handling another exception.  Below are some of the scenarios:

  o The  predicate setup_call_cleanup/3 calls the  cleanup handler as  a
    result  of an exception and the cleanup handler raises  an exception
    itself.   In this case the most _u_r_g_e_n_t exception is  propagated into
    the environment.

  o Raising  an exception  fails due to  lack of  resources, e.g.,  lack
    of  stack space to  store the exception.   In  this case a  resource
    exception is raised.   If that too fails the system tries to raise a
    resource  exception without (stack) context.  If that fails  it will
    raise  the exception  '$aborted', also  raised by  abort/0.   As  no
    stack  space is required for processing this atomic  exception, this
    should always succeed.

  o Certain  _c_a_l_l_b_a_c_k  operations raise  an exception  while  processing
    another   exception  or  a  previous  callback  already   raised  an
    exception   before  there   was  an  opportunity   to  process   the
    exception.     The  most  notable _c_a_l_l_b_a_c_k  subject  to  this  issue
    are  prolog_event_hook/1(supporting  e.g., the graphical  debugger),
    prolog_exception_hook/4  (rewriting  exceptions,  e.g.,   by  adding
    context)  and print_message/2 when called  from the core  facilities
    such  as the internal  debugger.  As  with setup_call_cleanup/3,  the
    most _u_r_g_e_n_t exception is preserved.

If  the most  urgent exceptions  needs to  be preserved,  the  following
exception ordering is respected, preserving the topmost matching error.

 1. '$aborted' (abort/0)

 2. time_limit_exceeded (call_with_time_limit/2)

 3. error(resource_error_(_R_e_s_o_u_r_c_e_)_, _C_o_n_t_e_x_t)

 4. error(_F_o_r_m_a_l_, _C_o_n_t_e_x_t)

 5. All other exceptions

NNoottee

The above  resolution is not  described in  the ISO standard.   This  is
not needed either because  ISO does not specify setup_call_cleanup/3 and
does  not deal  with environment  management issues  such as  (debugger)
callbacks.     Neither does  it  define  abort/0  or  timeout  handling.
Notably abort/0  and timeout are non-logical  control structures.   They
are implemented on top  of exceptions as they need to unwind  the stack,
destroy  choice  points and  call  cleanup  handlers in  the  same  way.
However, the  pending exception  should not be  replaced by another  one
before the intended handler  is reached.  The abort exception  cannot be
caught, something which  is achieved by wrapping the _c_l_e_a_n_u_p  _h_a_n_d_l_e_r of
catch/3 into call_cleanup(_H_a_n_d_l_e_r_, _a_b_o_r_t).


44..1111..22 DDeebbuuggggiinngg aanndd eexxcceeppttiioonnss

Before  the introduction  of exceptions  in SWI-Prolog  a runtime  error
was handled  by printing  an error  message, after  which the  predicate
failed.  If the  Prolog flag debug_on_errorwas in effect  (default), the
tracer was switched on.  The combination of the  error message and trace
information is generally sufficient to locate the error.

With exception handling,  things are different.   A programmer may  wish
to trap an  exception using catch/3 to avoid  it reaching the user.   If
the exception  is not handled  by user code,  the interactive top  level
will trap it to prevent termination.

If  we  do  not  take  special  precautions,   the  context  information
associated with an  unexpected exception (i.e., a programming  error) is
lost.   Therefore, if an exception is  raised which is not caught  using
catch/3 and  the top level is  running, the error  will be printed,  and
the system will enter trace mode.

If the system  is in a non-interactive  call-back from foreign code  and
there is no catch/3  active in the current context, it  cannot determine
whether or  not the  exception will  be caught by  the external  routine
calling Prolog.   It  will then  base its behaviour  on the Prolog  flag
debug_on_error:

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _f_a_l_s_e_)
    The  exception does  not trap the  debugger and  is returned to  the
    foreign  routine  calling Prolog,  where it  can  be accessed  using
    PL_exception().  This is the default.

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _t_r_u_e_)
    If the exception is  not caught by Prolog in the current context, it
    will trap the tracer to help analyse the context of the error.

While looking for the  context in which an exception takes place,  it is
advised to switch on  debug mode using the predicate debug/0.   The hook
prolog_exception_hook/4 can be used to add more debugging  facilities to
exceptions.   An  example is the  library http/http_error, generating  a
full stack trace on errors in the HTTP server library.


44..1111..33 TThhee eexxcceeppttiioonn tteerrmm

Built-in  predicates  generate exceptions  using  a  term  error(_F_o_r_m_a_l_,
_C_o_n_t_e_x_t).    The  first argument  is  the  `formal' description  of  the
error,  specifying the class  and generic  defined context  information.
When applicable,  the ISO  error term definition  is used.   The  second
part  describes some  additional context  to help  the programmer  while
debugging.    In its  most  generic form  this  is a  term of  the  form
context(_N_a_m_e_/_A_r_i_t_y_,  _M_e_s_s_a_g_e), where _N_a_m_e/_A_r_i_t_y  describes the  built-in
predicate  that raised  the error,  and _M_e_s_s_a_g_e  provides an  additional
description of the error.  Any part of this structure  may be a variable
if no information was present.


44..1111..44 PPrriinnttiinngg mmeessssaaggeess

The  predicate print_message/2 is  used to  print  a message  term in  a
human-readable format.   The  other predicates  from this section  allow
the user  to refine and extend  the message system.   A common usage  of
print_message/2 is to  print error messages from  exceptions.  The  code
below prints  errors encountered during the  execution of _G_o_a_l,  without
further propagating the exception and without starting the debugger.

________________________________________________________________________|                                                                        |
|        ...,                                                            |

|        catch(Goal, E,                                                  |
|              ( print_message(error, E),                                |
|                fail                                                    |
|              )),                                                       |
||_______...____________________________________________________________ ||

Another common  use is  to define  message_hook/3 for printing  messages
that are normally _s_i_l_e_n_t, suppressing messages,  redirecting messages or
make something happen in addition to printing the message.


pprriinntt__mmeessssaaggee((_+_K_i_n_d_, _+_T_e_r_m))
    The  predicate print_message/2 is used  by the system and  libraries
    to  print  messages.   _K_i_n_d  describes the  nature  of the  message,
    while  _T_e_r_m is a Prolog term  that describes the content.   Printing
    messages  through  this indirection  instead  of using  format/3  to
    the  stream user_error allows displaying the message appropriate  to
    the  application (terminal, logfile,  graphics), acting on  messages
    based on  their content instead of a string (see message_hook/3) and
    creating  language specific  versions  of the  messages.   See  also
    section ????.  The following message kinds are known:

    bbaannnneerr
         The system banner message.   Banner messages can  be suppressed
         by setting the Prolog flag verbose to silent.

    ddeebbuugg((_T_o_p_i_c))
         Message from library(debug).  See debug/3.

    eerrrroorr
         The  message indicates  an  erroneous  situation.    This  kind
         is used  to  print uncaught  exceptions of  type  error(_F_o_r_m_a_l_,
         _C_o_n_t_e_x_t).  See section introduction (section ????).

    hheellpp
         User requested help message, for example after  entering `h' or
         `?'  to a prompt.

    iinnffoorrmmaattiioonn
         Information that  is requested  by  the user.    An example  is
         statistics/0.

    iinnffoorrmmaattiioonnaall
         Typically messages  of events are  progres that are  considered
         useful to  a developer.   Such  messages can  be suppressed  by
         setting the Prolog flag verbose to silent.

    ssiilleenntt
         Message that is normally not printed.   Applications may define
         message_hook/3 to act upon such messages.

    ttrraaccee
         Messages from the (command line) tracer.

    wwaarrnniinngg
         The message indicates something dubious that is  not considered
         fatal.       For   example,   discontiguous   predicates   (see
         discontiguous/1).

    The predicate  print_message/2first translates the  _T_e_r_m into a list
    of  `message lines' (see print_message_lines/3 for details).   Next,
    it calls  the hook message_hook/3to allow the  user to intercept the
    message.   If message_hook/3fails it prints  the message unless _K_i_n_d
    is silent.

    The  print_message/2  predicate  and  its  rules  are  in  the  file
    <_p_l_h_o_m_e>/boot/messages.pl,   which  may   be   inspected  for   more
    information  on the error messages and related error terms.   If you
    need  to write messages from your own predicates, it  is recommended
    to  reuse the existing message terms if applicable.  If  no existing
    message  term  is  applicable,  invent  a fairly  unique  term  that
    represents  the event and define a rule for the  multifile predicate
    prolog:message//1.    See  section ????  for a  deeper discussion  and
    examples.

    See also message_to_string/2.


pprriinntt__mmeessssaaggee__lliinneess((_+_S_t_r_e_a_m_, _+_P_r_e_f_i_x_, _+_L_i_n_e_s))
    Print a  message (see print_message/2) that has  been translated to a
    list of message elements.  The elements of this list are:

    <_F_o_r_m_a_t>--<_A_r_g_s>
         Where  _F_o_r_m_a_t  is  an  atom  and  _A_r_g_s  is  a  list  of  format
         arguments.  Handed to format/3.

    fflluusshh
         If this  appears as the  last element,  _S_t_r_e_a_m is flushed  (see
         flush_output/1) and  no  final  newline  is generated.     This
         is  combined  with  a  subsequent  message  that   starts  with
         at_same_line to complete the line.

    aatt__ssaammee__lliinnee
         If this  appears as  first element,  no prefix  is printed  for
         the first line  and the line position  is not forced to 0  (see
         format/1, ~N).

    aannssii((_+_A_t_t_r_i_b_u_t_e_s_, _+_F_o_r_m_a_t_, _+_A_r_g_s))
         This message  may  be intercepted  by means  of  the hook  pro-
         log:message_line_element/2.   The  library ansi_term  implements
         this  hook  to  achieve  coloured  output.     If   it  is  not
         intercepted it invokes format(_S_t_r_e_a_m_, _F_o_r_m_a_t_, _A_r_g_s).

    nnll
         A new line is started.  If the message is  not complete, _P_r_e_f_i_x
         is printed before the remainder of the message.

    bbeeggiinn((_K_i_n_d_, _V_a_r))
    eenndd((_V_a_r))
         The entire message is  headed by begin(_K_i_n_d_, _V_a_r) and  ended by
         end(_V_a_r).  This feature is used  by, e.g., library ansi_term to
         colour entire messages.

    <_F_o_r_m_a_t>
         Handed to format/3 as  format(_S_t_r_e_a_m_, _F_o_r_m_a_t_, _[_]).   Deprecated
         because it  is ambiguous  if _F_o_r_m_a_t  collides with  one of  the
         atomic commands.

    See also print_message/2 and message_hook/3.


mmeessssaaggee__hhooookk((_+_T_e_r_m_, _+_K_i_n_d_, _+_L_i_n_e_s))
    Hook  predicate that may be defined in the module user  to intercept
    messages  from  print_message/2.    _T_e_r_m  and _K_i_n_d  are the  same  as
    passed to  print_message/2.  _L_i_n_e_s is a  list of format statements as
    described with print_message_lines/3.  See also message_to_string/2.

    This predicate must  be defined dynamic and multifile to allow other
    modules defining clauses for it too.


tthhrreeaadd__mmeessssaaggee__hhooookk((_+_T_e_r_m_, _+_K_i_n_d_, _+_L_i_n_e_s))
    As  message_hook/3,  but this  predicate  is  local to  the  calling
    thread   (see  thread_local/1).      This  hook  is  called   _b_e_f_o_r_e
    message_hook/3.    The  `pre-hook'  is  indented to  catch  messages
    they  may be produced by  calling some goal without affecting  other
    threads.


mmeessssaaggee__pprrooppeerrttyy((_+_K_i_n_d_, _?_P_r_o_p_e_r_t_y))
    This  hook can be  used to define  additional message kinds and  the
    way they are displayed.  The following properties are defined:

    ccoolloorr((_-_A_t_t_r_i_b_u_t_e_s))
         Print  message   using   ANSI  terminal   attributes.       See
         ansi_format/3 for details.   Here is an example, printing  help
         messages in blue:

         _______________________________________________________________|                                                               |

         |:- multifile user:message_property/2.                          |
         |                                                               |
         |user:message_property(help,|color([fg(blue)]))._______________ |                           |

    pprreeffiixx((_-_P_r_e_f_i_x))
         Prefix printed before  each line.   This argument is handed  to
         format/3.  The  default is '~N'. For example, messages  of kind
         warning use '~NWarning: '.

    llooccaattiioonn__pprreeffiixx((_+_L_o_c_a_t_i_o_n_, _-_F_i_r_s_t_P_r_e_f_i_x_, _-_C_o_n_t_i_n_u_e_P_r_e_f_i_x))
         Used for printing messages  that are related to a  source loca-
         tion.   Currently, _L_o_c_a_t_i_o_n is a  term _F_i_l_e:_L_i_n_e.   _F_i_r_s_t_P_r_e_f_i_x
         is the  prefix for the  first line  and _-_C_o_n_t_i_n_u_e_P_r_e_f_i_x is  the
         prefix for continuation  lines.   For example, the default  for
         errors is

         _______________________________________________________________|                                                               |
         |location_prefix(File:Line,                                     |
         ||_______________'~NERROR:_~w:~d:'-[File,Line],_'~N\t')).______ ||

    ssttrreeaamm((_-_S_t_r_e_a_m))
         Stream to which to print the message.  Default is user_error.

    wwaaiitt((_-_S_e_c_o_n_d_s))
         Amount of time to wait after printing the message.   Default is
         not to wait.


pprroolloogg::mmeessssaaggee__lliinnee__eelleemmeenntt((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    This  hook is called to print  the individual elements of a  message
    from  print_message_lines/3.    This hook  is used  by e.g.,  library
    ansi_term to colour messages on ANSI-capable terminals.


pprroolloogg::mmeessssaaggee__pprreeffiixx__hhooookk((_+_C_o_n_t_e_x_t_T_e_r_m_, _-_P_r_e_f_i_x))
    This  hook is called  to add context  to the message  prefix.   _C_o_n_-
    _t_e_x_t_T_e_r_m  is a member of  the list provided by  the message_context.
    _P_r_e_f_i_x  must be unified  with an atomic value  that is added to  the
    message prefix.


mmeessssaaggee__ttoo__ssttrriinngg((_+_T_e_r_m_, _-_S_t_r_i_n_g))
    Translates a message term into a string object (see section ????).


vveerrssiioonn
    Write  the SWI-Prolog banner message as well as  additional messages
    registered  using version/1.    This is  the default  _i_n_i_t_i_a_l_i_z_a_t_i_o_n
    _g_o_a_l which can be modified using -g.


vveerrssiioonn((_+_M_e_s_s_a_g_e))
    Register  additional messages  to  be printed  by version/0.    Each
    registered message is  handed to the message translation DCG and can
    thus  be defined using the hook prolog:message//1.  If  not defined,
    it is simply printed.


44..1111..44..11 PPrriinnttiinngg ffrroomm lliibbrraarriieess

Libraries should _n_o_t  use format/3 or other output predicates  directly.
Libraries that  print informational output directly  to the console  are
hard to  use from code  that depend on  your textual  output, such as  a
CGI script.   The predicates  in section ????  define the API for  dealing
with  messages.   The  idea behind  this is  that a  library that  wants
to provide  information about its status,  progress, events or  problems
calls print_message/2.  The first argument is the _l_e_v_e_l.   The supported
levels  are described  with print_message/2.    Libraries typically  use
informational and  warning, while  libraries should  use exceptions  for
errors (see throw/1, type_error/2, etc.).

The  second  argument is  an  arbitrary  Prolog term  that  carries  the
information  of the  message,  but  _n_o_t the  precise  text.    The  text
is defined  by the  grammar rule  prolog:message//1.   This  distinction
is made  to allow  for translations  and to allow  hooks processing  the
information in  a different  way (e.g., to  translate progress  messages
into a progress bar).

For example,  suppose we  have a  library that must  download data  from
the Internet (e.g.,  based on http_open/3).  The library wants  to print
the progress  after each  downloaded file.   The  code below  is a  good
skeleton:

________________________________________________________________________|                                                                        |
|download_urls(List) :-                                                  |
|        length(List, Total),                                            |
|        forall(nth1(I, List, URL),                                      |

|               (   download_url(URL),                                   |
|                   print_message(informational,                         |
||________________________________download_url(URL,_I,_Total))))._______ ||

The programmer  can now  specify the  default textual  output using  the
rule below.   Note that this  rule may be in  the same file or  anywhere
else.   Notably,  the application may  come with  several rule sets  for
different languages.    This, and  the user-hook example  below are  the
reason  to represent  the  message as  a  compound  term rather  than  a
string.    This is  similar  to using  message numbers  in  non-symbolic
languages.    The documentation  of print_message_lines/3 describes  the
elements that may appear in the output list.

________________________________________________________________________|                                                                        |
|:- multifile                                                            |
|        prolog:message//1.                                              |
|                                                                        |

|prolog:message(download_url(URL, I, Total)) -->                         |
|        { Perc is round(I*100/Total) },                                 |
||_______[_'Downloaded_~w;_~D_from_~D_(~d%)'-[URL,_I,_Total,_Perc]_].___ ||

A _u_s_e_r  of the library  may define rules for  message_hook/3.   The  rule
below acts on  the message content.   Other applications can act on  the
message level  and, for example,  popup a message  box for warnings  and
errors.

________________________________________________________________________|                                                                        |
|:- multifile user:message_hook/3.                                       |
|                                                                        |
|message_hook(download_url(URL, I, Total), _Kind, _Lines) :-             |
||_______<send_this_information_to_a_GUI_component>_____________________ ||

In addition, using the command line option -q, the  user can disable all
_i_n_f_o_r_m_a_t_i_o_n_a_l messages.


44..1122 HHaannddlliinngg ssiiggnnaallss

As of  version 3.1.0, SWI-Prolog is  able to handle software  interrupts
(signals) in Prolog as well as in foreign (C) code (see section ????).

Signals are used to handle internal errors (execution  of a non-existing
CPU  instruction,  arithmetic  domain  errors,  illegal  memory  access,
resource  overflow, etc.),  as  well as  for dealing  with  asynchronous
interprocess communication.

Signals  are  defined  by  the POSIX  standard  and  part  of  all  Unix
machines.    The  MS-Windows  Win32  provides  a subset  of  the  signal
handling routines, lacking the vital functionality to raise  a signal in
another thread for achieving asynchronous interprocess  (or interthread)
communication (Unix kill() function).


oonn__ssiiggnnaall((_+_S_i_g_n_a_l_, _-_O_l_d_, _:_N_e_w))
    Determines  the reaction on  _S_i_g_n_a_l.   _O_l_d is  unified with the  old
    behaviour, while the behaviour  is switched to _N_e_w.  As with similar
    environment  control  predicates,  the  current value  is  retrieved
    using on_signal(Signal, Current, Current).

    The  action  description  is  an  atom  denoting  the  name  of  the
    predicate  that will be called if _S_i_g_n_a_l arrives.   on_signal/3 is a
    meta-predicate, which implies that <_M_o_d_u_l_e>:<_N_a_m_e>  refers to <_N_a_m_e>/1
    in  module <_M_o_d_u_l_e>.  The handler  is called with a single argument:
    the  name of the signal  as an atom.   The Prolog names for  signals
    are explained below.

    Two  predicate names  have special  meaning.   throw implies  Prolog
    will  map  the  signal  onto  a Prolog  exception  as  described  in
    section  ????.   default  resets the  handler to  the settings  active
    before SWI-Prolog manipulated the handler.

    Signals  bound   to  a  foreign  function  through  PL_signal()  are
    reported using the term $foreign_function(_A_d_d_r_e_s_s).

    After  receiving a signal mapped to throw, the exception  raised has
    the following structure:

         error(signal(<SigName>, <SigNum>), <_C_o_n_t_e_x_t>)

    The  signal  names are  defined  by the  POSIX standard  as  symbols
    of  the form  SIG<SIGNAME>.   The Prolog  name for a  signal is  the
    lowercase version  of <SIGNAME>.  The predicate current_signal/3 may
    be used to map between names and signals.

    Initially,  some  signals  are  mapped to  throw,  while  all  other
    signals  are default.    The following signals  throw an  exception:
    fpe, alrm, xcpu, xfsz and vtalrm.


ccuurrrreenntt__ssiiggnnaall((_?_N_a_m_e_, _?_I_d_, _?_H_a_n_d_l_e_r))
    Enumerate  the  currently defined  signal  handling.   _N_a_m_e  is  the
    signal  name,  _I_d is  the numerical  identifier and  _H_a_n_d_l_e_r is  the
    currently defined handler (see on_signal/3).


pprroolloogg__aalleerrtt__ssiiggnnaall((_?_O_l_d_, _+_N_e_w))
    Query  or set the  signal used to  unblock blocking system calls  on
    Unix  systems and process  pending Prolog signals.   The default  is
    SIGUSR2.  See also --sigalert.


44..1122..11 NNootteess oonn ssiiggnnaall hhaannddlliinngg

Before  deciding  to deal  with  signals  in  your  application,  please
consider the following:

  o _P_o_r_t_a_b_i_l_i_t_y
    On MS-Windows, the  signal interface is severely limited.  Different
    Unix  brands support  different sets  of signals,  and the  relation
    between  signal name  and number may  vary.   Currently, the  system
    only  supports  signals numbered  1  to 32.    Installing  a  signal
    outside  the limited set of supported signals in  MS-Windows crashes
    the application.

  o _S_a_f_e_t_y
    Immediately delivered signals  (see below) are unsafe.  This implies
    that  foreign  functions called  from a  handler  cannot safely  use
    the  SWI-Prolog API and  cannot use C  longjmp().  Handlers  defined
    as  throw are  unsafe.   Handlers defined  to call  a predicate  are
    safe.   Note that the  predicate can call throw/1, but  the delivery
    is delayed until Prolog is in a safe state.

    The  C-interface  described   in  section  ????  provides  the  option
    PL_SIGSYNC to select either safe synchronous  or unsafe asynchronous
    delivery.

  o _T_i_m_e _o_f _d_e_l_i_v_e_r_y
    Using throw or  a foreign handler, signals are delivered immediately
    (as  defined by the OS). When using a Prolog predicate,  delivery is
    delayed  to a safe moment.   Blocking system calls or foreign  loops
    may cause long delays.   Foreign code can improve on that by calling
    PL_handle_signals().

    Signals are blocked when the garbage collector is active.


44..1133 DDCCGG GGrraammmmaarr rruulleess

Grammar rules form  a comfortable interface to  _d_i_f_f_e_r_e_n_c_e _l_i_s_t_s.   They
are designed  both to support  writing parsers that  build a parse  tree
from a list of characters or tokens and for generating  a flat list from
a term.

Grammar rules  look like  ordinary clauses  using -->/2  for  separating
the head  and body rather than  :-/2.   Expanding grammar rules is  done
by expand_term/2, which adds  two additional arguments to each term  for
representing the difference list.

The  body of  a grammar  rule  can contain  three  types of  terms.    A
callable term  is interpreted as a  reference to a  grammar rule.   Code
between  {...}  is  interpreted  as  plain  Prolog  code,  and  finally,
a  list  is  interpreted  as  a  sequence  of  _l_i_t_e_r_a_l_s.     The  Prolog
control-constructs  (\+/1, ->/2 , ;//2,  ,/2  and !/0)  can be  used  in
grammar rules.

We  illustrate the  behaviour by  defining  a rule  set for  parsing  an
integer.

________________________________________________________________________|                                                                        |
|integer(I) -->                                                          |

|        digit(D0),                                                      |
|        digits(D),                                                      |
|        { number_codes(I, [D0|D])                                       |
|        }.                                                              |
|                                                                        |
|digits([D|T]) -->                                                       |
|        digit(D), !,                                                    |
|        digits(T).                                                      |

|digits([]) -->                                                          |
|        [].                                                             |
|                                                                        |
|digit(D) -->                                                            |
|        [D],                                                            |
|        { code_type(D, digit)                                           |
||_______}._____________________________________________________________ ||

Grammar rule sets are called using the built-in  predicates phrase/2 and
phrase/3:


pphhrraassee((_:_D_C_G_B_o_d_y_, _?_L_i_s_t))
    Equivalent to phrase(_D_C_G_B_o_d_y, _I_n_p_u_t_L_i_s_t, []).


pphhrraassee((_:_D_C_G_B_o_d_y_, _?_L_i_s_t_, _?_R_e_s_t))
    True  when _D_C_G_B_o_d_y applies  to the difference  _L_i_s_t/_R_e_s_t.   Although
    _D_C_G_B_o_d_y  is typically a _c_a_l_l_a_b_l_e  term that denotes a grammar  rule,
    it can be any term that is valid as the body of a DCG rule.

    The  example  below   calls  the  rule  set  integer//1  defined  in
    section  ???? and available from library(dcg/basics), binding  _R_e_s_t to
    the remainder of the input after matching the integer.

    ____________________________________________________________________|                                                                    |
    | ?- [library(dcg/basics)].                                          |

    | ?- atom_codes('42 times', Codes),                                  |
    |    phrase(integer(X), Codes, Rest).                                |
    | X = 42                                                             |
    ||Rest_=_[32,_116,_105,_109,_101,_115]______________________________ ||

    The  next example  exploits a complete  body.   Given the  following
    definition of digit_weight//1, we can pose the query below.

    ____________________________________________________________________|                                                                    |
    | digit_weight(W) -->                                                |
    |         [D],                                                       |

    ||________{_code_type(D,_digit(W))_}._______________________________ ||

    ____________________________________________________________________|                                                                    |
    | ?- atom_codes('Version 3.4', Codes),                               |

    |    phrase(("Version ",                                             |
    |            digit_weight(Major),".",digit_weight(Minor)),           |
    |           Codes).                                                  |
    | Major = 3,                                                         |
    ||Minor_=_4.________________________________________________________ ||

    The  SWI-Prolog implementation  of phrase/3 verifies  that the  _L_i_s_t
    and  _R_e_s_t arguments are unbound, bound  to the empty list or  a list
    _c_o_n_s  _c_e_l_l.    Other  values raise  a  type error.    The  predicate
    call_dcg/3 is provided to use grammar rules with  terms that are not
    lists.

    Note  that  the syntax  for  lists of  codes changed  in  SWI-Prolog
    version  7 (see  section ????).   If  a DCG body  is translated,  both
    "text"  and `text` is  a valid code-list  literal in version  7.   A
    version  7 string  ("text")  is nnoott  acceptable for  the second  and
    third  arguments of phrase/3.   This is typically not a problem  for
    applications  as the  input of a  DCG rarely  appears in the  source
    code.  For  testing in the toplevel, one must use double quoted text
    in versions prior to 7 and back quoted text in version 7 or later.

    See  also  portray_text/1,  which can  be  used to  print  lists  of
    character  codes  as   a  string  to  the  top  level  and  debugger
    to   facilitate  debugging  DCGs   that  process  character   codes.
    The  library  apply_macros  compiles phrase/3  if  the  argument  is
    sufficiently  instantiated,  eliminating  the  runtime  overhead  of
    translating _D_C_G_B_o_d_y and meta-calling.


ccaallll__ddccgg((_:_D_C_G_B_o_d_y_, _?_S_t_a_t_e_0_, _?_S_t_a_t_e))
    As  phrase/3, but  without type  checking _S_t_a_t_e_0  and _S_t_a_t_e.    This
    allows  for  using  DCG  rules  for  threading  an  arbitrary  state
    variable.   This  predicate was introduced  after type checking  was
    added to phrase/3.

    A  portable  solution  for threading  state  through  a DCG  can  be
    implemented  by  wrapping  the state  in  a  list and  use  the  DCG
    semicontext  facility.   Subsequently, the following predicates  may
    be used to access and modify the state:

    ____________________________________________________________________|                                                                    |
    | state(S), [S] --> [S].                                             |

    ||state(S0,_S),_[S]_-->_[S0]._______________________________________ ||

As stated  above, grammar  rules are a  general interface to  difference
lists.  To illustrate, we show a DCG-based implementation of reverse/2:

________________________________________________________________________|                                                                        |
|reverse(List, Reversed) :-                                              |
|        phrase(reverse(List), Reversed).                                |
|                                                                        |

|reverse([])    --> [].                                                  |
|reverse([H|T])|-->_reverse(T),_[H].____________________________________ |              |


44..1144 DDaattaabbaassee

SWI-Prolog  offers several  ways to  store data  in globally  accessible
memory, i.e., outside the  Prolog _s_t_a_c_k_s.  Data stored this  way notably
does not  change on _b_a_c_k_t_r_a_c_k_i_n_g.   Typically  it is a  bad idea to  use
any of  the predicates in  this section  for realising global  variables
that  can be  assigned  to.    Typically,  first  consider  representing
data  processed by  your program  as terms  passed  around as  predicate
arguments.   If you need  to reason over  multiple solutions to a  goal,
consider findall/3, aggregate/3 and related predicates.

Nevertheless, there are scenarios where storing data  outside the Prolog
stacks is a good option.  Below are the main options for storing data:

UUssiinngg ddyynnaammiicc pprreeddiiccaatteess  Dynamic predicates  are predicates  for  which
    the  list  of  clauses  is  modified  at  runtime  using  asserta/1,
    assertz/1,  retract/1 or retractall/1.  Following the  ISO standard,
    predicates  that are  modified this  way need to  be declared  using
    the  dynamic/1 _d_i_r_e_c_t_i_v_e.  These  facilities are defined by the  ISO
    standard  and widely supported.   The mechanism is often  considered
    slow  in  the  literature.     Performance  depends  on  the  Prolog
    implementation.   In SWI-Prolog, querying dynamic predicates has the
    same  performance as static ones.   The manipulation predicates  are
    fast.    Using retract/1  or retractall/1 on  a predicate  registers
    the  predicate  as  `dirty'.     Dirty  predicates  are  cleaned  by
    garbage_collect_clauses/0, which is normally  automatically invoked.
    Some  workloads may result in significant performance  reduction due
    to skipping retracted clauses and/or clause garbage collection.

    Dynamic  predicates  can be  wrapped  using library  persistency  to
    maintain  a backup of the data on disk.  Dynamic predicates  come in
    two flavours, _s_h_a_r_e_d between  threads and _l_o_c_a_l to each thread.  The
    latter version is created using the directive thread_local/1.

TThhee rreeccoorrddeedd ddaattaabbaassee  The `recorded database' registers a list of terms
    with  a  _k_e_y,  an atom  or  compound term.     The list  is  managed
    using  recorda/3,  recordz/3  and erase/1.     It is  queried  using
    recorded/3.   The recorded database is not part of the  ISO standard
    but  fairly widely  supported, notably  in implementations  building
    on  the `Edinburgh tradition'.   There are  few reasons to use  this
    database  in  SWI-Prolog  due to  the  good performance  of  dynamic
    predicates.     Advantages are  (1)  the  handle provides  a  direct
    reference  to  a  term,  (2) cyclic  terms  can be  stored  and  (3)
    attributes  (section ????) are preserved.   Disadvantages are (1)  the
    terms  in a  list associated  with a key  are not  indexed, (2)  the
    poorly specified _i_m_m_e_d_i_a_t_e  _u_p_d_a_t_e _s_e_m_a_n_t_i_c_s (see section ???? applies
    to the recorded database and (3) reduced portability.

TThhee flag/3 pprreeddiiccaattee  The predicate flag/3  associates one simple  value
    (number  or atom) with  a key (atom,  integer or compound).   It  is
    an  old  SWI-Prolog specific  predicate  that should  be  considered
    deprecated, although there is no plan to remove it.

UUssiinngg gglloobbaall vvaarriiaabblleess  The   predicates  b_setval/2   and   nb_setval/2
    associate   a  term  living  on  the  Prolog  stack  with   a  name,
    either  backtrackable  or  non-backtrackable.     Backtrackable  and
    non-backtrackable  assignment without  using  a global  name can  be
    realised  with setarg/3  and nb_setarg/3.   Notably  the latter  are
    used to realise aggregation as e.g., aggregate_all/3 performs.

TTrriieess  As of version 7.3.21, SWI-Prolog provides _t_r_i_e_s (prefix trees) to
    associate  a term _v_a_r_i_a_n_t with a value.  Tries have  been introduced
    to support _t_a_b_l_i_n_g and are described in section ????.


44..1144..11 MMaannaaggiinngg ((ddyynnaammiicc)) pprreeddiiccaatteess


aabboolliisshh((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                                      _[_I_S_O_]
    Removes  all clauses of a  predicate with functor _F_u_n_c_t_o_r and  arity
    _A_r_i_t_y  from  the  database.    All  predicate  attributes  (dynamic,
    multifile,  index, etc.)  are  reset to their defaults.   Abolishing
    an  imported predicate only removes  the import link; the  predicate
    will keep its old definition in its definition module.

    According  to the  ISO standard,  abolish/1 can only  be applied  to
    dynamic  procedures.    This is  odd, as  for  dealing with  dynamic
    procedures  there  is  already  retract/1 and  retractall/1.     The
    abolish/1  predicate was introduced  in DEC-10 Prolog precisely  for
    dealing  with static procedures.  In SWI-Prolog, abolish/1  works on
    static procedures, unless the Prolog flag iso is set to true.

    It  is advised  to use  retractall/1 for  erasing all  clauses of  a
    dynamic predicate.


aabboolliisshh((_+_N_a_m_e_, _+_A_r_i_t_y))
    Same  as abolish(_N_a_m_e_/_A_r_i_t_y).   The predicate abolish/2 conforms  to
    the Edinburgh standard, while abolish/1 is ISO compliant.


ccooppyy__pprreeddiiccaattee__ccllaauusseess((_:_F_r_o_m_, _:_T_o))
    Copy  all clauses of predicate  _F_r_o_m to _T_o.   The predicate _T_o  must
    be  dynamic or  undefined.   If _T_o  is undefined, it  is created  as
    a  dynamic predicate  holding a copy  of the  clauses of _F_r_o_m.    If
    _T_o  is a dynamic  predicate, the  clauses of _F_r_o_m  are added (as  in
    assertz/1)  to the clauses of  _T_o.  _T_o  and _F_r_o_m must have the  same
    arity.    Acts as if  defined by the  program below,  but at a  much
    better performance by avoiding decompilation and compilation.

    ____________________________________________________________________|                                                                    |
    | copy_predicate_clauses(From, To) :-                                |

    |         head(From, MF:FromHead),                                   |
    |         head(To, MT:ToHead),                                       |
    |         FromHead =.. [_|Args],                                     |
    |         ToHead =.. [_|Args],                                       |
    |         forall(clause(MF:FromHead, Body),                          |
    |                assertz(MT:ToHead, Body)).                          |
    |                                                                    |
    | head(From, M:Head) :-                                              |

    |         strip_module(From, M, Name/Arity),                         |
    ||________functor(Head,_Name,_Arity)._______________________________ ||


rreeddeeffiinnee__ssyysstteemm__pprreeddiiccaattee((_+_H_e_a_d))
    This  directive  may be  used  both in  module  user and  in  normal
    modules to redefine  any system predicate.  If the system definition
    is  redefined in  module user,  the  new definition  is the  default
    definition  for  all sub-modules.    Otherwise  the redefinition  is
    local  to the module.   The system definition remains in the  module
    system.

    Redefining   system   predicate   facilitates  the   definition   of
    compatibility packages.  Use in other contexts is discouraged.


rreettrraacctt((_+_T_e_r_m))                                             _[_I_S_O_,_n_o_n_d_e_t_]
    When  _T_e_r_m  is an  atom  or a  term  it is  unified with  the  first
    unifying  fact or clause  in the database.   The  fact or clause  is
    removed  from the database.   The  retract/1 predicate respects  the
    _l_o_g_i_c_a_l  _u_p_d_a_t_e _v_i_e_w.  This implies that retract/1 succeeds  for all
    clauses that match _T_e_r_m  when the predicate was _c_a_l_l_e_d.  The example
    below  illustrates that the first call to retract/1 succeeds  on bee
    on backtracking despite the fact that bee is already retracted..

    ____________________________________________________________________|                                                                    |
    | :- dynamic insect/1.                                               |

    | insect(ant).                                                       |
    | insect(bee).                                                       |
    |                                                                    |
    | ?- (   retract(insect(I)),                                         |
    |        writeln(I),                                                 |
    |        retract(insect(bee)),                                       |
    |        fail                                                        |
    |    ;   true                                                        |

    |    ).                                                              |
    | ant ;                                                              |
    ||bee.______________________________________________________________ ||

    If  multiple threads start  a retract on  the same predicate at  the
    same  time their  notion of  the _e_n_t_r_y _g_e_n_e_r_a_t_i_o_n  is adjusted  such
    that  they do  not  retract the  same first  clause.   This  implies
    that,  if multiple threads  use once(retract(Term)), no two  threads
    will  retract  the same  clause.   Note  that  on backtracking  over
    retract/1,  multiple threads  may retract  the same  clause as  both
    threads respect the logical update view.


rreettrraaccttaallll((_+_H_e_a_d))                                             _[_I_S_O_,_d_e_t_]
    All  facts or  clauses in the  database for  which the _h_e_a_d  unifies
    with  _H_e_a_d are removed.  If  _H_e_a_d refers to a predicate that  is not
    defined, it is implicitly  created as a dynamic predicate.  See also
    dynamic/1.


aasssseerrttaa((_+_T_e_r_m))                                                    _[_I_S_O_]


aasssseerrttzz((_+_T_e_r_m))                                                    _[_I_S_O_]


aasssseerrtt((_+_T_e_r_m))                                              _[_d_e_p_r_e_c_a_t_e_d_]
    Assert  a clause (fact  or rule) into the  database.  The  predicate
    asserta/1  asserts  the  clause as  first  clause of  the  predicate
    while  assertz/1 assert the clause as  last clause.  The  deprecated
    assert/1  is equivalent to assertz/1.  If the program space  for the
    target  module is limited (see set_module/1), asserta/1 can  raise a
    resource_error(_p_r_o_g_r_a_m___s_p_a_c_e) exception.  The example below adds two
    facts and a rule.  Note the double parentheses around the rule.

    ____________________________________________________________________|                                                                    |
    | ?- assertz(parent('Bob', 'Jane')).                                 |

    | ?- assertz(female('Jane')).                                        |
    | ?- assertz((mother(Child, Mother) :-                               |
    |                 parent(Child, Mother),                             |
    ||________________female(Mother)))._________________________________ ||


aasssseerrttaa((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))


aasssseerrttzz((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))


aasssseerrtt((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))                                  _[_d_e_p_r_e_c_a_t_e_d_]
    Equivalent  to  asserta/1,  assertz/1,  assert/1,  but  in  addition
    unifies  _R_e_f_e_r_e_n_c_e  with a  handle to  the asserted  clauses.    The
    handle can be used to access this clause with clause/3 and erase/1.


44..1144..22 TThhee rreeccoorrddeedd ddaattaabbaassee


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Assert  _T_e_r_m in  the recorded  database under  key _K_e_y.    _K_e_y is  a
    small  integer (range min_tagged_integer ...max_tagged_integer,  atom
    or compound term.   If the key is a compound term, only the name and
    arity  define the key.   _R_e_f_e_r_e_n_c_e is unified with an opaque  handle
    to the record (see erase/1).


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recorda(_K_e_y, _T_e_r_m,  _).


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to recorda/3, but  puts the _T_e_r_m at the tail of the terms
    recorded under _K_e_y.


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recordz(_K_e_y, _T_e_r_m,  _).


rreeccoorrddeedd((_?_K_e_y_, _?_V_a_l_u_e_, _?_R_e_f_e_r_e_n_c_e))
    True  if _V_a_l_u_e  is recorded  under _K_e_y  and has  the given  database
    _R_e_f_e_r_e_n_c_e.     If  _R_e_f_e_r_e_n_c_e  is  given,  this  predicate  is  semi-
    deterministic.   Otherwise, it must be considered non-deterministic.
    If neither _R_e_f_e_r_e_n_c_e  nor _K_e_y is given, the triples are generated as
    in the code snippet below.  See also current_key/1.

    ____________________________________________________________________|                                                                    |
    |         current_key(Key),                                          |

    ||________recorded(Key,_Value,_Reference)___________________________ ||


rreeccoorrddeedd((_+_K_e_y_, _-_V_a_l_u_e))
    Equivalent to recorded(_K_e_y, _V_a_l_u_e,  _).


eerraassee((_+_R_e_f_e_r_e_n_c_e))
    Erase  a  record  or  clause  from  the  database.     _R_e_f_e_r_e_n_c_e  is
    a  db-reference  returned  by recorda/3,  recordz/3  or  recorded/3,
    clause/3,  assert/2, asserta/2 or assertz/2.   Fail silently if  the
    referenced  object no longer exists.   Notably, if multiple  threads
    attempt  to erase the  same clause one  will succeed and the  others
    will fail.


iinnssttaannccee((_+_R_e_f_e_r_e_n_c_e_, _-_T_e_r_m))
    Unify  _T_e_r_m with  the referenced clause  or database  record.   Unit
    clauses are represented as _H_e_a_d :- true.


44..1144..33 FFllaaggss

The  predicate   flag/3  is  the  oldest   way  to  store  global   non-
backtrackable data in  SWI-Prolog.  Flags  are global and shared by  all
threads.  Their  value is limited to atoms, small (64-bit)  integers and
floating point  numbers.   Flags are thread-safe.   The flags  described
in this  section must  not be  confused with _P_r_o_l_o_g  _f_l_a_g_s described  in
section ????.


ggeett__ffllaagg((_+_K_e_y_, _-_V_a_l_u_e))
    True when _V_a_l_u_e is  the value currently associated with _K_e_y.  If _K_e_y
    does not exist, a new flag with value `0' (zero) is created.


sseett__ffllaagg((_+_K_e_y_, _V_a_l_u_e))
    Set  flag _K_e_y  to _V_a_l_u_e.    Value must  be an  atom, small  (64-bit)
    integer or float.


ffllaagg((_+_K_e_y_, _-_O_l_d_, _+_N_e_w))
    True when _O_l_d is  the current value of the flag _K_e_y and the flag has
    been  set to _N_e_w.  _N_e_w can be an arithmetic expression.   The update
    is  _a_t_o_m_i_c.  This  predicate can be used  to create a _s_h_a_r_e_d  global
    counter as illustrated in the example below.

    ____________________________________________________________________|                                                                    |
    | next_id(Id) :-                                                     |

    ||____flag(my_id,_Id,_Id+1).________________________________________ ||


44..1144..44 TTrriieess

Tries (also called  _d_i_g_i_t_a_l _t_r_e_e, _r_a_d_i_x _t_r_e_e  or _p_r_e_f_i_x _t_r_e_e maintain  a
mapping between  a variant  of a term  (see =@=/2)  and a value.    They
have been introduced in SWI-Prolog 7.3.21 as part  of the implementation
of  _t_a_b_l_i_n_g.    The  current implementation  is  rather  immature.    In
particular, the following limitations currently apply:

  o Tries are not thread-safe.

  o Tries  should  not be  modified while  non-deterministic  predicates
    such as trie_gen/3 are running on the trie.

  o Terms cannot have _a_t_t_r_i_b_u_t_e_d _v_a_r_i_a_b_l_e_s.

  o Terms  cannot be  _c_y_c_l_i_c.   Possibly  this will  not change  because
    cyclic  terms can only be supported after creating a  canonical form
    of the term.

WWee ggiivvee tthhee  ddeeffiinniittiioonn ooff tthheessee pprreeddiiccaatteess ffoorr rreeffeerreennccee  aanndd ddeebbuuggggiinngg
ttaabblleedd pprreeddiiccaatteess..    FFuuttuurree vveerrssiioonnss aarree  lliikkeellyy ttoo  ggeett aa mmoorree  ssttaabbllee
aanndd ssaaffeerr  iimmpplleemmeennttaattiioonn..   TThhee AAPPII ttoo ttrriieess  sshhoouulldd nnoott bbee  ccoonnssiiddeerreedd
ssttaabbllee..


ttrriiee__nneeww((_-_T_r_i_e))
    Create  a  new trie  and  unify  _T_r_i_e with  a  handle to  the  trie.
    The  trie handle  is a  _b_l_o_b.   Tries  are subject  to atom  garbage
    collection.


ttrriiee__ddeessttrrooyy((_+_T_r_i_e))
    Destroy  _T_r_i_e.   This  removes all nodes  from the  trie and  causes
    further  access to _T_r_i_e to raise an  existence_error exception.   The
    handle itself is reclaimed by atom garbage collection.


iiss__ttrriiee((_@_T_r_i_e))                                                 _[_s_e_m_i_d_e_t_]
    True when _T_r_i_e is a trie object.  See also current_trie/1.


ccuurrrreenntt__ttrriiee((_-_T_r_i_e))                                             _[_n_o_n_d_e_t_]
    True  if _T_r_i_e is a currently existing trie.  As this  enumerates and
    then filters all  known atoms this predicate is slow and should only
    be used for debugging purposes.  See also is_trie/1.


ttrriiee__iinnsseerrtt((_+_T_r_i_e_, _+_K_e_y_, _+_V_a_l_u_e))
    Insert  the term _K_e_y into _T_r_i_e and  associate it with _V_a_l_u_e.   _V_a_l_u_e
    can  be  any term.    If  _K_e_y-_V_a_l_u_e is  already  part of  _T_r_i_e,  the
    predicates  _f_a_i_l_s silently.   If  _K_e_y is in  _T_r_i_e associated with  a
    different value, a permission_error is raised.


ttrriiee__uuppddaattee((_+_T_r_i_e_, _+_K_e_y_, _+_V_a_l_u_e))
    As  trie_insert/3,  but if _K_e_y  is in _T_r_i_e,  its associated value  is
    _u_p_d_a_t_e_d.


ttrriiee__iinnsseerrtt((_+_T_r_i_e_, _+_T_e_r_m_, _+_V_a_l_u_e_, _-_H_a_n_d_l_e))
    As  trie_insert/3,  returning a  handle  to the  trie  node.    This
    predicate  is  currently unsafe  as  _H_a_n_d_l_e is  an integer  used  to
    encode  a pointer.  It was  used to implement a pure  Prolog version
    of the tabling library.


ttrriiee__ddeelleettee((_+_T_r_i_e_, _+_K_e_y_, _?_V_a_l_u_e))
    Delete  _K_e_y from _T_r_i_e if the value associated with _K_e_y  unifies with
    _V_a_l_u_e.


ttrriiee__llooookkuupp((_+_T_r_i_e_, _+_K_e_y_, _-_V_a_l_u_e))
    True if the term _K_e_y is in _T_r_i_e and associated with _V_a_l_u_e.


ttrriiee__tteerrmm((_+_H_a_n_d_l_e_, _-_T_e_r_m))
    True  when  _T_e_r_m is  a  copy of  the  term associated  with  _H_a_n_d_l_e.
    The  result is  undefined  (including crashes)  if _H_a_n_d_l_e  is not  a
    handle  returned by trie_insert_new/3 or the  node has been  removed
    afterwards.


ttrriiee__ggeenn((_+_T_r_i_e_, _?_K_e_y_, _-_V_a_l_u_e))                                   _[_n_o_n_d_e_t_]
    True  when  _K_e_y is  associated with  _V_a_l_u_e in  _T_r_i_e.    Backtracking
    retrieves  all pairs.  Currently scans the entire trie, even  if _K_e_y
    is  partly known.   Currently unsafe if  _T_r_i_e is modified while  the
    values are being enumerated.


ttrriiee__pprrooppeerrttyy((_?_T_r_i_e_, _?_P_r_o_p_e_r_t_y))                                 _[_n_o_n_d_e_t_]
    True  if _T_r_i_e  exists with  _P_r_o_p_e_r_t_y.   Intended  for debugging  and
    statistical  purposes.   Retrieving some  of these properties  visit
    all nodes of the trie.  Defined properties are

    vvaalluuee__ccoouunntt((_-_C_o_u_n_t))
         Number of key-value pairs in the trie.

    nnooddee__ccoouunntt((_-_C_o_u_n_t))
         Number of nodes in the trie.

    ssiizzee((_-_B_y_t_e_s))
         Required storage space of the trie.

    hhaasshheedd((_-_C_o_u_n_t))
         Number of nodes that use a hashed index to its children.


44..1144..55 UUppddaattee vviieeww

Traditionally,  Prolog systems  used  the _i_m_m_e_d_i_a_t_e  _u_p_d_a_t_e _v_i_e_w:    new
clauses  became   visible  to   predicates  backtracking  over   dynamic
predicates   immediately,  and   retracted   clauses  became   invisible
immediately.

Starting with  SWI-Prolog 3.3.0 we  adhere to  the _l_o_g_i_c_a_l _u_p_d_a_t_e  _v_i_e_w,
where backtrackable predicates that enter the definition  of a predicate
will not  see any changes  (either caused by  assert/1 or retract/1)  to
the  predicate.    This view  is the  ISO  standard, the  most  commonly
used and  the most  `safe'.   Logical  updates are  realised by  keeping
reference counts  on predicates and  _g_e_n_e_r_a_t_i_o_n information on  clauses.
Each change  to the database  causes an increment  of the generation  of
the database.  Each  goal is tagged with the generation in which  it was
started.   Each  clause is flagged  with the  generation it was  created
in as  well as the  generation it was  erased from.   Only clauses  with
a `created'  ...`erased' interval  that encloses the  generation of  the
current goal are considered visible.


44..1144..66 IInnddeexxiinngg ddaattaabbaasseess

The indexing  capabilities of  SWI-Prolog are described  in section  ????.
Summarizing,  SWI-Prolog creates  indexes for  any applicable  argument,
pairs of arguments and  indexes on the arguments of compound  terms when
applicable.    Extended  JIT indexing  is  not widely  supported  amoung
Prolog  implementations.    Programs  that  aim  at  portability  should
consider using term_hash/2 and term_hash/4 to design their database such
that  indexing on  constant  or functor  (name/arity reference)  on  the
first  argument is  sufficient.   In  some cases,  using the  predicates
below to add  one or more additional  columns (arguments) to a  database
predicate may  improve performance.   The overall  design of code  using
these predicates is  given below.   Note that as term_hash/2 leaves  the
hash unbound if _T_e_r_m is  not ground.  This causes the lookup to  be fast
if _T_e_r_m is ground and correct (but slow) otherwise.

________________________________________________________________________|                                                                        |
|:- dynamic                                                              |

|    x/2.                                                                |
|                                                                        |
|assert_x(Term) :-                                                       |
|    term_hash(Term, Hash),                                              |
|    assertz(x(Hash, Term)).                                             |
|                                                                        |
|x(Term) :-                                                              |
|    term_hash(Term, Hash),                                              |

||___x(Hash,_Term)._____________________________________________________ ||


tteerrmm__hhaasshh((_+_T_e_r_m_, _-_H_a_s_h_K_e_y))                                         _[_d_e_t_]
    If  _T_e_r_m is a  ground term (see ground/1),  _H_a_s_h_K_e_y is unified  with
    a  positive integer  value that may  be used  as a hash  key to  the
    value.    If _T_e_r_m  is not ground,  the predicate  leaves _H_a_s_h_K_e_y  an
    unbound  variable.   Hash  keys are  in the  range 0:::16;777; 215, the
    maximal  integer that can  be stored efficiently  on both 32 and  64
    bit platforms.

    This  predicate may  be  used to  build hash  tables as  well as  to
    exploit argument indexing to find complex terms more quickly.

    The  hash key does not rely on temporary information  like addresses
    of  atoms and  may be  assumed constant  over different  invocations
    and  versions of SWI-Prolog.   Hashes differ between big and  little
    endian machines.  The term_hash/2 predicate is cycle-safe.


tteerrmm__hhaasshh((_+_T_e_r_m_, _+_D_e_p_t_h_, _+_R_a_n_g_e_, _-_H_a_s_h_K_e_y))                         _[_d_e_t_]
    As  term_hash/2, but  only considers  _T_e_r_m to  the specified  _D_e_p_t_h.
    The  top-level term has  depth 1, its arguments  have depth 2,  etc.
    That  is, _D_e_p_t_h =0  hashes nothing;  _D_e_p_t_h= 1 hashes  atomic values
    or  the functor  and arity of  a compound term,  not its  arguments;
    _D_e_p_t_h =2 also indexes the immediate arguments, etc.

    _H_a_s_h_K_e_y  is in the range  [0:::_R_a_n_g_e-1].   _R_a_n_g_e must be  in the range
    [1:::2147483647]


vvaarriiaanntt__sshhaa11((_+_T_e_r_m_, _-_S_H_A_1))                                         _[_d_e_t_]
    Compute  a  SHA1-hash from  _T_e_r_m.    The hash  is represented  as  a
    40-byte  hexadecimal atom.    Unlike term_hash/2  and friends,  this
    predicate  produces a hash  key for non-ground terms.   The hash  is
    invariant  over  variable-renaming (see  =@=/2) and  constants  over
    different invocations of Prolog.

    This  predicate raises an exception when trying to compute  the hash
    on  a cyclic  term or  attributed term.   Attributed  terms are  not
    handled  because subsumes_chk/2 is not  considered well defined  for
    attributed  terms.    Cyclic terms  are not  supported because  this
    would  require  establishing a  canonical cycle.    That  is,  given
    A=[a_A]  and B=[a,a_B], _A and _B should produce the same hash.   This
    is not (yet) implemented.

    This  hash was developed  for lookup of  solutions to a goal  stored
    in  a table.   By using a  cryptographic hash, heuristic  algorithms
    can  often ignore the possibility of hash collisions and  thus avoid
    storing the goal term itself as well as testing using =@=/2.


vvaarriiaanntt__hhaasshh((_+_T_e_r_m_, _-_H_a_s_h_K_e_y))                                      _[_d_e_t_]
    Similar  to  variant_sha1/2,  but  using  a  non-cryptographic  hash
    and  produces  an integer  result like  term_hash/2.    This  version
    does  deal  with attributed  variables,  processing them  as  normal
    variables.    This  hash is  primarily intended  to speedup  finding
    variant terms in a set of terms.


44..1155 DDeeccllaarriinngg pprreeddiiccaattee pprrooppeerrttiieess

This  section  describes  directives  which  manipulate   attributes  of
predicate   definitions.      The   functors   dynamic/1,   multifile/1,
discontiguous/1 and public/1 are operators of priority  1150 (see op/3),
which implies  that the list  of predicates they involve  can just be  a
comma-separated list:

________________________________________________________________________|                                                                        |
|:- dynamic                                                              |

|        foo/0,                                                          |
||_______baz/2._________________________________________________________ ||

In SWI-Prolog all  these directives are just  predicates.  This  implies
they can also  be called by a program.   Do not rely on this  feature if
you want to maintain portability to other Prolog implementations.


ddyynnaammiicc _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.                                  _[_I_S_O_]
    Informs  the interpreter  that  the definition  of the  predicate(s)
    may  change during execution (using assert/1 and/or retract/1).   In
    the  multithreaded version,  the clauses  of dynamic predicates  are
    shared  between the threads.  The  directive thread_local/1 provides
    an  alternative where each  thread has its  own clause list for  the
    predicate.   Dynamic predicates can be turned into static ones using
    compile_predicates/1.


ccoommppiillee__pprreeddiiccaatteess((_:_L_i_s_t_O_f_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_s))
    Compile  a list of specified  dynamic predicates (see dynamic/1  and
    assert/1)  into  normal static  predicates.    This call  tells  the
    Prolog  environment  the  definition  will not  change  anymore  and
    further  calls  to assert/1  or retract/1  on  the named  predicates
    raise  a permission error.  This predicate is designed to  deal with
    parts  of  the program  that are  generated at  runtime  but do  not
    change during the remainder of the program execution.


mmuullttiiffiillee _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.                                _[_I_S_O_]
    Informs  the system that the  specified predicate(s) may be  defined
    over  more than one  file.  This  stops consult/1 from redefining  a
    predicate when a new definition is found.


ddiissccoonnttiigguuoouuss _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.                            _[_I_S_O_]
    Informs  the system that the  clauses of the specified  predicate(s)
    might not be together in the source file.  See also style_check/1.


ppuubblliicc _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.
    Instructs  the cross-referencer  that the predicate  can be  called.
    It  has no semantics.   The public declaration can be queried  using
    predicate_property/2.   The public/1  directive does _n_o_t export  the
    predicate  (see module/1  and export/1).   The  public directive  is
    used for (1) direct  calls into the module from, e.g., foreign code,
    (2)  direct calls into the module from other modules, or (3)  flag a
    predicate  as being called if the call is generated  by meta-calling
    constructs that are not analysed by the cross-referencer.


44..1166 EExxaammiinniinngg tthhee pprrooggrraamm


ccuurrrreenntt__aattoomm((_-_A_t_o_m))
    Successively unifies _A_t_o_m with  all atoms known to the system.  Note
    that  current_atom/1 always succeeds if  _A_t_o_m is instantiated to  an
    atom.


ccuurrrreenntt__bblloobb((_?_B_l_o_b_, _?_T_y_p_e))
    Examine the type or  enumerate blobs of the given _T_y_p_e.  Typed blobs
    are  supported through  the foreign language  interface for  storing
    arbitrary  BLOBs  (Binary  Large  Object)  or  handles  to  external
    entities.  See section ???? for details.


ccuurrrreenntt__ffuunnccttoorr((_?_N_a_m_e_, _?_A_r_i_t_y))
    True  when  _N_a_m_e/_A_r_i_t_y is  a known  functor.    This means  that  at
    some  point in time  a term with name  _N_a_m_e and _A_r_i_t_y arguments  was
    created.    Functor  objects are  currently not  subject to  garbage
    collection.   Due  to timing, t/2  below with instantiated _N_a_m_e  and
    _A_r_i_t_y  can theoretically  fail, i.e.,  a functor may  be visible  in
    instantiated  mode while  it  is not  yet visible  in unbound  mode.
    Considering  that the only  practical value of  current_functor/2 we
    are  aware of  is to analyse  resource usage  we accept this  impure
    behaviour.

    ____________________________________________________________________|                                                                    |
    | t(Name, Arity) :-                                                  |
    |     (   current_functor(Name, Arity)                               |
    |     ->  current_functor(N, A), N == Name, A == Arity               |

    |     ;   true                                                       |
    ||____).____________________________________________________________ ||


ccuurrrreenntt__ffllaagg((_-_F_l_a_g_K_e_y))
    Successively  unifies  _F_l_a_g_K_e_y with  all keys  used  for flags  (see
    flag/3).


ccuurrrreenntt__kkeeyy((_-_K_e_y))
    Successively  unifies  _K_e_y  with  all keys  used  for  records  (see
    recorda/3, etc.).


ccuurrrreenntt__pprreeddiiccaattee((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                             _[_I_S_O_]
    True  if _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r  is a  currently defined predicate.    A
    predicate  is  considered  defined if  it  exists in  the  specified
    module,  is  imported  into  the module  or  is defined  in  one  of
    the  modules from  which the  predicate will  be imported  if it  is
    called  (see  section  ????).    Note  that  current_predicate/1  does
    _n_o_t  succeed  for predicates  that  can be  _a_u_t_o_l_o_a_d_e_d.    See  also
    current_predicate/2 and predicate_property/2.

    If  _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r is  not fully specified,  the predicate  only
    generates  values  that  are defined  in  or already  imported  into
    the  target module.   Generating  all callable predicates  therefore
    requires  enumerating modules  using current_module/1.    Generating
    predicates   callable  in  a   given  module  requires   enumerating
    the  import  modules  using  import_module/2  and  the  autoloadable
    predicates using the predicate_property/2 autoload.


ccuurrrreenntt__pprreeddiiccaattee((_?_N_a_m_e_, _:_H_e_a_d))
    Classical  pre-ISO implementation of current_predicate/1, where  the
    predicate  is represented by the head  term.  The advantage is  that
    this  can be used for checking  the existence of a predicate  before
    calling it without the need for functor/3:

    ____________________________________________________________________|                                                                    |
    | call_if_exists(G) :-                                               |

    |         current_predicate(_, G),                                   |
    ||________call(G).__________________________________________________ ||

    Because  of this intended  usage, current_predicate/2 also  succeeds
    if  the predicate can  be autoloaded.   Unfortunately, checking  the
    autoloader  makes  this  predicate relatively  slow,  in  particular
    because a failed  lookup of the autoloader will cause the autoloader
    to verify that its index is up-to-date.


pprreeddiiccaattee__pprrooppeerrttyy((_:_H_e_a_d_, _?_P_r_o_p_e_r_t_y))
    True  when _H_e_a_d refers  to a predicate  that has property  _P_r_o_p_e_r_t_y.
    With  sufficiently  instantiated  _H_e_a_d,  predicate_property/2  tries
    to  resolve  the   predicate  the  same  way  as  calling  it  would
    do:    if  the  predicate  is  not  defined  it  scans  the  default
    modules  (see default_module/2)  and finally  tries the  autoloader.
    Unlike  calling,   failure  to  find  the  target  predicate  causes
    predicate_property/2 to fail silently.  If  _H_e_a_d is not sufficiently
    bound,   only  currently   locally  defined  and  already   imported
    predicates are  enumerated.  See current_predicate/1 for enumerating
    all  predicates.   A common issue  concerns _g_e_n_e_r_a_t_i_n_g all  built-in
    predicates.  This can be achieved using the code below:

    ____________________________________________________________________|                                                                    |
    | generate_built_in(Name/Arity) :-                                   |

    |     predicate_property(system:Head, built_in),                     |
    |     functor(Head, Name, Arity),                                    |
    ||____\+_sub_atom(Name,_0,__,__,_$).___%_discard_reserved_names_____ ||

    _P_r_o_p_e_r_t_y is one of:

    aauuttoollooaadd((_F_i_l_e))
         True if  the predicate can  be autoloaded  from the file  _F_i_l_e.
         Like undefined, this property is _n_o_t generated.

    bbuuiilltt__iinn
         True if the predicate is locked as a built-in predicate.   This
         implies it cannot be redefined in its definition  module and it
         can normally not be seen in the tracer.

    ddeeffiinneedd
         True if the  predicate is defined.   This property is aware  of
         sources being _r_e_l_o_a_d_e_d,  in which case it claims the  predicate
         defined only if it is defined in another source or  it has seen
         a definition in the current source.  See compile_aux_clauses/1.

    ddyynnaammiicc
         True  if assert/1  and  retract/1 may  be  used to  modify  the
         predicate.  This property is set using dynamic/1.

    eexxppoorrtteedd
         True if  the predicate  is in the  public list  of the  context
         module.

    iimmppoorrtteedd__ffrroomm((_M_o_d_u_l_e))
         Is true if  the predicate is  imported into the context  module
         from module _M_o_d_u_l_e.

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify  _F_i_l_e_N_a_m_e with  the  name of  the  source file  in  which
         the predicate  is  defined.    See also  source_file/2 and  the
         property line_count.   Note that this  reports the file of  the
         first clause of  a predicate.   A more robust interface can  be
         achieved using nth_clause/3 and clause_property/2.

    ffoorreeiiggnn
         True if the predicate is defined in the C language.

    iimmpplleemmeennttaattiioonn__mmoodduullee((_-_M_o_d_u_l_e))
         True when  _M_o_d_u_l_e is the  module in  which _H_e_a_d is  or will  be
         defined.  Resolving this property goes through  the same search
         mechanism as  when the an  undefined predicate is  encountered,
         but  does not  perform  any  loading.    It  searches  (1)  the
         module inheritence hierarchy (see default_module/2) and (2) the
         autoload index if  the unknown flag is  not set to fail in  the
         target module.

    iinnddeexxeedd((_I_n_d_e_x_e_s))
         _I_n_d_e_x_e_s  is  a  list  of  additional  (hash)   indexes  on  the
         predicate.  Each  element of the list is a  term _A_r_g_S_p_e_c-_I_n_d_e_x.
         _A_r_g_S_p_e_c denotes the indexed argument(s) and is one of

         ssiinnggllee((_A_r_g_u_m_e_n_t))
             Hash  on  a  single argument.    _A_r_g_u_m_e_n_t  is  the  1-based
             argument number.

         mmuullttii((_A_r_g_u_m_e_n_t_L_i_s_t))
             Hash on a combination of arguments.

         ddeeeepp((_P_o_s_i_t_i_o_n))
             Index on a sub-argument.   Position is a list holding first
             the  argument of the predicate  then the argument into  the
             compound and recursively into deeper compound terms.

         _I_n_d_e_x is  a term hash(_B_u_c_k_e_t_s_,  _S_p_e_e_d_u_p_, _S_i_z_e_,  _I_s_L_i_s_t).   Here
         _B_u_c_k_e_t_s is  the number of  buckets in the  hash and _S_p_e_e_d_u_p  is
         the expected speedup  relative to trying all clauses  linearly,
         _S_i_z_e is the size of  the index in memory in bytes  and finally,
         _I_s_L_i_s_t indicates that  a list is  created for all clauses  with
         the same  key.   This is used  to create  _d_e_e_p _i_n_d_e_x_e_s for  the
         arguments of compound terms.

    iinntteerrpprreetteedd
         True if  the predicate is defined  in Prolog.   We return  true
         on this because, although the code is actually  compiled, it is
         completely transparent, just like interpreted code.

    iissoo
         True if the predicate  is covered by the ISO  standard (ISO/IEC
         13211-1).

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify _L_i_n_e_N_u_m_b_e_r with  the line number  of the first clause  of
         the predicate.   Fails if the predicate is not  associated with
         a file.   See also source_file/2.   See also the file  property
         above, notably the reference to clause_property/2.

    mmuullttiiffiillee
         True if there may  be multiple (or no) files  providing clauses
         for the predicate.  This property is set using multifile/1.

    mmeettaa__pprreeddiiccaattee((_H_e_a_d))
         If  the  predicate  is  declared  as  a   meta-predicate  using
         meta_predicate/1,  unify  _H_e_a_d with  the  head-pattern.     The
         head-pattern  is  a  compound  term  with  the  same  name  and
         arity as  the predicate where  each argument of  the term is  a
         meta-predicate specifier.  See meta_predicate/1 for details.

    nnooddeebbuugg
         Details of the predicate are  not shown by the debugger.   This
         is the default  for built-in predicates.   User predicates  can
         be compiled this way using the Prolog flag generate_debug_info.

    nnoottrraaccee
         Do not show ports of this predicate in the debugger.

    nnuummbbeerr__ooff__ccllaauusseess((_C_l_a_u_s_e_C_o_u_n_t))
         Unify _C_l_a_u_s_e_C_o_u_n_t to the number of clauses  associated with the
         predicate.  Fails for foreign predicates.

    nnuummbbeerr__ooff__rruulleess((_R_u_l_e_C_o_u_n_t))
         Unify  _R_u_l_e_C_o_u_n_t  to the  number  of  clauses  associated  with
         the  predicate.   A  _r_u_l_e  is defined  as  a clauses  that  has
         a body  that  is not  just true  (i.e.,  a _f_a_c_t).    Fails  for
         foreign predicates.   This property is used to  avoid analysing
         predicates with only facts in prolog_codewalk.

    llaasstt__mmooddiiffiieedd__ggeenneerraattiioonn((_G_e_n_e_r_a_t_i_o_n))
         Database generation  at which  the predicate  was modified  for
         the last time.   Intended to  quickly assesses the validity  of
         caches.

    ppuubblliicc
         Predicate  is  declared public  using  public/1.     Note  that
         without further  definition, public  predicates are  considered
         undefined and this property is _n_o_t reported.

    qquuaassii__qquuoottaattiioonn__ssyynnttaaxx
         The  predicate (with  arity 4)  is  declared to  provide  quasi
         quotation syntax with quasi_quotation_syntax/1.

    ssttaattiicc
         The  definition  can  _n_o_t  be  modified  using   assertz/1  and
         friends.   This property  is the opposite  from dynamic,  i.e.,
         for each defined  predicate, either static  or dynamic is  true
         but never both.

    tthhrreeaadd__llooccaall
         If  true (only  possible  on  the multithreaded  version)  each
         thread has its  own clauses for the  predicate.  This  property
         is set using thread_local/1.

    ttrraannssppaarreenntt
         True  if  the  predicate  is  declared  transparent  using  the
         module_transparent/1 or meta_predicate/1 declaration.   In  the
         latter case the property meta_predicate(_H_e_a_d) is also provided.
         See chapter ???? for details.

    uunnddeeffiinneedd
         True if a procedure definition block for  the predicate exists,
         but  there are  no  clauses  for  it and  it  is  not  declared
         dynamic or  multifile.   This is true  if the predicate  occurs
         in the body  of a loaded predicate,  an attempt to call it  has
         been made via  one of the  meta-call predicates, the  predicate
         has been declared  as e.g., a  meta-predicate or the  predicate
         had  a definition  in  the  past.    Originally  used  to  find
         missing predicate definitions.   The current implementation  of
         list_undefined/0 used cross-referencing.  Deprecated.

    vviissiibbllee
         True when predicate can  be called without raising a  predicate
         existence  error.    This  means  that  the  predicate  is  (1)
         defined, (2) can be  inherited from one of the  default modules
         (see default_module/2) or (3) can be autoloaded.  The behaviour
         is logically  consistent iff the  property visible is  provided
         explicitly.   If  the property  is left  unbound, only  defined
         predicates are enumerated.

    vvoollaattiillee
         If true,  the  clauses are  not  saved into  a saved  state  by
         qsave_program/[1,2].  This property is set using volatile/1.


ddwwiimm__pprreeddiiccaattee((_+_T_e_r_m_, _-_D_w_i_m))
    `Do  What I  Mean'  (`dwim') support  predicate.   _T_e_r_m  is a  term,
    whose  name and arity are used  as a predicate specification.   _D_w_i_m
    is  instantiated with the most general term built from _N_a_m_e  and the
    arity  of a defined predicate  that matches the predicate  specified
    by  _T_e_r_m in the `Do  What I Mean' sense.   See dwim_match/2 for  `Do
    What  I Mean' string matching.   Internal system predicates are  not
    generated,  unless the  access level  is system  (see access_level).
    Backtracking provides all alternative matches.


ccllaauussee((_:_H_e_a_d_, _?_B_o_d_y))                                              _[_I_S_O_]
    True  if  _H_e_a_d can  be unified  with  a clause  head and  _B_o_d_y  with
    the  corresponding  clause  body.    Gives  alternative  clauses  on
    backtracking.  For facts, _B_o_d_y is unified with the atom _t_r_u_e.


ccllaauussee((_:_H_e_a_d_, _?_B_o_d_y_, _?_R_e_f_e_r_e_n_c_e))
    Equivalent  to  clause/2,   but  unifies  _R_e_f_e_r_e_n_c_e  with  a  unique
    reference to the  clause (see also assert/2, erase/1).  If _R_e_f_e_r_e_n_c_e
    is  instantiated to a reference the  clause's head and body will  be
    unified with _H_e_a_d and _B_o_d_y.


nntthh__ccllaauussee((_?_P_r_e_d_, _?_I_n_d_e_x_, _?_R_e_f_e_r_e_n_c_e))
    Provides  access to  the clauses  of a predicate  using their  index
    number.    Counting  starts at  1.   If  _R_e_f_e_r_e_n_c_e  is specified  it
    unifies  _P_r_e_d with the  most general term  with the same  name/arity
    as  the predicate  and _I_n_d_e_x with  the index  number of the  clause.
    Otherwise  the name  and arity  of _P_r_e_d  are used  to determine  the
    predicate.   If  _I_n_d_e_x is provided,  _R_e_f_e_r_e_n_c_e will be unified  with
    the  clause  reference.   If  _I_n_d_e_x  is unbound,  backtracking  will
    yield  both the  indexes and the  references of  all clauses of  the
    predicate.  The following example finds the 2nd clause of append/3:

    ____________________________________________________________________|                                                                    |
    | ?- use_module(library(lists)).                                     |

    | ...                                                                |
    | ?- nth_clause(append(_,_,_), 2, Ref), clause(Head, Body, Ref).     |
    | Ref = <clause>(0x994290),                                          |
    | Head = lists:append([_G23|_G24], _G21, [_G23|_G27]),               |
    ||Body_=_append(_G24,__G21,__G27).__________________________________ ||


ccllaauussee__pprrooppeerrttyy((_+_C_l_a_u_s_e_R_e_f_, _-_P_r_o_p_e_r_t_y))
    Queries  properties  of   a  clause.     _C_l_a_u_s_e_R_e_f  is  a  reference
    to   a   clause   as   produced   by   clause/3,   nth_clause/3   or
    prolog_frame_attribute/3.  Unlike most other predicates  that access
    clause references,  clause_property/2may be used  to get information
    about erased clauses that  have not yet been reclaimed.  _P_r_o_p_e_r_t_y is
    one of the following:

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify _F_i_l_e_N_a_m_e with the name of the file from  which the clause
         is loaded.   Fails if the clause  was not created by loading  a
         file (e.g., clauses added using assertz/1).  See also source.

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify _L_i_n_e_N_u_m_b_e_r with the line number of the clause.   Fails if
         the clause is not associated to a file.

    ssiizzee((_S_i_z_e_I_n_B_y_t_e_s))
         True when  _S_i_z_e_I_n_B_y_t_e_s  is the  size that  the  clause uses  in
         memory  in bytes.    The  size  required  by a  predicate  also
         includes the predicate data  record, a linked list of  clauses,
         clause  selection  instructions  and  optionally  one  or  more
         clause indexes.

    ssoouurrccee((_F_i_l_e_N_a_m_e))
         Unify _F_i_l_e_N_a_m_e with  the name of  the source file that  created
         the clause.   This  is the  same as the  file property,  unless
         the file  is  loaded from  a file  that  is textually  included
         into source  using include/1.   In this  scenario, file is  the
         included file,  while the  source property refers  to the  _m_a_i_n
         file.

    ffaacctt
         True if the clause has no body.

    eerraasseedd
         True if  the  clause has  been erased,  but  not yet  reclaimed
         because it is referenced.

    pprreeddiiccaattee((_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))
         _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r denotes the  predicate to which this  clause
         belongs.    This  is needed  to  obtain information  on  erased
         clauses because the usual way to obtain  this information using
         clause/3 fails for erased clauses.

    mmoodduullee((_M_o_d_u_l_e))
         _M_o_d_u_l_e is the  context module used to  execute the body of  the
         clause.   For normal clauses,  this is the  same as the  module
         in which  the  predicate is  defined.    However, if  a  clause
         is compiled with  a module qualified  _h_e_a_d, the clause  belongs
         to the  predicate with the  qualified head,  while the body  is
         executed in the context  of the module in which the  clause was
         defined.


44..1177 IInnppuutt aanndd oouuttppuutt

SWI-Prolog provides two  different packages for input  and output.   The
native  I/O system  is  based on  the  ISO standard  predicates  open/3,
close/1 and  friends.   Being more widely portable  and equipped with  a
clearer and  more robust specification,  new code  is encouraged to  use
these predicates for manipulation of I/O streams.

Section ????  describes tell/1, see/1  and friends,  providing I/O in  the
spirit of  the traditional  Edinburgh standard.    These predicates  are
layered  on  top of  the  ISO  predicates.    Both  packages  are  fully
integrated; the user may switch freely between them.


44..1177..11 PPrreeddeeffiinneedd ssttrreeaamm aalliiaasseess

Each  thread  has   five  stream  aliases:     user_input,   user_output,
user_error, current_input, and  current_output.   Newly created  threads
inherit  these  stream aliases  from  their  parent.    The  user_input,
user_output and  user_error aliases  of the  main  thread are  initially
bound to  the standard operating system  I/O streams (_s_t_d_i_n, _s_t_d_o_u_t  and
_s_t_d_e_r_r, normally  bound to the POSIX  file handles 0, 1  and 2).   These
aliases may be re-bound, for example if standard I/O  refers to a window
such as in  the swipl-win.exe GUI executable for  Windows.  They can  be
re-bound by  the user using set_prolog_IO/3 and set_stream/2 by  setting
the  alias of  a stream  (e.g,  set_stream(S, alias(user_output))).    An
example of  rebinding can be  found in library  prolog_server,  providing
a telnet service.   The aliases  current_input  and current_output  define
the source  and destination  for predicates  that do not  take a  stream
argument (e.g.,  read/1, write/1,  get_code/1, ...).   Initially,  these
are  bound to  the  same stream  as  user_input and  user_error.    They
are  re-bound by  see/1,  tell/1,  set_input/1 and  set_output/1.    The
current_output stream  is  also temporary  re-bound  by with_output_to/2
or  format/3 using  e.g., format(atom(A), ....    Note  that code  which
explicitly writes to the streams  user_output and  user_error will  not be
redirected by with_output_to/2.

CCoommppaattiibbiilliittyy Note  that  the  ISO  standard  only  defines  the  user_*
streams.   The `current' streams  can be accessed  using current_input/1
and current_output/1.  For example, an ISO compatible  implementation of
write/1 is

________________________________________________________________________|                                                                        |
|write(Term)|:-_current_output(Out),_write_term(Out,_Term)._____________ |           |

while SWI-Prolog additionally allows for

________________________________________________________________________|                                                                        |

|write(Term)|:-_write(current_output,_Term).____________________________ |           |


44..1177..22 IISSOO IInnppuutt aanndd OOuuttppuutt SSttrreeaammss

The  predicates described  in this  section provide  ISO compliant  I/O,
where streams are  explicitly created using the  predicate open/3.   The
resulting  stream  identifier is  then  passed  as a  parameter  to  the
reading and writing  predicates to specify the source or  destination of
the data.

This schema  is not  vulnerable to  filename and  stream ambiguities  as
well as changes to the working directory.  On the  other hand, using the
notion of  current-I/O simplifies reusability of  code without the  need
to pass arguments around.  E.g., see with_output_to/2.

SWI-Prolog streams are,  compatible with the ISO standard,  either input
or output streams.  To accommodate portability to  other systems, a pair
of streams  can be  packed into a  _s_t_r_e_a_m_-_p_a_i_r.   See  stream_pair/3 for
details.

SWI-Prolog stream  handles are unique symbols  that have no  syntactical
representation.  They are written as <stream>(hex-number),  which is not
valid input for read/1.   They are realised using a _b_l_o_b of  type stream
(see blob/2 and section ????).


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _-_-_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))                         _[_I_S_O_]
    True  when  _S_r_c_D_e_s_t can  be opened  in  _M_o_d_e and  _S_t_r_e_a_m is  an  I/O
    stream  to/from the  object.    _S_r_c_D_e_s_t is  normally the  name of  a
    file,  represented as  an atom  or string.    _M_o_d_e is  one of  read,
    write,  append or update.   Mode append opens the file  for writing,
    positioning  the file pointer  at the  end.   Mode update opens  the
    file  for writing, positioning the file pointer at the  beginning of
    the file without truncating  the file.  _S_t_r_e_a_m is either a variable,
    in  which case it is bound to an integer identifying the  stream, or
    an atom, in which case this atom will be the stream identifier.

    SWI-Prolog  also allows  _S_r_c_D_e_s_t to  be a  term pipe(_C_o_m_m_a_n_d).    In
    this  form, _C_o_m_m_a_n_d  is started as  a child process  and if _M_o_d_e  is
    write,  output written to  _S_t_r_e_a_m is sent  to the standard input  of
    _C_o_m_m_a_n_d.   Viso versa, if _M_o_d_e  is read, data written by  _C_o_m_m_a_n_d to
    the  standard output  may be  read from _S_t_r_e_a_m.    On Unix  systems,
    _C_o_m_m_a_n_d  is handed to popen() which hands it to the Unix shell.   On
    Windows,  _C_o_m_m_a_n_d is executed  directly.  See  also process_create/3
    from process.

    If  _S_r_c_D_e_s_t is an _I_R_I, i.e., starts with  <_s_c_h_e_m_e>://, where <_s_c_h_e_m_e>
    is  a non-empty sequence of  lowercase ASCII letters open/3,4  calls
    hooks  registered  by  register_iri_scheme/3.    Currently  the  only
    predefined  IRI  scheme is  res, providing  access  to the  _r_e_s_o_u_r_c_e
    _d_a_t_a_b_a_s_e.  See section ????.

    The following _O_p_t_i_o_n_s are recognised by open/4:

    aalliiaass((_A_t_o_m))
         Gives the  stream a name.   Below  is an example.   Be  careful
         with  this option  as  stream  names  are global.     See  also
         set_stream/2.

         _______________________________________________________________|                                                               |
         |?- open(data, read, Fd, [alias(input)]).                       |

         |                                                               |
         |        ...,                                                   |
         |        read(input, Term),                                     |
         ||_______...___________________________________________________ ||

    bboomm((_B_o_o_l))
         Check for a BOM (_B_y_t_e _O_r_d_e_r _M_a_r_k_e_r) or write one.   If omitted,
         the default  is true for  mode read and  false for mode  write.
         See  also stream_property/2 and  especially  section ????  for  a
         discussion of this feature.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         Defines output  buffering.    The atom  full (default)  defines
         full buffering, line buffering  by line, and false implies  the
         stream is  fully unbuffered.   Smaller  buffering is useful  if
         another process or the user is waiting for the output  as it is
         being produced.   See also flush_output/[0,1].  This option  is
         not an ISO option.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         If  true (default),  the  stream is  closed  on an  abort  (see
         abort/0).   If  false, the  stream is  not closed.    If it  is
         an output  stream, however,  it will  be flushed.   Useful  for
         logfiles and if  the stream is  associated to a process  (using
         the pipe/1 construct).

    ccrreeaattee((_+_L_i_s_t))
         Specifies how  a new  file is  created when  opening in  write,
         append or  update mode.   Currently,  _L_i_s_t is  a list of  atoms
         that describe  the permissions of  the created  file.   Defined
         values are below.  Not recognised values  are silently ignored,
         allowing for adding platform specific extensions to this set.

         rreeaadd
             Allow read access to the file.

         wwrriittee
             Allow write access to the file.

         eexxeeccuuttee
             Allow execution access to the file.

         ddeeffaauulltt
             Allow read and write access to the file.

         aallll
             Allow any access provided by the OS.

         Note that if _L_i_s_t is empty, the created file  has no associated
         access permissions.   The create options map to the  POSIX _m_o_d_e
         option of  open(), where read  map to 0444,  write to 0222  and
         execute to  0111.   On POSIX systems,  the final permission  is
         defined as (mode & ~umask).

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Define the encoding used  for reading and writing text  to this
         stream.   The default  encoding for type  text is derived  from
         the Prolog  flag  encoding.   For  binary  streams the  default
         encoding  is octet.     For details  on  encoding  issues,  see
         section ????.

    eeooff__aaccttiioonn((_A_c_t_i_o_n))
         Defines  what  happens  if the  end  of  the  input  stream  is
         reached.  The default value for Action is eof_code, which makes
         get0/1 and  friends return  -1, and read/1  and friends  return
         the atom  end_of_file.   Repetitive  reading keeps yielding  the
         same result.   Action  error is  like eof_code, but  repetitive
         reading will raise  an error.   With action reset, Prolog  will
         examine the  file again and  return more data  if the file  has
         grown.

    llooccaallee((_+_L_o_c_a_l_e))
         Set the locale that  is used by notably format/2 for  output on
         this stream.  See section ????.

    lloocckk((_L_o_c_k_i_n_g_M_o_d_e))
         Try to obtain a lock on the open file.  Default  is none, which
         does not lock the file.   The value read or shared  means other
         processes may  read the  file, but  not write  it.   The  value
         write or  exclusive means no  other process  may read or  write
         the file.

         Locks are  acquired through  the POSIX  function fcntl()  using
         the command F_SETLKW, which makes  a blocked call wait for  the
         lock to  be  released.    Please note  that fcntl()  locks  are
         _a_d_v_i_s_o_r_y and therefore  only other applications using the  same
         advisory locks  honour your  lock.   As there  are many  issues
         around locking  in  Unix, especially  related  to NFS  (network
         file  system), please  study  the  fcntl() manual  page  before
         trusting your locks!

         The lock option is a SWI-Prolog extension.

    ttyyppee((_T_y_p_e))
         Using type text (default), Prolog will write a text  file in an
         operating system compatible way.   Using type binary  the bytes
         will be read or written without any translation.   See also the
         option encoding.

    wwaaiitt((_B_o_o_l))
         This option  can be combined with  the lock option.   If  false
         (default  true), the  open  call  returns immediately  with  an
         exception if the file is locked.  The exception  has the format
         permission_error(_l_o_c_k_, _s_o_u_r_c_e___s_i_n_k_, _S_r_c_D_e_s_t).

    The  option reposition is not supported in SWI-Prolog.   All streams
    connected to a file may be repositioned.


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _-_-_S_t_r_e_a_m))                                   _[_I_S_O_]
    Equivalent to open/4 with an empty option list.


ooppeenn__nnuullll__ssttrreeaamm((_-_-_S_t_r_e_a_m))
    Open  an  output stream  that  produces no  output.    All  counting
    functions  are enabled on such a stream.  It can be  used to discard
    output  (like Unix  /dev/null) or exploit  the counting  properties.
    The  initial encoding of _S_t_r_e_a_m is utf8, enabling  arbitrary Unicode
    output.    The  encoding can  be changed  to  determine byte  counts
    of  the output  in a particular  encoding or  validate if output  is
    possible  in a  particular encoding.   For example,  the code  below
    determines the number of characters emitted when writing _T_e_r_m.

    ____________________________________________________________________|                                                                    |
    | write_length(Term, Len) :-                                         |

    |         open_null_stream(Out),                                     |
    |         write(Out, Term),                                          |
    |         character_count(Out, Len0),                                |
    |         close(Out),                                                |
    ||________Len_=_Len0._______________________________________________ ||


cclloossee((_+_S_t_r_e_a_m))                                                    _[_I_S_O_]
    Close  the specified stream.   If _S_t_r_e_a_m  is not open, an  existence
    error is  raised.  See stream_pair/3for  the implications of closing
    a _s_t_r_e_a_m _p_a_i_r.

    If  the closed stream is the current input, output or  error stream,
    the  stream alias is  bound to the  initial standard I/O streams  of
    the  process.  Calling close/1  on the initial standard I/O  streams
    of the process is  a no-op for an input stream and flushes an output
    stream without closing it.


cclloossee((_+_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))                                          _[_I_S_O_]
    Provides  close(_S_t_r_e_a_m_, _[_f_o_r_c_e_(_t_r_u_e_)_]) as the  only option.   Called
    this  way, any resource errors (such as write errors  while flushing
    the output buffer) are ignored.


ssttrreeaamm__pprrooppeerrttyy((_?_S_t_r_e_a_m_, _?_S_t_r_e_a_m_P_r_o_p_e_r_t_y))                          _[_I_S_O_]
    True  when _S_t_r_e_a_m_P_r_o_p_e_r_t_y is a property  of _S_t_r_e_a_m.  If  enumeration
    of   streams  or  properties  is  demanded  because   either  _S_t_r_e_a_m
    or   _S_t_r_e_a_m_P_r_o_p_e_r_t_y  are  unbound,  the   implementation  enumerates
    all  candidate  streams  and  properties while  locking  the  stream
    database.   Properties  are fetched without  locking the stream  and
    may  be outdated before this  predicate returns due to  asynchronous
    activity.

    aalliiaass((_A_t_o_m))
         If _A_t_o_m is bound,  test if the stream has the  specified alias.
         Otherwise unify _A_t_o_m with the first alias of the stream.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         SWI-Prolog  extension  to query  the  buffering  mode  of  this
         stream.   _B_u_f_f_e_r_i_n_g is one of  full, line or  false.  See  also
         open/4.

    bbuuffffeerr__ssiizzee((_I_n_t_e_g_e_r))
         SWI-Prolog  extension to  query  the  size of  the  I/O  buffer
         associated to a  stream in bytes.   Fails if the stream is  not
         buffered.

    bboomm((_B_o_o_l))
         If present  and  true, a  BOM (_B_y_t_e  _O_r_d_e_r  _M_a_r_k) was  detected
         while opening the file for reading, or a BOM  was written while
         opening the stream.  See section ???? for details.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         Determine  whether or  not  abort/0  closes  the stream.     By
         default streams are closed.

    cclloossee__oonn__eexxeecc((_B_o_o_l))
         Determine whether or  not the stream  is closed when  executing
         a new  process (exec()  in Unix,  CreateProcess() in  Windows).
         Default  is  to   close  streams.      This  maps  to   fcntl()
         F_SETFD  using  the  flag  FD_CLOEXEC   on  Unix  and  (negated)
         HANDLE_FLAG_INHERIT on Windows.

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Query the  encoding  used for  text.   See  section  ???? for  an
         overview of wide character and encoding issues in SWI-Prolog.

    eenndd__ooff__ssttrreeaamm((_E))
         If _S_t_r_e_a_m is  an input stream,  unify _E with  one of the  atoms
         not, at or past.  See also at_end_of_stream/[0,1].

    eeooff__aaccttiioonn((_A))
         Unify _A with one of  eof_code,  reset or error.  See  open/4 for
         details.

    ffiillee__nnaammee((_A_t_o_m))
         If _S_t_r_e_a_m is  associated to a file,  unify _A_t_o_m to the name  of
         this file.

    ffiillee__nnoo((_I_n_t_e_g_e_r))
         If  the stream  is associated  with  a POSIX  file  descriptor,
         unify  _I_n_t_e_g_e_r  with   the  descriptor  number.      SWI-Prolog
         extension used  primarily  for integration  with foreign  code.
         See also Sfileno() from SWI-Stream.h.

    iinnppuutt
         True if _S_t_r_e_a_m has mode read.

    llooccaallee((_L_o_c_a_l_e))
         True when  _L_o_c_a_l_e is  the  current locale  associated with  the
         stream.  See section ????.

    mmooddee((_I_O_M_o_d_e))
         Unify  _I_O_M_o_d_e to  the  mode given  to  open/4 for  opening  the
         stream.   Values are:  read,  write, append and the  SWI-Prolog
         extension update.

    nneewwlliinnee((_N_e_w_l_i_n_e_M_o_d_e))
         One of posix or dos.   If dos, text streams will emit  \r\n for
         \n and discard \r from  input streams.  Default depends  on the
         operating system.

    nnlliinnkk((_-_C_o_u_n_t))
         Number of hard  links to the file.   This expresses the  number
         of `names'  the  file has.    Not  supported on  all  operating
         systems and the  value might be bogus.   See the  documentation
         of fstat() for your OS and the value st_nlink.

    oouuttppuutt
         True if _S_t_r_e_a_m has mode write, append or update.

    ppoossiittiioonn((_P_o_s))
         Unify  _P_o_s  with  the  current  stream  position.     A  stream
         position is an opaque term whose fields can  be extracted using
         stream_position_data/3.  See also set_stream_position/2.

    rreeppoossiittiioonn((_B_o_o_l))
         Unify _B_o_o_l with _t_r_u_e if  the position of the stream can  be set
         (see seek/4).   It is  assumed the position  can be set if  the
         stream has  a _s_e_e_k_-_f_u_n_c_t_i_o_n and  is not based  on a POSIX  file
         descriptor that is not associated to a regular file.

    rreepprreesseennttaattiioonn__eerrrroorrss((_M_o_d_e))
         Determines behaviour of  character output if the stream  cannot
         represent a  character.   For  example, an  ISO Latin-1  stream
         cannot represent  Cyrillic characters.   The  behaviour is  one
         of error (throw  an I/O error  exception), prolog (write  \...\
         escape code) or xml  (write &#...; XML character entity).   The
         initial mode is prolog  for the user streams and error  for all
         other streams.  See also section ???? and set_stream/2.

    ttiimmeeoouutt((_-_T_i_m_e))
         _T_i_m_e is the timeout currently associated with the stream.   See
         set_stream/2 with the same option.  If no timeout is specified,
         _T_i_m_e is unified to the atom infinite.

    ttyyppee((_T_y_p_e))
         Unify _T_y_p_e with text or binary.

    ttttyy((_B_o_o_l))
         This  property is  reported  with _B_o_o_l  equal  to true  if  the
         stream is associated with a terminal.  See also set_stream/2.

    wwrriittee__eerrrroorrss((_A_t_o_m))
         _A_t_o_m is  one  of error  (default) or  ignore.    The latter  is
         intended to deal with service processes for  which the standard
         output handles are  not connected to valid  streams.  In  these
         cases write errors may be ignored on user_error.


ccuurrrreenntt__ssttrreeaamm((_?_O_b_j_e_c_t_, _?_M_o_d_e_, _?_S_t_r_e_a_m))
    The  predicate current_stream/3 is  used to access  the status of  a
    stream  as well  as to generate  all open  streams.   _O_b_j_e_c_t is  the
    name  of the file opened  if the stream refers  to an open file,  an
    integer  file descriptor  if  the stream  encapsulates an  operating
    system  stream, or the  atom [] if the  stream refers to some  other
    object.  _M_o_d_e is one of read or write.


iiss__ssttrreeaamm((_+_T_e_r_m))
    True  if  _T_e_r_m is  a  stream name  or  valid stream  handle.    This
    predicate  realises a safe test for the existence of a  stream alias
    or handle.


ssttrreeaamm__ppaaiirr((_?_S_t_r_e_a_m_P_a_i_r_, _?_R_e_a_d_, _?_W_r_i_t_e))
    This  predicate can be used in mode (-,+,+) to create  a _s_t_r_e_a_m_-_p_a_i_r
    from  an input stream  and an output  stream.   Mode (+,-,-) can  be
    used  to get  access to the  underlying streams.   If  a stream  has
    already  been closed,  the corresponding  argument is left  unbound.
    If mode (+,-,-) is  used on a single stream, either _R_e_a_d or _W_r_i_t_e is
    unified  with the stream while  the other argument is left  unbound.
    This  behaviour simplifies  writing code that  must operate both  on
    streams and stream pairs.

    Stream-pairs  can be used  by all I/O  operations on streams,  where
    the  operation selects  the appropriate  member of  the pair.    The
    predicate  close/1 closes the still open  streams of the pair.   The
    output  stream  is closed  before  the input  stream.    If  closing
    the  output stream results  in an error,  the input stream is  still
    closed.    Success  is only  returned if  both  streams were  closed
    successfully.


sseett__ssttrreeaamm__ppoossiittiioonn((_+_S_t_r_e_a_m_, _+_P_o_s))                                 _[_I_S_O_]
    Set  the current  position  of _S_t_r_e_a_m  to _P_o_s.    _P_o_s is  a term  as
    returned  by  stream_property/2 using  the  position(_P_o_s)  property.
    See also seek/4.


ssttrreeaamm__ppoossiittiioonn__ddaattaa((_?_F_i_e_l_d_, _+_P_o_s_, _-_D_a_t_a))
    Extracts  information from  the opaque stream  position term as  re-
    turned  by stream_property/2 requesting the position(_P_o_s)  property.
    _F_i_e_l_d is  one of line_count, line_position, char_count or byte_count.
    See   also  line_count/2,  line_position/2,   character_count/2  and
    byte_count/2.


sseeeekk((_+_S_t_r_e_a_m_, _+_O_f_f_s_e_t_, _+_M_e_t_h_o_d_, _-_N_e_w_L_o_c_a_t_i_o_n))
    Reposition the current point  of the given _S_t_r_e_a_m.  _M_e_t_h_o_d is one of
    bof,  current or eof, indicating positioning relative to  the start,
    current  point or  end of  the underlying  object.   _N_e_w_L_o_c_a_t_i_o_n  is
    unified with the new offset, relative to the start of the stream.

    Positions  are  counted in  `units'.    A  unit is  1  byte,  except
    for  text files  using 2-byte  Unicode encoding (2  bytes) or  _w_c_h_a_r
    encoding  (sizeof(wchar_t)).    The  latter  guarantees  comfortable
    interaction  with  wide-character  text objects.     Otherwise,  the
    use  of  seek/4  on non-binary  files  (see  open/4) is  of  limited
    use,  especially when using  multi-byte text encodings (e.g.  UTF-8)
    or   multi-byte  newline  files  (e.g.   DOS/Windows).     On   text
    files,   SWI-Prolog  offers  reliable  backup  to  an  old  position
    using  stream_property/2  and set_stream_position/2.    Skipping  N
    character  codes is  achieved calling  get_code/2 N times  or using
    copy_stream_data/3,  directing the  output  to  a null  stream  (see
    open_null_stream/1).   If  the seek modifies  the current  location,
    the line number and character position in the line are set to 0.

    If the  stream cannot be repositioned, a permission_error is raised.
    If  applying  the  offset  would  result in  a  file  position  less
    than  zero, a  domain_error  is raised.   Behaviour  when seeking  to
    positions  beyond the size  of the underlying  object depend on  the
    object  and possibly  the operating  system.   The predicate  seek/4
    is  compatible  with Quintus  Prolog,  though the  error  conditions
    and  signalling is ISO  compliant.   See also  stream_property/2 and
    set_stream_position/2.


sseett__ssttrreeaamm((_+_S_t_r_e_a_m_, _+_A_t_t_r_i_b_u_t_e))
    Modify  an attribute  of an  existing stream.   _A_t_t_r_i_b_u_t_e  specifies
    the   stream  property  to  set.      If  stream  is  a  _p_a_i_r   (see
    stream_pair/3)  both streams are  modified, unless  the property  is
    only  meaningful  on one  of  the streams  or  setting both  is  not
    meaningful.    In particular,  eof_action  only applies  to the  _r_e_a_d
    stream,  representation_errors  only  applies to  the  _w_r_i_t_e  stream
    and  trying to  set alias or  line_position  on a  pair results in  a
    permission_error exception.  See also stream_property/2 and open/4.

    aalliiaass((_A_l_i_a_s_N_a_m_e))
         Set the  alias of  an  already created  stream.   If  _A_l_i_a_s_N_a_m_e
         is  the name  of  one  of the  standard  streams,  this  stream
         is rebound.    Thus,  set_stream(S, current_input) is the  same
         as  set_input/1,  and  by  setting  the  alias of  a  stream  to
         user_input, etc.,  all user  terminal input is  read from  this
         stream.  See also interactor/0.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         Set the buffering mode  of an already created stream.   Buffer-
         ing is one of full, line or false.

    bbuuffffeerr__ssiizzee((_+_S_i_z_e))
         Set the  size of  the I/O buffer  of the  underlying stream  to
         _S_i_z_e bytes.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         Determine whether or not the  stream is closed by abort/0.   By
         default, streams are closed.

    cclloossee__oonn__eexxeecc((_B_o_o_l))
         Set the close_on_exec property.  See stream_property/2.

    eennccooddiinngg((_A_t_o_m))
         Defines the mapping between bytes and character  codes used for
         the stream.    See section  ???? for  supported encodings.    The
         value  bom causes  the  stream  to check  whether  the  current
         character  is a  Unicode  BOM  marker.    If a  BOM  marker  is
         found, the encoding  is set accordingly and the call  succeeds.
         Otherwise the call fails.

    eeooff__aaccttiioonn((_A_c_t_i_o_n))
         Set end-of-file handling to one of eof_code, reset or error.

    ffiillee__nnaammee((_F_i_l_e_N_a_m_e))
         Set the filename associated to  this stream.  This call  can be
         used to set the file for error locations  if _S_t_r_e_a_m corresponds
         to _F_i_l_e_N_a_m_e and  is not obtained  by opening the file  directly
         but, for example, through a network service.

    lliinnee__ppoossiittiioonn((_L_i_n_e_P_o_s))
         Set the line  position attribute of the  stream.  This  feature
         is  intended  to correct  position  management  of  the  stream
         after sending  a terminal escape  sequence (e.g., setting  ANSI
         character  attributes).     Setting  this  attribute  raises  a
         permission error if the stream does not record positions.   See
         line_position/2 and stream_property/2(property position).

    llooccaallee((_+_L_o_c_a_l_e))
         Change the locale of the stream.  See section ????.

    nneewwlliinnee((_N_e_w_l_i_n_e_M_o_d_e))
         Set input or output translation for newlines.   See correspond-
         ing stream_property/2 for details.  In addition to the detected
         modes, an input stream can  be set in mode detect.  It  will be
         set to dos if a \r character was removed.

    ttiimmeeoouutt((_S_e_c_o_n_d_s))
         This option can be  used to make streams generate  an exception
         if it  takes longer than  _S_e_c_o_n_d_s before  any new data  arrives
         at  the  stream.    The  value  _i_n_f_i_n_i_t_e  (default)  makes  the
         stream block  indefinitely.   Like wait_for_input/3, this  call
         only  applies  to streams  that  support  the  select()  system
         call.   For  further information  about  timeout handling,  see
         wait_for_input/3.  The exception is of the form

             error(timeout_error_(_r_e_a_d_, _S_t_r_e_a_m_)_, __)

    ttyyppee((_T_y_p_e))
         Set the type of the stream to one of text or binary.   See also
         open/4 and  the encoding  property of  streams.   Switching  to
         binary sets the encoding to octet.  Switching to  text sets the
         encoding to the default text encoding.

    rreeccoorrdd__ppoossiittiioonn((_B_o_o_l))
         Do/do   not   record   the   line   count   and    line   posi-
         tion  (see   line_count/2  and   line_position/2).       Calling
         set_stream(S, record_position(true)) resets  the  position  the
         start of line 1.

    rreepprreesseennttaattiioonn__eerrrroorrss((_M_o_d_e))
         Change the  behaviour  when writing  characters to  the  stream
         that  cannot  be  represented  by  the  encoding.     See  also
         stream_property/2 and section ????.

    ttttyy((_B_o_o_l))
         Modify whether Prolog  thinks there is  a terminal (i.e.  human
         interaction) connected  to this stream.    On Unix systems  the
         initial value  comes from isatty().   On  Windows, the  initial
         user streams are supposed to be associated to a terminal.   See
         also stream_property/2.


sseett__pprroolloogg__IIOO((_+_I_n_, _+_O_u_t_, _+_E_r_r_o_r))
    Prepare  the   given  streams  for  interactive  behaviour  normally
    associated  to  the  terminal.     _I_n  becomes  the  user_input  and
    current_input  of  the calling  thread.    _O_u_t  becomes  user_output
    and  current_output.    If _E_r_r_o_r  equals  _O_u_t an  unbuffered  stream
    is  associated to  the same  destination and  linked to  user_error.
    Otherwise  _E_r_r_o_r is used for  user_error.   Output buffering for  _O_u_t
    is  set  to line  and buffering  on _E_r_r_o_r  is disabled.    See  also
    prolog/0  and set_stream/2.  The  _c_l_i_b package provides the  library
    prolog_server, creating a TCP/IP server for  creating an interactive
    session to Prolog.


44..1177..33 EEddiinnbbuurrgghh--ssttyyllee II//OO

The  package for  implicit  input and  output destinations  is  (almost)
compatible with Edinburgh DEC-10 and C-Prolog.  The  reading and writing
predicates  refer to,  resp.,  the  _c_u_r_r_e_n_t  input and  output  streams.
Initially these  streams are  connected to  the terminal.   The  current
output stream is  changed using tell/1 or  append/1.  The current  input
stream  is changed  using see/1.    The stream's  current  value can  be
obtained using telling/1 for output and seeing/1 for input.

Source  and   destination  are   either  a  file,   user,   or  a   term
`pipe(_C_o_m_m_a_n_d)'.  The reserved stream name user refers  to the terminal.
In the predicate descriptions below we will  call the source/destination
argument  `_S_r_c_D_e_s_t'.    Below are  some examples  of  source/destination
specifications.

         ?- see(data).        % Start reading from file `data'.
         ?- tell(user).       % Start writing to the terminal.
         ?- tell(pipe(lpr)).  % Start writing to the printer.

Another example  of using  the pipe/1 construct  is shown  below.   Note
that  the  pipe/1  construct  is  not  part  of  Prolog's  standard  I/O
repertoire.

________________________________________________________________________|                                                                        |
|getwd(Wd) :-                                                            |
|        seeing(Old), see(pipe(pwd)),                                    |

|        collect_wd(String),                                             |
|        seen, see(Old),                                                 |
|        atom_codes(Wd, String).                                         |
|                                                                        |
|collect_wd([C|R]) :-                                                    |
|        get0(C), C \== -1, !,                                           |
|        collect_wd(R).                                                  |

|collect_wd([]).|_______________________________________________________ |               |

The  effect of  tell/1 is  not  undone on  backtracking, and  since  the
stream  handle is  not specified  explicitly in  further I/O  operations
when  using Edinburgh-style  I/O, you  may write  to unintended  streams
more  easily  than  when using  ISO  compliant  I/O.  For  example,  the
following query writes both "a" and "b" into the file `out' :

________________________________________________________________________|                                                                        |
|?-|(tell(out),_write(a),_false_;_write(b)),_told.______________________ |  |


CCoommppaattiibbiilliittyy nnootteess

Unlike Edinburgh  Prolog systems, telling/1  and seeing/1 do not  return
the  filename  of  the  current  input/output  but   rather  the  stream
identifier,  to  ensure  the  design  pattern   below  works  under  all
circumstances:

________________________________________________________________________|                                                                        |
|        ...,                                                            |
|        telling(Old), tell(x),                                          |
|        ...,                                                            |

|        told, tell(Old),                                                |
||_______...,___________________________________________________________ ||

The predicates tell/1 and see/1 first check for  user, the pipe(_c_o_m_m_a_n_d)
and a stream handle.  Otherwise, if the argument is  an atom it is first
compared to  open streams  associated to  a file with  _e_x_a_c_t_l_y the  same
name.   If such a stream exists,  created using tell/1 or see/1,  output
(input) is  switched to  the open  stream.   Otherwise a  file with  the
specified name is opened.

The behaviour is compatible with Edinburgh Prolog.   This is not without
problems.   Changing  directory,  non-file streams,  and multiple  names
referring to  the same file  easily lead to unexpected  behaviour.   New
code, especially  when managing multiple  I/O channels, should  consider
using the ISO I/O predicates defined in section ????.


sseeee((_+_S_r_c_D_e_s_t))
    Open  _S_r_c_D_e_s_t  for  reading  and  make it  the  current  input  (see
    set_input/1).  If _S_r_c_D_e_s_t is a stream  handle, just make this stream
    the current input.  See the introduction of section ???? for details.


tteellll((_+_S_r_c_D_e_s_t))
    Open  _S_r_c_D_e_s_t  for  writing and  make  it  the current  output  (see
    set_output/1).    If _S_r_c_D_e_s_t  is  a stream  handle,  just make  this
    stream  the current output.  See the introduction of section  ???? for
    details.


aappppeenndd((_+_F_i_l_e))
    Similar  to tell/1,  but positions the  file pointer  at the end  of
    _F_i_l_e  rather than truncating an existing  file.  The pipe  construct
    is not accepted by this predicate.


sseeeeiinngg((_?_S_r_c_D_e_s_t))
    Same  as  current_input/1,  except  that user  is  returned  if  the
    current  input  is the  stream user_input  to improve  compatibility
    with  traditional Edinburgh I/O. See the introduction of  section ????
    for details.


tteelllliinngg((_?_S_r_c_D_e_s_t))
    Same  as  current_output/1, except  that  user  is returned  if  the
    current  output is the  stream user_output to improve  compatibility
    with  traditional Edinburgh I/O. See the introduction of  section ????
    for details.


sseeeenn
    Close  the  current input  stream.   The  new  input stream  becomes
    user_input.


ttoolldd
    Close  the current  output stream.   The  new output stream  becomes
    user_output.


44..1177..44 SSwwiittcchhiinngg bbeettwweeeenn EEddiinnbbuurrgghh aanndd IISSOO II//OO

The predicates below can be used for switching between  the implicit and
the explicit stream-based I/O predicates.


sseett__iinnppuutt((_+_S_t_r_e_a_m))                                                 _[_I_S_O_]
    Set   the  current   input  stream   to  become  _S_t_r_e_a_m.       Thus,
    open(file, read, Stream), set_input(Stream)    is   equivalent    to
    see(file).


sseett__oouuttppuutt((_+_S_t_r_e_a_m))                                                _[_I_S_O_]
    Set  the  current  output  stream  to  become  _S_t_r_e_a_m.     See  also
    with_output_to/2.


ccuurrrreenntt__iinnppuutt((_-_S_t_r_e_a_m))                                             _[_I_S_O_]
    Get  the current input  stream.   Useful for  getting access to  the
    status predicates associated with streams.


ccuurrrreenntt__oouuttppuutt((_-_S_t_r_e_a_m))                                            _[_I_S_O_]
    Get the current output stream.


44..1177..55 AAddddiinngg IIRRII sscchheemmaass

The  file handling  predicates may  be _h_o_o_k_e_d  to deal  with _I_R_I_s.    An
IRI  starts with  <_s_c_h_e_m_e>://,  where <_s_c_h_e_m_e>  is  a non-empty  sequence
of  lowercase   ASCII  letters.      After  detecting  the  scheme   the
file  manipulation predicates  call  a  hook that  is  registered  using
register_iri_scheme/3.

Hooking the  file operations using extensible  IRI schemas allows us  to
place any  resource that is  accessed through  Prolog I/O predicates  on
arbitrary devices such as  web servers or the ZIP archive used  to store
program resources  (see section ????).   This  is typically combined  with
file_search_path/2 declarations  to switch  between accessing  a set  of
resources from local files,  from the program resource database,  from a
web-server, etc.


rreeggiisstteerr__iirrii__sscchheemmee(())
    +Scheme,  :Hook, +Options  Register _H_o_o_k  to be called  by all  file
    handling  predicates  if  a  name  that  starts  with  _S_c_h_e_m_e://  is
    encountered.    The _H_o_o_k is  called by  call/4 using the  _o_p_e_r_a_t_i_o_n,
    the  _I_R_I and a term that receives the _r_e_s_u_l_t of the operation.   The
    following operations are defined:

    ooppeenn((_M_o_d_e_,_O_p_t_i_o_n_s))
         Called by open/3,4.   The result argument must be  unified with
         a stream.

    aacccceessss((_M_o_d_e))
         Called  by  access_file/2,  exists_file/1  (_M_o_d_e  is  file)  and
         exists_directory/1 (_M_o_d_e is  directory).   The result  argument
         must be unified with a boolean.

    ttiimmee
         Called by time_file/2.  The result must be unified  with a time
         stamp.

    ssiizzee
         Called by  size_file/2.   The result  must be  unified with  an
         integer representing the size in bytes.


44..1177..66 WWrriittee oonnttoo aattoommss,, ccooddee--lliissttss,, eettcc..


wwiitthh__oouuttppuutt__ttoo((_+_O_u_t_p_u_t_, _:_G_o_a_l))
    Run  _G_o_a_l  as  once/1,  while  characters  written  to  the  current
    output  are sent to _O_u_t_p_u_t.   The predicate is  SWI-Prolog-specific,
    inspired  by  various posts  to  the mailinglist.    It  provides  a
    flexible  replacement for predicates  such as sformat/3,  swritef/3,
    term_to_atom/2, atom_number/2 converting numbers to atoms, etc.  The
    predicate format/3 accepts the same terms as output argument.

    Applications  should generally avoid creating atoms by  breaking and
    concatenating  other  atoms, as  the creation  of  large numbers  of
    intermediate  atoms generally leads  to poor performance, even  more
    so in multithreaded  applications.  This predicate supports creating
    difference  lists  from character  data efficiently.    The  example
    below defines the DCG rule term//1 to insert a term in the output:

    ____________________________________________________________________|                                                                    |
    | term(Term, In, Tail) :-                                            |

    |         with_output_to(codes(In, Tail), write(Term)).              |
    |                                                                    |
    | ?- phrase(term(hello), X).                                         |
    |                                                                    |
    ||X_=_[104,_101,_108,_108,_111]_____________________________________ ||

    AA SSttrreeaamm hhaannddllee oorr aalliiaass
         Temporarily switch current output  to the given stream.   Redi-
         rection using  with_output_to/2guarantees  the original  output
         is restored, also  if _G_o_a_l fails or  raises an exception.   See
         also call_cleanup/2.

    aattoomm((_-_A_t_o_m))
         Create an atom  from the emitted characters.   Please note  the
         remark above.

    ssttrriinngg((_-_S_t_r_i_n_g))
         Create a string object as defined in section ????.

    ccooddeess((_-_C_o_d_e_s))
         Create a list of  character codes from the emitted  characters,
         similar to atom_codes/2.

    ccooddeess((_-_C_o_d_e_s_, _-_T_a_i_l))
         Create a list of character codes as a difference list.

    cchhaarrss((_-_C_h_a_r_s))
         Create a list of  one-character atoms from the emitted  charac-
         ters, similar to atom_chars/2.

    cchhaarrss((_-_C_h_a_r_s_, _-_T_a_i_l))
         Create a list of one-character atoms as a difference list.


44..1177..77 FFaasstt bbiinnaarryy tteerrmm II//OO

The predicates  in this  section provide  fast binary  I/O of  arbitrary
Prolog  terms,  including  cyclic terms  and  terms  holding  attributed
variables.   Library fastrw  is a  SICSTus/Ciao compatible library  that
extends the core primitives described below.

The  binary representation  the  same as  used  by PL_record_external().
The  use of  these  primitives instead  of  using write_canonical/2  has
advantages and disadvantages.  Below are the main considerations:

  o Using  write_canonical/2  allows or  exchange  of terms  with  other
    Prolog  systems.  The format is stable and, as it is text  based, it
    can be inspected and corrected.

  o Using the binary format improves the performance roughly 3 times.

  o The size of both representations is comparable.

  o The  binary format  can deal  with cycles,  sharing and  attributes.
    Special  precautions  are   needed  to  transfer  such  terms  using
    write_canonical/2.  See term_factorized/3 and copy_term/3.

  o In  the  current  version,   reading  the  binary  format  has  only
    incomplete  consistency checks.   This implies  a user must be  able
    to  ttrruusstt tthhee ssoouurrccee as crafted messages may compromise  the reading
    Prolog system.


ffaasstt__tteerrmm__sseerriiaalliizzeedd((_?_T_e_r_m_, _?_S_t_r_i_n_g))
    (De-)serialize _T_e_r_m to/from _S_t_r_i_n_g.


ffaasstt__wwrriittee((_+_O_u_t_p_u_t_, _+_T_e_r_m))
    Write  _T_e_r_m  using  the  fast serialization  format  to  the  _O_u_t_p_u_t
    stream.  _O_u_t_p_u_t _m_u_s_t be a binary stream.


ffaasstt__rreeaadd((_+_I_n_p_u_t_, _-_T_e_r_m))
    Read  _T_e_r_m  using  the  fast serialization  format  from  the  _I_n_p_u_t
    stream.  _I_n_p_u_t _m_u_s_t be a binary stream.


44..1188 SSttaattuuss ooff ssttrreeaammss


wwaaiitt__ffoorr__iinnppuutt((_+_L_i_s_t_O_f_S_t_r_e_a_m_s_, _-_R_e_a_d_y_L_i_s_t_, _+_T_i_m_e_O_u_t))               _[_d_e_t_]
    Wait  for input on  one of the  streams in _L_i_s_t_O_f_S_t_r_e_a_m_s and  return
    a  list  of  streams  on  which input  is  available  in  _R_e_a_d_y_L_i_s_t.
    Each  element of  _L_i_s_t_O_f_S_t_r_e_a_m_s is  either a stream  or an  integer.
    Integers  are consider waitable  OS handles.   This  can be used  to
    wait  (also) wait for  handles that are  not associated with  Prolog
    streams such as UDP sockets.  See tcp_sockopt/2.

    This  predicate waits  for at  most _T_i_m_e_O_u_t  seconds.   _T_i_m_e_O_u_t  may
    be  specified as  a floating  point number to  specify fractions  of
    a  second.    If  _T_i_m_e_O_u_t  equals  infinite,  wait_for_input/3 waits
    indefinitely.    If  _T_i_m_e_o_u_t  is 0  or  0.0 this  predicate  returns
    without waiting.

    This  predicate can be used  to implement timeout while reading  and
    to handle input  from multiple sources and is typically used to wait
    for  multiple (network) sockets.    On Unix systems  it may be  used
    on  any stream  that is  associated with a  system file  descriptor.
    On  Windows  it can  only be  used  on sockets.    If  _L_i_s_t_O_f_S_t_r_e_a_m_s
    contains a stream  that is not associated with a supported device, a
    domain_error(_w_a_i_t_a_b_l_e___s_t_r_e_a_m_, _S_t_r_e_a_m) is raised.

    The  example below waits for input  from the user and an  explicitly
    opened  secondary  terminal stream.    On  return, _I_n_p_u_t_s  may  hold
    user_input or _P_4 or both.

    ____________________________________________________________________|                                                                    |
    | ?- open('/dev/ttyp4', read, P4),                                   |

    ||___wait_for_input([user_input,_P4],_Inputs,_0).___________________ ||

    When  available, the  implementation is based  on the poll()  system
    call.    The poll()  puts no  additional restriction  on the  number
    of  open  files the  process  may have.    It  does limit  the  time
    to  231-1  milliseconds (a bit  less than  25 days).   Specifying  a
    too  large timeout raises a representation_error(_t_i_m_e_o_u_t) exception.
    If  poll()  is not  supported by  the OS,  select() is  used.    The
    select()  call can  only handle file  descriptors up  to FD_SETSIZE.
    If  the  set  contains  a  descriptor  that  exceeds  this  limit  a
    representation_error(_'_F_D___S_E_T_S_I_Z_E_') is raised.

    Note  that wait_for_input/3 returns streams that have data  waiting.
    This  does  not  mean you  can,  for  example,  call read/2  on  the
    stream  without  blocking as  the stream  might  hold an  incomplete
    term.   The predicate set_stream/2 using the option timeout(_S_e_c_o_n_d_s)
    can  be used  to make  the stream generate  an exception  if no  new
    data  arrives within  the  timeout period.    Suppose two  processes
    communicate  by exchanging Prolog terms.   The following code  makes
    the server immune for clients that write an incomplete term:

    ____________________________________________________________________|                                                                    |
    |     ...,                                                           |
    |     tcp_accept(Server, Socket, _Peer),                             |
    |     tcp_open(Socket, In, Out),                                     |
    |     set_stream(In, timeout(10)),                                   |
    |     catch(read(In, Term), _, (close(Out), close(In), fail)),       |

    ||____...,__________________________________________________________ ||


bbyyttee__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Byte  position in _S_t_r_e_a_m.   For binary streams  this is the same  as
    character_count/2.   For text files the number may be  different due
    to  multi-byte encodings  or additional record  separators (such  as
    Control-M in Windows).


cchhaarraacctteerr__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the  current character index.   For input  streams
    this  is the number  of characters read since  the open; for  output
    streams  this is the number of characters written.   Counting starts
    at 0.


lliinnee__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the  number of  lines read or  written.   Counting
    starts at 1.


lliinnee__ppoossiittiioonn((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the position on the current line.  Note  that this
    assumes  the position  is 0 after  the open.   Tabs  are assumed  to
    be  defined on each  8-th character, and  backspaces are assumed  to
    reduce the count by one, provided it is positive.


44..1199 PPrriimmiittiivvee cchhaarraacctteerr II//OO

See section ???? for an overview of supported character representations.


nnll                                                                _[_I_S_O_]
    Write  a newline character  to the current output  stream.  On  Unix
    systems nl/0 is equivalent to put(10).


nnll((_+_S_t_r_e_a_m))                                                       _[_I_S_O_]
    Write a newline to _S_t_r_e_a_m.


ppuutt((_+_C_h_a_r))
    Write  _C_h_a_r  to the  current  output  stream.    _C_h_a_r is  either  an
    integer  expression evaluating  to a  character code or  an atom  of
    one  character.   Deprecated.    New code  should use  put_char/1 or
    put_code/1.


ppuutt((_+_S_t_r_e_a_m_, _+_C_h_a_r))
    Write _C_h_a_r to _S_t_r_e_a_m.  See put/1 for details.


ppuutt__bbyyttee((_+_B_y_t_e))                                                    _[_I_S_O_]
    Write a single byte  to the output.  _B_y_t_e must be an integer between
    0 and 255.


ppuutt__bbyyttee((_+_S_t_r_e_a_m_, _+_B_y_t_e))                                           _[_I_S_O_]
    Write  a single byte to _S_t_r_e_a_m.   _B_y_t_e must be an integer  between 0
    and 255.


ppuutt__cchhaarr((_+_C_h_a_r))                                                    _[_I_S_O_]
    Write  a  character to  the  current output,  obeying  the  encoding
    defined  for the current  output stream.   Note that this may  raise
    an  exception if the encoding of the output stream  cannot represent
    _C_h_a_r.


ppuutt__cchhaarr((_+_S_t_r_e_a_m_, _+_C_h_a_r))                                           _[_I_S_O_]
    Write  a  character to  _S_t_r_e_a_m,  obeying  the encoding  defined  for
    _S_t_r_e_a_m.   Note that this may  raise an exception if the  encoding of
    _S_t_r_e_a_m cannot represent _C_h_a_r.


ppuutt__ccooddee((_+_C_o_d_e))                                                    _[_I_S_O_]
    Similar  to put_char/1,  but using  a _c_h_a_r_a_c_t_e_r  _c_o_d_e.    _C_o_d_e is  a
    non-negative integer.   Note that this may raise an exception if the
    encoding of the output stream cannot represent _C_o_d_e.


ppuutt__ccooddee((_+_S_t_r_e_a_m_, _+_C_o_d_e))                                           _[_I_S_O_]
    Same as put_code/1 but directing _C_o_d_e to _S_t_r_e_a_m.


ttaabb((_+_A_m_o_u_n_t))
    Write  _A_m_o_u_n_t spaces on  the current output  stream.  _A_m_o_u_n_t  should
    be  an  expression   that  evaluates  to  a  positive  integer  (see
    section ????).


ttaabb((_+_S_t_r_e_a_m_, _+_A_m_o_u_n_t))
    Write _A_m_o_u_n_t spaces to _S_t_r_e_a_m.


fflluusshh__oouuttppuutt                                                       _[_I_S_O_]
    Flush  pending output on current  output stream.   flush_output/0 is
    automatically  generated by  read/1 and derivatives  if the  current
    input stream is user and the cursor is not at the left margin.


fflluusshh__oouuttppuutt((_+_S_t_r_e_a_m))                                              _[_I_S_O_]
    Flush  output on the specified stream.  The stream must be  open for
    writing.


ttttyyfflluusshh
    Flush pending output on stream user.  See also flush_output/[0,1].


ggeett__bbyyttee((_-_B_y_t_e))                                                    _[_I_S_O_]
    Read the current input  stream and unify the next byte with _B_y_t_e (an
    integer  between 0  and 255).   _B_y_t_e is  unified with  -1 on end  of
    file.


ggeett__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))                                           _[_I_S_O_]
    Read  the  next byte  from _S_t_r_e_a_m  and unify  _B_y_t_e  with an  integer
    between 0 and 255.


ggeett__ccooddee((_-_C_o_d_e))                                                    _[_I_S_O_]
    Read  the current  input stream  and unify _C_o_d_e  with the  character
    code  of the  next character.   _C_o_d_e is  unified with  -1 on end  of
    file.  See also get_char/1.


ggeett__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))                                           _[_I_S_O_]
    Read the next character code from _S_t_r_e_a_m.


ggeett__cchhaarr((_-_C_h_a_r))                                                    _[_I_S_O_]
    Read  the  current  input  stream  and  unify  _C_h_a_r  with  the  next
    character  as a  one-character atom.    See also  atom_chars/2.    On
    end-of-file, _C_h_a_r is unified to the atom end_of_file.


ggeett__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                           _[_I_S_O_]
    Unify  _C_h_a_r with the next  character from _S_t_r_e_a_m as a  one-character
    atom.  See also get_char/2, get_byte/2 and get_code/2.


ggeett00((_-_C_h_a_r))                                                _[_d_e_p_r_e_c_a_t_e_d_]
    Edinburgh  version  of the  ISO  get_code/1 predicate.    Note  that
    Edinburgh  Prolog  didn't  support  wide  characters  and  therefore
    technically  speaking get0/1 should have been  mapped to get_byte/1.
    The intention of get0/1, however, is to read character codes.


ggeett00((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                       _[_d_e_p_r_e_c_a_t_e_d_]
    Edinburgh  version  of  the ISO  get_code/2  predicate.    See  also
    get0/1.


ggeett((_-_C_h_a_r))                                                 _[_d_e_p_r_e_c_a_t_e_d_]
    Read  the  current   input  stream  and  unify  the  next  non-blank
    character  with _C_h_a_r.  _C_h_a_r is unified with -1 on end of file.   The
    predicate get/1 operates on character _c_o_d_e_s.  See also get0/1.


ggeett((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                        _[_d_e_p_r_e_c_a_t_e_d_]
    Read  the next  non-blank character from  _S_t_r_e_a_m.   See also  get/1,
    get0/1 and get0/2.


ppeeeekk__bbyyttee((_-_B_y_t_e))                                                   _[_I_S_O_]


ppeeeekk__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))                                          _[_I_S_O_]


ppeeeekk__ccooddee((_-_C_o_d_e))                                                   _[_I_S_O_]


ppeeeekk__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))                                          _[_I_S_O_]


ppeeeekk__cchhaarr((_-_C_h_a_r))                                                   _[_I_S_O_]


ppeeeekk__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                          _[_I_S_O_]
    Read  the  next  byte/code/char  from  the  input  without  removing
    it.    These  predicates  do not  modify  the stream's  position  or
    end-of-file  status.   These  predicates require  a buffered  stream
    (see  set_stream/2)  and raise  a  permission  error if  the  stream
    is  unbuffered  or the  buffer  is too  small  to hold  the  longest
    multi-byte sequence that might need to be buffered.


ppeeeekk__ssttrriinngg((_+_S_t_r_e_a_m_, _+_L_e_n_, _-_S_t_r_i_n_g))
    Read  the next _L_e_n  characters (if the stream  is a text stream)  or
    bytes  (if the stream  is binary) from  Stream without removing  the
    data.   If  _L_e_n is larger  that the stream  buffer size, the  buffer
    size  is increased to _L_e_n.   _S_t_r_i_n_g can  be shorter than _L_e_n if  the
    stream contains less data.   This predicate is intended to guess the
    content type of data read from non-repositionable streams.


sskkiipp((_+_C_o_d_e))
    Read the input until  _C_o_d_e or the end of the file is encountered.  A
    subsequent  call to get_code/1 will  read the first character  after
    _C_o_d_e.


sskkiipp((_+_S_t_r_e_a_m_, _+_C_o_d_e))
    Skip input (as skip/1) on _S_t_r_e_a_m.


ggeett__ssiinnggllee__cchhaarr((_-_C_o_d_e))
    Get  a single character from input stream `user' (regardless  of the
    current  input stream).  Unlike get_code/1, this predicate  does not
    wait  for a  return.   The  character is  not echoed  to the  user's
    terminal.    This predicate  is meant for  keyboard menu  selection,
    etc.  If  SWI-Prolog was started with the -tty option this predicate
    reads  an  entire line  of  input and  returns the  first  non-blank
    character  on this line, or the  character code of the newline  (10)
    if the entire line consisted of blank characters.


aatt__eenndd__ooff__ssttrreeaamm                                                    _[_I_S_O_]
    Succeeds  after the last character  of the current input stream  has
    been  read.    Also succeeds  if  there is  no valid  current  input
    stream.


aatt__eenndd__ooff__ssttrreeaamm((_+_S_t_r_e_a_m))                                           _[_I_S_O_]
    Succeeds  after the last character of  the named stream is read,  or
    _S_t_r_e_a_m is not a  valid input stream.  The end-of-stream test is only
    available  on buffered input  streams (unbuffered input streams  are
    rarely used; see open/4).


sseett__eenndd__ooff__ssttrreeaamm((_+_S_t_r_e_a_m))
    Set  the size  of  the file  opened as  _S_t_r_e_a_m to  the current  file
    position.   This is typically used in combination with the open-mode
    update.


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t_, _+_L_e_n))
    Copy  _L_e_n codes from _S_t_r_e_a_m_I_n to _S_t_r_e_a_m_O_u_t.   Note that the  copy is
    done  using the semantics of get_code/2 and  put_code/2, taking  care
    of  possibly recoding  that  needs to  take place  between two  text
    files.  See section ????.


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t))
    Copy all (remaining) data from _S_t_r_e_a_m_I_n to _S_t_r_e_a_m_O_u_t.


ffiillll__bbuuffffeerr((_+_S_t_r_e_a_m))                                               _[_d_e_t_]
    Fill  the  _S_t_r_e_a_m's input  buffer.   Subsequent  calls  try to  read
    more  input until the buffer is  completely filled.  This  predicate
    is  used together  with read_pending_codes/3 to  process input  with
    minimal buffering.


rreeaadd__ppeennddiinngg__ccooddeess((_+_S_t_r_e_a_m_I_n_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Read input pending in  the input buffer of _S_t_r_e_a_m_I_n and return it in
    the  difference list _C_o_d_e_s-_T_a_i_l.  That is, the  available characters
    codes  are used to  create the list _C_o_d_e_s  ending in the tail  _T_a_i_l.
    On  encountering end-of-file, both _C_o_d_e_s  and _T_a_i_l are unified  with
    the empty list ([]).

    This  predicate is  intended  for efficient  unbuffered copying  and
    filtering  of input coming from network connections or devices.   It
    also  enables  the library  pure_input,  which  processes input  from
    files and streams using a DCG.

    The following  code fragment realises efficient non-blocking copying
    of  data from an input to an  output stream.  The  at_end_of_stream/1
    call  checks for  end-of-stream and fills  the input  buffer.   Note
    that  the use of a  get_code/2 and put_code/2 based loop requires  a
    flush_output/1 call  after _e_a_c_h put_code/2.   The copy_stream_data/2
    does  not allow for inspection of  the copied data and suffers  from
    the same buffering issues.

    ____________________________________________________________________|                                                                    |
    | copy(In, Out) :-                                                   |

    |         repeat,                                                    |
    |             fill_buffer(In),                                       |
    |             read_pending_codes(In, Chars, Tail),                   |
    |             \+ \+ ( Tail = [],                                     |
    |                     format(Out, '~s', [Chars]),                    |
    |                     flush_output(Out)                              |
    |                   ),                                               |
    |             (   Tail == []                                         |

    |             ->  !                                                  |
    |             ;   fail                                               |
    ||____________).____________________________________________________ ||


rreeaadd__ppeennddiinngg__cchhaarrss((_+_S_t_r_e_a_m_I_n_, _-_C_h_a_r_s_, _?_T_a_i_l))
    As  read_pending_codes/3, but  returns  a  difference list  of  one-
    character atoms.


44..2200 TTeerrmm rreeaaddiinngg aanndd wwrriittiinngg

This section  describes the basic term  reading and writing  predicates.
The  predicates  format/[1,2] and  writef/2  provide  formatted  output.
Writing  to  Prolog data  structures  such  as atoms  or  code-lists  is
supported by with_output_to/2and format/3.

Reading  is  sensitive  to  the  Prolog  flag  character_escapes,   which
controls  the interpretation  of the  \ character  in  quoted atoms  and
strings.


wwrriittee__tteerrmm((_+_T_e_r_m_, _+_O_p_t_i_o_n_s))                                        _[_I_S_O_]
    The  predicate  write_term/2  is  the generic  form  of  all  Prolog
    term-write predicates.  Valid options are:

    aattttrriibbuutteess((_A_t_o_m))
         Define how attributed  variables (see section ????) are  written.
         The default is determined by  the Prolog flag write_attributes.
         Defined values are  ignore (ignore the attribute), dots  (write
         the attributes  as {...}),  write (simply  hand the  attributes
         recursively to write_term/2) and  portray (hand the  attributes
         to attr_portray_hook/2).

    bbaacckk__qquuootteess((_A_t_o_m))
         Fulfills  the  same  role  as   the  back_quotes  prolog  flag.
         Notably, the value  string causes string objects to be  printed
         between back quotes and symbol_char causes the backquote  to be
         printed unquoted.  In all other cases the  backquote is printed
         as a quoted atom.

    bbrraaccee__tteerrmmss((_B_o_o_l))
         If true (default), write {}(X)  as {X}.  See also  dotlists and
         ignore_ops.

    bblloobbss((_A_t_o_m))
         Define how  non-text blobs are  handled.   By default, this  is
         left to the write handler specified with the blob type.   Using
         portray, portray/1 is  called for each  blob encountered.   See
         section ????.

    cchhaarraacctteerr__eessccaappeess((_B_o_o_l))
         If  true and  quoted(_t_r_u_e)  is active,  special  characters  in
         quoted atoms and strings  are emitted as ISO escape  sequences.
         Default is taken from the reference module (see below).

    ccyycclleess((_B_o_o_l))
         If true  (default),  cyclic terms  are  written as  @(_T_e_m_p_l_a_t_e_,
         _S_u_b_s_t_i_t_u_t_i_o_n_s), where _S_u_b_s_t_i_t_u_t_i_o_n_s is a list _V_a_r = _V_a_l_u_e.   If
         cycles is false,  max_depth is not given,  and _T_e_r_m is  cyclic,
         write_term/2 raises a domain_error.   See also the cycles option
         in read_term/2.

    ddoottlliissttss((_B_o_o_l))
         If true  (default false),  write  lists using  the dotted  term
         notation  rather  than  the  list  notation.     Note  that  as
         of  version  7,   the  list  constructor  is  '[|]'.      Using
         dotlists(_t_r_u_e),  write_term/2 writes  a  list  using `.'     as
         constructor.  This is intended for  communication with programs
         such as other Prolog systems, that rely on this notation.

    ffuullllssttoopp((_B_o_o_l))
         If true (default  false), add a  fullstop token to the  output.
         The dot  is preceeded  by  a space  if needed  and followed  by
         a space  (default) or newline  if the  nl(_t_r_u_e) option is  also
         given.

    iiggnnoorree__ooppss((_B_o_o_l))
         If true, the generic term representation (<_f_u_n_c_t_o_r>(<_a_r_g_s> ...))
         will be  used for all  terms.   Otherwise (default),  operators
         will be used where appropriate..

    mmaaxx__ddeepptthh((_I_n_t_e_g_e_r))
         If the term is nested deeper than _I_n_t_e_g_e_r,  print the remainder
         as ellipses  (...).    A 0  (zero) value  (default) imposes  no
         depth limit.   This option also delimits the number  of printed
         items in a list.  Example:

         _______________________________________________________________|                                                               |

         |?- write_term(a(s(s(s(s(0)))), [a,b,c,d,e,f]),                 |
         |              [max_depth(3)]).                                 |
         |a(s(s(...)), [a, b|...])                                       |
         |true.|________________________________________________________ |     |

         Used  by   the  top   level  and  debugger   to  limit   screen
         output.   See  also the  Prolog flags  answer_write_options and
         debugger_write_options.

    mmoodduullee((_M_o_d_u_l_e))
         Define the reference module  (default user).  This  defines the
         default value for  the character_escapes option as well as  the
         operator definitions to use.  See also op/3.

    nnll((_B_o_o_l))
         Add a newline to the output.  See also the fullstop option.

    nnuummbbeerrvvaarrss((_B_o_o_l))
         If  true, terms  of  the  format $VAR(N),  where  _N is  a  non-
         negative integer, will be written as a variable name.   If _N is
         an atom it  is written without quotes.   This extension  allows
         for writing variables  with user-provided names.   The  default
         is false.  See also numbervars/3 and the option variable_names.

    ppaarrttiiaall((_B_o_o_l))
         If true (default  false), do not  reset the logic that  inserts
         extra  spaces that  separate  tokens where  needed.    This  is
         intended to solve  the problems with the  code below.   Calling
         write_value(.) writes  .., which  cannot be  read.   By  adding
         partial(_t_r_u_e)  to the  option  list,  it correctly  emits  . ..
         Similar problems appear when emitting operators  using multiple
         calls to write_term/3.

         _______________________________________________________________|                                                               |
         |write_value(Value) :-                                          |
         |        write_term(Value, [partial(true)]),                    |

         ||_______write('.'),_nl._______________________________________ ||

    ppoorrttrraayy((_B_o_o_l))
         Same as portrayed(_B_o_o_l).  Deprecated.

    ppoorrttrraayy__ggooaall((_:_G_o_a_l))
         Implies portray(_t_r_u_e),  but calls _G_o_a_l  rather than the  prede-
         fined hook  portray/1.   _G_o_a_l is called  through call/3,  where
         the first  argument  is _G_o_a_l,  the  second is  the term  to  be
         printed and the 3rd argument is the current  write option list.
         The  write option  list  is copied  from  the  write_term  call,
         but the  list is  guaranteed to  hold an  option priority  that
         reflects the current priority.

    ppoorrttrraayyeedd((_B_o_o_l))
         If true, the  hook portray/1 is  called before printing a  term
         that is not  a variable.   If portray/1  succeeds, the term  is
         considered printed.  See  also print/1.  The default  is false.
         This option is an extension to the ISO write_term options.

    pprriioorriittyy((_I_n_t_e_g_e_r))
         An  integer  between  0  and  1200  representing  the  `context
         priority'.   Default is  1200.   Can be  used to write  partial
         terms appearing as the argument to an operator.  For example:

         _______________________________________________________________|                                                               |
         |        format('~w = ', [VarName]),                            |
         ||_______write_term(Value,_[quoted(true),_priority(699)])______ ||

    qquuootteedd((_B_o_o_l))
         If true, atoms  and functors that  need quotes will be  quoted.
         The default is false.

    ssppaacciinngg((_+_S_p_a_c_i_n_g))
         Determines whether  and where  extra  white space  is added  to
         enhance readability.    The default  is  standard, adding  only
         space  where needed  for  proper  tokenization by  read_term/3.
         Currently,  the only  other value  is  next_argument,  adding  a
         space after  a comma used  to separate arguments  in a term  or
         list.

    vvaarriiaabbllee__nnaammeess((_+_L_i_s_t))
         Assign names to  variables in _T_e_r_m.   _L_i_s_t  is a list of  terms
         _N_a_m_e = _V_a_r,  where _N_a_m_e  is  an atom  that represents  a  valid
         Prolog  variable name.    Terms  where _V_a_r  is  bound or  is  a
         variable that does not appear  in _T_e_r_m are ignored.   Raises an
         error if _L_i_s_t is not  a list, one of the members is not  a term
         _N_a_m_e = _V_a_r, _N_a_m_e is  not an atom or  _N_a_m_e does not represent  a
         valid Prolog variable name.

         The implementation  binds the  variables  from _L_i_s_t  to a  term
         '$VAR'(_N_a_m_e).  Like write_canonical/1, terms that where already
         bound to  '$VAR'(_X) before  write_term/2 are printed  normally,
         unless the option  numbervars(_t_r_u_e) is also  provided.  If  the
         option numbervars(_t_r_u_e)  is used, the  user is responsible  for
         avoiding collisions between assigned names and  numbered names.
         See also the variable_names option of read_term/2.

         Possible variable attributes (see section ????) are ignored.   In
         most cases  one should  use copy_term/3 to obtain  a copy  that
         is  free of  attributed  variables  and handle  the  associated
         constraints as appropriate for the use-case.


wwrriittee__tteerrmm((_+_S_t_r_e_a_m_, _+_T_e_r_m_, _+_O_p_t_i_o_n_s))                               _[_I_S_O_]
    As  write_term/2,  but output  is sent  to  _S_t_r_e_a_m rather  than  the
    current output.


wwrriittee__lleennggtthh((_+_T_e_r_m_, _-_L_e_n_g_t_h_, _+_O_p_t_i_o_n_s))                         _[_s_e_m_i_d_e_t_]
    True   when  _L_e_n_g_t_h  is  the   number  of  characters  emitted   for
    _w_r_i_t_e___t_e_r_mTerm,  Options.     In  addition  to   valid  options  for
    write_term/2, it processes the option:

    mmaaxx__lleennggtthh((_+_M_a_x_L_e_n_g_t_h))
         If provided,  fail if  _L_e_n_g_t_h would be  larger than  _M_a_x_L_e_n_g_t_h.
         The implementation  ensures that  the runtime  is limited  when
         computing the length of a huge term with a bounded maximum.


wwrriittee__ccaannoonniiccaall((_+_T_e_r_m))                                             _[_I_S_O_]
    Write  _T_e_r_m  on  the current  output  stream using  standard  paren-
    thesised  prefix notation  (i.e.,  ignoring operator  declarations).
    Atoms  that  need  quotes are  quoted.    Terms  written  with  this
    predicate  can always be read  back, regardless of current  operator
    declarations.      Equivalent  to  write_term/2  using  the  options
    ignore_ops,  quoted  and  numbervars after  numbervars/4  using  the
    singletons option.

    Note  that due to the use of numbervars/4, non-ground terms  must be
    written  using a  _s_i_n_g_l_e write_canonical/1 call.   This  used to  be
    the  case anyhow,  as garbage collection  between multiple calls  to
    one  of the write predicates can change the _G<NNN> identity  of the
    variables.


wwrriittee__ccaannoonniiccaall((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                    _[_I_S_O_]
    Write _T_e_r_m in canonical form on _S_t_r_e_a_m.


wwrriittee((_+_T_e_r_m))                                                      _[_I_S_O_]
    Write  _T_e_r_m  to the  current output,  using  brackets and  operators
    where appropriate.


wwrriittee((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                             _[_I_S_O_]
    Write _T_e_r_m to _S_t_r_e_a_m.


wwrriitteeqq((_+_T_e_r_m))                                                     _[_I_S_O_]
    Write  _T_e_r_m  to the  current output,  using  brackets and  operators
    where  appropriate.    Atoms that  need quotes  are quoted.    Terms
    written  with this predicate can  be read back with read/1  provided
    the currently active operator declarations are identical.


wwrriitteeqq((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                            _[_I_S_O_]
    Write _T_e_r_m to _S_t_r_e_a_m, inserting quotes.


wwrriitteellnn((_+_T_e_r_m))
    Equivalent to write(Term), nl..   The output stream is locked, which
    implies  no output from  other threads can  appear between the  term
    and newline.


wwrriitteellnn((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Equivalent  to write(Stream, Term), nl(Stream)..  The  output stream
    is  locked, which implies  no output from  other threads can  appear
    between the term and newline.


pprriinntt((_+_T_e_r_m))
    Print a term for  debugging purposes.  The predicate print/1 acts as
    if defined as below.

    ____________________________________________________________________|                                                                    |
    | print(Term) :-                                                     |
    |     current_prolog_flag(print_write_options, Options), !,          |
    |     write_term(Term, Options).                                     |

    | print(Term) :-                                                     |
    |     write_term(Term, [ portray(true),                              |
    |                        numbervars(true),                           |
    |                        quoted(true)                                |
    ||_____________________]).__________________________________________ ||

    The  print/1  predicate  is used  primarily  through the  ~p  escape
    sequence  of format/2, which is  commonly used in the recipies  used
    by print_message/2 to emit messages.

    The  classical definition  of this  predicate is  equivalent to  the
    ISO  predicate  write_term/2  using the  options  portray(_t_r_u_e)  and
    numbervars(_t_r_u_e).    The  portray(_t_r_u_e) option  allows  the user  to
    implement  application-specific  printing  of terms  printed  during
    debugging to facilitate  easy understanding of the output.  See also
    portray/1  and portray_text.   SWI-Prolog  adds quoted(_t_r_u_e) to  (1)
    facilitate  the copying/pasting  of terms that  are not affected  by
    portray/1  and to (2)  allow numbers, atoms  and strings to be  more
    easily distinguished, e.g., 42, '42' and "42".


pprriinntt((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Print _T_e_r_m to _S_t_r_e_a_m.


ppoorrttrraayy((_+_T_e_r_m))
    A dynamic predicate, which  can be defined by the user to change the
    behaviour  of print/1 on (sub)terms.   For each subterm  encountered
    that is not  a variable print/1 first calls portray/1 using the term
    as  argument.   For  lists, only  the list as  a whole  is given  to
    portray/1.   If portray/1 succeeds print/1 assumes the term has been
    written.


rreeaadd((_-_T_e_r_m))                                                       _[_I_S_O_]
    Read  the next Prolog term from  the current input stream and  unify
    it  with _T_e_r_m.  On a syntax error read/1 displays an  error message,
    attempts  to  skip  the erroneous  term  and  fails.    On  reaching
    end-of-file _T_e_r_m is unified with the atom end_of_file.


rreeaadd((_+_S_t_r_e_a_m_, _-_T_e_r_m))                                              _[_I_S_O_]
    Read _T_e_r_m from _S_t_r_e_a_m.


rreeaadd__ccllaauussee((_+_S_t_r_e_a_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))
    Equivalent  to  read_term/3,  but  sets  options  according  to  the
    current  compilation  context  and  optionally  processes  comments.
    Defined options:

    ssyynnttaaxx__eerrrroorrss((_+_A_t_o_m))
         See read_term/3, but the default is dec10 (report and restart).

    tteerrmm__ppoossiittiioonn((_-_T_e_r_m_P_o_s))
         Same as for read_term/3.

    ssuubbtteerrmm__ppoossiittiioonnss((_-_T_e_r_m_P_o_s))
         Same as for read_term/3.

    vvaarriiaabbllee__nnaammeess((_-_B_i_n_d_i_n_g_s))
         Same as for read_term/3.

    pprroocceessss__ccoommmmeenntt((_+_B_o_o_l_e_a_n))
         If true (default),  call prolog:comment_hook(_C_o_m_m_e_n_t_s_,  _T_e_r_m_P_o_s_,
         _T_e_r_m)   if  this   multifile   hook   is  defined   (see   pro-
         log:comment_hook/3).  This is used to drive PlDoc.

    ccoommmmeennttss((_-_C_o_m_m_e_n_t_s))
         If  provided,  unify _C_o_m_m_e_n_t_s  with  the  comments  encountered
         while   reading   _T_e_r_m.         This   option   implies    pro-
         cess_comment(_f_a_l_s_e).

    The singletons  option of read_term/3is  initialised from the active
    style-checking  mode.    The  module option  is initialised  to  the
    current compilation module (see prolog_load_context/2).


rreeaadd__tteerrmm((_-_T_e_r_m_, _+_O_p_t_i_o_n_s))                                         _[_I_S_O_]
    Read  a term from the current  input stream and unify the term  with
    _T_e_r_m.    The  reading is  controlled  by options  from the  list  of
    _O_p_t_i_o_n_s.   If this list is  empty, the behaviour is the same  as for
    read/1.    The options  are upward compatible  with Quintus  Prolog.
    The  argument  order is  according  to the  ISO  standard.    Syntax
    errors  are always reported using exception-handling  (see catch/3).
    Options:

    bbaacckkqquuootteedd__ssttrriinngg((_B_o_o_l))
         If true, read `...` to  a string object (see section ????).   The
         default depends on the Prolog flag back_quotes.

    cchhaarraacctteerr__eessccaappeess((_B_o_o_l))
         Defines how to  read \ escape sequences  in quoted atoms.   See
         the  Prolog  flag  character_escapes in  current_prolog_flag/2.
         (SWI-Prolog).

    ccoommmmeennttss((_-_C_o_m_m_e_n_t_s))
         Unify _C_o_m_m_e_n_t_s with a list of _P_o_s_i_t_i_o_n-_C_o_m_m_e_n_t,  where _P_o_s_i_t_i_o_n
         is  a  stream   position  object  (see  stream_position_data/3)
         indicating the  start  of a  comment and  _C_o_m_m_e_n_t  is a  string
         object containing the  text including delimiters of a  comment.
         It returns all comments from where the read_term/2 call started
         up to the end of the term read.

    ccyycclleess((_B_o_o_l))
         If true (default  false), re-instantiate templates as  produced
         by  the corresponding  write_term/2  option.    Note  that  the
         default  is false  to  avoid misinterpretation  of  @(_T_e_m_p_l_a_t_e_,
         _S_u_b_s_t_u_t_i_o_n_s), while the default of write_term/2 is true because
         emitting  cyclic terms  without  using the  template  construct
         produces an infinitely large  term (read:  it will  generate an
         error after producing a huge amount of output).

    ddoottlliissttss((_B_o_o_l))
         If true (default false), read .(a,[]) as a list,  even if lists
         are internally nor constructed using the dot as functor.   This
         is primarily intended to read the output from write_canonical/1
         from other Prolog systems.  See section ????.

    ddoouubbllee__qquuootteess((_A_t_o_m))
         Defines  how to  read  "..." strings.     See the  Prolog  flag
         double_quotes.  (SWI-Prolog).

    mmoodduullee((_M_o_d_u_l_e))
         Specify  _M_o_d_u_l_e  for  operators,   character_escapes  flag  and
         double_quotes flag.  The  value of the latter two is  overruled
         if the  corresponding read_term/3 option  is provided.   If  no
         module  is specified,  the  current  `source module'  is  used.
         (SWI-Prolog).

    qquuaassii__qquuoottaattiioonnss((_-_L_i_s_t))
         If present,  unify  _L_i_s_t with  the quasi  quotations (see  sec-
         tion ????) instead  of evaluating quasi  quotations.  Each  quasi
         quotation is a term  quasi_quotation(_+_S_y_n_t_a_x_, _+_Q_u_o_t_a_t_i_o_n_,  _+_V_a_r_-
         _D_i_c_t_, _-_R_e_s_u_l_t),  where _S_y_n_t_a_x  is the  term in  {|Syntax||..|},
         _Q_u_o_t_a_t_i_o_n  is a  list of  character  codes that  represent  the
         quotation, _V_a_r_D_i_c_t is a  list of _N_a_m_e=_V_a_r_i_a_b_l_e and _R_e_s_u_l_t  is a
         variable that shares  with the place  where the quotation  must
         be inserted.   This  option is intended  to support tools  that
         manipulate Prolog source text.

    ssiinngglleettoonnss((_V_a_r_s))
         As variable_names,  but only  reports  the variables  occurring
         only  once   in  the   _T_e_r_m  read   (ISO).  If   _V_a_r_s  is   the
         constant  warning,  singleton  variables   are  reported  using
         print_message/2.  The variables  appear in the order they  have
         been read.   The latter option provides backward  compatibility
         and  is  used to  read  terms  from  source files.     Not  all
         singleton variables are reported as a warning.   See section ????
         for  the  rules  that  apply  for  warning  about  a  singleton
         variable.

    ssyynnttaaxx__eerrrroorrss((_A_t_o_m))
         If error  (default),  throw  an exception  on a  syntax  error.
         Other values  are fail, which  causes a  message to be  printed
         using print_message/2, after which  the predicate fails,  quiet
         which causes the  predicate to fail  silently, and dec10  which
         causes syntax errors to be printed, after which read_term/[2,3]
         continues reading the next term.   Using dec10, read_term/[2,3]
         never fails.  (Quintus, SICStus).

    ssuubbtteerrmm__ppoossiittiioonnss((_T_e_r_m_P_o_s))
         Describes the  detailed layout of  the term.   The formats  for
         the various types of terms are given below.   All positions are
         character positions.    If  the input  is related  to a  normal
         stream,  these  positions are  relative  to the  start  of  the
         input; when  reading from  the terminal,  they are relative  to
         the start of the term.

         _F_r_o_m--_T_o
             Used for primitive types (atoms, numbers, variables).

         ssttrriinngg__ppoossiittiioonn((_F_r_o_m_, _T_o))
             Used  to indicate  the  position of  a string  enclosed  in
             double quotes (").

         bbrraaccee__tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _A_r_g))
             Term  of  the form  {...},  as used  in  DCG  rules.    _A_r_g
             describes the argument.

         lliisstt__ppoossiittiioonn((_F_r_o_m_, _T_o_, _E_l_m_s_, _T_a_i_l))
             A  list.   _E_l_m_s describes  the positions  of the  elements.
             If  the list  specifies the  tail as  |<TailTerm>, _T_a_i_l  is
             unified with the term position  of the tail, otherwise with
             the atom none.

         tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _F_F_r_o_m_, _F_T_o_, _S_u_b_P_o_s))
             Used  for a compound  term not matching  one of the  above.
             _F_F_r_o_m  and  _F_T_o  describe  the  position  of  the  functor.
             _S_u_b_P_o_s is a list, each element  of which describes the term
             position of the corresponding subterm.

         ddiicctt__ppoossiittiioonn((_F_r_o_m_, _T_o_, _T_a_g_F_r_o_m_, _T_a_g_T_o_, _K_e_y_V_a_l_u_e_P_o_s_L_i_s_t))
             Used  for  a  dict (see  section  ????).    The  position  of
             the  key-value  pairs  is   described  by  _K_e_y_V_a_l_u_e_P_o_s_L_i_s_t,
             which  is  a  list  of  key_value_position/7 terms.     The
             key_value_position/7  terms appear  in  the  order  of  the
             input.   Because maps to not preserve ordering, the  key is
             provided in the position description.

         kkeeyy__vvaalluuee__ppoossiittiioonn((_F_r_o_m_, _T_o_, _S_e_p_F_r_o_m_, _S_e_p_T_o_, _K_e_y_, _K_e_y_P_o_s_, _V_a_l_u_e_P_o_s))
             Used  for key-value pairs in  a map (see  section ????).   It
             is  similar to the  term_position/5 that would be  created,
             except  that the  key and value  positions do  not need  an
             intermediate list and the key is  provided in _K_e_y to enable
             synchronisation  of the  file position data  with the  data
             structure.

         ppaarreenntthheesseess__tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _C_o_n_t_e_n_t_P_o_s))
             Used for  terms between parentheses.  This is  an extension
             compared  to the  original Quintus  specification that  was
             considered necessary for secure refactoring of terms.

         qquuaassii__qquuoottaattiioonn__ppoossiittiioonn((_F_r_o_m_, _T_o_, _S_y_n_t_a_x_F_r_o_m_, _S_y_n_t_a_x_T_o_, _C_o_n_t_e_n_t_P_o_s))
             Used for quasi quotations.

    tteerrmm__ppoossiittiioonn((_P_o_s))
         Unifies _P_o_s with the starting  position of the term read.   _P_o_s
         is of the same format as used by stream_property/2.

    vvaarr__pprreeffiixx((_B_o_o_l))
         If true,  demand variables to  start with an  underscore.   See
         section ????.

    vvaarriiaabblleess((_V_a_r_s))
         Unify  _V_a_r_s  with a  list  of  variables  in the  term.     The
         variables appear in  the order they have  been read.  See  also
         term_variables/2.  (ISO).

    vvaarriiaabbllee__nnaammeess((_V_a_r_s))
         Unify _V_a_r_s with a list  of `_N_a_m_e = _V_a_r', where _N_a_m_e is  an atom
         describing the variable name and _V_a_r is a  variable that shares
         with the corresponding variable in _T_e_r_m.   (ISO). The variables
         appear in the order they have been read.


rreeaadd__tteerrmm((_+_S_t_r_e_a_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))                                _[_I_S_O_]
    Read term with options from _S_t_r_e_a_m.  See read_term/2.


rreeaadd__tteerrmm__ffrroomm__aattoomm((_+_A_t_o_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))
    Use  read_term/3 to read the  next term from _A_t_o_m.   _A_t_o_m is  either
    an  atom or a string  object (see section ????).   It is not  required
    for  _A_t_o_m  to end  with  a full-stop.    This  predicate  supersedes
    atom_to_term/3.


rreeaadd__hhiissttoorryy((_+_S_h_o_w_, _+_H_e_l_p_, _+_S_p_e_c_i_a_l_, _+_P_r_o_m_p_t_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))
    Similar  to read_term/2 using the option variable_names, but  allows
    for history  substitutions.  read_history/6is used  by the top level
    to  read the user's actions.   _S_h_o_w is  the command the user  should
    type  to show  the saved  events.   _H_e_l_p is  the command  to get  an
    overview  of the capabilities.   _S_p_e_c_i_a_l is a list of commands  that
    are  not saved in the  history.  _P_r_o_m_p_t  is the first prompt  given.
    Continuation  prompts for  more  lines are  determined by  prompt/2.
    A  %w  in the  prompt  is substituted  by  the event  number.    See
    section ???? for available substitutions.

    SWI-Prolog calls read_history/6 as follows:

    ____________________________________________________________________|                                                                    |
    ||read_history(h,_'!h',_[trace],_'%w_?-_',_Goal,_Bindings)__________ ||


pprroommpptt((_-_O_l_d_, _+_N_e_w))
    Set  prompt associated  with read/1  and its  derivatives.   _O_l_d  is
    first  unified with the current prompt.  On success the  prompt will
    be  set to _N_e_w if  this is an atom.   Otherwise an error message  is
    displayed.   A prompt  is printed if one  of the read predicates  is
    called  and the cursor is  at the left margin.   It is also  printed
    whenever  a newline is given and  the term has not been  terminated.
    Prompts are only printed when the current input stream is _u_s_e_r.


pprroommpptt11((_+_P_r_o_m_p_t))
    Sets  the prompt for the next line  to be read.   Continuation lines
    will be read using the prompt defined by prompt/2.


44..2211 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg TTeerrmmss


ffuunnccttoorr((_?_T_e_r_m_, _?_N_a_m_e_, _?_A_r_i_t_y))                                     _[_I_S_O_]
    True  when _T_e_r_m is  a term with  functor _N_a_m_e/_A_r_i_t_y.   If _T_e_r_m is  a
    variable  it is  unified with  a new  term whose  arguments are  all
    different variables (such a  term is called a skeleton).  If _T_e_r_m is
    atomic,  _A_r_i_t_y will be unified with the integer 0, and _N_a_m_e  will be
    unified  with _T_e_r_m.   Raises instantiation_error if _T_e_r_m is  unbound
    and _N_a_m_e/_A_r_i_t_y is insufficiently instantiated.

    SWI-Prolog   also  supports   terms  with   arity  0,   as  in   a()
    (see   section  ????.       Such   terms  must   be  processed   using
    compound_name_arity/3.   The predicate functor/3  and =../2 raise  a
    domain_error when faced with these terms.   Without this precaution,
    the inconsistency demonstrated below could happen silently.

    ____________________________________________________________________|                                                                    |
    | ?- functor(a(), N, A).                                             |

    | N = a, A = 0.                                                      |
    | ?- functor(T, a, 0).                                               |
    ||T_=_a.____________________________________________________________ ||


aarrgg((_?_A_r_g_, _+_T_e_r_m_, _?_V_a_l_u_e))                                          _[_I_S_O_]
    _T_e_r_m  should be instantiated  to a term,  _A_r_g to an integer  between
    1  and  the  arity of  _T_e_r_m.    _V_a_l_u_e  is  unified with  the  _A_r_g-th
    argument  of _T_e_r_m.   _A_r_g may also  be unbound.   In this case  _V_a_l_u_e
    will  be unified  with the  successive arguments of  the term.    On
    successful  unification, _A_r_g  is unified  with the argument  number.
    Backtracking  yields alternative  solutions.    The predicate  arg/3
    fails  silently if  _A_r_g= 0 or _A_r_g > _a_r_i_t_y and raises  the exception
    domain_error(not_less_than_zero, _A_r_g)if _A_r_g <0.


_?_T_e_r_m =.. _?_L_i_s_t                                                   _[_I_S_O_]
    _L_i_s_t  is a list whose head is the functor of _T_e_r_m and  the remaining
    arguments  are  the arguments  of the  term.    Either side  of  the
    predicate  may be  a variable,  but  not both.    This predicate  is
    called `Univ'.

    ____________________________________________________________________|                                                                    |
    | ?- foo(hello, X) =.. List.                                         |
    | List = [foo, hello, X]                                             |
    |                                                                    |

    | ?- Term =.. [baz, foo(1)].                                         |
    ||Term_=_baz(foo(1))________________________________________________ ||

    SWI-Prolog   also  supports   terms  with   arity  0,   as  in   a()
    (see   section  ????.       Such   terms  must   be  processed   using
    compound_name_arguments/3.  This predicate raises a  domain error as
    shown below.  See also functor/3.

    ____________________________________________________________________|                                                                    |
    | ?- a() =.. L.                                                      |
    ||ERROR:_Domain_error:_`compound_non_zero_arity'_expected,_found_`a()'||_


ccoommppoouunndd__nnaammee__aarriittyy((_?_C_o_m_p_o_u_n_d_, _?_N_a_m_e_, _?_A_r_i_t_y))
    Rationalized  version  of functor/3  that  only works  for  compound
    terms and can  examine and create compound terms with zero arguments
    (e.g, name().  See also compound_name_arguments/3.


ccoommppoouunndd__nnaammee__aarrgguummeennttss((_?_C_o_m_p_o_u_n_d_, _?_N_a_m_e_, _?_A_r_g_u_m_e_n_t_s))
    Rationalized  version of =../2 that  can compose and decompose  com-
    pound terms with zero arguments.  See also compound_name_arity/3.


nnuummbbeerrvvaarrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_E_n_d))
    Unify  the free variables  in _T_e_r_m with a  term $VAR(_N), where _N  is
    the  number of  the variable.   Counting starts  at _S_t_a_r_t.   _E_n_d  is
    unified  with the number that should be given to the  next variable.
    The  example below illustrates this.  Note that the  toplevel prints
    '$VAR'(0)  as _A  due to  the numbervars(_t_r_u_e) option  used to  print
    answers.

    ____________________________________________________________________|                                                                    |
    | ?- Term = f(X,Y,X),                                                |
    |    numbervars(Term, 0, End),                                       |
    |    write_canonical(Term), nl.                                      |

    | f('$VAR'(0),'$VAR'(1),'$VAR'(0))                                   |
    | Term = f(A, B, A),                                                 |
    | X = A,                                                             |
    | Y = B,                                                             |
    ||End_=_2.__________________________________________________________ ||

    See also the numbervars option to write_term/3 and numbervars/4.


nnuummbbeerrvvaarrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_E_n_d_, _+_O_p_t_i_o_n_s))
    As numbervars/3, providing the following options:

    ffuunnccttoorr__nnaammee((_+_A_t_o_m))
         Name of the functor to use instead of $VAR.

    aattttvvaarr((_+_A_c_t_i_o_n))
         What to do if  an attributed variable is encountered.   Options
         are skip,  which causes numbervars/3  to ignore the  attributed
         variable,  bind  which  causes  it to  treat  it  as  a  normal
         variable  and  assign  the  next  '$VAR'(N)  term  to  it,   or
         (default) error which raises a type_error exception.

    ssiinngglleettoonnss((_+_B_o_o_l))
         If true  (default false),  numbervars/4  does singleton  detec-
         tion.    Singleton  variables  are  unified  with  '$VAR'('_'),
         causing  them  to  be  printed  as   _  by  write_term/2  using
         the  numbervars  option.      This   option  is  exploited   by
         portray_clause/2 and write_canonical/2.


vvaarr__nnuummbbeerr((_@_T_e_r_m_, _-_V_a_r_N_u_m_b_e_r))
    True  if  _T_e_r_m is  numbered  by numbervars/3  and _V_a_r_N_u_m_b_e_r  is  the
    number  given to this variable.  This predicate avoids the  need for
    unification  with '$VAR'(X)  and opens the  path for replacing  this
    valid Prolog term  by an internal representation that has no textual
    equivalent.


tteerrmm__vvaarriiaabblleess((_+_T_e_r_m_, _-_L_i_s_t))                                       _[_I_S_O_]
    Unify  _L_i_s_t with  a list of  variables, each  sharing with a  unique
    variable  of _T_e_r_m.   The variables in _L_i_s_t  are ordered in order  of
    appearance traversing _T_e_r_m  depth-first and left-to-right.  See also
    term_variables/3 and nonground/2.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- term_variables(a(X, b(Y, X), Z), L).                            |

    ||L_=_[X,_Y,_Z].____________________________________________________ ||


nnoonnggrroouunndd((_+_T_e_r_m_, _-_V_a_r))                                        _[_s_e_m_i_d_e_t_]
    True  when _V_a_r is a variable in _T_e_r_m.  Fails if _T_e_r_m  is _g_r_o_u_n_d (see
    ground/1).   This predicate is intended for coroutining to trigger a
    wakeup  if _T_e_r_m  becomes ground, e.g.,  using when/2.   The  current
    implemention  always  returns  the  first  variable  in  depth-first
    left-right search.   Ideally it should return a random member of the
    set  of variables  (see term_variables/2)  to realise  logarithmetic
    complexity  for the  ground trigger.   Compatible  with ECLiPSe  and
    hProlog.


tteerrmm__vvaarriiaabblleess((_+_T_e_r_m_, _-_L_i_s_t_, _?_T_a_i_l))
    Difference  list version of term_variables/2.  That is, _T_a_i_l  is the
    tail of the variable list _L_i_s_t.


tteerrmm__ssiinngglleettoonnss((_+_T_e_r_m_, _-_L_i_s_t))
    Unify  _L_i_s_t with a list of  variables, each sharing with a  variable
    that  appears only once in _T_e_r_m.   Note that, if a  variable appears
    in  a shared subterm, it  is _n_o_t considered singleton.   Thus, _A  is
    _n_o_t  a singleton  in  the example  below.   See  also the  singleton
    option of numbervars/4.

    ____________________________________________________________________|                                                                    |
    |                                                                    |

    | ?- S = a(A), term_singletons(t(S,S), L).                           |
    ||L_=_[].___________________________________________________________ ||


ccooppyy__tteerrmm((_+_I_n_, _-_O_u_t))                                               _[_I_S_O_]
    Create  a version  of _I_n  with renamed (fresh)  variables and  unify
    it  to  _O_u_t.    Attributed variables  (see  section ????)  have  their
    attributes  copied.    The  implementation of  copy_term/2 can  deal
    with  infinite  trees  (cyclic  terms).     As  pure  Prolog  cannot
    distinguish a ground  term from another ground term with exactly the
    same  structure, ground  sub-terms are  _s_h_a_r_e_d between  _I_n and  _O_u_t.
    Sharing  ground terms  does affect  setarg/3.   SWI-Prolog  provides
    duplicate_term/2 to create a true copy of a term.


44..2211..11 NNoonn--llooggiiccaall ooppeerraattiioonnss oonn tteerrmmss

Prolog is  not able to  _m_o_d_i_f_y instantiated  parts of a  term.   Lacking
that capability makes  the language much safer, but  unfortunately there
are problems that suffer severely in terms of time  and/or memory usage.
Always try hard  to avoid the use of  these primitives, but they can  be
a good alternative  to using dynamic predicates.   See also section  ????,
discussing the use of global variables.


sseettaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    Extra-logical  predicate.     Assigns the  _A_r_g-th  argument  of  the
    compound  term _T_e_r_m with the given _V_a_l_u_e.  The assignment  is undone
    if  backtracking brings the  state back into  a position before  the
    setarg/3 call.  See also nb_setarg/3.

    This  predicate may  be used  for destructive  assignment to  terms,
    using  them as an  extra-logical storage  bin.   Always try hard  to
    avoid  the use of  setarg/3 as  it is not  supported by many  Prolog
    systems  and one  has to  be very careful  about unexpected  copying
    as  well as  unexpected noncopying  of terms.   A  good practice  to
    improve somewhat on  this situation is to make sure that terms whose
    arguments  are  subject to  setarg/3 have  one  unused and  unshared
    variable  in addition to the used  arguments.  This variable  avoids
    unwanted  sharing in, e.g., copy_term/2,  and causes the term to  be
    considered  as non-ground.   An alternative is to  use put_attr/3 to
    attach information to attributed variables (see section ????).


nnbb__sseettaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    Assigns  the _A_r_g-th  argument  of the  compound term  _T_e_r_m with  the
    given  _V_a_l_u_e  as  setarg/3,   but  on  backtracking  the  assignment
    is  _n_o_t  reversed.    If  _V_a_l_u_e  is not  atomic,  it  is  duplicated
    using  duplicate_term/2.   This  predicate uses  the same  technique
    as  nb_setval/2.     We  therefore  refer   to  the  description  of
    nb_setval/2  for details on  non-backtrackable assignment of  terms.
    This  predicate is  compatible with GNU-Prolog  setarg(_A_,_T_,_V_,_f_a_l_s_e),
    removing  the type  restriction on  _V_a_l_u_e.   See  also nb_linkarg/3.
    Below  is  an example  for counting  the number  of  solutions of  a
    goal.    Note  that this  implementation is  thread-safe,  reentrant
    and  capable of handling exceptions.  Realising these  features with
    a  traditional implementation based  on assert/retract or flag/3  is
    much more complicated.

    ____________________________________________________________________|                                                                    |
    | :- meta_predicate                                                  |

    |         succeeds_n_times(0, -).                                    |
    |                                                                    |
    | succeeds_n_times(Goal, Times) :-                                   |
    |         Counter = counter(0),                                      |
    |         (   Goal,                                                  |
    |             arg(1, Counter, N0),                                   |
    |             N is N0 + 1,                                           |
    |             nb_setarg(1, Counter, N),                              |

    |             fail                                                   |
    |         ;   arg(1, Counter, Times)                                 |
    ||________).________________________________________________________ ||


nnbb__lliinnkkaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    As  nb_setarg/3,  but like nb_linkval/2 it does _n_o_t duplicate  _V_a_l_u_e.
    Use with  extreme care and consult the documentation of nb_linkval/2
    before use.


dduupplliiccaattee__tteerrmm((_+_I_n_, _-_O_u_t))
    Version  of copy_term/2 that also copies ground terms  and therefore
    ensures  that  destructive  modification  using  setarg/3  does  not
    affect  the copy.   See also  nb_setval/2,  nb_linkval/2, nb_setarg/3
    and nb_linkarg/3.


ssaammee__tteerrmm((_@_T_1_, _@_T_2))                                            _[_s_e_m_i_d_e_t_]
    True  if _T_1 and _T_2 are  equivalent and will remain equivalent,  even
    if  setarg/3 is  used  on either  of them.    This means  _T_1 and  _T_2
    are  the same variable,  equivalent atomic data  or a compound  term
    allocated at the same address.


44..2222 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg AAttoommss

These  predicates  convert   between  Prolog  constants  and  lists   of
character codes.  The predicates atom_codes/2, number_codes/2 and name/2
behave the same when  converting from a constant to a list  of character
codes.     When converting  the  other  way  around,  atom_codes/2  will
generate an  atom, number_codes/2  will generate a  number or  exception
and name/2 will return a number if possible and an atom otherwise.

The ISO standard  defines atom_chars/2 to describe the `broken-up'  atom
as  a list  of one-character  atoms instead  of a  list of  codes.    Up
to  version 3.2.x,  SWI-Prolog's  atom_chars/2 behaved  like atom_codes,
compatible with  Quintus and SICStus  Prolog.   As of 3.3.x,  SWI-Prolog
atom_codes/2 and atom_chars/2are compliant to the ISO standard.

To  ease  the pain  of  all  variations in  the  Prolog  community,  all
SWI-Prolog predicates  behave as  flexible as  possible.   This  implies
the  `list-side' accepts  either  a code-list  or  a char-list  and  the
`atom-side' accepts all atomic types (atom, number and string).


aattoomm__ccooddeess((_?_A_t_o_m_, _?_S_t_r_i_n_g))                                         _[_I_S_O_]
    Convert  between an atom and a list of character codes.   If _A_t_o_m is
    instantiated,  it will be translated into a list of  character codes
    and  the result  is unified with  _S_t_r_i_n_g.   If _A_t_o_m  is unbound  and
    _S_t_r_i_n_g  is a list of character  codes, _A_t_o_m will be unified  with an
    atom constructed from this list.


aattoomm__cchhaarrss((_?_A_t_o_m_, _?_C_h_a_r_L_i_s_t))                                       _[_I_S_O_]
    As  atom_codes/2, but  _C_h_a_r_L_i_s_t  is a  list of  one-character  atoms
    rather than a list of character codes.

    ____________________________________________________________________|                                                                    |
    | ?- atom_chars(hello, X).                                           |
    |                                                                    |
    ||X_=_[h,_e,_l,_l,_o]_______________________________________________ ||


cchhaarr__ccooddee((_?_A_t_o_m_, _?_C_o_d_e))                                            _[_I_S_O_]
    Convert  between character and character  code for a single  charac-
    ter.


nnuummbbeerr__cchhaarrss((_?_N_u_m_b_e_r_, _?_C_h_a_r_L_i_s_t))                                   _[_I_S_O_]
    Similar  to  atom_chars/2,  but  converts between  a number  and  its
    representation  as a list  of one-character atoms.   If _C_h_a_r_L_i_s_t  is
    a  _p_r_o_p_e_r _l_i_s_t,  i.e., not unbound  or a  _p_a_r_t_i_a_l _l_i_s_t, _C_h_a_r_L_i_s_t  is
    parsed according to  the Prolog syntax for numbers and the resulting
    number  is unified with _N_u_m_b_e_r.   Otherwise, if _N_u_m_b_e_r is  a number,
    _N_u_m_b_e_r is serialized and the result is unified with _C_h_a_r_L_i_s_t.

    If  _C_h_a_r_L_i_s_t is  parsed, it is  parsed using  the Prolog syntax  for
    numbers.   Following the ISO  standard, it allows for _l_e_a_d_i_n_g  white
    space  (including newlines)  and does not  allow for _t_r_a_i_l_i_n_g  white
    space.    A syntax_error exception  is raised if  _C_h_a_r_L_i_s_t does  not
    represent a valid Prolog number.


nnuummbbeerr__ccooddeess((_?_N_u_m_b_e_r_, _?_C_o_d_e_L_i_s_t))                                   _[_I_S_O_]
    As number_chars/2, but converts to a list  of character codes rather
    than  one-character  atoms.   In  the  mode (-,+),  both  predicates
    behave identically to improve handling of non-ISO source.


aattoomm__nnuummbbeerr((_?_A_t_o_m_, _?_N_u_m_b_e_r))
    Realises  the popular combination of atom_codes/2 and number_codes/2
    to   convert  between  atom  and   number  (integer  or  float)   in
    one  predicate,   avoiding  the  intermediate  list.     Unlike  the
    ISO  number_codes/2  predicates,  atom_number/2  fails  silently  in
    mode  (+,-)  if  _A_t_o_m  does  not  represent a  number.     See  also
    atomic_list_concat/2 for assembling an atom from atoms and numbers.


nnaammee((_?_A_t_o_m_i_c_, _?_C_o_d_e_L_i_s_t))
    _C_o_d_e_L_i_s_t  is a list  of character codes  representing the same  text
    as  _A_t_o_m_i_c.    Each of  the arguments  may be  a variable,  but  not
    both.   When _C_o_d_e_L_i_s_t describes an integer or floating  point number
    and  _A_t_o_m_i_c is a variable, _A_t_o_m_i_c  will be unified with the  numeric
    value  described by  _C_o_d_e_L_i_s_t (e.g.,  name(N, "300"), 400 is N + 100
    succeeds).    If  _C_o_d_e_L_i_s_t  is not  a  representation of  a  number,
    _A_t_o_m_i_c  will be unified  with the  atom with the  name given by  the
    character  code list.  If _A_t_o_m_i_c is an atom or number,  the unquoted
    print representation of  it as a character code list is unified with
    _C_o_d_e_L_i_s_t.

    This  predicate  is part  of the  Edinburgh tradition.    It  should
    be  considered _d_e_p_r_e_c_a_t_e_d  although,  given its  long tradition,  it
    is  unlikely to  be removed  from the  system.   It  still has  some
    value  for converting input  to, depending on  the syntax, a  number
    or atom.   New code should consider the ISO predicates atom_codes/2,
    number_codes/2 or the SWI-Prolog predicate atom_number/2.


tteerrmm__ttoo__aattoomm((_?_T_e_r_m_, _?_A_t_o_m))
    True  if  _A_t_o_m describes  a  term  that unifies  with  _T_e_r_m.    When
    _A_t_o_m  is instantiated, _A_t_o_m  is parsed and  the result unified  with
    _T_e_r_m.    If _A_t_o_m has  no valid syntax,  a syntax_error exception  is
    raised.   Otherwise _T_e_r_m  is ``written'' on _A_t_o_m  using write_term/2
    with  the option quoted(_t_r_u_e).   See also format/3, with_output_to/2
    and term_string/2.


aattoomm__ttoo__tteerrmm((_+_A_t_o_m_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))                       _[_d_e_p_r_e_c_a_t_e_d_]
    Use  _A_t_o_m as  input to  read_term/2 using the  option variable_names
    and  return  the read  term in  _T_e_r_m and  the  variable bindings  in
    _B_i_n_d_i_n_g_s.   _B_i_n_d_i_n_g_s is a list of _N_a_m_e =_V_a_r couples, thus providing
    access  to the actual  variable names.   See  also read_term/2.   If
    _A_t_o_m  has no valid syntax, a syntax_error exception is raised.   New
    code should use read_term_from_atom/3.


aattoomm__ccoonnccaatt((_?_A_t_o_m_1_, _?_A_t_o_m_2_, _?_A_t_o_m_3))                                _[_I_S_O_]
    _A_t_o_m_3  forms the concatenation  of _A_t_o_m_1  and _A_t_o_m_2.   At least  two
    of  the arguments  must be instantiated  to atoms.   This  predicate
    also  allows for the  mode (-,-,+), non-deterministically  splitting
    the  3rd  argument into  two  parts (as  append/3 does  for  lists).
    SWI-Prolog  allows for  atomic arguments.   Portable  code must  use
    atomic_concat/3 if non-atom arguments are involved.


aattoommiicc__ccoonnccaatt((_+_A_t_o_m_i_c_1_, _+_A_t_o_m_i_c_2_, _-_A_t_o_m))
    _A_t_o_m  represents the  text after converting  _A_t_o_m_i_c_1 and _A_t_o_m_i_c_2  to
    text and concatenating the result:

    ____________________________________________________________________|                                                                    |
    | ?- atomic_concat(name, 42, X).                                     |

    ||X_=_name42._______________________________________________________ ||


aattoommiicc__lliisstt__ccoonnccaatt((_+_L_i_s_t_, _-_A_t_o_m))                               _[_c_o_m_m_o_n_s_]
    _L_i_s_t  is  a  list of  strings,  atoms,  integers or  floating  point
    numbers.    Succeeds if _A_t_o_m  can be  unified with the  concatenated
    elements  of  _L_i_s_t.     Equivalent to  atomic_list_concat(_L_i_s_t_,  _'_'_,
    _A_t_o_m).


aattoommiicc__lliisstt__ccoonnccaatt((_+_L_i_s_t_, _+_S_e_p_a_r_a_t_o_r_, _-_A_t_o_m))                   _[_c_o_m_m_o_n_s_]
    Creates  an atom just like atomic_list_concat/2, but  inserts _S_e_p_a_r_a_-
    _t_o_r between each pair of inputs.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- atomic_list_concat([gnu, gnat], ', ', A).                       |
    |                                                                    |
    ||A_=_'gnu,_gnat'___________________________________________________ ||

    The  SWI-Prolog version of this predicate can also be used  to split
    atoms  by  instantiating _S_e_p_a_r_a_t_o_r  and _A_t_o_m  as shown  below.    We
    kept  this functionality  to  simplify porting  old SWI-Prolog  code
    where  this  predicate  was called  concat_atom/3.    When  used  in
    mode  (-,+,+),  _S_e_p_a_r_a_t_o_r  must  be a  non-empty  atom.    See  also
    split_string/4.

    ____________________________________________________________________|                                                                    |

    | ?- atomic_list_concat(L, -, 'gnu-gnat').                           |
    |                                                                    |
    ||L_=_[gnu,_gnat]___________________________________________________ ||


aattoomm__lleennggtthh((_+_A_t_o_m_, _-_L_e_n_g_t_h))                                        _[_I_S_O_]
    True  if _A_t_o_m  is  an atom  of _L_e_n_g_t_h  characters.   The  SWI-Prolog
    version  accepts  all  atomic  types,  as  well  as  code-lists  and
    character-lists.     New code  should  avoid  this feature  and  use
    write_length/3  to  get  the  number of  characters  that  would  be
    written if the argument was handed to write_term/3.


aattoomm__pprreeffiixx((_+_A_t_o_m_, _+_P_r_e_f_i_x))                                 _[_d_e_p_r_e_c_a_t_e_d_]
    True if _A_t_o_m starts  with the characters from _P_r_e_f_i_x.  Its behaviour
    is equivalent to ?- sub_atom(_A_t_o_m, 0, _, _, _P_r_e_f_i_x).  Deprecated.


ssuubb__aattoomm((_+_A_t_o_m_, _?_B_e_f_o_r_e_, _?_L_e_n_, _?_A_f_t_e_r_, _?_S_u_b))                       _[_I_S_O_]
    ISO  predicate  for breaking  atoms.    It maintains  the  following
    relation:  _S_u_b is  a sub-atom of _A_t_o_m that starts at _B_e_f_o_r_e, has _L_e_n
    characters, and _A_t_o_m contains _A_f_t_e_r characters after the match.

    ____________________________________________________________________|                                                                    |
    | ?- sub_atom(abc, 1, 1, A, S).                                      |
    |                                                                    |

    ||A_=_1,_S_=_b______________________________________________________ ||

    The implementation  minimises non-determinism and creation of atoms.
    This  is  a  flexible predicate  that  can do  search,  prefix-  and
    suffix-matching, etc.


ssuubb__aattoomm__iiccaasseecchhkk((_+_H_a_y_s_t_a_c_k_, _?_S_t_a_r_t_, _+_N_e_e_d_l_e))                  _[_s_e_m_i_d_e_t_]
    True  when _N_e_e_d_l_e is a sub atom of _H_a_y_s_t_a_c_k starting at _S_t_a_r_t.   The
    match is `half  case insensitive', i.e., uppercase letters in _N_e_e_d_l_e
    only match themselves,  while lowercase letters in _N_e_e_d_l_e match case
    insensitively.   _S_t_a_r_t is  the first 0-based offset inside  _H_a_y_s_t_a_c_k
    where _N_e_e_d_l_e matches.


44..2233 LLooccaalliizzaattiioonn ((llooccaallee)) ssuuppppoorrtt

SWI-Prolog   provides   (currently  limited)   support   for   localized
applications.

  o The  predicates char_type/2 and code_type/2 query character  classes
    depending on the locale.

  o The  predicates collation_key/2  and locale_sort/2 can  be used  for
    locale dependent sorting of atoms.

  o The  predicate format_time/3  can be used  to format  time and  date
    representations, where some of the specifiers are locale dependent.

  o The   predicate  format/2  provides  locale-specific  formating   of
    numbers.     This functionality  is  based  on a  more  fine-grained
    localization model that is the subject of this section.

A  locale  is  a  (optionally  named)  read-only  object  that  provides
information to locale specific functions.  The system  creates a default
locale object  named default  from the system  locale.   This locale  is
used as  the initial locale  for the three standard  streams as well  as
the main thread.   Locale sensitive  output predicates such as  format/3
get their  locale from the  stream to which  they deliver their  output.
New streams get  their locale from the  thread that created the  stream.
Threads get their locale from the thread that created them.


llooccaallee__ccrreeaattee((_-_L_o_c_a_l_e_, _+_D_e_f_a_u_l_t_, _+_O_p_t_i_o_n_s))
    Create  a new locale object.   _D_e_f_a_u_l_t is either an existing  locale
    or  a string  that  denotes the  name of  a locale  provided by  the
    system,  such as "en_EN.UTF-8".   The  values read from the  default
    locale can be modified using _O_p_t_i_o_n_s.  _O_p_t_i_o_n_s provided are:

    aalliiaass((_+_A_t_o_m))
         Give the locale a name.

    ddeecciimmaall__ppooiinntt((_+_A_t_o_m))
         Specify the decimal point to use.

    tthhoouussaannddss__sseepp((_+_A_t_o_m))
         Specify the string that delimits digit groups.   Only effective
         is grouping is also specified.

    ggrroouuppiinngg((_+_L_i_s_t))
         Specify the grouping  of digits.   Groups are created from  the
         right (least  significant) digits, left  of the decimal  point.
         _L_i_s_t is a list of integers, specifying the number  of digits in
         each group, counting  from the right.   If the last element  is
         repeat(_C_o_u_n_t), the  remaining digits are  grouped in groups  of
         size _C_o_u_n_t.   If the last element  is a normal integer,  digits
         further to the left are not grouped.

    For example, the English locale uses

    ____________________________________________________________________|                                                                    |

    ||[_decimal_point('.'),_thousands_sep(','),_grouping([repeat(3)])_]_ ||

    Named    locales   exists   until    they   are   destroyed    using
    locale_destroy/1  and   they  are  no   longer  referenced.      Un-
    named locales are subject to (atom) garbage collection.


llooccaallee__ddeessttrrooyy((_+_L_o_c_a_l_e))
    Destroy  a locale.   If the locale is  named, this removes the  name
    association  from the locale, after which  the locale is left to  be
    reclaimed by garbage collection.


llooccaallee__pprrooppeerrttyy((_?_L_o_c_a_l_e_, _?_P_r_o_p_e_r_t_y))
    True  when _L_o_c_a_l_e  has _P_r_o_p_e_r_t_y.   Properties  are the  same as  the
    _O_p_t_i_o_n_s described with locale_create/3.


sseett__llooccaallee((_+_L_o_c_a_l_e))
    Set  the  default  locale  for  the  current  thread,   as  well  as
    the  locale  for  the  standard  streams  (user_input,  user_output,
    user_error, current_output and  current_input.   This locale is  used
    for  new streams, unless  overruled using the locale(_L_o_c_a_l_e)  option
    of open/4 or set_stream/2.


ccuurrrreenntt__llooccaallee((_-_L_o_c_a_l_e))
    True when _L_o_c_a_l_e is the locale of the calling thread.


44..2244 CChhaarraacctteerr pprrooppeerrttiieess

SWI-Prolog   offers  two   comprehensive  predicates   for   classifying
characters  and  character   codes.     These  predicates  are   defined
as  built-in  predicates to  exploit  the  C-character  classification's
handling  of  _l_o_c_a_l_e  (handling  of  local  character  sets).      These
predicates are fast, logical and deterministic if applicable.

In addition,  there is the  library ctypes providing compatibility  with
some other Prolog systems.   The predicates of this library  are defined
in terms of code_type/2.


cchhaarr__ttyyppee((_?_C_h_a_r_, _?_T_y_p_e))
    Tests or generates  alternative _T_y_p_es or _C_h_a_rs.  The character types
    are inspired by the standard C <ctype.h>  primitives.  Note that the
    mode  (-,+) is  only efficient if  the _T_y_p_e has  a parameter,  e.g.,
    char_type(_C_,  _d_i_g_i_t_(_8_)).   With  an atomic  _T_y_p_e  the whole  unicode
    range  (0..0x1ffff) is generated and tested against the  C character
    classification function.

    aallnnuumm
         _C_h_a_r is a letter (upper- or lowercase) or digit.

    aallpphhaa
         _C_h_a_r is a letter (upper- or lowercase).

    ccssyymm
         _C_h_a_r  is a  letter  (upper- or  lowercase),  digit or  the  un-
         derscore  (_).      These  are   valid  C  and  Prolog   symbol
         characters.

    ccssyymmff
         _C_h_a_r is a letter  (upper- or lowercase) or the  underscore (_).
         These are valid first characters for C and Prolog symbols.

    aasscciiii
         _C_h_a_r is a 7-bit ASCII character (0..127).

    wwhhiittee
         _C_h_a_r is a space or tab, i.e. white space inside a line.

    ccnnttrrll
         _C_h_a_r is an ASCII  control character (0..31), ASCII DEL  charac-
         ter (127),  or  non-ASCII character  in the  range 128..159  or
         8232..8233.

    ddiiggiitt
         _C_h_a_r is a digit.

    ddiiggiitt((_W_e_i_g_h_t))
         _C_h_a_r is a digit with value _W_e_i_g_h_t.  I.e. char_type(X, digit(6))
         yields _X = '6'.  Useful for parsing numbers.

    xxddiiggiitt((_W_e_i_g_h_t))
         _C_h_a_r  is  a  hexadecimal  digit  with  value  _W_e_i_g_h_t.      I.e.
         char_type(a, xdigit(X)) yields _X  = '10'.   Useful for  parsing
         numbers.

    ggrraapphh
         _C_h_a_r produces  a visible mark  on a  page when printed.    Note
         that the space is not included!

    lloowweerr
         _C_h_a_r is a lowercase letter.

    lloowweerr((_U_p_p_e_r))
         _C_h_a_r is a  lowercase version of  _U_p_p_e_r.   Only true if _C_h_a_r  is
         lowercase and _U_p_p_e_r uppercase.

    ttoo__lloowweerr((_U_p_p_e_r))
         _C_h_a_r is  a lowercase  version of _U_p_p_e_r.    For non-letters,  or
         letter without case,  _C_h_a_r and  _L_o_w_e_r are the same.   See  also
         upcase_atom/2 and downcase_atom/2.

    uuppppeerr
         _C_h_a_r is an uppercase letter.

    uuppppeerr((_L_o_w_e_r))
         _C_h_a_r is an  uppercase version of _L_o_w_e_r.   Only true if _C_h_a_r  is
         uppercase and _L_o_w_e_r lowercase.

    ttoo__uuppppeerr((_L_o_w_e_r))
         _C_h_a_r is  an uppercase version  of _L_o_w_e_r.   For non-letters,  or
         letter without case,  _C_h_a_r and  _L_o_w_e_r are the same.   See  also
         upcase_atom/2 and downcase_atom/2.

    ppuunncctt
         _C_h_a_r is  a punctuation character.   This  is a graph  character
         that is not a letter or digit.

    ssppaaccee
         _C_h_a_r is  some  form of  layout  character (tab,  vertical  tab,
         newline, etc.).

    eenndd__ooff__ffiillee
         _C_h_a_r is -1.

    eenndd__ooff__lliinnee
         _C_h_a_r ends a line (ASCII: 10..13).

    nneewwlliinnee
         _C_h_a_r is a newline character (10).

    ppeerriioodd
         _C_h_a_r counts as the end of a sentence (.,!,?).

    qquuoottee
         _C_h_a_r is a quote character (", ', `).

    ppaarreenn((_C_l_o_s_e))
         _C_h_a_r is  an open  parenthesis  and _C_l_o_s_e  is the  corresponding
         close parenthesis.

    pprroolloogg__vvaarr__ssttaarrtt
         _C_h_a_r can start a Prolog variable name.

    pprroolloogg__aattoomm__ssttaarrtt
         _C_h_a_r can start a unquoted Prolog atom that is not a symbol.

    pprroolloogg__iiddeennttiiffiieerr__ccoonnttiinnuuee
         _C_h_a_r can continue a Prolog variable name or atom.

    pprroolloogg__ssyymmbbooll
         _C_h_a_r is a Prolog symbol character.  Sequences  of Prolog symbol
         characters glue together  to form an  unquoted atom.   Examples
         are =.., \=, etc.


ccooddee__ttyyppee((_?_C_o_d_e_, _?_T_y_p_e))
    As  char_type/2,  but uses character codes rather than  one-character
    atoms.     Please note  that  both  predicates are  as  flexible  as
    possible.    They handle  either representation if  the argument  is
    instantiated  and will instantiate  only with an  integer code or  a
    one-character  atom, depending of  the version used.   See also  the
    Prolog flag double_quotes, atom_chars/2 and atom_codes/2.


44..2244..11 CCaassee ccoonnvveerrssiioonn

There is nothing in  the Prolog standard for converting case  in textual
data.    The SWI-Prolog  predicates code_type/2 and  char_type/2 can  be
used to test  and convert individual characters.   We have started  some
additional support:


ddoowwnnccaassee__aattoomm((_+_A_n_y_C_a_s_e_, _-_L_o_w_e_r_C_a_s_e))
    Converts  the characters  of _A_n_y_C_a_s_e  into lowercase  as char_type/2
    does  (i.e. based on  the defined _l_o_c_a_l_e  if Prolog provides  locale
    support  on the  hosting platform)  and unifies  the lowercase  atom
    with _L_o_w_e_r_C_a_s_e.


uuppccaassee__aattoomm((_+_A_n_y_C_a_s_e_, _-_U_p_p_e_r_C_a_s_e))
    Converts, similar to downcase_atom/2, an atom to uppercase.


44..2244..22 WWhhiittee ssppaaccee nnoorrmmaalliizzaattiioonn


nnoorrmmaalliizzee__ssppaaccee((_-_O_u_t_, _+_I_n))
    Normalize  white  space in  _I_n.    All  leading and  trailing  white
    space  is removed.  All non-empty sequences for Unicode  white space
    characters  are replaced by a single space (\u0020) character.   _O_u_t
    uses the same conventions as with_output_to/2 and format/3.


44..2244..33 LLaanngguuaaggee--ssppeecciiffiicc ccoommppaarriissoonn

This  section  deals   with  predicates  for  language-specific   string
comparison operations.


ccoollllaattiioonn__kkeeyy((_+_A_t_o_m_, _-_K_e_y))
    Create  a _K_e_y from _A_t_o_m for locale-specific comparison.  The  key is
    defined  such that if the key of atom A precedes the  key of atom B
    in the  standard order of terms, A is alphabetically smaller than B
    using the sort order of the current locale.

    The   predicate  collation_key/2  is  used  by   locale_sort/2  from
    library(sort).   Please examine the  implementation of locale_sort/2
    as an example of using this call.

    The  _K_e_y  is  an  implementation-defined  and  generally  unreadable
    string.   On  systems that  do not support  locale handling, _K_e_y  is
    simply unified with _A_t_o_m.


llooccaallee__ssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Sort  a list of atoms using the current  locale.  _L_i_s_t is a  list of
    atoms  or string objects (see section  ????).  _S_o_r_t_e_d is unified  with
    a  list containing all  atoms of  _L_i_s_t, sorted to  the rules of  the
    current locale.  See also collation_key/2 and setlocale/3.


44..2255 OOppeerraattoorrss

Operators  are  defined  to improve  the  readability  of  source  code.
For  example, without  operators, to  write  2*3+4*5 one  would have  to
write +(*(2,3),*(4,5)).    In Prolog,  a number of  operators have  been
predefined.   All operators, except for  the comma (,) can be  redefined
by the user.

Some care  has to  be taken  before defining  new operators.    Defining
too many  operators might  make your  source `natural'  looking, but  at
the same  time make  it hard to  understand the  limits of your  syntax.
To ease  the pain, as  of SWI-Prolog 3.3.0,  operators are local to  the
module  in which  they are  defined.   Operators  can  be exported  from
modules  using a  term op(_P_r_e_c_e_d_e_n_c_e_,  _T_y_p_e_,  _N_a_m_e) in  the export  list
as  specified by  module/2.    Many modern  Prolog systems  have  module
specific operators.   Unfortunately,  there is no established  interface
for  exporting and  importing operators.    SWI-Prolog's convention  has
been addopted by YAP.

The  module table  of the  module user  acts as  default  table for  all
modules  and  can  be  modified  explicitly  from  inside  a  module  to
achieve compatibility  with other Prolog that  do not have  module-local
operators:

________________________________________________________________________|                                                                        |
|:- module(prove,                                                        |

|          [ prove/1                                                     |
|          ]).                                                           |
|                                                                        |
|:-|op(900,_xfx,_user:(=>)).____________________________________________ |  |

In SWI-Prolog, a _q_u_o_t_e_d  _a_t_o_m never acts as an operator.  Note  that the
portable way to stop an  atom acting as an operator is to enclose  it in
parentheses like this:  (myop).  See also section ????.


oopp((_+_P_r_e_c_e_d_e_n_c_e_, _+_T_y_p_e_, _:_N_a_m_e))                                     _[_I_S_O_]
    Declare  _N_a_m_e  to  be  an  operator of  type  _T_y_p_e  with  precedence
    _P_r_e_c_e_d_e_n_c_e.    _N_a_m_e  can also  be a  list of  names,  in which  case
    all  elements of the  list are declared  to be identical  operators.
    _P_r_e_c_e_d_e_n_c_e  is an integer between 0 and 1200.  Precedence  0 removes
    the  declaration.  _T_y_p_e  is one of:   xf, yf, xfx,  xfy, yfx, fy  or
    fx.   The `f' indicates the  position of the functor, while x  and y
    indicate  the position of the arguments.  `y' should  be interpreted
    as  ``on this position a term with precedence lower or equal  to the
    precedence  of the functor should occur''.   For `x' the  precedence
    of  the argument must be strictly lower.   The precedence of  a term
    is  0, unless its  principal functor is an  operator, in which  case
    the precedence is the  precedence of this operator.  A term enclosed
    in parentheses (...) has precedence 0.

    The  predefined operators  are shown  in table  ????.   Operators  can
    be  redefined, unless  prohibited by one  of the limitations  below.
    Applications  must be careful  with (re-)defining operators  because
    changing  operators  may  cause  (other)  files  to  be  interpreted
    ddiiffffeerreennttllyy.   Often  this will lead  to a syntax error.   In  other
    cases,  text is read silently into  a different term which may  lead
    to subtle and difficult to track errors.

      o  It is not allowed to redefine the comma (',').

      o  The bar  (|) can only  be (re-)defined  as infix operator  with
         priority not less than 1001.

      o  It  is not  allowed  to  define  the empty  list  ([])  or  the
         curly-bracket pair ({}) as operators.

    In   SWI-Prolog,  operators  are   _l_o_c_a_l  to  a  module  (see   also
    section  ????).   Keeping  operators in modules  and using  controlled
    import/export of operators  as described with the module/2 directive
    keep  the  issues  manageable.    The  module  system  provides  the
    operators  from table  ???? and  these operators  cannot be  modified.
    Files  that  are  loaded  from the  SWI-Prolog  directories  resolve
    operators  and predicates from this system module rather  than user,
    which  makes the  semantics of  the library  and development  system
    modules independent of operator changes to the user module.
     ______________________________________________________________
     | 1200 |xfx  |-->, :-                                        |

     | 1200 | fx  |:-, ?-                                         |
     | 1150 | fx  |dynamic,    discontiguous,     initialization, |
     |      |     |meta_predicate,  module_transparent, multifile,|
     |      |     |public,  thread_local,   thread_initialization,|
     |      |     |volatile                                       |
     | 1100 |xfy  |;, |                                           |
     | 1050 |xfy  |->, *->                                        |
     | 1000 |xfy  |,                                              |

     |  990 |xfx  |:=                                             |
     |  900 | fy  |\+                                             |
     |  700 |xfx  |<, =, =.., =@=, \=@=, =:=, =<, ==, =\=, >, >=, |
     |      |     |@<, @=<, @>, @>=, \=, \==, as, is, >:<, :<     |
     |  600 |xfy  |:                                              |
     |  500 | yfx |+, -, /\, \/, xor                              |
     |  500 | fx  |?                                              |

     |  400 | yfx |*, /, //, div, rdiv, <<, >>, mod, rem          |
     |  200 |xfx  |**                                             |
     |  200 |xfy  |^                                              |
     |  200 | fy  |+, -, \                                        |
     |  100 | yfx |.                                              |
     |____1_|_fx__|$______________________________________________|_

                      Table 4.2:  System operators


ccuurrrreenntt__oopp((_?_P_r_e_c_e_d_e_n_c_e_, _?_T_y_p_e_, _?_:_N_a_m_e))                             _[_I_S_O_]
    True  if _N_a_m_e is currently defined as an operator of type  _T_y_p_e with
    precedence _P_r_e_c_e_d_e_n_c_e.  See also op/3.


44..2266 CChhaarraacctteerr CCoonnvveerrssiioonn

Although  I  wouldn't really  know  why  you  would like  to  use  these
features, they are provided for ISO compliance.


cchhaarr__ccoonnvveerrssiioonn((_+_C_h_a_r_I_n_, _+_C_h_a_r_O_u_t))                                 _[_I_S_O_]
    Define  that term input  (see read_term/3) maps each character  read
    as  _C_h_a_r_I_n to the character _C_h_a_r_O_u_t.   Character conversion is  only
    executed  if  the Prolog  flag char_conversion is  set  to true  and
    not  inside quoted atoms  or strings.   The initial table maps  each
    character onto itself.  See also current_char_conversion/2.


ccuurrrreenntt__cchhaarr__ccoonnvveerrssiioonn((_?_C_h_a_r_I_n_, _?_C_h_a_r_O_u_t))                         _[_I_S_O_]
    Queries   the   current   character   conversion   table.        See
    char_conversion/2 for details.


44..2277 AArriitthhmmeettiicc

Arithmetic can be  divided into some special purpose integer  predicates
and  a series  of general  predicates for  integer,  floating point  and
rational arithmetic as  appropriate.  The general arithmetic  predicates
all handle _e_x_p_r_e_s_s_i_o_n_s.   An expression is  either a simple number or  a
_f_u_n_c_t_i_o_n.  The  arguments of a function are expressions.   The functions
are described in section ????.


44..2277..11 SSppeecciiaall ppuurrppoossee iinntteeggeerr aarriitthhmmeettiicc

The predicates in  this section provide more logical operations  between
integers.  They  are not covered by the ISO standard, although  they are
`part of the community' and found as either library  or built-in in many
other Prolog systems.


bbeettwweeeenn((_+_L_o_w_, _+_H_i_g_h_, _?_V_a_l_u_e))
    _L_o_w  and _H_i_g_h are  integers, _H_i_g_h >=_L_o_w.   If  _V_a_l_u_e is an  integer,
    _L_o_w=< _V_a_l_u_e=< _H_i_g_h.   When _V_a_l_u_e  is a  variable it is  successively
    bound  to  all integers  between  _L_o_w and  _H_i_g_h.    If _H_i_g_h  is  inf
    or  infinite between/3 is  true iff _V_a_l_u_e>= _L_o_w,  a feature that  is
    particularly  interesting  for generating  integers from  a  certain
    value.


ssuucccc((_?_I_n_t_1_, _?_I_n_t_2))
    True  if _I_n_t_2= _I_n_t_1+1  and _I_n_t_1>=0.   At least one of the arguments
    must  be instantiated to  a natural number.   This predicate  raises
    the  domain  error  not_less_than_zero  if  called  with  a  negative
    integer.   E.g. succ(_X_, _0)  fails silently and succ(_X_, _-_1) raises  a
    domain error.


pplluuss((_?_I_n_t_1_, _?_I_n_t_2_, _?_I_n_t_3))
    True  if _I_n_t_3 =_I_n_t_1 +_I_n_t_2.    At least two  of the  three arguments
    must be instantiated to integers.


ddiivvmmoodd((_+_D_i_v_i_d_e_n_d_, _+_D_i_v_i_s_o_r_, _-_Q_u_o_t_i_e_n_t_, _-_R_e_m_a_i_n_d_e_r))
    This  predicate is a shorthand  for computing both the _Q_u_o_t_i_e_n_t  and
    _R_e_m_a_i_n_d_e_r  of two integers in a  single operation.  This allows  for
    exploiting the fact  that the low level implementation for computing
    the  quotient also  produces the  remainder.   Timing confirms  that
    this  predicate is  almost  twice as  fast as  performing the  steps
    independently.  Semantically, divmod/4 is defined as below.

    ____________________________________________________________________|                                                                    |
    | divmod(Dividend, Divisor, Quotient, Remainder) :-                  |

    |         Quotient  is Dividend div Divisor,                         |
    ||________Remainder_is_Dividend_mod_Divisor.________________________ ||

    Note  that  this  predicate  is  only  available  if  SWI-Prolog  is
    compiled  with unbounded integer support.  This is the case  for all
    packaged versions.


nntthh__iinntteeggeerr__rroooott__aanndd__rreemmaaiinnddeerr((_+_N_, _+_I_, _-_R_o_o_t_, _-_R_e_m_a_i_n_d_e_r))
    True  when  Root to the power N+ Remainder= I.    _N and  _I must  be
    integers.   _N must be one or more.   If _I is negative and _N  is _o_d_d,
    _R_o_o_t  and  _R_e_m_a_i_n_d_e_r are  negative, i.e.,  the  following holds  for
    _I <0:

    ____________________________________________________________________|                                                                    |
    | %   I < 0,                                                         |
    | %   N mod 2 =\= 0,                                                 |
    |     nth_integer_root_and_remainder(                                |

    |         N, I, Root, Remainder),                                    |
    |     IPos is -I,                                                    |
    |     nth_integer_root_and_remainder(                                |
    |         N, IPos, RootPos, RemainderPos),                           |
    |     Root =:= -RootPos,                                             |
    ||____Remainder_=:=_-RemainderPos.__________________________________ ||


44..2277..22 GGeenneerraall ppuurrppoossee aarriitthhmmeettiicc

The  general   arithmetic  predicates   are  optionally  compiled   (see
set_prolog_flag/2  and  the   -O  command  line   option).      Compiled
arithmetic reduces global  stack requirements and improves  performance.
Unfortunately compiled arithmetic cannot  be traced, which is why  it is
optional.


_+_E_x_p_r_1 > _+_E_x_p_r_2                                                   _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a larger number than _E_x_p_r_2.


_+_E_x_p_r_1 < _+_E_x_p_r_2                                                   _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a smaller number than _E_x_p_r_2.


_+_E_x_p_r_1 =< _+_E_x_p_r_2                                                  _[_I_S_O_]
    True  if expression _E_x_p_r_1 evaluates to a smaller or equal  number to
    _E_x_p_r_2.


_+_E_x_p_r_1 >= _+_E_x_p_r_2                                                  _[_I_S_O_]
    True  if expression _E_x_p_r_1 evaluates to  a larger or equal number  to
    _E_x_p_r_2.


_+_E_x_p_r_1 =\= _+_E_x_p_r_2                                                 _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a number non-equal to _E_x_p_r_2.


_+_E_x_p_r_1 =:= _+_E_x_p_r_2                                                 _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a number equal to  _E_x_p_r_2.


_-_N_u_m_b_e_r iiss _+_E_x_p_r                                                  _[_I_S_O_]
    True  when _N_u_m_b_e_r is the value to which _E_x_p_r evaluates.   Typically,
    is/2  should be used with unbound left  operand.  If equality  is to
    be tested, =:=/2 should be used.  For example:

             ?- 1 is sin(pi/2).   Fails!    sin(pi/2) evaluates
                                  to the float  1.0, which does
                                  not unify with the integer 1.
             ?- 1 =:= sin(pi/2).  Succeeds as expected.


44..2277..22..11 AArriitthhmmeettiicc ttyyppeess

SWI-Prolog defines the following numeric types:

  o _i_n_t_e_g_e_r
    If  SWI-Prolog is built using the _G_N_U _m_u_l_t_i_p_l_e  _p_r_e_c_i_s_i_o_n _a_r_i_t_h_m_e_t_i_c
    _l_i_b_r_a_r_y  (GMP), integer  arithmetic is _u_n_b_o_u_n_d_e_d,  which means  that
    the  size of integers is limited by available memory only.   Without
    GMP,  SWI-Prolog  integers are  64-bits,  regardless of  the  native
    integer  size  of  the  platform.    The  type  of  integer  support
    can  be detected  using the  Prolog flags  bounded, min_integer  and
    max_integer.   As the use of GMP  is default, most of the  following
    descriptions assume unbounded integer arithmetic.

    Internally,  SWI-Prolog has  three integer  representations.   Small
    integers   (defined  by  the  Prolog  flag  max_tagged_integer)  are
    encoded directly.   Larger integers are represented as 64-bit values
    on  the global  stack.   Integers  that do not  fit in  64 bits  are
    represented as serialised GNU MPZ structures on the global stack.

  o _r_a_t_i_o_n_a_l _n_u_m_b_e_r
    Rational  numbers  (Q) are  quotients of  two  integers.   Rational
    arithmetic  is only provided if GMP  is used (see above).   Rational
    numbers  are currently not  supported by  a Prolog type.   They  are
    represented  by the compound  term rdiv(_N_,_M). Rational numbers  that
    are  returned from is/2  are _c_a_n_o_n_i_c_a_l, which  means M  is positive
    and  N  and  M have  no  common divisors.    Rational  numbers  are
    introduced  in the computation  using the rational/1,  rationalize/1
    or the rdiv/2  (rational division) function.  Using the same functor
    for  rational division and for representing rational  numbers allows
    for  passing rational  numbers between computations  as well as  for
    using format/3 for printing.

    In  the long term,  it is likely  that rational numbers will  become
    _a_t_o_m_i_c  as well  as a subtype  of _n_u_m_b_e_r.   User  code that  creates
    or  inspects the  rdiv(_M_,_N)  terms will  not be  portable to  future
    versions.     Rationals  are  created using  one  of  the  functions
    mentioned above and inspected using rational/3.

  o _f_l_o_a_t
    Floating  point numbers  are represented  using the  C type  double.
    On  most of today's platforms  these are 64-bit IEEE floating  point
    numbers.

Arithmetic functions that require integer arguments accept,  in addition
to integers,  rational numbers  with (canonical)  denominator `1'.    If
the required  argument is a  float the argument  is converted to  float.
Note that conversion of integers to floating point numbers  may raise an
overflow exception.  In all other cases, arguments  are converted to the
same type using the order below.

    integer ! rational number ! floating point number


44..2277..22..22 RRaattiioonnaall nnuummbbeerr eexxaammpplleess

The  use  of  rational  numbers  with  unbounded   integers  allows  for
exact integer  or _f_i_x_e_d  _p_o_i_n_t arithmetic  under addition,  subtraction,
multiplication  and division.    To exploit  rational arithmetic  rdiv/2
should  be used  instead  of `/'  and  floating  point numbers  must  be
converted to  rational using  rational/1.   Omitting  the rational/1  on
floats  will  convert a  rational  operand  to float  and  continue  the
arithmetic using floating point numbers.  Here are some examples.

              A is 2 rdiv 6                  A = 1 rdiv 3
              A is 4 rdiv 3 + 1              A = 7 rdiv 3
              A is 4 rdiv 3 + 1.5            A = 2.83333
              A is 4 rdiv 3 + rational(1.5)  A = 17 rdiv 6

Note that  floats cannot  represent all  decimal numbers exactly.    The
function  rational/1 creates  an _e_x_a_c_t  equivalent of  the float,  while
rationalize/1  creates  a  rational number  that  is  within  the  float
rounding error from the original float.  Please  check the documentation
of these functions for details and examples.

Rational  numbers can  be  printed  as decimal  numbers  with  arbitrary
precision using the format/3 floating point conversion:

________________________________________________________________________|                                                                        |
|?- A is 4 rdiv 3 + rational(1.5),                                       |

|   format('~50f~n', [A]).                                               |
|2.83333333333333333333333333333333333333333333333333                    |
|                                                                        |
|A|=_17_rdiv_6__________________________________________________________ | |


44..2277..22..33 AArriitthhmmeettiicc FFuunnccttiioonnss

Arithmetic functions  are terms  which are evaluated  by the  arithmetic
predicates described in section  ????.  There are four types  of arguments
to functions:

       _E_x_p_r       Arbitrary   expression,   returning  either   a
                  floating point value or an integer.
       _I_n_t_E_x_p_r    Arbitrary expression  that must evaluate to  an
                  integer.
       _R_a_t_E_x_p_r    Arbitrary expression  that must  evaluate to  a
                  rational number.
       _F_l_o_a_t_E_x_p_r  Arbitrary expression  that must  evaluate to  a

                  floating point.

For systems using bounded integer arithmetic (default  is unbounded, see
section ????  for details), integer  operations that would cause  overflow
automatically convert to floating point arithmetic.

SWI-Prolog  provides  many  extensions to  the  set  of  floating  point
functions  defined  by  the  ISO  standard.     The  current  policy  is
to  provide  such  functions  on  `as-needed'  basis   if  the  function
is  widely  supported  elsewhere  and notably  if  it  is  part  of  the
http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdfC99  mathemati-
cal  library.    In addition,  we  try  to maintain  compatibility  with
http://www.dcc.fc.up.pt/ vsc/Yap/YAP.


- _+_E_x_p_r                                                           _[_I_S_O_]
    _R_e_s_u_l_t =-_E_x_p_r


+ _+_E_x_p_r                                                           _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r.   Note that if + is  followed by a number, the parser
    discards the +.  I.e. ?- integer(+1) succeeds.


_+_E_x_p_r_1 + _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1 +_E_x_p_r_2


_+_E_x_p_r_1 - _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1 -_E_x_p_r_2


_+_E_x_p_r_1 * _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1_*Expr2


_+_E_x_p_r_1 / _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t = _E_x_p_r_1=_E_x_p_r_2.  If the flag  iso is true, both arguments are
    converted  to float  and the  return value is  a float.    Otherwise
    (default),  if both arguments are integers the operation  returns an
    integer if the division  is exact.  If at least one of the arguments
    is  rational  and  the  other argument  is  integer,  the  operation
    returns  a rational number.  In all other cases the return  value is
    a float.  See also ///2 and rdiv/2.


_+_I_n_t_E_x_p_r_1 mmoodd _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Modulo, defined as _R_e_s_u_l_t = _I_n_t_E_x_p_r_1 - (_I_n_t_E_x_p_r_1 div _I_n_t_E_x_p_r_2)  * _I_n_t_E_x_p_r_2,
    where div is _f_l_o_o_r_e_d division.


_+_I_n_t_E_x_p_r_1 rreemm _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Remainder   of  integer  division.     Behaves  as  if   defined  by
    _R_e_s_u_l_t is _I_n_t_E_x_p_r_1 - (_I_n_t_E_x_p_r_1 // _I_n_t_E_x_p_r_2)  * _I_n_t_E_x_p_r_2


_+_I_n_t_E_x_p_r_1 // _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Integer  division,  defined  as  _R_e_s_u_l_t is rndI(_E_x_p_r_1/_E_x_p_r_2).     The
    function  rndI is the  default rounding used  by the C  compiler and
    available  through the  Prolog flag  integer_rounding_function.    In
    the C99 standard, C-rounding is defined as towards_zero.


ddiivv((_+_I_n_t_E_x_p_r_1_, _+_I_n_t_E_x_p_r_2))                                         _[_I_S_O_]
    Integer              division,                defined             as
    _R_e_s_u_l_t is (_I_n_t_E_x_p_r_1 - _I_n_t_E_x_p_r_1 mod _I_n_t_E_x_p_r_2) // _I_n_t_E_x_p_r_2 .        In
    other   words,  this  is   integer  division  that  rounds   towards
    -infinity.   This function  guarantees behaviour that is  consistent
    with  mod/2, i.e.,  the following holds for  every pair of  integers
    X; Y where Y =\= 0.

    ____________________________________________________________________|                                                                    |
    |         Q is div(X, Y),                                            |
    |         M is mod(X, Y),                                            |

    ||________X_=:=_Y*Q+M.______________________________________________ ||


_+_R_a_t_E_x_p_r rrddiivv _+_R_a_t_E_x_p_r
    Rational  number  division.    This function  is only  available  if
    SWI-Prolog  has been  compiled with  rational number support.    See
    section ???? for details.


_+_I_n_t_E_x_p_r_1 ggccdd _+_I_n_t_E_x_p_r_2
    Result is the greatest common divisor of _I_n_t_E_x_p_r_1, _I_n_t_E_x_p_r_2.


aabbss((_+_E_x_p_r))                                                        _[_I_S_O_]
    Evaluate _E_x_p_r and return the absolute value of it.


ssiiggnn((_+_E_x_p_r))                                                       _[_I_S_O_]
    Evaluate to -1  if _E_x_p_r< 0, 1 if _E_x_p_r> 0 and 0 if _E_x_p_r= 0.  If _E_x_p_r
    evaluates  to a float, the return value is a float (e.g.,  -1.0, 0.0
    or  1.0).   In particular,  note that  sign(-0.0) evaluates to  0.0.
    See also copysign/2


ccooppyyssiiggnn((_+_E_x_p_r_1_, _+_E_x_p_r_2))                                          _[_I_S_O_]
    Evaluate  to _X, where  the absolute value  of _X equals the  absolute
    value  of  _E_x_p_r_1 and  the  sign  of _X  matches  the sign  of  _E_x_p_r_2.
    This  function  is based  on copysign()  from  C99, which  works  on
    double precision floats  and deals with handling the sign of special
    floating point values  such as -0.0.  Our implementation follows C99
    if  both arguments are floats.   Otherwise, copysign/2 evaluates  to
    _E_x_p_r_1  if the  sign of  both expressions  matches or  -_E_x_p_r_1 if  the
    signs  do not match.  Here, we use the extended notion  of signs for
    floating  point numbers, where  the sign of  -0.0 and other  special
    floats is negative.


mmaaxx((_+_E_x_p_r_1_, _+_E_x_p_r_2))                                               _[_I_S_O_]
    Evaluate  to the  larger of  _E_x_p_r_1 and _E_x_p_r_2.    Both arguments  are
    compared after converting  to the same type, but the return value is
    in  the original type.   For example,  max(2.5, 3) compares the  two
    values after converting to float, but returns the integer 3.


mmiinn((_+_E_x_p_r_1_, _+_E_x_p_r_2))                                               _[_I_S_O_]
    Evaluate  to  the smaller  of _E_x_p_r_1  and _E_x_p_r_2.    See  max/2 for  a
    description of type handling.


.((_+_I_n_t_, _[_]))
    A  list of one element evaluates to  the element.  This  implies "a"
    evaluates  to the character  code of the  letter `a' (97) using  the
    traditional  mapping of double quoted string to a list  of character
    codes.   Arithmetic evaluation also translates a string  object (see
    section  ????) of  one character  length into the  character code  for
    that character.   This implies that expression "a" also works of the
    Prolog flag  double_quotesis set to string.   The recommended way to
    specify the character code of the letter `a' is 0'a.


rraannddoomm((_+_I_n_t_E_x_p_r))
    Evaluate  to  a random  integer _i  for which  0=< i< _I_n_t_E_x_p_r.    The
    system  has two  implementations.   If it  is compiled with  support
    for  unbounded arithmetic (default) it  uses the GMP library  random
    functions.   In this case,  each thread keeps its own  random state.
    The  default algorithm is the _M_e_r_s_e_n_n_e _T_w_i_s_t_e_r algorithm.   The seed
    is  set when the first random number  in a thread is generated.   If
    available,  it is set  from /dev/random.   Otherwise it is set  from
    the system clock.   If unbounded arithmetic is not supported, random
    numbers are shared  between threads and the seed is initialised from
    the  clock when SWI-Prolog was started.   The predicate set_random/1
    can be used to control the random number generator.

    WWaarrnniinngg!!     Although properly  seeded  (if  supported on  the  OS),
    the  Mersenne Twister algorithm  does _n_o_t produce  cryptographically
    secure random numbers.   To generate cryptographically secure random
    numbers, use crypto_n_random_bytes/2 from library crypto provided by
    the ssl package.


rraannddoomm__ffllooaatt
    Evaluate  to a random float I  for which 0:0 <i <1:0.   This function
    shares  the  random state  with  random/1.    All remarks  with  the
    function  random/1 also apply  for random_float/0.   Note that  both
    sides  of the domain  are _o_p_e_n.   This avoids evaluation errors  on,
    e.g., log/1 or //2 while no practical application can expect 0.0.


rroouunndd((_+_E_x_p_r))                                                      _[_I_S_O_]
    Evaluate  _E_x_p_r  and   round  the  result  to  the  nearest  integer.
    According  to  ISO, round/1  is  defined as  floor(_E_x_p_r_+_1_/_2),  i.e.,
    rounding  _d_o_w_n.     This  is  an  unconventional  choice  and  under
    which  the  relation  round(Expr) == -round(-Expr)  does  not  hold.
    SWI-Prolog   rounds  _o_u_t_w_a_r_d,   e.g.,  round(1.5) =:= 2  and   round
    round(-1.5) =:= -2.


iinntteeggeerr((_+_E_x_p_r))
    Same as round/1 (backward compatibility).


ffllooaatt((_+_E_x_p_r))                                                      _[_I_S_O_]
    Translate  the result to a floating point number.   Normally, Prolog
    will  use integers  whenever possible.    When used  around the  2nd
    argument  of is/2, the result will  be returned as a floating  point
    number.  In other contexts, the operation has no effect.


rraattiioonnaall((_+_E_x_p_r))
    Convert  the _E_x_p_r to  a rational  number or integer.   The  function
    returns  the input on integers and  rational numbers.  For  floating
    point  numbers, the returned rational number _e_x_a_c_t_l_y  represents the
    float.   As floats cannot exactly represent all decimal  numbers the
    results  may be  surprising.   In  the examples  below, doubles  can
    represent  0.25 and the  result is as expected,  in contrast to  the
    result of rational(_0_._1).   The function rationalize/1 remedies this.
    See section ???? for more information on rational number support.

    ____________________________________________________________________|                                                                    |
    | ?- A is rational(0.25).                                            |

    |                                                                    |
    | A is 1 rdiv 4                                                      |
    | ?- A is rational(0.1).                                             |
    ||A_=_3602879701896397_rdiv_36028797018963968_______________________ ||


rraattiioonnaalliizzee((_+_E_x_p_r))
    Convert  the _E_x_p_r to  a rational  number or integer.   The  function
    is  similar to rational/1,  but the result  is only accurate  within
    the rounding error  of floating point numbers, generally producing a
    much smaller denominator.

    ____________________________________________________________________|                                                                    |
    | ?- A is rationalize(0.25).                                         |
    |                                                                    |
    | A = 1 rdiv 4                                                       |

    | ?- A is rationalize(0.1).                                          |
    |                                                                    |
    ||A_=_1_rdiv_10_____________________________________________________ ||


ffllooaatt__ffrraaccttiioonnaall__ppaarrtt((_+_E_x_p_r))                                       _[_I_S_O_]
    Fractional   part  of  a  floating  point  number.      Negative  if
    _E_x_p_r   is  negative,  rational   if  _E_x_p_r  is  rational  and  0   if
    _E_x_p_r   is  integer.     The  following  relation  is   always  true:
    Xisfloatfractionalpart(X)+ floatintegerpart(X).


ffllooaatt__iinntteeggeerr__ppaarrtt((_+_E_x_p_r))                                          _[_I_S_O_]
    Integer  part  of  floating point  number.    Negative  if  _E_x_p_r  is
    negative, _E_x_p_r if _E_x_p_r is integer.


ttrruunnccaattee((_+_E_x_p_r))                                                   _[_I_S_O_]
    Truncate  _E_x_p_r to  an integer.    If _E_x_p_r>= 0  this is  the same  as
    floor(_E_x_p_r).  For _E_x_p_r <0 this is the same as ceil(_E_x_p_r).  That is,
    truncate/1 rounds towards zero.


fflloooorr((_+_E_x_p_r))                                                      _[_I_S_O_]
    Evaluate  _E_x_p_r and return  the largest integer  smaller or equal  to
    the result of the evaluation.


cceeiilliinngg((_+_E_x_p_r))                                                    _[_I_S_O_]
    Evaluate  _E_x_p_r and return  the smallest integer  larger or equal  to
    the result of the evaluation.


cceeiill((_+_E_x_p_r))
    Same as ceiling/1 (backward compatibility).


_+_I_n_t_E_x_p_r_1 >> _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise  shift  _I_n_t_E_x_p_r_1  by  _I_n_t_E_x_p_r_2  bits to  the  right.     The
    operation   performs  _a_r_i_t_h_m_e_t_i_c  _s_h_i_f_t,  which  implies   that  the
    inserted  most  significant bits  are copies  of  the original  most
    significant bits.


_+_I_n_t_E_x_p_r_1 << _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise shift _I_n_t_E_x_p_r_1 by _I_n_t_E_x_p_r_2 bits to the left.


_+_I_n_t_E_x_p_r_1 \/ _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise `or' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r_1 /\ _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise `and' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r_1 xxoorr _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Bitwise `exclusive or' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


\ _+_I_n_t_E_x_p_r                                                        _[_I_S_O_]
    Bitwise  negation.   The returned value  is the one's complement  of
    _I_n_t_E_x_p_r.


ssqqrrtt((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =square root of _E_x_p_r


ssiinn((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =sine of _E_x_p_r.  _E_x_p_r is the angle in radians.


ccooss((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =cosine of _E_x_p_r.  _E_x_p_r is the angle in radians.


ttaann((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =tangus of _E_x_p_r.  _E_x_p_r is the angle in radians.


aassiinn((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =inverse sine of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aaccooss((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =inverse cosine of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aattaann((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =inverse tangus of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aattaann22((_+_Y_E_x_p_r_, _+_X_E_x_p_r))                                             _[_I_S_O_]
    _R_e_s_u_l_t = inverse tangus of _Y_E_x_p_r / _X_E_x_p_r.   _R_e_s_u_l_t is  the angle in
    radians.    The return  value is  in the  range [-pi:::pi].   Used  to
    convert between rectangular and polar coordinate system.

    Note  that the ISO Prolog  standard demands atan2(_0_._0_,_0_._0) to  raise
    an  evaluation error,  whereas the  C99 and  POSIX standards  demand
    this to evaluate to 0.0.  SWI-Prolog follows C99 and POSIX.


aattaann((_+_Y_E_x_p_r_, _+_X_E_x_p_r))
    Same as atan2/2 (backward compatibility).


ssiinnhh((_+_E_x_p_r))
    _R_e_s_u_l_t = sinh_E_x_p_r.     The  hyperbolic  sine  of  X  is  defined  as
    e to the power X -e to the power -X=2.


ccoosshh((_+_E_x_p_r))
    _R_e_s_u_l_t = cosh_E_x_p_r.     The hyperbolic  cosine  of  X is  defined  as
    e to the power X +e to the power -X=2.


ttaannhh((_+_E_x_p_r))
    _R_e_s_u_l_t = tanh_E_x_p_r.   The  hyperbolic  tangent of  X  is defined  as
    sinhX=coshX.


aassiinnhh((_+_E_x_p_r))
    _R_e_s_u_l_t =arcsinh(_E_x_p_r) (inverse hyperbolic sine).


aaccoosshh((_+_E_x_p_r))
    _R_e_s_u_l_t =arccosh(_E_x_p_r) (inverse hyperbolic cosine).


aattaannhh((_+_E_x_p_r))
    _R_e_s_u_l_t =arctanh(_E_x_p_r).  (inverse hyperbolic tangent).


lloogg((_+_E_x_p_r))                                                        _[_I_S_O_]
    Natural logarithm.  _R_e_s_u_l_t =natural logarithm of _E_x_p_r


lloogg1100((_+_E_x_p_r))
    Base-10 logarithm.  _R_e_s_u_l_t =10 base logarithm of _E_x_p_r


eexxpp((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =e to the power _E_x_p_r


_+_E_x_p_r_1 ** _+_E_x_p_r_2                                                  _[_I_S_O_]
    _R_e_s_u_l_t = _E_x_p_r_1 to the power _E_x_p_r_2.   The result is  a float, unless
    SWI-Prolog  is  compiled  with  unbounded integer  support  and  the
    inputs are integers and  produce an integer result.  The integer ex-
    pressions  0 to the power I, 1 to the power I and  -1 to the power I
    are  guaranteed to  work  for any  integer I.    Other integer  base
    values  generate a  resource error  if the  result does  not fit  in
    memory.

    The  ISO  standard  demands  a  float  result  for  all  inputs  and
    introduces  ^/2 for  integer exponentiation.   The function  float/1
    can  be used  on one  or both arguments  to force  a floating  point
    result.     Note  that  casting  the  _i_n_p_u_t  result  in  a  floating
    point  computation,   while  casting  the  _o_u_t_p_u_t  performs  integer
    exponentiation followed by a conversion to float.


_+_E_x_p_r_1 ^ _+_E_x_p_r_2                                                   _[_I_S_O_]
    In  SWI-Prolog,  ^/2 is  equivalent to  **/2.   The  ISO version  is
    similar,  except that it produces  a evaluation error if both  _E_x_p_r_1
    and _E_x_p_r_2 are integers  and the result is not an integer.  The table
    below  illustrates the behaviour of the exponentiation  functions in
    ISO and SWI.

          ________________________________________________________
          |__E_x_p_r_1_____E_x_p_r_2__|_Function_|SWI__________|ISO__________|
          | Int      Int   | **/2     |Int or Float |Float        |
          | Int      Float | **/2     |Float        |Float        |
          | Rational Int   | **/2     |Rational     |-            |

          | Float    Int   | **/2     |Float        |Float        |
          |_Float____Float_|_**/2_____|Float________|Float________|
          | Int      Int   | ^/2      |Int or Float |Int or error |
          | Int      Float | ^/2      |Float        |Float        |
          | Rational Int   | ^/2      |Rational     |-            |
          | Float    Int   | ^/2      |Float        |Float        |
          |_Float____Float_|_^/2______|Float________|Float________|


ppoowwmm((_+_I_n_t_E_x_p_r_B_a_s_e_, _+_I_n_t_E_x_p_r_E_x_p_, _+_I_n_t_E_x_p_r_M_o_d))
    _R_e_s_u_l_t   =  (_I_n_t_E_x_p_r_B_a_s_e to the power _I_n_t_E_x_p_r_E_x_p) modulo _I_n_t_E_x_p_r_M_o_d.
    Only  available when compiled with unbounded integer support.   This
    formula  is required  for Diffie-Hellman  key-exchange, a  technique
    where two parties  can establish a secret key over a public network.
    _I_n_t_E_x_p_r_B_a_s_e  and _I_n_t_E_x_p_r_E_x_p must be non-negative (>= 0), _I_n_t_E_x_p_r_M_o_d
    must be positive (> 0).


llggaammmmaa((_+_E_x_p_r))
    Return  the natural  logarithm of  the absolute value  of the  Gamma
    function.


eerrff((_+_E_x_p_r))
    https://en.wikipedia.org/wiki/Error_functionWikipedia:   ``In  math-
    ematics,   the   error  function  (also   called  the  Gauss   error
    function)  is a special  function (non-elementary) of sigmoid  shape
    which  occurs in  probability, statistics  and partial  differential
    equations.''


eerrffcc((_+_E_x_p_r))
    https://en.wikipedia.org/wiki/Error_functionWikipedia:   ``The  com-
    plementary error function.''


ppii                                                                _[_I_S_O_]
    Evaluate to the mathematical constant pi (3.14159...).


ee
    Evaluate to the mathematical constant e (2.71828...).


eeppssiilloonn
    Evaluate  to the  difference  between the  float 1.0  and the  first
    larger floating point number.


iinnff
    Evaluate  to positive infinity.  See section ????.  This  value can be
    negated using -/1 .


nnaann
    Evaluate to _N_o_t _a _N_u_m_b_e_r.  See section ????.


ccppuuttiimmee
    Evaluate  to a  floating point  number expressing the  cpu time  (in
    seconds)  used by Prolog  up till  now.   See also statistics/2  and
    time/1.


eevvaall((_+_E_x_p_r))
    Evaluate  _E_x_p_r.  Although  ISO standard dictates that `A=1+2,  B is
    A'  works and unifies B to  3, it is widely felt  that source level
    variables  in arithmetic  expressions  should have  been limited  to
    numbers.   In this  view the eval function  can be used to  evaluate
    arbitrary expressions.

BBiittvveeccttoorr ffuunnccttiioonnss

The  functions   below  are  not   covered  by  the   standard.      The
msb/1  function  also appears  in  hProlog  and  SICStus Prolog.     The
getbit/2  function  also   appears  in  ECLiPSe,  which   also  provides
setbit(_V_e_c_t_o_r_,_I_n_d_e_x)  and   clrbit(_V_e_c_t_o_r_,_I_n_d_e_x).      The  others   are
SWI-Prolog extensions that improve handling of  ---unbounded--- integers
as bit-vectors.


mmssbb((_+_I_n_t_E_x_p_r))
    Return  the largest integer N  such that (IntExpr >> N) /\ 1 =:= 1.
    This  is the (zero-origin)  index of the  most significant 1 bit  in
    the  value of _I_n_t_E_x_p_r,  which must evaluate  to a positive  integer.
    Errors for 0, negative integers, and non-integers.


llssbb((_+_I_n_t_E_x_p_r))
    Return  the smallest integer N such that (IntExpr >> N) /\ 1 =:= 1.
    This  is the (zero-origin) index of  the least significant 1 bit  in
    the  value of _I_n_t_E_x_p_r,  which must evaluate  to a positive  integer.
    Errors for 0, negative integers, and non-integers.


ppooppccoouunntt((_+_I_n_t_E_x_p_r))
    Return  the  number  of  1s  in the  binary  representation  of  the
    non-negative integer _I_n_t_E_x_p_r.


ggeettbbiitt((_+_I_n_t_E_x_p_r_V_, _+_I_n_t_E_x_p_r_I))
    Evaluates  to the  bit  value (0  or 1)  of the  _I_n_t_E_x_p_r_I-th bit  of
    _I_n_t_E_x_p_r_V.  Both arguments  must evaluate  to non-negative  integers.
    The  result  is equivalent  to (IntExprV >> IntExprI)/\1,  but  more
    efficient  because materialization of the shifted value  is avoided.
    Future  versions will optimise  (IntExprV >> IntExprI)/\1 to a  call
    to getbit/2, providing both portability and performance.


44..2288 MMiisscc aarriitthhmmeettiicc ssuuppppoorrtt pprreeddiiccaatteess


sseett__rraannddoomm((_+_O_p_t_i_o_n))
    Controls   the  random  number  generator  accessible   through  the
    _f_u_n_c_t_i_o_n_s  random/1  and  random_float/0.     Note that  the  library
    random provides an alternative API to the same random primitives.

    sseeeedd((_+_S_e_e_d))
         Set the  seed of the random  generator for this  thread.   _S_e_e_d
         is an  integer  or the  atom random.    If random,  repeat  the
         initialization procedure described with the  function random/1.
         Here is an example:

         _______________________________________________________________|                                                               |

         |?- set_random(seed(111)), A is random(6).                      |
         |A = 5.                                                         |
         |?- set_random(seed(111)), A is random(6).                      |
         |A|=_5.________________________________________________________ | |

    ssttaattee((_+_S_t_a_t_e))
         Set the generator to  a state fetched using the  state property
         of random_property/1.  Using other values may lead to undefined
         behaviour.


rraannddoomm__pprrooppeerrttyy((_?_O_p_t_i_o_n))
    True  when _O_p_t_i_o_n  is a  current property of  the random  generator.
    Currently,  this  predicate provides  access  to the  state.    This
    predicate   is  not   present  on   systems  where   the  state   is
    inaccessible.

    ssttaattee((_-_S_t_a_t_e))
         Describes the  current state of  the random  generator.   State
         is a normal  Prolog term that can  be asserted or written to  a
         file.  Applications should make no other  assumptions about its
         representation.   The only  meaningful operation  is to use  as
         argument to set_random/1 using the state(_S_t_a_t_e) option.


ccuurrrreenntt__aarriitthhmmeettiicc__ffuunnccttiioonn((_?_H_e_a_d))
    True when _H_e_a_d is an evaluable function.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- current_arithmetic_function(sin(_)).                            |

    ||true._____________________________________________________________ ||


44..2299 BBuuiilltt--iinn lliisstt ooppeerraattiioonnss

Most  list operations  are defined  in the  library  lists described  in
section ????.   Some that are  implemented with more low-level  primitives
are built-in and described here.


iiss__lliisstt((_+_T_e_r_m))
    True if _T_e_r_m is  bound to the empty list ([]) or a term with functor
    `'[|]''  and  arity 2  and the  second argument  is a  list.    This
    predicate  acts as  if defined  by the definition  below on  _a_c_y_c_l_i_c
    terms.   The implementation _f_a_i_l_s safely if _T_e_r_m represents a cyclic
    list.

    ____________________________________________________________________|                                                                    |
    | is_list(X) :-                                                      |
    |         var(X), !,                                                 |
    |         fail.                                                      |

    | is_list([]).                                                       |
    | is_list([_|T]) :-                                                  |
    ||________is_list(T)._______________________________________________ ||


mmeemmbbeerrcchhkk((_?_E_l_e_m_, _+_L_i_s_t))                                       _[_s_e_m_i_d_e_t_]
    True  when  _E_l_e_m  is  an  element  of _L_i_s_t.     This  `chk'  variant
    of  member/2  is  semi  deterministic and  typically  used  to  test
    membership  of  a list.     Raises a  type  error if  scanning  _L_i_s_t
    encounters  a non-list.   Note that  memberchk/2 does _n_o_t perform  a
    full  list typecheck.    For  example, memberchk(a, [a|b])  succeeds
    without error.   If _L_i_s_t is cyclic and _E_l_e_m is not a member of _L_i_s_t,
    memberchk/2 eventually raises a type error.


lleennggtthh((_?_L_i_s_t_, _?_I_n_t))                                               _[_I_S_O_]
    True  if  _I_n_t represents  the number  of  elements in  _L_i_s_t.    This
    predicate  is a true  relation and  can be used  to find the  length
    of  a list  or produce  a list  (holding variables)  of length  _I_n_t.
    The  predicate is non-deterministic,  producing lists of  increasing
    length  if _L_i_s_t is  a _p_a_r_t_i_a_l _l_i_s_t  and _I_n_t is unbound.   It  raises
    errors if

      o  _I_n_t is bound to a non-integer.

      o  _I_n_t is a negative integer.

      o  _L_i_s_t  is neither  a  list  nor a  partial  list.    This  error
         condition includes cyclic lists.

    This  predicate  fails if  the tail  of _L_i_s_t  is  equivalent to  _I_n_t
    (e.g., length(L,L)).


ssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))                                              _[_I_S_O_]
    True  if _S_o_r_t_e_d  can be  unified with  a list  holding the  elements
    of  _L_i_s_t, sorted to  the standard order  of terms (see section  ????).
    Duplicates  are removed.  The implementation is in C,  using _n_a_t_u_r_a_l
    _m_e_r_g_e _s_o_r_t.   The sort/2 predicate can sort a cyclic list, returning
    a non-cyclic version with the same elements.

    Note  that _L_i_s_t may contain non-ground terms.  If _S_o_r_t_e_d  is unbound
    at  call-time,  for each  consequtive pair  of  elements in  _S_o_r_t_e_d,
    the  relation E1 @< E2 will hold.   However, unifying a variable  in
    _S_o_r_t_e_d  may cause  this relation  to become  invalid, _e_v_e_n  unifying
    a  variable  in _S_o_r_t_e_d  with another  (older) variable.    See  also
    section ????.


ssoorrtt((_+_K_e_y_, _+_O_r_d_e_r_, _+_L_i_s_t_, _-_S_o_r_t_e_d))
    True  when _S_o_r_t_e_d can be unified with a list holding the  element of
    _L_i_s_t.   _K_e_y determines  which part of each  element in _L_i_s_t is  used
    for  comparing two  term and  _O_r_d_e_r describes  the relation  between
    each set of consecutive elements in _S_o_r_t_e_d.

    If  _K_e_y is the integer zero (0), the entire term is used  to compare
    two  elements.   Using _K_e_y=0  can be used  to sort arbitrary  Prolog
    terms.   Other values for _K_e_y  can only be used with  compound terms
    or  dicts (see  section ????).   An  integer key  extracts the  _K_e_y-th
    argument  from a compound  term.   An integer  or atom key  extracts
    the  value from a  dict that is  associated with the given  key.   A
    type_error is  raised  if the  list  element is  of the  wrong  type
    and  an existence_error is  raised if  the compound  has not  enough
    argument or the dict does not contain the requested key.

    Deeper  nested elements  of structures  can be selected  by using  a
    list of keys for the _K_e_y argument.

    The _O_r_d_e_r argument is described in the table below

                   _Order__Ordering____Duplicate_handling__
                    @<     ascending   remove
                    @=<    ascending   keep
                    @>     descending  remove
                    @>=    descending  keep

    The sort is _s_t_a_b_l_e,  which implies that, if duplicates are kept, the
    order  of duplicates  is not changed.    If duplicates are  removed,
    only  the  first element  of  a sequence  of duplicates  appears  in
    _S_o_r_t_e_d.

    This predicate supersedes  most of the other sorting primitives, for
    example:

    ____________________________________________________________________|                                                                    |

    | sort(List, Sorted)     :- sort(0,  @<, List,  Sorted).             |
    | msort(List, Sorted)    :- sort(0, @=<, List,  Sorted).             |
    ||keysort(Pairs,_Sorted)_:-_sort(1,_@=<,_Pairs,_Sorted).____________ ||

    The  following example sorts a  list of rows, for example  resulting
    from  csv_read_file/2) ascending on the 3th column  and descending on
    the 4th column:

    ____________________________________________________________________|                                                                    |
    |     sort(4, @>=, Rows0, Rows1),                                    |
    ||____sort(3,_@=<,_Rows1,_Sorted).__________________________________ ||

    See   also  sort/2   (ISO),  msort/2,   keysort/2,  predsort/3   and
    order_by/2.


mmssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Equivalent  to sort/2,  but does not  remove duplicates.   Raises  a
    type_error if _L_i_s_t is a cyclic list or not a list.


kkeeyyssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))                                           _[_I_S_O_]
    Sort  a list  of _p_a_i_r_s.   _L_i_s_t must  be a  list of _K_e_y-_V_a_l_u_e  pairs,
    terms  whose  principal  functor  is  (-)/2.    _L_i_s_t  is  sorted  on
    _K_e_y  according to  the  standard order  of terms  (see section  ????).
    Duplicates  are _n_o_t removed.   Sorting is _s_t_a_b_l_e with regard to  the
    order of the _V_a_l_u_e_s,  i.e., the order of multiple elements that have
    the same _K_e_y is not changed.

    The  keysort/2 predicate is often used together with  library pairs.
    It  can be  used to sort  lists on  different or multiple  criteria.
    For  example,  the  following  predicates  sorts  a  list  of  atoms
    according  to their length, maintaining the initial order  for atoms
    that have the same length.

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(pairs)).                                     |

    |                                                                    |
    | sort_atoms_by_length(Atoms, ByLength) :-                           |
    |         map_list_to_pairs(atom_length, Atoms, Pairs),              |
    |         keysort(Pairs, Sorted),                                    |
    ||________pairs_values(Sorted,_ByLength).___________________________ ||


pprreeddssoorrtt((_+_P_r_e_d_, _+_L_i_s_t_, _-_S_o_r_t_e_d))
    Sorts  similar to sort/2, but determines  the order of two terms  by
    calling  _P_r_e_d(-_D_e_l_t_a, +_E_1, +_E_2).   This call  must unify _D_e_l_t_a  with
    one of <, >  or =.  If the built-in predicate compare/3 is used, the
    result is the same as sort/2.  See also keysort/2.


44..3300 FFiinnddiinngg aallll SSoolluuttiioonnss ttoo aa GGooaall


ffiinnddaallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                                   _[_I_S_O_]
    Create  a list of the  instantiations _T_e_m_p_l_a_t_e gets successively  on
    backtracking  over _G_o_a_l  and unify the  result with  _B_a_g.   Succeeds
    with  an  empty  list  if _G_o_a_l  has  no  solutions.    findall/3  is
    equivalent  to  bagof/3  with  all free  variables  bound  with  the
    existential  operator (^), except that  bagof/3 fails when _G_o_a_l  has
    no solutions.


ffiinnddaallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g_, _+_T_a_i_l))
    As  findall/3,  but  returns  the  result  as  the  difference  list
    _B_a_g-_T_a_i_l.  The 3-argument version is defined as

    ____________________________________________________________________|                                                                    |
    | findall(Templ, Goal, Bag) :-                                       |

    ||________findall(Templ,_Goal,_Bag,_[])_____________________________ ||


ffiinnddnnssoollss((_+_N_, _@_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_L_i_s_t))                         _[_n_o_n_d_e_t_]


ffiinnddnnssoollss((_+_N_, _@_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_L_i_s_t_, _?_T_a_i_l))                  _[_n_o_n_d_e_t_]
    As  findall/3 and findall/4, but generates at most _N solutions.   If
    _N  solutions are  returned, this  predicate succeeds  with a  choice
    point  if _G_o_a_l has  a choice point.   Backtracking returns the  next
    chunk  of (at most)  _N solutions.   In addition  to passing a  plain
    integer  for _N,  a term of  the form  count(_N) is accepted.    Using
    count(_N),  the  size  of the  next  chunk  can be  controlled  using
    nb_setarg/3.  The non-deterministic behaviour  used to implement the
    _c_h_u_n_k  option in  pengines.   Based on  Ciao, but  the Ciao  version
    is  deterministic.    Portability can  be achieved  by wrapping  the
    goal  in once/1.  Below are  three examples.  The  first illustrates
    standard  chunking of  answers.    The second  illustrates that  the
    chunk  size can  be adjusted  dynamically and  the last  illustrates
    that  no choice point is left  if _G_o_a_l leaves no choice-point  after
    the last solution.

    ____________________________________________________________________|                                                                    |
    | ?- findnsols(5, I, between(1, 12, I), L).                          |
    | L = [1, 2, 3, 4, 5] ;                                              |
    | L = [6, 7, 8, 9, 10] ;                                             |

    | L = [11, 12].                                                      |
    |                                                                    |
    | ?- State = count(2),                                               |
    |    findnsols(State, I, between(1, 12, I), L),                      |
    |    nb_setarg(1, State, 5).                                         |
    | State = count(5), L = [1, 2] ;                                     |
    | State = count(5), L = [3, 4, 5, 6, 7] ;                            |
    | State = count(5), L = [8, 9, 10, 11, 12].                          |

    |                                                                    |
    | ?- findnsols(4, I, between(1, 4, I), L).                           |
    ||L_=_[1,_2,_3,_4]._________________________________________________ ||


bbaaggooff((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                                     _[_I_S_O_]
    Unify  _B_a_g with  the alternatives  of _T_e_m_p_l_a_t_e.   If  _G_o_a_l has  free
    variables  besides  the  one sharing  with  _T_e_m_p_l_a_t_e,  bagof/3  will
    backtrack  over the alternatives  of these free variables,  unifying
    _B_a_g with the  corresponding alternatives of _T_e_m_p_l_a_t_e.  The construct
    +_V_a_r^_G_o_a_l  tells bagof/3 not to bind _V_a_r in _G_o_a_l.  bagof/3  fails if
    _G_o_a_l has no solutions.

    The  example below  illustrates bagof/3  and the  ^ operator.    The
    variable bindings are printed together on one line to save paper.

    ____________________________________________________________________|                                                                    |
    | 2 ?- listing(foo).                                                 |
    | foo(a, b, c).                                                      |
    | foo(a, b, d).                                                      |

    | foo(b, c, e).                                                      |
    | foo(b, c, f).                                                      |
    | foo(c, c, g).                                                      |
    | true.                                                              |
    |                                                                    |
    | 3 ?- bagof(C, foo(A, B, C), Cs).                                   |
    | A = a, B = b, C = G308, Cs = [c, d] ;                              |
    | A = b, B = c, C = G308, Cs = [e, f] ;                              |

    | A = c, B = c, C = G308, Cs = [g].                                  |
    |                                                                    |
    | 4 ?- bagof(C, A^foo(A, B, C), Cs).                                 |
    | A = G324, B = b, C = G326, Cs = [c, d] ;                           |
    | A = G324, B = c, C = G326, Cs = [e, f, g].                         |
    |                                                                    |
    ||5_?-______________________________________________________________ ||


sseettooff((_+_T_e_m_p_l_a_t_e_, _+_G_o_a_l_, _-_S_e_t))                                     _[_I_S_O_]
    Equivalent  to bagof/3, but sorts the  result using sort/2 to get  a
    sorted list of alternatives without duplicates.


44..3311 FFoorraallll


ffoorraallll((_:_C_o_n_d_, _:_A_c_t_i_o_n))                                        _[_s_e_m_i_d_e_t_]
    For  all alternative bindings of  _C_o_n_d, _A_c_t_i_o_n can  be proven.   The
    example  verifies that all arithmetic  statements in the given  list
    are correct.  It does not say which is wrong if one proves wrong.

    ____________________________________________________________________|                                                                    |
    | ?- forall(member(Result = Formula, [2 = 1 + 1, 4 = 2 * 2]),        |

    ||_________________Result_=:=_Formula)._____________________________ ||

    The  predicate  forall/2  is implemented  as  \+ ( Cond, \+ Action),
    i.e., _T_h_e_r_e _i_s  _n_o _i_n_s_t_a_n_t_i_a_t_i_o_n _o_f _C_o_n_d _f_o_r _w_h_i_c_h _A_c_t_i_o_n _i_s _f_a_l_s_e_..
    The  use of double  negation implies that  forall/2 _d_o_e_s _n_o_t  _c_h_a_n_g_e
    _a_n_y _v_a_r_i_a_b_l_e _b_i_n_d_i_n_g_s.   It proves a relation.  The forall/2 control
    structure  can be used  for its side-effects.   E.g., the  following
    asserts relations in a list into the dynamic database:

    ____________________________________________________________________|                                                                    |
    | ?- forall(member(Child-Parent, ChildPairs),                        |
    ||__________assertz(child_of(Child,_Parent))).______________________ ||

    Using  forall/2 as forall(_G_e_n_e_r_a_t_o_r_,  _S_i_d_e_E_f_f_e_c_t) is preferred  over
    the  classical _f_a_i_l_u_r_e _d_r_i_v_e_n _l_o_o_p  as shown below because it  makes
    it  explicit which part of the construct is the generator  and which
    part  creates the  side effects.   Also,  unexpected failure of  the
    side effect causes the  construct to fail.  Failure makes it evident
    that  there is an issue with  the code, while a failure  driven loop
    would succeed with an erroneous result.

    ____________________________________________________________________|                                                                    |
    |         ...,                                                       |
    |         (   Generator,                                             |
    |             SideEffect,                                            |

    |             fail                                                   |
    |         ;   true                                                   |
    ||________)_________________________________________________________ ||

    If your intent  is to create variable bindings, the forall/2 control
    structure  is inadequate.   Possibly you are looking for  maplist/2,
    findall/3 or foreach/2.


44..3322 FFoorrmmaatttteedd WWrriittee

The  current  version   of  SWI-Prolog  provides  two  formatted   write
predicates.   The  `writef' family (writef/1,  writef/2, swritef/3),  is
compatible with Edinburgh C-Prolog and should  be considered _d_e_p_r_e_c_a_t_e_d.
The  `format' family  (format/1,  format/2,  format/3), was  defined  by
Quintus Prolog and currently available in many  Prolog systems, although
the details vary.


44..3322..11 WWrriitteeff


wwrriitteeff((_+_A_t_o_m))                                              _[_d_e_p_r_e_c_a_t_e_d_]
    Equivalent to writef(Atom, []). See writef/2 for details.


wwrriitteeff((_+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))                                _[_d_e_p_r_e_c_a_t_e_d_]
    Formatted  write.    _F_o_r_m_a_t  is an  atom  whose characters  will  be
    printed.    _F_o_r_m_a_t may contain  certain special character  sequences
    which   specify   certain  formatting   and  substitution   actions.
    _A_r_g_u_m_e_n_t_s provides all the terms required to be output.

    Escape sequences to generate a single special character:

             __________________________________________________
             | \n   |Output  a  newline  character  (see  also |
             |      |nl/[0,1])                                 |
             | \l   |Output a line separator (same as \n)      |

             | \r   |Output  a   carriage   return   character |
             |      |(ASCII 13)                                |
             | \t   |Output the ASCII character TAB (9)        |
             | \\   |The character \ is output                 |
             | \%   |The character % is output                 |
             | \nnn |where <_n_n_n> is  an integer  (1-3 digits); |
             |      |the character with  code <_n_n_n>  is output |

             |______|(NB_:_<_n_n_n>_is_read_as_ddeecciimmaall)___________|

    Note  that  \l,   \nnn  and  \\  are  interpreted  differently  when
    character escapes are in effect.  See section ????.

    Escape  sequences to include  arguments from _A_r_g_u_m_e_n_t_s.   Each  time
    a  %  escape sequence  is found  in _F_o_r_m_a_t  the  next argument  from
    _A_r_g_u_m_e_n_t_s is formatted according to the specification.

              _________________________________________________%t

              | %w  print/1 the next item (mnemonic:  term)   |    |

              | %q  |write/1the next item                     |

              |     |writeq/1the next item                    |
              | %d  |Write the term,  ignoring operators.  See|
              |     |also  write_term/2.      Mnemonic:    old|
              | %p  |Edinburgh display/1                      |

              |     |print/1the next item (identical to %t)   |
              | %n  |Put the  next item as  a character (i.e.,|

              |     |it is a character code)                  |
              | %r  |Write the  next item  N times where  N is|
              |     |the second item (an integer)             |
              | %s  |Write the  next item  as a String  (so it|
              |     |must be a list of characters)            |
              | %f  |Perform a ttyflush/0 (no items used)     |
              | %Nc |Write  the   next  item  Centered  in  N |

              |     |columns                                  |
              | %Nl |Write the next  item Left justified in N |
              |     |columns                                  |
              | %Nr |Write the next item Right justified in N |
              |     |columns.   N is a decimal number with  at|
              |     |least  one digit.   The  item must  be an|
              |_____|atom,_integer,_float_or_string.__________|_


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))                      _[_d_e_p_r_e_c_a_t_e_d_]
    Equivalent to writef/2,  but ``writes'' the result on _S_t_r_i_n_g instead
    of the current output stream.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- swritef(S, '%15L%w', ['Hello', 'World']).                       |
    |                                                                    |
    ||S_=_"Hello__________World"________________________________________ ||


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t))                                  _[_d_e_p_r_e_c_a_t_e_d_]
    Equivalent to swritef(String, Format, []).


44..3322..22 FFoorrmmaatt

The format family of  predicates is the most versatile and  portable way
to produce textual output.


ffoorrmmaatt((_+_F_o_r_m_a_t))
    Defined  as `format(Format) :- format(Format, []).'.   See  format/2
    for details.


ffoorrmmaatt((_+_F_o_r_m_a_t_, _:_A_r_g_u_m_e_n_t_s))
    _F_o_r_m_a_t  is an  atom, list of  character codes,  or a Prolog  string.
    _A_r_g_u_m_e_n_t_s   provides   the   arguments  required   by   the   format
    specification.   If  only one argument  is required and this  single
    argument  is not a  list, the argument  need not be  put in a  list.
    Otherwise the arguments are put in a list.

    Special sequences start  with the tilde (~), followed by an optional
    numeric  argument,  optionally  followed by  a colon  modifier  (:),
    followed  by a character describing the action to be undertaken.   A
    numeric  argument is  either a  sequence of  digits, representing  a
    positive  decimal number, a sequence  `<_c_h_a_r_a_c_t_e_r>, representing  the
    character  code value  of the character  (only useful  for ~t) or  a
    asterisk  (*), in which case the numeric argument is taken  from the
    next  argument of  the argument  list,  which should  be a  positive
    integer.  E.g., the following three examples all pass 46 (.) to ~t:

    ____________________________________________________________________|                                                                    |
    | ?- format('~w ~46t ~w~72|~n', ['Title', 'Page']).                  |

    | ?- format('~w ~`.t ~w~72|~n', ['Title', 'Page']).                  |
    ||?-_format('~w_~*t_~w~72|~n',_['Title',_46,_'Page']).______________ ||

    Numeric  conversion (d, D,  e, E, f, g  and G) accept an  arithmetic
    expression  as argument.    This  is introduced  to handle  rational
    numbers  transparently  (see  section  ????).     The  floating  point
    conversions  allow  for unlimited  precision for  printing  rational
    numbers  in decimal form.   E.g., the  following will write as  many
    3's as you want by changing the `50'.

    ____________________________________________________________________|                                                                    |
    | ?- format('~50f', [10 rdiv 3]).                                    |
    ||3.33333333333333333333333333333333333333333333333333______________ ||

      ~  Output the tilde itself.

      a  Output the next argument, which  must be an atom.   This option
         is equivalent to ww, except that it requires the  argument to be
         an atom.

      c  Interpret the next argument  as a character code and add  it to
         the output.   This argument must  be a valid Unicode  character
         code.  Note that the actually emitted bytes are  defined by the
         character encoding of  the output stream  and an exception  may
         be raised if the  output stream is not capable  of representing
         the requested Unicode character.  See section ???? for details.

      d  Output  next argument  as  a decimal  number.    It  should  be
         an integer.    If a  numeric argument  is specified,  a dot  is
         inserted _a_r_g_u_m_e_n_t  positions from the  right (useful for  doing
         fixed point arithmetic with integers, such as  handling amounts
         of money).

         The colon modifier (e.g., ~:d) causes the number  to be printed
         according to the locale of the output stream.  See section ????.

      D  Same as dd, but  makes large values easier to read  by inserting
         a comma every three digits  left or right of the dot.   This is
         the same as ~:d, but using the fixed English locale.

      e  Output next argument as a floating point  number in exponential
         notation.    The  numeric  argument  specifies  the  precision.
         Default is  6 digits.   Exact representation  depends on the  C
         library function printf().   This function is invoked  with the
         format %.<_p_r_e_c_i_s_i_o_n>e.

      E  Equivalent  to ee,  but  outputs a  capital  E to  indicate  the
         exponent.

      f  Floating  point  in non-exponential  notation.     The  numeric
         argument defines  the number  of  digits right  of the  decimal
         point.   If  the colon  modifier (:)   is  used,  the float  is
         formatted using conventions from the current locale,  which may
         define the decimal point as well as grouping of  digits left of
         the decimal point.

      g  Floating point in ee or ff notation, whichever is shorter.

      G  Floating point in EE or ff notation, whichever is shorter.

      i  Ignore  next argument  of  the  argument  list.    Produces  no
         output.

      I  Emit  a  decimal  number  using  Prolog  digit   grouping  (the
         underscore, _).  The argument describes the size  of each digit
         group.  The default is 3.  See also section ????.  For example:

         _______________________________________________________________|                                                               |

         |?- A is 1<<100, format('~10I', [A]).                           |
         |1_2676506002_2822940149_6703205376|___________________________ |                                  |

      k  Give the next argument to write_canonical/1.

      n  Output a newline character.

      N  Only output  a newline  if the  last character  output on  this
         stream was not a newline.  Not properly implemented yet.

      p  Give the next argument to print/1.

      q  Give the next argument to writeq/1.

      r  Print integer in  radix numeric argument  notation.  Thus  ~16r
         prints its  argument hexadecimal.   The  argument should be  in
         the range [2;:::;36].   Lowercase letters are used for digits above
         9.   The  colon modifier may  be used  to form  locale-specific
         digit groups.

      R  Same as rr, but uses uppercase letters for digits above 9.

      s  Output text  from a list  of character codes  or a string  (see
         string/1 and section ????) from the next argument.

      @  Interpret the next argument as  a goal and execute it.   Output
         written to the current_output stream is inserted at this place.
         Goal is  called in the  module calling format/3.   This  option
         is not  present  in the  original  definition by  Quintus,  but
         supported by some other Prolog systems.

      t  All remaining space between 2 tab stops  is distributed equally
         over ~t  statements  between the  tab  stops.   This  space  is
         padded with spaces by default.  If an argument  is supplied, it
         is taken  to be the  character code of  the character used  for
         padding.   This  can be  used to  do left  or right  alignment,
         centering, distributing, etc.   See also  ~| and ~+ to set  tab
         stops.  A tab stop is assumed at the start of each line.

      |  Set a  tab stop on  the current position.    If an argument  is
         supplied set  a  tab stop  on the  position  of that  argument.
         This  will  cause  all  ~t's  to  be  distributed  between  the
         previous and this tab stop.

      +  Set  a tab  stop (as  ~|)  relative to  the  last tab  stop  or
         the beginning  of  the line  if  no tab  stops are  set  before
         the ~+.    This constructs can  be used  to fill fields.    The
         partial format sequence  below prints an integer  right-aligned
         and padded with zeros in 6 columns.  The ...   sequences in the
         example illustrate  that the  integer is aligned  in 6  columns
         regardless of the remainder of the format specification.

         _______________________________________________________________|                                                               |
         ||_______format('...~|~`0t~d~6+...',_[...,_Integer,_...])______ ||

      w  Give the next argument to write/1.

      W  Give the  next two  arguments to  write_term/2.   For  example,
         format('~W', [Term, [numbervars(true)]]).     This   option  is
         SWI-Prolog specific.

    Example:

    ____________________________________________________________________|                                                                    |
    | simple_statistics :-                                               |

    |     <obtain statistics>         % left to the user                 |
    |     format('~tStatistics~t~72|~n~n'),                              |
    |     format('Runtime: ~`.t ~2f~34|  Inferences: ~`.t ~D~72|~n',     |
    |                                             [RunT, Inf]),          |
    ||____....__________________________________________________________ ||

    will output

    ____________________________________________________________________|                                                                    |

    |                              Statistics                            |
    |                                                                    |
    ||Runtime:_.................._3.45__Inferences:_.........._60,345___ ||


ffoorrmmaatt((_+_O_u_t_p_u_t_, _+_F_o_r_m_a_t_, _:_A_r_g_u_m_e_n_t_s))
    As  format/2, but write  the output on  the given _O_u_t_p_u_t.   The  de-
    facto  standard only allows _O_u_t_p_u_t to  be a stream.  The  SWI-Prolog
    implementation  allows  all  valid  arguments for  with_output_to/2.
    For example:

    ____________________________________________________________________|                                                                    |
    | ?- format(atom(A), '~D', [1000000]).                               |

    ||A_=_'1,000,000'___________________________________________________ ||


44..3322..33 PPrrooggrraammmmiinngg FFoorrmmaatt


ffoorrmmaatt__pprreeddiiccaattee((_+_C_h_a_r_, _+_H_e_a_d))
    If  a sequence ~c (tilde, followed by some character) is  found, the
    format/3  and friends  first check  whether the user  has defined  a
    predicate  to handle the  format.  If  not, the built-in  formatting
    rules  described above are  used.  _C_h_a_r  is either a character  code
    or  a one-character atom, specifying  the letter to be  (re)defined.
    _H_e_a_d  is a  term, whose  name and  arity are used  to determine  the
    predicate  to call  for  the redefined  formatting character.    The
    first  argument to  the  predicate is  the numeric  argument of  the
    format  command, or the  atom default if  no argument is  specified.
    The  remaining arguments  are filled from  the argument  list.   The
    example  below defines  ~T to  print a timestamp  in ISO8601  format
    (see  format_time/3).   The  subsequent block illustrates a  possible
    call.

    ____________________________________________________________________|                                                                    |
    | :- format_predicate('T', format_time(_Arg,_Time)).                 |
    |                                                                    |
    | format_time(_Arg, Stamp) :-                                        |

    |         must_be(number, Stamp),                                    |
    ||________format_time(current_output,_'%FT%T%z',_Stamp).____________ ||

    ____________________________________________________________________|                                                                    |

    | ?- get_time(Now),                                                  |
    |    format('Now, it is ~T~n', [Now]).                               |
    | Now, it is 2012-06-04T19:02:01+0200                                |
    ||Now_=_1338829321.6620328._________________________________________ ||


ccuurrrreenntt__ffoorrmmaatt__pprreeddiiccaattee((_?_C_o_d_e_, _?_:_H_e_a_d))
    True  when ~_C_o_d_e is handled by the user-defined  predicate specified
    by _H_e_a_d.


44..3333 GGlloobbaall vvaarriiaabblleess

Global  variables are  associations  between  names (atoms)  and  terms.
They differ in  various ways from storing information using  assert/1 or
recorda/3.

  o The  value lives on  the Prolog (global) stack.   This implies  that
    lookup  time  is independent  of the  size of  the term.    This  is
    particularly  interesting for large  data structures such as  parsed
    XML documents or the CHR global constraint store.

  o They   support  both   global  assignment   using  nb_setval/2   and
    backtrackable assignment using b_setval/2.

  o Only  one value (which can be an arbitrary complex Prolog  term) can
    be associated to a variable at a time.

  o Their  value cannot be  shared among threads.   Each thread has  its
    own namespace and values for global variables.

  o Currently  global variables are  scoped globally.   We may  consider
    module scoping in future versions.

Both  b_setval/2 and nb_setval/2  implicitly create  a  variable if  the
referenced name does not already refer to a variable.

Global  variables  may  be initialised  from  directives  to  make  them
available  during the  program  lifetime,  but some  considerations  are
necessary  for  saved  states  and  threads.     Saved   states  do  not
store global  variables, which  implies they  have to  be declared  with
initialization/1 to recreate them  after loading the saved state.   Each
thread  has its  own set  of global  variables, starting  with an  empty
set.  Using thread_initialization/1 to define a global  variable it will
be defined,  restored after reloading a saved  state and created in  all
threads  that are  created  _a_f_t_e_r the  registration.    Finally,  global
variables can be initialised using the exception hook exception/3.   The
latter technique is used by CHR (see chapter ????).


bb__sseettvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associate  the  term  _V_a_l_u_e  with  the  atom  _N_a_m_e  or  replace  the
    currently  associated value  with _V_a_l_u_e.    If _N_a_m_e  does not  refer
    to  an existing global  variable, a variable  with initial value  []
    is  created (the  empty list).   On  backtracking the assignment  is
    reversed.


bb__ggeettvvaall((_+_N_a_m_e_, _-_V_a_l_u_e))
    Get the value  associated with the global variable _N_a_m_e and unify it
    with _V_a_l_u_e.   Note that this unification may further instantiate the
    value  of the global  variable.  If  this is undesirable the  normal
    precautions  (double negation or  copy_term/2) must be  taken.   The
    b_getval/2 predicate generates errors if _N_a_m_e is not  an atom or the
    requested variable does not exist.


nnbb__sseettvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associates  a copy of  _V_a_l_u_e created with duplicate_term/2 with  the
    atom  _N_a_m_e.   Note that  this can be  used to  set an initial  value
    other than [] prior to backtrackable assignment.


nnbb__ggeettvvaall((_+_N_a_m_e_, _-_V_a_l_u_e))
    The  nb_getval/2 predicate is  a synonym for  b_getval/2,  introduced
    for  compatibility  and  symmetry.    As  most  scenarios  will  use
    a   particular  global   variable  using  either   non-backtrackable
    or   backtrackable  assignment,   using  nb_getval/2  can  be   used
    to  document  that  the  variable  is  non-backtrackable.     Raises
    existence_error(_v_a_r_i_a_b_l_e_,  _N_a_m_e)  if the  variable does  not  exist.
    Alternatively,  nb_current/2 can  used to query  a global  variable.
    This  version  _f_a_i_l_s if  the  variable does  not exist  rather  than
    raising an exception.


nnbb__lliinnkkvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associates  the term _V_a_l_u_e  with the atom  _N_a_m_e without copying  it.
    This  is a  fast special-purpose  variation of  nb_setval/2 intended
    for  expert  users   only  because  the  semantics  on  backtracking
    to  a  point  before  creating  the  link  are  poorly  defined  for
    compound  terms.    The  principal term  is always  left  untouched,
    but  backtracking behaviour on arguments  is undone if the  original
    assignment  was  _t_r_a_i_l_e_d and  left  alone otherwise,  which  implies
    that  the history  that created  the term affects  the behaviour  on
    backtracking.  Consider the following example:

    ____________________________________________________________________|                                                                    |
    | demo_nb_linkval :-                                                 |

    |         T = nice(N),                                               |
    |         (   N = world,                                             |
    |             nb_linkval(myvar, T),                                  |
    |             fail                                                   |
    |         ;   nb_getval(myvar, V),                                   |
    |             writeln(V)                                             |
    ||________).________________________________________________________ ||


nnbb__ccuurrrreenntt((_?_N_a_m_e_, _?_V_a_l_u_e))
    Enumerate  all defined  variables with their  value.   The order  of
    enumeration is  undefined.  Note that nb_current/2 can be used as an
    alternative  for nb_getval/2 to request the value of a  variable and
    fail silently if the variable does not exists.


nnbb__ddeelleettee((_+_N_a_m_e))
    Delete  the  named global  variable.   Succeeds  also  if the  named
    variable does not exist.


44..3333..11 CCoommppaattiibbiilliittyy ooff SSWWII--PPrroolloogg GGlloobbaall VVaarriiaabblleess

Global variables have been introduced by  various Prolog implementations
recently.  The implementation of them in SWI-Prolog  is based on hProlog
by  Bart Demoen.    In  discussion with  Bart it  was  decided that  the
semantics of  hProlog nb_setval/2, which is equivalent  to nb_linkval/2,
is  not  acceptable  for  normal  Prolog  users  as   the  behaviour  is
influenced  by how  built-in predicates  that  construct terms  (read/1,
=../2, etc.)  are implemented.

GNU-Prolog provides  a rich set of  global variables, including  arrays.
Arrays  can be  implemented  easily in  SWI-Prolog using  functor/3  and
setarg/3 due to the unrestricted arity of compound terms.


44..3344 TTeerrmmiinnaall CCoonnttrrooll

The  following  predicates  form  a  simple  access   mechanism  to  the
Unix  termcap library  to provide  terminal-independent  I/O for  screen
terminals.  These  predicates are only available on Unix machines.   The
SWI-Prolog Windows console accepts the ANSI escape sequences.


ttttyy__ggeett__ccaappaabbiilliittyy((_+_N_a_m_e_, _+_T_y_p_e_, _-_R_e_s_u_l_t))
    Get  the  capability named  _N_a_m_e  from the  termcap  library.    See
    termcap(5)  for the capability  names.   _T_y_p_e specifies the type  of
    the  expected result, and is one of string, number or bool.   String
    results  are returned as an atom, number results as an  integer, and
    bool  results as the atom on or off.  If an option  cannot be found,
    this predicate fails  silently.  The results are only computed once.
    Successive queries on the same capability are fast.


ttttyy__ggoottoo((_+_X_, _+_Y))
    Goto  position  (_X, _Y) on  the screen.    Note  that the  predicates
    line_count/2  and  line_position/2  will  not  have  a  well-defined
    behaviour while using this predicate.


ttttyy__ppuutt((_+_A_t_o_m_, _+_L_i_n_e_s))
    Put  an  atom  via the  termcap  library  function tputs().     This
    function  decodes padding  information  in the  strings returned  by
    tty_get_capability/3 and  should be  used to  output these  strings.
    _L_i_n_e_s is the number  of lines affected by the operation, or 1 if not
    applicable (as in almost all cases).


ttttyy__ssiizzee((_-_R_o_w_s_, _-_C_o_l_u_m_n_s))
    Determine the size of the terminal.  Platforms:

    UUnniixx  If  the  system  provides _i_o_c_t_l  calls  for  this,  these  are
         used and  tty_size/2 properly  reflects the  actual size  after
         a user  resize of  the window.    The  _i_o_c_t_l is  issued on  teh
         file descriptor  associated  with the  user_input  stream.    As
         a fallback,  the system uses tty_get_capability/3 using li  and
         co capabilities.    In  this case  the  reported size  reflects
         the  size  at  the first  call  and  is  not  updated  after  a
         user-initiated resize of the terminal.

    WWiinnddoowwss  Getting  the   size  of  the   terminal  is  provided   for
         swipl-win.exe.  The requested value reflects  the current size.
         For the  multithreaded version the  console that is  associated
         with the user_input stream is used.


44..3355 OOppeerraattiinngg SSyysstteemm IInntteerraaccttiioonn

The predicates  in this section  provide basic  access to the  operating
system that  has been part of  the Prolog legacy  tradition.  Note  that
more advanced  access to low-level  OS features  is provided by  several
libaries from  the clib package, notably  library process, socket,  unix
and filesex.


sshheellll((_+_C_o_m_m_a_n_d))
    Equivalent to `shell(Command, 0)'.  See shell/2 for details.


sshheellll((_+_C_o_m_m_a_n_d_, _-_S_t_a_t_u_s))
    Execute  _C_o_m_m_a_n_d on the operating system.   _C_o_m_m_a_n_d is given to  the
    Bourne  shell (/bin/sh).  _S_t_a_t_u_s is unified with the exit  status of
    the command.

    On   Windows,    shell/[1,2]  executes   the   command   using   the
    CreateProcess() API and waits  for the command to terminate.  If the
    command  ends with a & sign, the command is handed to  the WinExec()
    API,  which does not wait for the  new task to terminate.   See also
    win_exec/2 and  win_shell/2.   Please  note that the  CreateProcess()
    API  does nnoott  imply the  Windows command  interpreter (cmd.exe  and
    therefore  commands that  are built in  the command interpreter  can
    only  be activated using  the command interpreter.   For example,  a
    file can be compied using the command below.

    ____________________________________________________________________|                                                                    |
    ||?-_shell('cmd.exe_/C_copy_file1.txt_file2.txt').__________________ ||

    Note  that  many  of  the  operations that  can  be  achieved  using
    the  shell built-in  commands can  easily be  achieved using  Prolog
    primitives.    See  make_directory/1, delete_file/1,  rename_file/2,
    etc.   The clib package provides filesex, implementing  various high
    level file  operations such as copy_file/2.   Using Prolog primitives
    instead of shell commands improves the portability of your program.

    The  library process  provides process_create/3 and several  related
    primitives   that   support  more   fine-grained  interaction   with
    processes, including  I/O redirection and management of asynchronous
    processes.


ggeetteennvv((_+_N_a_m_e_, _-_V_a_l_u_e))
    Get  environment variable.    Fails  silently if  the variable  does
    not  exist.     Please  note that  environment  variable  names  are
    case-sensitive on Unix systems and case-insensitive on Windows.


sseetteennvv((_+_N_a_m_e_, _+_V_a_l_u_e))
    Set  an environment variable.   _N_a_m_e and _V_a_l_u_e must be  instantiated
    to  atoms or  integers.   The  environment variable  will be  passed
    to  shell/[0-2] and  can be  requested using  getenv/2.   They  also
    influence  expand_file_name/2.    Environment variables  are  shared
    between  threads.  Depending  on the underlying C library,  setenv/2
    and  unsetenv/1 may not be  thread-safe and may cause memory  leaks.
    Only  changing the environment once  and before starting threads  is
    safe in all versions of SWI-Prolog.


uunnsseetteennvv((_+_N_a_m_e))
    Remove  an environment variable from the environment.   Some systems
    lack  the underlying unsetenv() library function.  On  these systems
    unsetenv/1 sets the variable to the empty string.


sseettllooccaallee((_+_C_a_t_e_g_o_r_y_, _-_O_l_d_, _+_N_e_w))
    Set/Query  the  _l_o_c_a_l_e setting  which  tells the  C library  how  to
    interpret  text  files, write  numbers,  dates, etc.    Category  is
    one  of all, collate,  ctype, messages,  monetary, numeric or  time.
    For  details,  please consult  the C  library locale  documentation.
    See  also  section ????.     Please note  that  the locale  is  shared
    between  all  threads and  thread-safe usage  of  setlocale/3 is  in
    general  not  possible.     Do  locale  operations  before  starting
    threads  or thoroughly  study  threading aspects  of locale  support
    in  your  environment before  using in  multithreaded  environments.
    Locale  settings  are  used  by format_time/3,  collation_key/2  and
    locale_sort/2.


uunniixx((_+_C_o_m_m_a_n_d))
    This  predicate comes  from  the Quintus  compatibility library  and
    provides  a partial implementation thereof.   It provides access  to
    some operating system  features and unlike the name suggests, is not
    operating system specific.  Defined _C_o_m_m_a_n_d's are below.

    ssyysstteemm((_+_C_o_m_m_a_n_d))
         Equivalent to calling shell/1.  Use for compatibility only.

    sshheellll((_+_C_o_m_m_a_n_d))
         Equivalent to calling shell/1.  Use for compatibility only.

    sshheellll
         Equivalent to calling shell/0.  Use for compatibility only.

    ccdd
         Equivalent to calling working_directory/2 to the expansion (see
         expand_file_name/2) of ~.  For compatibility only.

    ccdd((_+_D_i_r_e_c_t_o_r_y))
         Equivalent to calling working_directory/2.  Use for compatibil-
         ity only.

    aarrggvv((_-_A_r_g_v))
         Unify _A_r_g_v with the list of command line  arguments provided to
         this Prolog run.  Please note that Prolog  system arguments and
         application arguments are separated  by --.  Integer  arguments
         are  passed as  Prolog  integers,  float arguments  and  Prolog
         floating  point  numbers and  all  other  arguments  as  Prolog
         atoms.  New applications should use the Prolog flag argv.   See
         also the Prolog flag argv.


44..3355..11 WWiinnddoowwss--ssppeecciiffiicc OOppeerraattiinngg SSyysstteemm IInntteerraaccttiioonn

The  predicates  in this  section  are  only available  on  the  Windows
version  of  SWI-Prolog.     Their  use  is  discouraged  if  there  are
portably  alternatives.   For  example,  win_exec/2 and win_shell/2  can
often be  replaced by  the more  portable shell/2 or  the more  powerful
process_create/3.


wwiinn__eexxeecc((_+_C_o_m_m_a_n_d_, _+_S_h_o_w))
    Windows  only.    Spawns  a Windows  task  without waiting  for  its
    completion.    _S_h_o_w  is  one  of the  Win32  SW_*  constants  written
    in  lowercase  without the  SW_*:   hide maximize  minimize  restore
    show showdefault  showmaximized showminimized showminnoactive showna
    shownoactive  shownormal.   In  addition,  iconic is  a synonym  for
    minimize and normal for shownormal.


wwiinn__sshheellll((_+_O_p_e_r_a_t_i_o_n_, _+_F_i_l_e_, _+_S_h_o_w))
    Windows  only.   Opens  the document  _F_i_l_e using  the Windows  shell
    rules  for doing so.  _O_p_e_r_a_t_i_o_n is one of open, print  or explore or
    another  operation registered with the shell for the  given document
    type.  On  modern systems it is also possible to pass a URL as _F_i_l_e,
    opening  the URL in Windows default  browser.  This call  interfaces
    to  the Win32 API ShellExecute().  The _S_h_o_w argument  determines the
    initial  state of the  opened window (if any).   See  win_exec/2 for
    defined values.


wwiinn__sshheellll((_+_O_p_e_r_a_t_i_o_n_, _+_F_i_l_e))
    Same as win_shell(_O_p_e_r_a_t_i_o_n_, _F_i_l_e_, _n_o_r_m_a_l)


wwiinn__rreeggiissttrryy__ggeett__vvaalluuee((_+_K_e_y_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Windows  only.  Fetches  the value of a  Windows registry key.   _K_e_y
    is  an atom formed  as a path  name describing the desired  registry
    key.   _N_a_m_e  is the  desired attribute name  of the key.   _V_a_l_u_e  is
    unified  with  the value.    If  the  value is  of type  DWORD,  the
    value  is returned  as an integer.   If  the value is  a string,  it
    is  returned  as a  Prolog atom.    Other  types are  currently  not
    supported.    The default  `root' is HKEY_CURRENT_USER. Other  roots
    can be  specified explicitly as HKEY_CLASSES_ROOT, HKEY_CURRENT_USER,
    HKEY_LOCAL_MACHINE  or HKEY_USERS.  The  example below  fetches  the
    extension  to use for  Prolog files (see  README.TXT on the  Windows
    version):

    ____________________________________________________________________|                                                                    |
    | ?- win_registry_get_value(                                         |
    |        'HKEY_LOCAL_MACHINE/Software/SWI/Prolog',                   |
    |        fileExtension,                                              |

    |        Ext).                                                       |
    |                                                                    |
    ||Ext_=_pl__________________________________________________________ ||


wwiinn__ffoollddeerr((_?_N_a_m_e_, _-_D_i_r_e_c_t_o_r_y))
    True  if _N_a_m_e  is the  Windows `CSIDL'  of _D_i_r_e_c_t_o_r_y.    If _N_a_m_e  is
    unbound,  all  known Windows  special  paths are  generated.    _N_a_m_e
    is  the  CSIDL after  deleting the  leading CSIDL_  and mapping  the
    constant  to lowercase.    Check the Windows  documentation for  the
    function  SHGetSpecialFolderPath() for a description of  the defined
    constants.  This example extracts the `My Documents' folder:

    ____________________________________________________________________|                                                                    |
    | ?- win_folder(personal, MyDocuments).                              |

    |                                                                    |
    ||MyDocuments_=_'C:/Documents_and_Settings/jan/My_Documents'________ ||


wwiinn__aadddd__ddllll__ddiirreeccttoorryy((_+_A_b_s_D_i_r))
    This  predicate  adds  a  directory  to  the  search  path  for  de-
    pendent   DLL  files.      If  possible,   this  is  achieved   with
    win_add_dll_directory/2.   Otherwise,  %PATH% is  extended with  the
    provided  directory.     _A_b_s_D_i_r  may  be  specified  in  the  Prolog
    canonical   syntax.     See  prolog_to_os_filename/2.      Note  that
    use_foreign_library/1 passes  an absolute  path  to the  DLL if  the
    destination  DLL  can   be  located  from  the  specification  using
    absolute_file_name/3.


wwiinn__aadddd__ddllll__ddiirreeccttoorryy((_+_A_b_s_D_i_r_, _-_C_o_o_k_i_e))
    This  predicate adds a  directory to the  search path for  dependent
    DLL  files.   If the  call is  successful it unifies  _C_o_o_k_i_e with  a
    handle  that must be passed  to win_remove_dll_directory/1to  remove
    the directory from the search path.  Error conditions:

      o  This predicate is available  in the Windows port of  SWI-Prolog
         starting from 6.3.8/6.2.6.

      o  This  predicate _f_a_i_l_s  if  Windows  does not  yet  support  the
         underlying  primitives.     These  are  available  in  recently
         patched Windows 7 systems and later.

      o  This predicate  throws an  acception  if the  provided path  is
         invalid or the underlying Windows API returns an error.

    If    open_shared_object/2  is   passed   an   _a_b_s_o_l_u_t_e    path   to
    a    DLL   on   a    Windows   installation   that   supports    Ad-
    dDllDirectory()    and    friends,     SWI-Prolog    uses    LoadLi-
    braryEx()   with  the   flags   LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR   and
    LOAD_LIBRARY_SEARCH_DEFAULT_DIRS. In this  scenario, directories from
    %PATH% and _n_o_t  searched.  Additional directories can be added using
    win_add_dll_directory/2.


wwiinn__rreemmoovvee__ddllll__ddiirreeccttoorryy((_-_C_o_o_k_i_e))
    Remove     a     DLL     search    directory     installed     using
    win_add_dll_directory/2.


44..3355..22 DDeeaalliinngg wwiitthh ttiimmee aanndd ddaattee

Representing  time in  a computer  system  is surprisingly  complicated.
There  are a  large  number of  time  representations in  use,  and  the
correct choice  depends on factors such  as compactness, resolution  and
desired operations.   Humans  tend to think about  time in hours,  days,
months, years  or centuries.   Physicists think  about time in  seconds.
But, a  month does not  have a defined  number of seconds.   Even a  day
does not  have a defined  number of seconds  as sometimes a  leap-second
is introduced  to synchronise properly  with our earth's  rotation.   At
the same time, resolution demands a range from  better than pico-seconds
to millions  of years.    Finally, civilizations  have a  wide range  of
calendars.   Although there  exist libraries dealing  with most if  this
complexity,  our desire  to keep  Prolog clean  and lean  stops us  from
fully supporting these.

For human-oriented tasks,  time can be broken into years, months,  days,
hours,  minutes, seconds  and a  timezone.   Physicists  prefer to  have
time in an arithmetic type representing seconds or  fraction thereof, so
basic arithmetic  deals with comparison  and durations.   An  additional
advantage of  the physicist's  approach is  that it  requires much  less
space.   For these  reasons, SWI-Prolog uses an  arithmetic type as  its
prime time representation.

Many C  libraries deal with time  using fixed-point arithmetic,  dealing
with a large  but finite time interval at  constant resolution.  In  our
opinion, using a  floating point number is  a more natural choice as  we
can use a natural unit and the interface does not need  to be changed if
a higher resolution  is required in the future.   Our unit of choice  is
the second as it is  the scientific unit.  We have placed our  origin at
1970-1-1T0:0:0Z for compatibility with the POSIX notion of  time as well
as with older time support provided by SWI-Prolog.

Where    older     versions    of     SWI-Prolog    relied    on     the
POSIX   conversion   functions,    the   current   implementation   uses
http://cr.yp.to/libtai.htmllibtai  to realise  conversion between  time-
stamps and calendar dates for a period of 10 million years.


44..3355..22..11 TTiimmee aanndd ddaattee ddaattaa ssttrruuccttuurreess

We use the following time representations

TTiimmeeSSttaammpp
    A  TimeStamp  is a  floating  point number  expressing the  time  in
    seconds since the Epoch at 1970-1-1.

ddaattee((_Y_,_M_,_D_,_H_,_M_n_,_S_,_O_f_f_,_T_Z_,_D_S_T))
    We  call this term a  _d_a_t_e_-_t_i_m_e structure.   The first 5 fields  are
    integers  expressing  the year,  month  (1..12), day  (1..31),  hour
    (0..23)  and minute (0..59).   The  _S field holds  the seconds as  a
    floating  point number  between 0.0  and 60.0.   _O_f_f  is an  integer
    representing  the offset relative to UTC in seconds,  where positive
    values  are west of  Greenwich.  If  converted from local time  (see
    stamp_date_time/3), _T_Z  holds the name  of the local  timezone.   If
    the  timezone is  not known,  _T_Z is  the atom  -.   _D_S_T  is true  if
    daylight saving time  applies to the current time, false if daylight
    saving  time is relevant but not effective, and - if unknown  or the
    timezone has no daylight saving time.

ddaattee((_Y_,_M_,_D))
    Date  using the  same values as  described above.   Extracted  using
    date_time_value/3.

ttiimmee((_H_,_M_n_,_S))
    Time  using the  same values as  described above.   Extracted  using
    date_time_value/3.


44..3355..22..22 TTiimmee aanndd ddaattee pprreeddiiccaatteess


ggeett__ttiimmee((_-_T_i_m_e_S_t_a_m_p))
    Return  the  current  time as  a  _T_i_m_e_S_t_a_m_p.    The  granularity  is
    system-dependent.  See section ????.


ssttaammpp__ddaattee__ttiimmee((_+_T_i_m_e_S_t_a_m_p_, _-_D_a_t_e_T_i_m_e_, _+_T_i_m_e_Z_o_n_e))
    Convert  a _T_i_m_e_S_t_a_m_p  to  a _D_a_t_e_T_i_m_e  in the  given timezone.    See
    section  ???? for details on the  data types.  _T_i_m_e_Z_o_n_e describes  the
    timezone  for the conversion.   It  is one of  local to extract  the
    local  time, 'UTC' to  extract a UTC  time or an integer  describing
    the seconds west of Greenwich.


ddaattee__ttiimmee__ssttaammpp((_+_D_a_t_e_T_i_m_e_, _-_T_i_m_e_S_t_a_m_p))
    Compute  the timestamp from a date/9  term.  Values for month,  day,
    hour,  minute or second  need not be  normalized.  This  flexibility
    allows  for easy  computation of  the time  at any  given number  of
    these  units from a given timestamp.  Normalization can  be achieved
    following  this call with stamp_date_time/3.  This example  computes
    the date 200 days after 2006-7-14:

    ____________________________________________________________________|                                                                    |
    | ?- date_time_stamp(date(2006,7,214,0,0,0,0,-,-), Stamp),           |

    |    stamp_date_time(Stamp, D, 0),                                   |
    |    date_time_value(date, D, Date).                                 |
    ||Date_=_date(2007,_1,_30)__________________________________________ ||

    When  computing a time  stamp from a  local time specification,  the
    UTC offset (arg 7),  TZ (arg 8) and DST (arg 9) argument may be left
    unbound  and are unified with the  proper information.  The  example
    below,  executed in Amsterdam, illustrates  this behaviour.  On  the
    25th of March at 01:00,  DST does not apply.  At 02.00, the clock is
    advanced  by one hour  and thus both  02:00 and 03:00 represent  the
    same time stamp.

    ____________________________________________________________________|                                                                    |
    | 1 ?- date_time_stamp(date(2012,3,25,1,0,0,UTCOff,TZ,DST),          |
    |                      Stamp).                                       |
    | UTCOff = -3600,                                                    |

    | TZ = 'CET',                                                        |
    | DST = false,                                                       |
    | Stamp = 1332633600.0.                                              |
    |                                                                    |
    | 2 ?- date_time_stamp(date(2012,3,25,2,0,0,UTCOff,TZ,DST),          |
    |                      Stamp).                                       |
    | UTCOff = -7200,                                                    |
    | TZ = 'CEST',                                                       |

    | DST = true,                                                        |
    | Stamp = 1332637200.0.                                              |
    |                                                                    |
    | 3 ?- date_time_stamp(date(2012,3,25,3,0,0,UTCOff,TZ,DST),          |
    |                      Stamp).                                       |
    | UTCOff = -7200,                                                    |
    | TZ = 'CEST',                                                       |

    | DST = true,                                                        |
    ||Stamp_=_1332637200.0._____________________________________________ ||

    Note   that   DST  and   offset  calculation   are   based  on   the
    POSIX  function  mktime().     If  mktime()  returns  an  error,   a
    representation_error dst is generated.


ddaattee__ttiimmee__vvaalluuee((_?_K_e_y_, _+_D_a_t_e_T_i_m_e_, _?_V_a_l_u_e))
    Extract values from a date/9 term.  Provided keys are:

       ______________________________________________________________kkeeyyvvaalluuee
       ____________________________________________________________________________________________________________________________yearCalendar year as an integer

        month            Calendar month as an integer 1..12
        day              Calendar day as an integer 1..31
        hour             Clock hour as an integer 0..23

        minute           Clock minute as an integer 0..59
        second           Clock second as a float 0.0..60.0
        utc_offset       Offset to UTC in seconds (positive is west)
        time_zone        Name of timezone; fails if unknown
        daylight_saving  Bool (true) if dst is in effect
        date             Term date(_Y_,_M_,_D)
       _time_____________Term_time(_H_,_M_,_S)____________________________


ffoorrmmaatt__ttiimmee((_+_O_u_t_, _+_F_o_r_m_a_t_, _+_S_t_a_m_p_O_r_D_a_t_e_T_i_m_e))
    Modelled  after POSIX  strftime(),  using GNU  extensions.   _O_u_t  is
    a  destination  as  specified  with  with_output_to/2.     _F_o_r_m_a_t  is
    an  atom or  string  with the  following conversions.    Conversions
    start  with a percent  (%) character.   _S_t_a_m_p_O_r_D_a_t_e_T_i_m_e is either  a
    numeric  time-stamp,  a term  date(_Y_,_M_,_D_,_H_,_M_,_S_,_O_,_T_Z_,_D_S_T)  or a  term
    date(_Y_,_M_,_D).

      a  The abbreviated weekday  name according to the current  locale.
         Use format_time/4 for POSIX locale.

      A  The full  weekday name according  to the current  locale.   Use
         format_time/4 for POSIX locale.

      b  The abbreviated  month name  according to  the current  locale.
         Use format_time/4 for POSIX locale.

      B  The full  month name  according  to the  current locale.    Use
         format_time/4 for POSIX locale.

      c  The preferred  date  and time  representation for  the  current
         locale.

      C  The century number (year/100) as a 2-digit integer.

      d  The day of the month as a decimal number (range 01 to 31).

      D  Equivalent  to %m/%d/%y.    (For  Americans  only.    Americans
         should note that in other countries %d/%m/%y  is rather common.
         This means  that in  an  international context  this format  is
         ambiguous and should not be used.)

      e  Like %d,  the  day of  the month  as a  decimal number,  but  a
         leading zero is replaced by a space.

      E  Modifier.  Not implemented.

      f  Number of microseconds.   The f  can be prefixed by an  integer
         to print  the  desired number  of  digits.   E.g.,  %3f  prints
         milliseconds.   This  format is  not covered  by any  standard,
         but  available  with different  format  specifiers  in  various
         incarnations of the strftime() function.

      F  Equivalent to %Y-%m-%d (the ISO 8601 date format).

      g  Like  %G,  but without  century,  i.e.,  with  a  2-digit  year
         (00-99).

      G  The ISO  8601  year with  century as  a decimal  number.    The
         4-digit year  corresponding to  the ISO week  number (see  %V).
         This has the  same format and value as  %y, except that if  the
         ISO week  number belongs  to the  previous or  next year,  that
         year is used instead.

      V  The ISO 8601:1988 week number of the current year  as a decimal
         number, range  01 to 53,  where week 1 is  the first week  that
         has at least  4 days in  the current year,  and with Monday  as
         the first day of the week.  See also %U and %W.

      h  Equivalent to %b.

      H  The hour as  a decimal number using  a 24-hour clock (range  00
         to 23).

      I  The hour as  a decimal number using  a 12-hour clock (range  01
         to 12).

      j  The day of the year as a decimal number (range 001 to 366).

      k  The hour (24-hour clock)  as a decimal number (range 0  to 23);
         single digits are preceded by a blank.  (See also %H.)

      l  The hour (12-hour clock)  as a decimal number (range 1  to 12);
         single digits are preceded by a blank.  (See also %I.)

      m  The month as a decimal number (range 01 to 12).

      M  The minute as a decimal number (range 00 to 59).

      n  A newline character.

      O  Modifier to select locale-specific output.  Not implemented.

      p  Either `AM' or `PM'  according to the given time value,  or the
         corresponding strings for the current locale.   Noon is treated
         as `pm' and midnight as `am'.

      P  Like %p  but in  lowercase:  `am'  or `pm'  or a  corresponding
         string for the current locale.

      r  The time in  a.m. or p.m. notation.   In the POSIX locale  this
         is equivalent to `%I:%M:%S %p'.

      R  The time in 24-hour  notation (%H:%M). For a version  including
         the seconds, see %T below.

      s  The number of seconds  since the Epoch, i.e., since  1970-01-01
         00:00:00 UTC.

      S  The second as  a decimal number (range 00  to 60).  (The  range
         is up to 60 to allow for occasional leap seconds.)

      t  A tab character.

      T  The time in 24-hour notation (%H:%M:%S).

      u  The day of the  week as a decimal,  range 1 to 7, Monday  being
         1.  See also %w.

      U  The week number of the current year as a  decimal number, range
         00 to 53,  starting with the first  Sunday as the first day  of
         week 01.  See also %V and %W.

      w  The day of the  week as a decimal,  range 0 to 6, Sunday  being
         0.  See also %u.

      W  The week number of the current year as a  decimal number, range
         00 to 53,  starting with the first  Monday as the first day  of
         week 01.

      x  The  preferred  date  representation  for  the  current  locale
         without the time.

      X  The  preferred  time  representation  for  the  current  locale
         without the date.

      y  The year  as a decimal  number without a  century (range 00  to
         99).

      Y  The year as a decimal number including the century.

      z  The  timezone  as  hour  offset  from  GMT   using  the  format
         HHmm.     Required  to  emit  RFC822-conforming   dates  (using
         '%a, %d %b %Y %T %z').  Our implementation supports  %:z, which
         modifies the output to  HH:mm as required by XML-Schema.   Note
         that both notations  are valid in ISO  8601.  The sequence  %:z
         is compatible to the GNU date(1) command.

      Z  The timezone or name or abbreviation.

      +  The date and time in date(1) format.

      %  A literal `%' character.

    The  table  below   gives  some  format  strings  for  popular  time
    representations.   RFC1123 is used by HTTP. The  full implementation
    of http_timestamp/2 as available from http/http_header is here.

    ____________________________________________________________________|                                                                    |

    | http_timestamp(Time, Atom) :-                                      |
    |         stamp_date_time(Time, Date, 'UTC'),                        |
    |         format_time(atom(Atom),                                    |
    |                     '%a, %d %b %Y %T GMT',                         |
    ||____________________Date,_posix)._________________________________ ||

                      __________________________________SSttaannddaarrddFFoorrmmaatt ssttrriinngg
                      ____________________________________________________________________xxssdd'%FT%T%:z'

                       IISSOO88660011   '%FT%T%z'
                       RRFFCC882222    '%a, %d %b %Y %T %z'
                      _RRFFCC11112233___'%a,_%d_%b_%Y_%T_GMT'__


ffoorrmmaatt__ttiimmee((_+_O_u_t_, _+_F_o_r_m_a_t_, _+_S_t_a_m_p_O_r_D_a_t_e_T_i_m_e_, _+_L_o_c_a_l_e))
    Format  time  given  a  specified  _L_o_c_a_l_e.    This  predicate  is  a
    work-around  for   lacking  proper  portable  and  thread-safe  time
    and  locale  handling  in current  C  libraries.    In  its  current
    implementation  the only value  allowed for  _L_o_c_a_l_e is posix,  which
    currently  only modifies the behaviour of  the a, A, b and  B format
    specifiers.   The predicate is used to be able to emit  POSIX locale
    week  and month names for emitting standardised time-stamps  such as
    RFC1123.


ppaarrssee__ttiimmee((_+_T_e_x_t_, _-_S_t_a_m_p))
    Same as parse_time(_T_e_x_t_, ___F_o_r_m_a_t_, _S_t_a_m_p).  See parse_time/3.


ppaarrssee__ttiimmee((_+_T_e_x_t_, _?_F_o_r_m_a_t_, _-_S_t_a_m_p))
    Parse  a  textual  time  representation,   producing  a  time-stamp.
    Supported  formats  for  _T_e_x_t  are in  the  table  below.    If  the
    format  is  known,  it  may  be  given  to  reduce  parse  time  and
    avoid  ambiguities.   Otherwise, _F_o_r_m_a_t is  unified with the  format
    encountered.

                 ___________________________________________
                 |__NNaammee________||EExxaammppllee__________________________________________________||
                 || rfc_1123F|ri, 08 Dec 2006 15:29:44 GMT   |
                 |_________|Fri,_08_Dec_2006_15:29:44_+0000_|
                 | iso_86012|006-12-08T17:29:44+02:00       |

                 |         |20061208T172944+0200            |
                 |         |2006-12-08T15:29Z               |
                 |         |2006-12-08                      |
                 |         |20061208                        |
                 |         |2006-12                         |
                 |         |2006-W49-5                      |
                 |_________|2006-342________________________|


ddaayy__ooff__tthhee__wweeeekk((_+_D_a_t_e_,_-_D_a_y_O_f_T_h_e_W_e_e_k))
    Computes    the   day    of   the   week    for   a   given    date.
    _D_a_t_e = date(_Y_e_a_r,_M_o_n_t_h,_D_a_y).       Days   of  the   week  are   num-
    bered  from one to seven:   Monday = 1, Tuesday  = 2, ..., Sunday  =
    7.


44..3355..33 CCoonnttrroolllliinngg tthhee swipl-win.exe ccoonnssoollee wwiinnddooww

The Windows executable swipl-win.exe console has a  number of predicates
to control the appearance  of the console.  Being  totally non-portable,
we do  not advise using  it for your  own application,  but use XPCE  or
another  portable GUI  platform instead.    We give  the predicates  for
reference here.


wwiinnddooww__ttiittllee((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d with the  title displayed in  the console and change  the
    title to _N_e_w.


wwiinn__wwiinnddooww__ppooss((_+_L_i_s_t_O_f_O_p_t_i_o_n_s))
    Interface  to the  MS-Windows  SetWindowPos() function,  controlling
    size,  position and stacking order of the window.   _L_i_s_t_O_f_O_p_t_i_o_n_s is
    a list that may hold any number of the terms below:

    ssiizzee((_W_, _H))
         Change the  size of  the window.    _W  and _H  are expressed  in
         character units.

    ppoossiittiioonn((_X_, _Y))
         Change the  top-left corner  of  the window.    The values  are
         expressed in pixel units.

    zzoorrddeerr((_Z_O_r_d_e_r))
         Change the  location  in the  window stacking  order.    Values
         are bottom, top,  topmost and notopmost.   _T_o_p_m_o_s_t windows  are
         displayed above all other windows.

    sshhooww((_B_o_o_l))
         If true, show the window, if false hide the window.

    aaccttiivvaattee
         If present, activate the window.


wwiinn__hhaass__mmeennuu
    True if win_insert_menu/2 and win_insert_menu_item/4are present.


wwiinn__iinnsseerrtt__mmeennuu((_+_L_a_b_e_l_, _+_B_e_f_o_r_e))
    Insert  a new entry  (pulldown) in the  menu.   If the menu  already
    contains  this entry,  nothing  is done.    The _L_a_b_e_l  is the  label
    and,  using  the Windows  convention, a  letter prefixed  with &  is
    underlined  and defines the associated  accelerator key.  _B_e_f_o_r_e  is
    the label before which this one  must be inserted.  Using - adds the
    new  entry at the end (right).  For example, the call  below adds an
    Application entry just before the Help menu.

    ____________________________________________________________________|                                                                    |
    ||win_insert_menu('&Application',_'&Help')__________________________ ||


wwiinn__iinnsseerrtt__mmeennuu__iitteemm((_+_P_u_l_l_d_o_w_n_, _+_L_a_b_e_l_, _+_B_e_f_o_r_e_, _:_G_o_a_l))
    Add  an  item  to  the  named  _P_u_l_l_d_o_w_n menu.     _L_a_b_e_l  and  _B_e_f_o_r_e
    are  handled  as in  win_insert_menu/2,  but the  label -  inserts  a
    _s_e_p_a_r_a_t_o_r.  _G_o_a_l is called if the user selects the item.


44..3366 FFiillee SSyysstteemm IInntteerraaccttiioonn


aacccceessss__ffiillee((_+_F_i_l_e_, _+_M_o_d_e))
    True  if _F_i_l_e  exists and  can be  accessed by  this Prolog  process
    under  mode _M_o_d_e.   _M_o_d_e is  one of the  atoms read, write,  append,
    exist,  none or execute.  _F_i_l_e may also be the name  of a directory.
    Fails  silently otherwise.   access_file(File, none)simply  succeeds
    without testing anything.

    If  _M_o_d_e is  write or append,  this predicate  also succeeds if  the
    file  does not exist and the user has write access to  the directory
    of the specified location.

    The  bahaviour  is   backed  up  by  the  POSIX  access()  API.  The
    Windows  replacement (_waccess())  returns incorrect results  because
    it  does  not consider  ACLs (Access  Control Lists).    The  Prolog
    flag  win_file_access_check may  be used  to  control the  level  of
    checking  performed by  Prolog.   Please note  that checking  access
    never  provides a guarantee that a subsequent open  succeeds without
    errors  due  to inherent  concurrency in  file operations.    It  is
    generally  more robust to try and open the file and  handle possible
    exceptions.  See open/4 and catch/3.


eexxiissttss__ffiillee((_+_F_i_l_e))
    True if _F_i_l_e exists  and is a regular file.  This does not imply the
    user  has read and/or write  permission for the file.   This is  the
    same as access_file(_F_i_l_e_, _e_x_i_s_t).


ffiillee__ddiirreeccttoorryy__nnaammee((_+_F_i_l_e_, _-_D_i_r_e_c_t_o_r_y))
    Extracts  the directory part  of _F_i_l_e.   This predicate removes  the
    longest match for  the regular expression /*[^/]*/*$.  If the result
    is  empty it binds  _D_i_r_e_c_t_o_r_y to  / if the  first character of  _F_i_l_e
    is  / and . otherwise.   The behaviour is consistent with  the POSIX
    dirname program.

    See   also  directory_file_path/3  from   filesex.      The   system
    ensures  that  for   every  valid  _P_a_t_h  using  the  Prolog  (POSIX)
    directory  separators, following  is true  on systems  with a  sound
    implementation of same_file/2.  See also prolog_to_os_filename/2.

    ____________________________________________________________________|                                                                    |
    |         ...,                                                       |

    |         file_directory_name(Path, Dir),                            |
    |         file_base_name(Path, File),                                |
    |         directory_file_path(Dir, File, Path2),                     |
    ||________same_file(Path,_Path2).___________________________________ ||


ffiillee__bbaassee__nnaammee((_+_P_a_t_h_, _-_F_i_l_e))
    Extracts   the  file   name  part  from   a  path.      Similar   to
    file_directory_name/2  the   extraction  is  based   on  the   regex
    /*([^/]*)/*$,  now capturing the non-/ segment.   If the segment  is
    empty  it unifies _F_i_l_e with  / if _P_a_t_h starts  with / and the  empty
    atom  ('') otherwise.   The behaviour  is consistent with the  POSIX
    basename program.


ssaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    True  if both  filenames  refer to  the same  physical file.    That
    is,  if _F_i_l_e_1  and _F_i_l_e_2  are the  same string or  both names  exist
    and  point  to  the  same  file  (due  to  hard  or  symbolic  links
    and/or  relative  vs. absolute  paths).    On systems  that  provide
    stat()  with meaningful values for  st_dev  and st_inode, same_file/2
    is  implemented  by  comparing  the device  and  inode  identifiers.
    On  Windows,  same_file/2  compares  the  strings  returned  by  the
    GetFullPathName() system call.


eexxiissttss__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    True  if _D_i_r_e_c_t_o_r_y exists and is a  directory.  This does  not imply
    the user has read, search or write permission for the directory.


ddeelleettee__ffiillee((_+_F_i_l_e))
    Remove _F_i_l_e from the file system.


rreennaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    Rename  _F_i_l_e_1 as _F_i_l_e_2.   The semantics  is compatible to the  POSIX
    semantics  of  the rename()  system  call as  far as  the  operating
    system  allows.   Notably, if _F_i_l_e_2  exists, the operation  succeeds
    (except  for  possible permission  errors)  and is  _a_t_o_m_i_c  (meaning
    there is no window where _F_i_l_e_2 does not exist).


ssiizzee__ffiillee((_+_F_i_l_e_, _-_S_i_z_e))
    Unify _S_i_z_e with the size of _F_i_l_e in bytes.


ttiimmee__ffiillee((_+_F_i_l_e_, _-_T_i_m_e))
    Unify  the last  modification time of  _F_i_l_e with  _T_i_m_e.   _T_i_m_e is  a
    floating  point number expressing the  seconds elapsed since Jan  1,
    1970.  See also convert_time/[2,8] and get_time/1.


aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e_, _-_A_b_s_o_l_u_t_e))
    Expand  a  local filename  into  an absolute  path.    The  absolute
    path  is  canonicalised:    references  to .  and  ..  are  deleted.
    This  predicate ensures that expanding  a filename returns the  same
    absolute  path regardless of how the file is addressed.   SWI-Prolog
    uses  absolute filenames  to  register source  files independent  of
    the  current working directory.   See  also absolute_file_name/3 and
    expand_file_name/2.


aabbssoolluuttee__ffiillee__nnaammee((_+_S_p_e_c_, _-_A_b_s_o_l_u_t_e_, _+_O_p_t_i_o_n_s))
    Convert  the given file specification into  an absolute path.   _S_p_e_c
    is  a  term  Alias(Relative)  (e.g.,  (library(lists)),  a  relative
    filename  or an absolute  filename.   The primary intention of  this
    predicate is to  resolve files specified as Alias(Relative).  _O_p_t_i_o_n
    is a list of options to guide the conversion:

    eexxtteennssiioonnss((_L_i_s_t_O_f_E_x_t_e_n_s_i_o_n_s))
         List of  file extensions  to try.   Default  is ''.   For  each
         extension,  absolute_file_name/3 will first  add the  extension
         and then verify  the conditions imposed  by the other  options.
         If the  condition  fails, the  next extension  on  the list  is
         tried.  Extensions may be specified both as .ext or plain ext.

    rreellaattiivvee__ttoo((_+_F_i_l_e_O_r_D_i_r))
         Resolve  the  path relative  to  the  given  directory  or  the
         directory  holding  the given  file.     Without  this  option,
         paths  are   resolved   relative  to   the  working   directory
         (see   working_directory/2)   or,   if   _S_p_e_c  is   atomic   and
         absolute_file_name/[2,3] is executed  in a  directive, it  uses
         the current source file as reference.

    aacccceessss((_M_o_d_e))
         Imposes the  condition access_file(_F_i_l_e, _M_o_d_e).    _M_o_d_e is  one
         of read,  write,  append, execute,  exist or  none.   See  also
         access_file/2.

    ffiillee__ttyyppee((_T_y_p_e))
         Defines  extensions.    Current  mapping:   txt  implies  [''],
         prolog  implies ['.pl', ''],  executable  implies  ['.so', ''],
         qlf implies  ['.qlf', '']  and  directory implies  [''].    The
         file  type source  is an  alias  for prolog  for  compatibility
         with  SICStus Prolog.     See also  prolog_file_type/2.     This
         predicate  only  returns  non-directories,  unless  the  option
         file_type(_d_i_r_e_c_t_o_r_y) is specified.

    ffiillee__eerrrroorrss((_f_a_i_l_/_e_r_r_o_r))
         If error (default),  throw an existence_error exception if  the
         file cannot be found.  If fail, stay silent.

    ssoolluuttiioonnss((_f_i_r_s_t_/_a_l_l))
         If  first (default),  the  predicate  leaves no  choice  point.
         Otherwise a  choice point  will  be left  and backtracking  may
         yield more solutions.

    eexxppaanndd((_B_o_o_l_e_a_n))
         If  true  (default   is  false)  and   _S_p_e_c  is  atomic,   call
         expand_file_name/2  followed  by   member/2   on  _S_p_e_c   before
         proceeding.    This  is  a  SWI-Prolog  extension  intended  to
         minimise  porting effort  after  SWI-Prolog  stopped  expanding
         environment  variables and  the  ~ by  default.    This  option
         should be  considered deprecated.    In particular  the use  of
         _w_i_l_d_c_h_a_r_t patterns such as * should be avoided.

    The  Prolog  flag verbose_file_search can  be set  to  true to  help
    debugging Prolog's search for files.

    This  predicate is derived from Quintus Prolog.  In  Quintus Prolog,
    the  argument order was  absolute_file_name(_+_S_p_e_c_, _+_O_p_t_i_o_n_s_,  _-_P_a_t_h).
    The  argument order has been changed for compatibility with  ISO and
    SICStus.  The Quintus argument order is still accepted.


iiss__aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e))
    True  if _F_i_l_e specifies  an absolute  path name.   On Unix  systems,
    this  implies the path starts with a `/'.  For  Microsoft-based sys-
    tems  this implies the path  starts with <_l_e_t_t_e_r>:.  This  predicate
    is  intended to provide  platform-independent checking for  absolute
    paths.  See also absolute_file_name/2 and prolog_to_os_filename/2.


ffiillee__nnaammee__eexxtteennssiioonn((_?_B_a_s_e_, _?_E_x_t_e_n_s_i_o_n_, _?_N_a_m_e))
    This  predicate is used to add, remove or test  filename extensions.
    The  main reason  for  its introduction  is to  deal with  different
    filename  properties  in a  portable manner.    If  the file  system
    is  case-insensitive, testing  for an  extension will  also be  done
    case-insensitive.    _E_x_t_e_n_s_i_o_n may  be specified with  or without  a
    leading  dot (.).  If an _E_x_t_e_n_s_i_o_n is generated, it will  not have a
    leading dot.


ddiirreeccttoorryy__ffiilleess((_+_D_i_r_e_c_t_o_r_y_, _-_E_n_t_r_i_e_s))
    Unify  _E_n_t_r_i_e_s with a  list of  entries in _D_i_r_e_c_t_o_r_y.   Each  member
    of  _E_n_t_r_i_e_s is  an  atom denoting  an entry  relative to  _D_i_r_e_c_t_o_r_y.
    _E_n_t_r_i_e_s  contains  all  entries,  including  hidden  files  and,  if
    supplied  by  the OS,  the  special entries  .  and ...    See  also
    expand_file_name/2.


eexxppaanndd__ffiillee__nnaammee((_+_W_i_l_d_C_a_r_d_, _-_L_i_s_t))
    Unify  _L_i_s_t with  a  sorted list  of files  or directories  matching
    _W_i_l_d_C_a_r_d.   The  normal Unix wildcard  constructs `?', `*',  `[...]'
    and  `{...}'  are recognised.    The  interpretation  of `{...}'  is
    slightly  different from the C shell (csh(1)).   The comma-separated
    argument  can  be arbitrary  patterns,  including `{...}'  patterns.
    The  empty pattern  is  legal as  well:   `\{.pl,\}' matches  either
    `.pl' or the empty string.

    If  the pattern  contains wildcard characters,  only existing  files
    and  directories  are  returned.    Expanding  a  `pattern'  without
    wildcard  characters returns the argument, regardless of  whether or
    not it exists.

    Before  expanding wildcards, the construct  $_v_a_r is expanded to  the
    value  of the  environment variable  _v_a_r, and a  possible leading  ~
    character is expanded to the user's home directory.


pprroolloogg__ttoo__ooss__ffiilleennaammee((_?_P_r_o_l_o_g_P_a_t_h_, _?_O_s_P_a_t_h))
    Convert  between the internal Prolog  path name conventions and  the
    operating  system path name conventions.   The internal  conventions
    follow  the POSIX  standard, which  implies that  this predicate  is
    equivalent  to  =/2 (unify)  on  POSIX (e.g.,  Unix)  systems.    On
    Windows systems it changes the directory separator from \ into /.


rreeaadd__lliinnkk((_+_F_i_l_e_, _-_L_i_n_k_, _-_T_a_r_g_e_t))
    If _F_i_l_e points to  a symbolic link, unify _L_i_n_k with the value of the
    link and _T_a_r_g_e_t to  the file the link is pointing to.  _T_a_r_g_e_t points
    to  a file, directory or non-existing entry in the file  system, but
    never  to a link.   Fails if _F_i_l_e  is not a link.   Fails always  on
    systems that do not support symbolic links.


ttmmpp__ffiillee((_+_B_a_s_e_, _-_T_m_p_N_a_m_e))                                   _[_d_e_p_r_e_c_a_t_e_d_]
    Create  a name for a temporary file.  _B_a_s_e is an  identifier for the
    category  of file.  The _T_m_p_N_a_m_e is guaranteed to be unique.   If the
    system  halts, it  will automatically  remove all created  temporary
    files.    _B_a_s_e is  used as  part of the  final filename.    Portable
    applications should limit themselves to alphanumeric characters.

    Because  it is possible to  guess the generated filename,  attackers
    may  create the  filesystem entry as  a link  and possibly create  a
    security issue.  New code should use tmp_file_stream/3.


ttmmpp__ffiillee__ssttrreeaamm((_+_E_n_c_o_d_i_n_g_, _-_F_i_l_e_N_a_m_e_, _-_S_t_r_e_a_m))


ttmmpp__ffiillee__ssttrreeaamm((_-_F_i_l_e_N_a_m_e_, _-_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))
    Create a temporary  filename _F_i_l_e_N_a_m_e, open it for writing and unify
    _S_t_r_e_a_m  with the output stream.  If the OS supports it,  the created
    file is only accessible  to the current user and the file is created
    using  the open()-flag  O_EXCL,  which guarantees  that the file  did
    not exist before this call.  The following options are processed:

    eennccooddiinngg((_+_E_n_c_o_d_i_n_g))
         Encoding of _S_t_r_e_a_m.   Default is  the value of the Prolog  flag
         encoding.  The value binary opens the file in binary mode.

    eexxtteennssiioonn((_+_E_x_t))
         Ensure the created  file has the given  extension.  Default  is
         no extension.    Using  an extension  may be  necessary to  run
         external programs on the file.

    This  predicate is a safe replacement  of tmp_file/2.  Note that  in
    those cases where  the temporary file is needed to store output from
    an  external command,  the file  must be closed  first.   E.g.,  the
    following downloads a file  from a URL to a temporary file and opens
    the  file for reading (on Unix  systems you can delete the file  for
    cleanup after opening it for reading):

    ____________________________________________________________________|                                                                    |

    | open_url(URL, In) :-                                               |
    |         tmp_file_stream(text, File, Stream),                       |
    |         close(Stream),                                             |
    |         process_create(curl, ['-o', File, URL], []),               |
    |         open(File, read, In),                                      |

    ||________delete_file(File).______________%_Unix-only_______________ ||

    Temporary  files  created   using  this  call  are  removed  if  the
    Prolog   process  terminates  _g_r_a_c_e_f_u_l_l_y.     Calling  delete_file/1
    using  _F_i_l_e_N_a_m_e removes  the  file and  removes the  entry from  the
    administration of files-to-be-deleted.


mmaakkee__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    Create  a  new directory  (folder) on  the filesystem.    Raises  an
    exception  on failure.   On Unix systems,  the directory is  created
    with default permissions (defined by the process _u_m_a_s_k setting).


ddeelleettee__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    Delete directory (folder)  from the filesystem.  Raises an exception
    on failure.   Please note that in general it will not be possible to
    delete a non-empty directory.


wwoorrkkiinngg__ddiirreeccttoorryy((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d with an  absolute path to  the current working  directory
    and   change  working   directory  to   _N_e_w.      Use  the   pattern
    working_directory(_C_W_D_, _C_W_D) to get the current directory.   See also
    absolute_file_name/2 and chdir/1.   Note that the working  directory
    is shared between all threads.


cchhddiirr((_+_P_a_t_h))
    Compatibility predicate.  New code should use working_directory/2.


44..3377 UUsseerr TToopp--lleevveell MMaanniippuullaattiioonn


bbrreeaakk
    Recursively  start  a  new  Prolog  top level.     This  Prolog  top
    level  shares everything  from the  environment it  was started  in.
    Debugging  is  switched off  on  entering a  break and  restored  on
    leaving  one.   The break  environment is  terminated by typing  the
    system's  end-of-file character (control-D). If that is  somehow not
    functional,  the  term end_of_file. can  be entered  to return  from
    the  break environment.    If  the -t toplevel  command line  option
    is  given,  this goal  is started  instead of  entering the  default
    interactive top level (prolog/0).

    Notably  the gui  based versions  (swipl-win on  Windows and  MacOS)
    provide the menu  Run/New thread that opens a new toplevel that runs
    concurrently  with the  initial toplevel.   The concurrent  toplevel
    can  be used to  examine the program,  in particular global  dynamic
    predicates.    It can  not access _g_l_o_b_a_l  _v_a_r_i_a_b_l_e_s or  thread-local
    dynamic predicates (see thread_local/1) of the main thread.


aabboorrtt
    Abort  the Prolog  execution  and restart  the top  level.   If  the
    -t toplevel  command line option  is given,  this goal is  restarted
    instead of entering the default interactive top level.

    Aborting   is  implemented  by   throwing  the  reserved   exception
    '$aborted'.   This  exception can be caught  using catch/3, but  the
    recovery  goal is wrapped  with a predicate  that prunes the  choice
    points  of the  recovery goal  (i.e., as once/1)  and re-throws  the
    exception.    This is  illustrated in  the example  below, where  we
    press control-C and `a'.  See also section ????.

    ____________________________________________________________________|                                                                    |
    | ?- catch((repeat,fail), E, true).                                  |

    | ^CAction (h for help) ? abort                                      |
    ||%_Execution_Aborted_______________________________________________ ||


hhaalltt                                                              _[_I_S_O_]
    Terminate  Prolog execution.   This  is the  same as halt(_0).    See
    halt/1 for details.


hhaalltt((_+_S_t_a_t_u_s))                                                     _[_I_S_O_]
    Terminate  Prolog  execution  with _S_t_a_t_u_s.    This  predicate  calls
    PL_halt() which preforms the following steps:

     1.  Set the Prolog flag exit_status to _S_t_a_t_u_s.

     2.  Call all hooks registered using at_halt/1.  If _S_t_a_t_u_s  equals 0
         (zero), any of these hooks  calls cancel_halt/1,  termination is
         cancelled.

     3.  Call all hooks  registered using PL_at_halt().   In the  future,
         if any  of these  hooks returns non-zero,  termination will  be
         cancelled.  Currently, this only prints a warning.

     4.  Perform the following system cleanup actions:

           o Cancel  all  threads,  calling thread_at_exit/1  registered
             termination hooks.  Threads  not responding within 1 second
             are cancelled forcefully.

           o Flush I/O and close all streams except for standard I/O.

           o Reset the terminal if its properties were changed.

           o Remove temporary files and incomplete compilation output.

           o Reclaim memory.

     5.  Call exit(Status) to terminate the process


pprroolloogg
    This  goal starts the  default interactive top  level.  Queries  are
    read from  the stream user_input.  See  also the Prolog flag history.
    The  prolog/0  predicate  is  terminated (succeeds)  by  typing  the
    end-of-file character (typically control-D).

The following  two hooks allow  for expanding  queries and handling  the
result of  a query.   These  hooks are  used by the  top level  variable
expansion mechanism described in section ????.


eexxppaanndd__qquueerryy((_+_Q_u_e_r_y_, _-_E_x_p_a_n_d_e_d_, _+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook  in module  user, normally  not defined.    _Q_u_e_r_y and  _B_i_n_d_i_n_g_s
    represents  the  query read  from  the user  and  the names  of  the
    free  variables as obtained  using read_term/3.   If this  predicate
    succeeds, it should  bind _E_x_p_a_n_d_e_d and _E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s to the query
    and  bindings to be executed  by the top level.   This predicate  is
    used  by the  top level (prolog/0).    See also  expand_answer/2 and
    term_expansion/2.


eexxppaanndd__aannsswweerr((_+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook  in module user,  normally not defined.   Expand the result  of
    a  successfully executed  top-level query.   _B_i_n_d_i_n_g_s  is the  query
    < Name >=<_V_a_l_u_e> binding list  from the query.    _E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s
    must be unified with the bindings the top level should print.


44..3388 CCrreeaattiinngg aa PPrroottooccooll ooff tthhee UUsseerr IInntteerraaccttiioonn

SWI-Prolog offers the  possibility to log the interaction with  the user
on  a file.    All  Prolog interaction,  including warnings  and  tracer
output, are written to the protocol file.


pprroottooccooll((_+_F_i_l_e))
    Start  protocolling on file  _F_i_l_e.  If  there is already a  protocol
    file open, then close it first.  If _F_i_l_e exists it is truncated.


pprroottooccoollaa((_+_F_i_l_e))
    Equivalent  to protocol/1,  but  does not  truncate the  _F_i_l_e if  it
    exists.


nnoopprroottooccooll
    Stop  making a protocol of the user interaction.  Pending  output is
    flushed on the file.


pprroottooccoolllliinngg((_-_F_i_l_e))
    True  if a protocol was  started with protocol/1 or protocola/1  and
    unifies _F_i_l_e with the current protocol output file.


44..3399 DDeebbuuggggiinngg aanndd TTrraacciinngg PPrrooggrraammss

This section is a  reference to the debugger interaction predicates.   A
more use-oriented overview of the debugger is in section ????.

If you have installed  XPCE, you can use the graphical front-end  of the
tracer.  This front-end is installed using the predicate guitracer/0.


ttrraaccee
    Start  the tracer.   trace/0  itself cannot be  seen in the  tracer.
    Note  that the  Prolog top level  treats trace/0  special; it  means
    `trace the next goal'.


ttrraacciinngg
    True  if the  tracer is  currently switched  on.   tracing/0  itself
    cannot be seen in the tracer.


nnoottrraaccee
    Stop the tracer.  notrace/0 itself cannot be seen in the tracer.


gguuiittrraacceerr
    Installs  hooks  (see prolog_trace_interception/4) into  the  system
    that  redirect  tracing information  to  a GUI  front-end  providing
    structured  access to variable  bindings, graphical overview of  the
    stack and highlighting of relevant source code.


nnoogguuiittrraacceerr
    Revert back to the textual tracer.


ttrraaccee((_+_P_r_e_d))
    Equivalent to trace(_P_r_e_d, +all).


ttrraaccee((_+_P_r_e_d_, _+_P_o_r_t_s))
    Put  a  trace  point  on all  predicates  satisfying  the  predicate
    specification  _P_r_e_d.   _P_o_r_t_s is  a list of  port names (call,  redo,
    exit,  fail).   The atom all refers  to all ports.   If the port  is
    preceded  by a - sign, the trace point is cleared for the port.   If
    it is preceded by a +, the trace point is set.

    The  predicate trace/2  activates debug  mode (see debug/0).    Each
    time  a port (of the 4-port model) is passed that has a  trace point
    set, the goal is  printed as with trace/0.  Unlike trace/0, however,
    the  execution is continued without asking for  further information.
    Examples:

        ?- trace(hello).         Trace all  ports of hello  with any
                                 arity in any module.
        ?- trace(foo/2, +fail).  Trace  failures  of  foo/2  in  any
                                 module.
        ?- trace(bar/1, -all).   Stop tracing bar/1.

    The predicate debugging/0 shows all currently defined trace points.


nnoottrraaccee((_:_G_o_a_l))
    Call  _G_o_a_l,  but  suspend  the  debugger while  _G_o_a_l  is  executing.
    The  current implementation  cuts the  choice points  of _G_o_a_l  after
    successful completion.   See once/1.  Later implementations may have
    the same semantics as call/1.


ddeebbuugg
    Start  debugger.   In  debug mode,  Prolog  stops at  spy and  trace
    points,  disables last-call optimisation and aggressive  destruction
    of   choice  points  to   make  debugging  information   accessible.
    Implemented by the Prolog flag debug.

    Note  that the min_free parameter of all  stacks is enlarged to 8  K
    cells  if debugging is switched off in order to avoid  excessive GC.
    GC  complicates tracing because it renames the __G_<_N_N_N_>  variables and
    replaces  unreachable variables  with the atom  <garbage_collected>.
    Calling  nodebug/0 does  _n_o_t reset the  initial free-margin  because
    several  parts of the  top level and  debugger disable debugging  of
    system code regions.  See also set_prolog_stack/2.


nnooddeebbuugg
    Stop  debugger.   Implemented by the  Prolog flag debug.   See  also
    debug/0.


ddeebbuuggggiinngg
    Print  debug status and  spy points on current  output stream.   See
    also the Prolog flag debug.


ssppyy((_+_P_r_e_d))
    Put  a spy point on all predicates meeting the  predicate specifica-
    tion _P_r_e_d.  See section ????.


nnoossppyy((_+_P_r_e_d))
    Remove   spy  point  from  all  predicates  meeting   the  predicate
    specification _P_r_e_d.


nnoossppyyaallll
    Remove all spy points from the entire program.


lleeaasshh((_?_P_o_r_t_s))
    Set/query leashing (ports  which allow for user interaction).  _P_o_r_t_s
    is  one of _+_N_a_m_e, _-_N_a_m_e,  _?_N_a_m_e or a list  of these.  _+_N_a_m_e  enables
    leashing  on that  port,  _-_N_a_m_e disables  it and  _?_N_a_m_e succeeds  or
    fails according to  the current setting.  Recognised ports are call,
    redo,  exit, fail and  unify.  The  special shorthand all refers  to
    all  ports,  full refers  to all  ports except  for  the unify  port
    (default).  half refers to the call, redo and fail port.


vviissiibbllee((_+_P_o_r_t_s))
    Set the ports shown  by the debugger.  See leash/1 for a description
    of the _P_o_r_t_s specification.  Default is full.


uunnkknnoowwnn((_-_O_l_d_, _+_N_e_w))
    Edinburgh-Prolog  compatibility predicate,  interfacing  to the  ISO
    Prolog  flag unknown.   Values are  trace (meaning error) and  fail.
    If  the unknown flag is set to warning, unknown/2 reports  the value
    as trace.


ssttyyllee__cchheecckk((_+_S_p_e_c))
    Modify/query  style checking  options.   _S_p_e_c  is one  of the  terms
    below or a list of these.

      o  +_S_t_y_l_e enables a style check

      o  -_S_t_y_l_e disables a style check

      o  ?(_S_t_y_l_e) queries a style  check (note the brackets).   If _S_t_y_l_e
         is unbound,  all  active style  check options  are returned  on
         backtracking.

    Loading  a file using load_files/2 or one of its  derived predicates
    reset  the style checking options to their value before  loading the
    file, scoping the option  to the remainder of the file and all files
    loaded _a_f_t_e_r changing the style checking.

    ssiinngglleettoonn((_t_r_u_e))
         The  predicate read_clause/3  (used  by the  compiler  to  read
         source code) warns on  variables appearing only once in  a term
         (clause) which  have a  name not starting  with an  underscore.
         See section ???? for details on variable handling and warnings.

    nnoo__eeffffeecctt((_t_r_u_e))
         This warning is  generated by the  compiler for BIPs  (built-in
         predicates) that  are inlined  by  the compiler  and for  which
         the  compiler  can  prove  that  they  are  meaningless.     An
         example is  using ==/2 against  a not-yet-initialised  variable
         as  illustrated in  the  example below.    This  comparison  is
         always false.

         _______________________________________________________________|                                                               |
         |always_false(X) :-                                             |
         |        X == Y,                                                |
         ||_______write(Y)._____________________________________________ ||

    vvaarr__bbrraanncchheess((_f_a_l_s_e))
         Verifies that if a variable is introduced in a  branch and used
         _a_f_t_e_r the branch, it is introduced in all branches.   This code
         aims at bugs  following the skeleton  below, where p(_N_e_x_t)  may
         be called with _N_e_x_t unbound.

         _______________________________________________________________|                                                               |

         |p(Arg) :-                                                      |
         |        (  Cond                                                |
         |        -> Next = value1                                       |
         |        ;  true                                                |
         |        ),                                                     |
         ||_______p(Next).______________________________________________ ||

         If a variable  _V is intended  to be left  unbound, one can  use
         V=_.  This construct is removed by the compiler and thus has no
         implications for the performance of your program.

         This  check  was suggested  together  with  _s_e_m_a_n_t_i_c  singleton
         checking.   The  SWI-Prolog libraries contain  about a  hundred
         clauses  that are  triggered  by  this  style check.     Unlike
         semantic singleton  analysis,  only a  tiny  fraction of  these
         clauses proofed faulty.   In  most cases, the branches  failing
         to bind the variable  fail or raise an exception or  the caller
         handles the  case where the  variable is unbound.   The  status
         of this style  check is unclear.   It  might be removed in  the
         future or  it might be  enhanced with a  deeper analysis to  be
         more precise.

    ddiissccoonnttiigguuoouuss((_t_r_u_e))
         Warn if  the clauses for  a predicate are  not together in  the
         same source  file.  It  is advised to  disable the warning  for
         discontiguous predicates using the discontiguous/1 directive.

    cchhaarrsseett((_f_a_l_s_e))
         Warn on atoms  and variable names holding non-ASCII  characters
         that are not quoted.  See also section ????.


44..4400 OObbttaaiinniinngg RRuunnttiimmee SSttaattiissttiiccss


ssttaattiissttiiccss((_+_K_e_y_, _-_V_a_l_u_e))
    Unify system statistics  determined by _K_e_y with _V_a_l_u_e.  The possible
    keys are given in  the table ????.  This predicate supports additional
    keys  for  compatibility  reasons.    These  keys are  described  in
    table ????.
_____________________________________________________________________________
|__________________Native_keys_(times_as_float_in_seconds)___________________|
| agc              |Number of atom garbage collections performed            |
| agc_gained       N|umber of atoms removed                                 |
| agc_time         T|ime spent in atom garbage collections                  |
| atoms            |Total number of defined atoms                           |
| c_stack          S|ystem (C-) stack limit.  0 if not known.               |

| cgc              |Number of clause garbage collections performed          |
| cgc_gained       N|umber of clauses reclaimed                             |
| cgc_time         T|ime spent in clause garbage collections                |
| clauses          |Total number of clauses in the program                  |
| codes            |Total size of (virtual) executable code in words        |
| cputime          |(User) cpu time since thread was started in seconds     |
| epoch            |Time stamp when thread was started                      |

| functors         |Total number of defined name/arity pairs                |
| global           |Allocated size of the global stack in bytes             |
| globalused       |Number of bytes in use on the global stack              |
| globallimit      |Size to which the global stack is allowed to grow       |
| global_shifts    N|umber of global stack expansions                       |
| heapused         |Bytes of heap in use by Prolog (0 if not maintained)    |
| inferences       |Total  number  of passes  via  the call  and redo  ports|
|                  |since Prolog was started                                |

| modules          |Total number of defined modules                         |
| local            |Allocated size of the local stack in bytes              |
| local_shifts     N|umber of local stack expansions                        |
| locallimit       |Size to which the local stack is allowed to grow        |
| localused        |Number of bytes in use on the local stack               |
| table_space_used A|mount of bytes in use by the thread's answer tables    |
| trail            |Allocated size of the trail stack in bytes              |

| trail_shifts     N|umber of trail stack expansions                        |
| traillimit       |Size to which the trail stack is allowed to grow        |
| trailused        |Number of bytes in use on the trail stack               |
| shift_time       T|ime spent in stack-shifts                              |
| stack            |Total memory in use for stacks in all threads           |
| predicates       |Total  number of predicates.   This  includes predicates|
|                  |that are undefined or not yet resolved.                 |
| indexes_created  N|umber of clause index tables creates.                  |

| indexes_destroyedN|umber of clause index tables destroyed.                |
| process_epoch    T|ime stamp when Prolog was started                      |
| process_cputime  (|User) cpu time since Prolog was started in seconds     |
| thread_cputime   M|T-version:   Seconds CPU time used by finished threads.|
|                  B|asically   non-portable.     Works  on  Linux,  MacOSX,|
|                  W|indows and probably some more.                         |
| threads          |MT-version:  number of active threads                   |

| threads_created  M|T-version:  number of created threads                  |
| engines          |MT-version:  number of existing engines                 |
|_engines_created__M|T-version:__number_of_created_engines__________________|_

Table 4.3:  Keys for  statistics/2.  Space is expressed in bytes.   Time
is expressed in seconds, represented as a floating point number.
____________________________________________________________________________________
|_____________________Compatibility_keys_(times_in_milliseconds)____________________|
| runtime                  |[  CPU  time,  CPU  time  since  last ]  (milliseconds,|

|                          |excluding time spent in garbage collection)            |
| system_time              [| System  CPU  time,  System  CPU  time  since last  ] |
|                          (|milliseconds)                                         |
| real_time                [|Wall time,  Wall time since  last ] (integer seconds. |
|                          S|ee get_time/1)                                        |
| walltime                 |[  Wall  time  since  start,   Wall  time  since  last]|
|                          |(milliseconds, SICStus compatibility)                  |

| memory                   |[ Total unshared data, free  memory ] (Used is based on|
|                          |ru_idrss from getrusage().  Free is based on RLIMIT_DATA|
|                          |from getrlimit().  Both  are reported as zero if the OS|
|                          |lacks support.)                                        |
| stacks                   |[ global use, local use ]                              |
| program                  |[ heap, 0 ]                                            |
| global_stack             [|global use, global free ]                             |
| local_stack              [|local use, local free ]                               |

| trail                    |[ trail use, trail free ]                              |
| garbage_collection       [|number of GC, bytes  gained, time spent, bytes left ] |
|                          T|he last column is a SWI-Prolog extension.  It contains|
|                          t|he  sum of  the  memory  left  after  each collection,|
|                          w|hich can be  divided by the count  to find the average|
|                          w|orking set size  after GC. Use  [Count, Gained, Time|_]|
|                          f|or compatiblity.                                      |

| stack_shifts             [|global shifts, local shifts, time spent ]             |
| atoms                    |[ number, memory use, 0 ]                              |
| atom_garbage_collection  [|number of AGC, bytes gained, time spent ]             |
| clause_garbage_collection[|number of CGC, clauses gained, time spent ]           |
|_core_____________________|Same_as_memory_________________________________________|_

Table 4.4:  Compatibility  keys for statistics/2.  Time is  expressed in
milliseconds.


ssttaattiissttiiccss
    Display a table of system statistics on the stream user_error.


ttiimmee((_:_G_o_a_l))
    Execute  _G_o_a_l  just  like call/1  and  print time  used,  number  of
    logical   inferences  and  the  average  number  of   _l_i_p_s  (logical
    inferences  per second).    Note that SWI-Prolog  counts the  actual
    executed  number  of inferences  rather than  the  number of  passes
    through  the call and  redo ports of  the theoretical 4-port  model.
    If  _G_o_a_l is non-deterministic,  print statistics for each  solution,
    where the reported values are relative to the previous answer.


44..4411 EExxeeccuuttiioonn pprrooffiilliinngg

This  section describes  the  hierarchical  execution profiler.     This
profiler is based  on ideas from gprof described  in [??].  The  profiler
consists of two  parts:  the information-gathering component built  into
the  kernel,  and a  presentation  component  which is  defined  in  the
statistics  library.    The  latter can  be  hooked,  which is  used  by
the  XPCE module  swi/pce_profile to  provide an  interactive  graphical
frontend for the results.


44..4411..11 PPrrooffiilliinngg pprreeddiiccaatteess

The following predicates are defined to interact with the profiler.


pprrooffiillee((_:_G_o_a_l))
    Execute _G_o_a_l just  like once/1, collecting profiling statistics, and
    call  show_profile(_[_]).   With XPCE installed this opens  a graphical
    interface to examine the collected profiling data.


pprrooffiillee((_:_G_o_a_l_, _+_O_p_t_i_o_n_s))
    Execute  _G_o_a_l  just  like  once/1.    Collect  profiling  statistics
    according  to _O_p_t_i_o_n_s  and call  show_profile/1 with _O_p_t_i_o_n_s.    The
    default collects CPU  profiling and opens a graphical interface when
    provided,  printing the `plain' time usage of the top  25 predicates
    as a ballback.   Options are described below.  Remaining options are
    passed to show_profile/1.

    ttiimmee((_+_W_h_i_c_h))
         If _W_h_i_c_h is cpu  (default), collect CPU timing statistics.   If
         wall, collect  wall time  statistics based on  a 5  millisecond
         sampling rate.    Wall time statistics  can be  useful if  _G_o_a_l
         calls blocking system calls.


sshhooww__pprrooffiillee((_+_O_p_t_i_o_n_s))
    This  predicate first calls  prolog:show_profile_hook/1.   If XPCE  is
    loaded,  this hook is used to activate a GUI interface  to visualise
    the  profile results.  If not,  a report is printed to  the terminal
    according to _O_p_t_i_o_n_s:

    ttoopp((_+_N))
         Show the only top _N predicates.  Default is 25.

    ccuummuullaattiivvee((_+_B_o_o_l))
         If true (default false), include the time spent  in children in
         the time reported for a predicate.


pprrooffiilleerr((_-_O_l_d_, _+_N_e_w))
    Query or change the status of the profiler.  The status is one of

    ffaallssee
         The profiler is not activated.

    ccppuuttiimmee
         The profiler collects CPU statistics.

    wwaallllttiimmee
         The profiler collects wall time statistics.

    The   value  true  is  accepted   as  a  synonym  for  cputime   for
    compatibility reasons.


rreesseett__pprrooffiilleerr
    Switches the profiler to false and clears all collected statistics.


nnoopprrooffiillee((_+_N_a_m_e_/_+_A_r_i_t_y_, _._._.))
    Declares  the predicate _N_a_m_e/_A_r_i_t_y to be invisible to  the profiler.
    The  time  spent in  the named  predicate is  added  to the  caller,
    and  the  callees are  linked  directly  to the  caller.    This  is
    particularly  useful  for  simple meta-predicates  such  as  call/1,
    ignore/1, catch/3, etc.


44..4411..22 VViissuuaalliizziinngg pprrooffiilliinngg ddaattaa

Browsing  the annotated  call-tree  as described  in section  ????  itself
is  not  very  attractive.      Therefore,  the  results   are  combined
per  predicate,  collecting all  _c_a_l_l_e_r_s  and  _c_a_l_l_e_e_s as  well  as  the
propagation  of time  and activations  in both  directions.   Figure  ????
illustrates  this.     The  central  yellowish  line  is  the  `current'
predicate with  counts for time  spent in  the predicate (`Self'),  time
spent in  its children  (`Siblings'), activations through  the call  and
redo ports.   Above  that are the _c_a_l_l_e_r_s.   Here,  the two time  fields
indicate  how much  time is  spent serving  each of  the callers.    The
columns sum to the time in the yellowish  line.  The caller <_r_e_c_u_r_s_i_v_e>
is the  number of recursive calls.   Below  the yellowish lines are  the
callees,  with the  time  spent in  the callee  itself for  serving  the
current  predicate and  the time  spent  in the  callees of  the  callee
('Siblings'), so  the whole time-block adds  up to the `Siblings'  field
of the current predicate.   The `Access' fields show how many  times the
current predicate accesses each of the callees.

The predicates have a  menu that allows changing the view of  the detail
window to the given  caller or callee, showing the documentation  (if it
is a built-in) and/or jumping to the source.

The  statistics  shown  in  the report  field  of  figure  ????  show  the
following information:

  o _s_a_m_p_l_e_s
    Number  of  times  the call-tree  was  sampled for  collecting  time
    statistics.   On most hardware,  the resolution of SIGPROF is  1/100
    second.    This number must  be sufficiently  large to get  reliable
    timing  figures.   The  Time menu  allows viewing  time as  samples,
    relative time or absolute time.

  o _s_e_c
    Total user CPU time with the profiler active.

  o _p_r_e_d_i_c_a_t_e_s
    Total  count of predicates that have  been called at least one  time
    during the profile.

  o _n_o_d_e_s
    Number of nodes in the call-tree.

  o _d_i_s_t_o_r_t_i_o_n
    How  much  of  the  time  is  spent  building  the  call-tree  as  a
    percentage  of the total execution time.   Timing samples while  the
    profiler is building the call-tree are not added to the call-tree.


44..4411..33 IInnffoorrmmaattiioonn ggaatthheerriinngg

While  the program  executes under  the profiler,  the  system builds  a
_d_y_n_a_m_i_c call-tree.    It does this  using three  hooks from the  kernel:
one  that starts  a  new goal  (_p_r_o_f_C_a_l_l),  one  that tells  the  system
which goal is  resumed after an _e_x_i_t  (_p_r_o_f_E_x_i_t) and one that tells  the
system which  goal is  resumed after a  _f_a_i_l (i.e.,  which goal is  used
to _r_e_t_r_y  (_p_r_o_f_R_e_d_o)).   The  profCall() function finds  or creates  the
subnode for  the argument predicate below  the current node,  increments
the call-count of this  link and returns the sub-node which  is recorded
in the Prolog  stack-frame.  Choice-points  are marked with the  current
profiling  node.   profExit()  and profRedo()  pass  the profiling  node
where execution resumes.

Just using the above  algorithm would create a much too big tree  due to
recursion.  For this reason the system performs  detection of recursion.
In the  simplest case,  recursive procedures  increment the  `recursive'
count on  the current node.   Mutual recursion,  however, is not  easily
detected.   For example,  call/1 can call a  predicate that uses  call/1
itself.   This  can be  viewed as a  recursive invocation,  but this  is
generally not  desirable.   Recursion is currently  assumed if the  same
predicate _w_i_t_h _t_h_e _s_a_m_e _p_a_r_e_n_t appears higher in the  call-graph.  Early
experience with some non-trivial programs are promising.

The  last part  of the  profiler  collects statistics  on the  CPU  time
used in each  node.  On  systems providing setitimer() with SIGPROF,  it
`ticks' the  current node of  the call-tree each  time the timer  fires.
On Windows, a MM-timer in a separate thread checks  100 times per second
how much  time is  spent in  the profiled thread  and adds  this to  the
current node.  See section ???? for details.


44..4411..33..11 PPrrooffiilliinngg iinn tthhee WWiinnddoowwss IImmpplleemmeennttaattiioonn

Profiling  in the  Windows version  is similar,  but as  profiling is  a
statistical process  it is good  to be aware  of the implementation  for
proper interpretation of the results.

Windows does not  provide timers that fire asynchronously,  frequent and
proportional to the CPU time used by the process.   Windows does provide
multi-media  timers that  can  run at  high  frequency.    Such  timers,
however, run  in a separate  thread of execution and  they are fired  on
the wall clock  rather than the amount of  CPU time used.  The  profiler
installs such a timer running, for saving CPU  time, rather inaccurately
at about 100 Hz.   Each time it is fired, it determines the CPU  time in
milliseconds used by Prolog since  the last time it was fired.   If this
value is non-zero, active predicates are incremented with this value.


44..4422 MMeemmoorryy MMaannaaggeemmeenntt


ggaarrbbaaggee__ccoolllleecctt
    Invoke  the global  and  trail stack  garbage collector.    Normally
    the  garbage   collector  is  invoked  automatically  if  necessary.
    Explicit  invocation  might   be  useful  to  reduce  the  need  for
    garbage  collections in time-critical segments  of the code.   After
    the  garbage  collection  trim_stacks/0 is  invoked to  release  the
    collected memory resources.


ggaarrbbaaggee__ccoolllleecctt__aattoommss
    Reclaim  unused atoms.  Normally invoked  after agc_margin (a Prolog
    flag)  atoms  have been  created.    On multithreaded  versions  the
    actual  collection is delayed until there are no  threads performing
    normal  garbage collection.    In this  case garbage_collect_atoms/0
    returns  immediately.    Note that  there is  no  guarantee it  will
    _e_v_e_r  happen,  as there  may always  be  threads performing  garbage
    collection.


ggaarrbbaaggee__ccoolllleecctt__ccllaauusseess
    Reclaim  retracted clauses.    During  normal operation,  retracting
    a  clause  implies  setting the  _e_r_a_s_e_d  _g_e_n_e_r_a_t_i_o_n to  the  current
    _g_e_n_e_r_a_t_i_o_n  of the database and  increment the generation.   Keeping
    the clause around  is both needed to realise the _l_o_g_i_c_a_l _u_p_d_a_t_e _v_i_e_w
    and  deal with  the fact  that other  threads may  be executing  the
    clause.  Both static and dynamic code is processed this way..

    The  clause garbage collector (CGC) scans the environment  stacks of
    all threads for  referenced dirty predicates and at which generation
    this  reference  accesses  the  predicate.    It  then  removes  the
    references  for clauses that have  been retracted before the  oldest
    access  generation from  the clause  list as well  as the  secondary
    clauses  indexes of the predicate.  If the clause list is  not being
    scanned,  the clause references and ultimately the clause  itself is
    reclaimed.

    The  clause  garbage collector  is  called under  three  conditions,
    (1)  after  _r_e_l_o_a_d_i_n_g a  source file,  (2)  if the  memory  occupied
    by  retracted but  not yet  reclaimed clauses exceeds  12.5% of  the
    program  store, or (3) if skipping dead clauses in the  clause lists
    becomes  too  costly.   The  cost of  clause  garbage collection  is
    proportional  with the total size of the local stack of  all threads
    (the  scanning  phase) and  the  number of  clauses in  all  `dirty'
    predicates (the reclaiming phase).


sseett__pprroolloogg__ggcc__tthhrreeaadd((_+_S_t_a_t_u_s))
    Control  whether  or  not atom  and  clause garbage  collection  are
    executed  in a dedicated thread.   The default is true.   Values for
    _S_t_a_t_u_s  are true, false and  stop.  The  latter stops the gc  thread
    but  allows is to be recreated lazily.  This is use by  e.g., fork/1
    to avoid forking a multi-threaded application.  See also gc_thread.


ttrriimm__ssttaacckkss
    Release  stack memory resources that are not in use at  this moment,
    returning  them to the operating system.  It can be used  to release
    memory  resources  in  a backtracking  loop,  where  the  iterations
    require  typically seconds  of  execution time  and very  different,
    potentially  large, amounts  of stack  space.   Such a  loop can  be
    written as follows:

    ____________________________________________________________________|                                                                    |
    | loop :-                                                            |
    |         generator,                                                 |
    |             trim_stacks,                                           |

    |             potentially_expensive_operation,                       |
    ||________stop_condition,_!.________________________________________ ||

    The  Prolog top-level loop  is written  this way, reclaiming  memory
    resources after every user query.


sseett__pprroolloogg__ssttaacckk((_+_S_t_a_c_k_, _+_K_e_y_V_a_l_u_e))
    Set  a parameter for  one of the  Prolog runtime stacks.   _S_t_a_c_k  is
    one  of local,  global  or trail.    The table  below describes  the
    _K_e_y(_V_a_l_u_e) pairs.

    Current settings can be retrieved with prolog_stack_property/2.

    mmiinn__ffrreeee((_+_C_e_l_l_s))
         Minimum amount  of free  space after trimming  or shifting  the
         stack.   Setting  this value higher  can reduce  the number  of
         garbage collections  and  stack-shifts at  the cost  of  higher
         memory usage.   The amount is reported and specified  in _c_e_l_l_s.
         A cell  is 4 bytes  in the 32-bit  version and  8 bytes on  the
         64-bit version.  See address_bits.   See also trim_stacks/0 and
         debug/0.

    llooww((_+_C_e_l_l_s))
    ffaaccttoorr((_+_N_u_m_b_e_r))
         These  two  figures  determine  whether,  if   the  stacks  are
         low,  a  stack  _s_h_i_f_t  (expansion)  or  garbage  collection  is
         performed.  This  depends on these two parameters,  the current
         stack  usage and  the  amount  of  stack used  after  the  last
         garbage  collection.    A  garbage  collection  is  started  if
         used> factorl* astused+low.

    ssppaarree((_+_C_e_l_l_s))
         All  stacks  trigger  overflow  before  actually  reaching  the
         limit,  so  the  resulting error  can  be  handled  gracefully.
         The spare  stack is used  for print_message/2 from the  garbage
         collector and for handling  exceptions.  The default  suffices,
         unless  the user  redefines  related hooks.    Do  nnoott  specify
         large values for this  because it reduces the amount  of memory
         available for your real task.

         Related  hooks  are message_hook/3  (redefining  GC  messages),
         prolog_trace_interception/4and prolog_exception_hook/4.


pprroolloogg__ssttaacckk__pprrooppeerrttyy((_?_S_t_a_c_k_, _?_K_e_y_V_a_l_u_e))
    True   if  _K_e_y_V_a_l_u_e  is   a  current  property   of  _S_t_a_c_k.      See
    set_prolog_stack/2 for defined properties.


44..4433 WWiinnddoowwss DDDDEE iinntteerrffaaccee

The  predicates in  this  section  deal with  MS-Windows  `Dynamic  Data
Exchange'  or DDE  protocol.    A Windows  DDE  conversation is  a  form
of interprocess  communication based on  sending reserved window  events
between the communicating processes.

Failing DDE  operations raise  an error  of the  structure below,  where
_O_p_e_r_a_t_i_o_n  is  the name  of  the  (partial) operation  that  failed  and
_M_e_s_s_a_g_e is a translation  of the operator error code.  For  some errors,
_C_o_n_t_e_x_t provides additional comments.

________________________________________________________________________|                                                                        |
||_______error(dde_error(Operation,_Message),_Context)__________________ ||


44..4433..11 DDDDEE cclliieenntt iinntteerrffaaccee

The DDE client interface  allows Prolog to talk to DDE  server programs.
We  will demonstrate  the use  of the  DDE interface  using the  Windows
PROGMAN (Program Manager) application:

________________________________________________________________________|                                                                        |
|1 ?- open_dde_conversation(progman, progman, C).                        |

|                                                                        |
|C = 0                                                                   |
|2 ?- dde_request(0, groups, X)                                          |
|                                                                        |
|--> Unifies X with description of groups                                |
|                                                                        |
|3 ?- dde_execute(0, '[CreateGroup("DDE Demo")]').                       |
|true.                                                                   |

|                                                                        |
|4 ?- close_dde_conversation(0).                                         |
|true.|_________________________________________________________________ |     |

For  details   on  interacting  with   progman,   use  the  SDK   online
manual  section on  the  Shell  DDE interface.     See also  the  Prolog
library(progman),  which  may be  used  to  write simple  Windows  setup
scripts in Prolog.


ooppeenn__ddddee__ccoonnvveerrssaattiioonn((_+_S_e_r_v_i_c_e_, _+_T_o_p_i_c_, _-_H_a_n_d_l_e))
    Open a conversation  with a server supporting the given service name
    and  topic (atoms).    If successful,  _H_a_n_d_l_e  may be  used to  send
    transactions  to the server.    If no willing  server is found  this
    predicate fails silently.


cclloossee__ddddee__ccoonnvveerrssaattiioonn((_+_H_a_n_d_l_e))
    Close  the  conversation   associated  with  _H_a_n_d_l_e.     All  opened
    conversations  should  be  closed  when they're  no  longer  needed,
    although  the system  will  close any  that remain  open on  process
    termination.


ddddee__rreeqquueesstt((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _-_V_a_l_u_e))
    Request  a value from the server.   _I_t_e_m is an atom  that identifies
    the requested  data, and _V_a_l_u_e will be a string (CF_TEXT data in DDE
    parlance) representing that data, if the request is successful.


ddddee__eexxeeccuuttee((_+_H_a_n_d_l_e_, _+_C_o_m_m_a_n_d))
    Request  the  DDE  server  to  execute  the  given  command  string.
    Succeeds  if the command could be  executed and fails with an  error
    message otherwise.


ddddee__ppookkee((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _+_C_o_m_m_a_n_d))
    Issue  a POKE command to the server on the specified _I_t_e_m.   _c_o_m_m_a_n_d
    is passed as data of type CF_TEXT.


44..4433..22 DDDDEE sseerrvveerr mmooddee

The  library(dde)  defines  primitives  to  realise  simple  DDE  server
applications in SWI-Prolog.   These features are provided as  of version
2.0.6 and  should be  regarded as prototypes.    The C part  of the  DDE
server can  handle some  more primitives,  so if you  need features  not
provided by this interface, please study library(dde).


ddddee__rreeggiisstteerr__sseerrvviiccee((_+_T_e_m_p_l_a_t_e_, _+_G_o_a_l))
    Register  a server  to handle  DDE request or  DDE execute  requests
    from  other applications.  To register a service for a  DDE request,
    _T_e_m_p_l_a_t_e is of the form:

         +Service(+Topic, +Item, +Value)

    _S_e_r_v_i_c_e  is the name  of the DDE  service provided (like progman  in
    the  client example  above).   _T_o_p_i_c is either  an atom,  indicating
    _G_o_a_l  only handles requests on this  topic, or a variable that  also
    appears  in _G_o_a_l.  _I_t_e_m and _V_a_l_u_e are variables that also  appear in
    _G_o_a_l.  _I_t_e_m represents the request data as a Prolog atom.

    The   example  below  registers   the  Prolog  current_prolog_flag/2
    predicate  to be accessible  from other applications.   The  request
    may  be  given  from  the  same  Prolog  as  well  as  from  another
    application.

    ____________________________________________________________________|                                                                    |
    | ?- dde_register_service(prolog(current_prolog_flag, F, V),         |

    |                         current_prolog_flag(F, V)).                |
    |                                                                    |
    | ?- open_dde_conversation(prolog, current_prolog_flag, Handle),     |
    |    dde_request(Handle, home, Home),                                |
    |    close_dde_conversation(Handle).                                 |
    |                                                                    |
    ||Home_=_'/usr/local/lib/pl-2.0.6/'_________________________________ ||

    Handling  DDE execute requests  is very similar.   In this case  the
    template is of the form:

         +Service(+Topic, +Item)

    Passing  a _V_a_l_u_e argument is  not needed as execute requests  either
    succeed  or fail.  If _G_o_a_l  fails, a `not processed' is  passed back
    to the caller of the DDE request.


ddddee__uunnrreeggiisstteerr__sseerrvviiccee((_+_S_e_r_v_i_c_e))
    Stop  responding  to  _S_e_r_v_i_c_e.     If  Prolog  is  halted,  it  will
    automatically call this on all open services.


ddddee__ccuurrrreenntt__sseerrvviiccee((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently registered services and the topics served on them.


ddddee__ccuurrrreenntt__ccoonnnneeccttiioonn((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently open conversations.


44..4444 MMiisscceellllaanneeoouuss


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2))
    True  if _A_t_o_m_1 matches _A_t_o_m_2  in the `Do What  I Mean' sense.   Both
    _A_t_o_m_1  and _A_t_o_m_2  may also be  integers or  floats.   The two  atoms
    match if:

      o  They are identical

      o  They differ by one character (spy  spu)

      o  One character is inserted/deleted (debug  deug)

      o  Two characters are transposed (trace  tarce)

      o  `Sub-words' are glued  differently (existsfile   existsFile
         exists_file)

      o  Two   adjacent   sub-words   are  transposed   (existsFile
         fileExists)


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2_, _-_D_i_f_f_e_r_e_n_c_e))
    Equivalent  to  dwim_match/2,  but unifies  _D_i_f_f_e_r_e_n_c_e  with an  atom
    identifying  the difference  between _A_t_o_m_1  and _A_t_o_m_2.   The  return
    values  are (in the same  order as above):   equal, mismatched_char,
    inserted_char, transposed_char, separated and transposed_word.


wwiillddccaarrdd__mmaattcchh((_+_P_a_t_t_e_r_n_, _+_S_t_r_i_n_g))
    True  if _S_t_r_i_n_g matches  the wildcard pattern  _P_a_t_t_e_r_n.  _P_a_t_t_e_r_n  is
    very  similar to the  Unix csh  pattern matcher.   The patterns  are
    given below:

     ?      Matches one arbitrary character.
     *      Matches any number of arbitrary characters.
     [...]  Matches one of the characters specified between the brackets.
            <_c_h_a_r_1>-<_c_h_a_r_2>indicates a range.
     {...}  Matches any of the patterns of the comma-separated list between the braces.

    Example:

    ____________________________________________________________________|                                                                    |
    | ?- wildcard_match('[a-z]*.{pro,pl}[%~]', 'a_hello.pl%').           |
    ||true._____________________________________________________________ ||


sslleeeepp((_+_T_i_m_e))
    Suspend  execution _T_i_m_e seconds.   _T_i_m_e  is either a floating  point
    number  or an  integer.   Granularity is  dependent on the  system's
    timer  granularity.   A  negative time  causes the  timer to  return
    immediately.   On  most non-realtime operating  systems we can  only
    ensure execution is suspended for aatt lleeaasstt _T_i_m_e seconds.

    On  Unix systems the  sleep/1 predicate is  realised ---in order  of
    preference---  by nanosleep(),  usleep(),  select() if  the time  is
    below 1 minute, or sleep().  On Windows systems Sleep() is used.


CChhaapptteerr 55..  SSWWII--PPRROOLLOOGG EEXXTTEENNSSIIOONNSS

This  chapter describes  extensions to  the  Prolog language  introduced
with SWI-Prolog version  7.  The  changes bring more modern  syntactical
conventions to  Prolog such as key-value  maps, called _d_i_c_t_s as  primary
citizens  and a  restricted form  of  _f_u_n_c_t_i_o_n_a_l _n_o_t_a_t_i_o_n.    They  also
extend Prolog basic types with strings, providing a  natural notation to
textual material as opposed to identifiers (atoms) and lists.

These extensions make the  syntax more intuitive to new users,  simplify
the integration  of domain  specific languages (DSLs)  and facilitate  a
more natural Prolog  representation for popular exchange languages  such
as XML and JSON.

While many programs  run unmodified in SWI-Prolog version 7,  especially
those  that  pass   double  quoted  strings  to  general  purpose   list
processing  predicates  require  modifications.     We  provide  a  tool
(list_strings/0) that we used to port a huge code base in half a day.


55..11 LLiissttss aarree ssppeecciiaall

As of version 7, SWI-Prolog lists can be  distinguished unambiguously at
runtime from ./2  terms and the atom '[]'.   The constant [] is  special
constant that is not an atom.  It has the following properties:

________________________________________________________________________|                                                                        |
|?- atom([]).                                                            |

|false.                                                                  |
|?- atomic([]).                                                          |
|true.                                                                   |
|?- [] == '[]'.                                                          |
|false.                                                                  |
|?- [] == [].                                                            |
|true.|_________________________________________________________________ |     |

The `cons' operator for creating list cells has changed  from the pretty
atom  '.' to  the ugly  atom '[|]',  so we  can  use the  '.' for  other
purposes.  See section ????.

This modification has  minimal impact on typical  Prolog code.  It  does
affect  foreign code  (see section  ????) that  uses the  normal atom  and
compound term interface for manipulation lists.  In  most cases this can
be avoided by using the dedicated list functions.   For convenience, the
macros ATOM_nil and ATOM_dot are provided by SWI-Prolog.h.

Another  place  that  is  affected is  write_canonical/1.     Impact  is
minimized  by  using  the  list  syntax  for  lists.     The  predicates
read_term/2 and  write_term/2 support the  option dotlists(_t_r_u_e),  which
causes read_term/2 to read .(a,[]) as [a]  and write_term/2to  write [a]
as .(a,[]).


55..11..11 MMoottiivvaattiinngg ''[|]'' aanndd [] ffoorr lliissttss

Representing lists the conventional way using ./2 as  cons-cell and '[]'
as list  terminator both  (independently) poses  conflicts, while  these
conflicts are easily avoided.

  o Using  ./2 prevents using this  commonly used symbol as an  operator
    because  a.B  cannot   be  distinguished  from  [a|B].  Freeing  ./2
    provides  us  with a  unique term  that we  can  use for  functional
    notation on dicts as described in section ????.

  o Using  '[]' as list terminator prevents dynamic  distinction between
    atoms  and lists.    As a result,  we cannot  use type  polymorphism
    that  involve both  atoms and  lists.   For example,  we cannot  use
    _m_u_l_t_i  _l_i_s_t_s  (arbitrary  deeply nested  lists)  of  atoms.    Multi
    lists  of atoms are  in some situations  a good representation of  a
    flat  list that is assembled from  sub sequences.  The  alternative,
    using  difference lists or DCGs is often less natural  and sometimes
    demands  for `opening' proper  lists (i.e.,  copying the list  while
    replacing  the terminating  empty list  with a  variable) that  have
    to  be  added to  the sequence.    The ambiguity  of  atom and  list
    is  particularly painful when mapping external  data representations
    that do not suffer from this ambiguity.

    At  the same  time, avoiding  '[]' as  a list  terminator makes  the
    various  text representations unambiguous, which allows us  to write
    predicates  that require  a textual argument  to accept both  atoms,
    strings,  and  lists  of  character codes  or  one-character  atoms.
    Traditionally, the empty  list can be interpreted both as the string
    "[]" and "".


55..22 TThhee ssttrriinngg ttyyppee aanndd iittss ddoouubbllee qquuootteedd ssyynnttaaxx

As  of SWI-Prolog  version  7, text  enclosed  in double  quotes  (e.g.,
"Hello world")  is read  as  objects  of the  type  _s_t_r_i_n_g.    A  string
is  a compact  representation  of a  character  sequence that  lives  on
the  global  (term) stack.     Strings represent  sequences  of  Unicode
characters including the  character code 0 (zero).   The length  strings
is  limited by  the available  space  on the  global (term)  stack  (see
set_prolog_stack/2).   Strings  are distinct from  lists, which makes  it
possible  to detect  them at  runtime and  print them  using the  string
syntax, as illustrated below:

________________________________________________________________________|                                                                        |
|?- write("Hello world!").                                               |

|Hello world!                                                            |
|                                                                        |
|?- writeq("Hello world!").                                              |
|"Hello|world!"_________________________________________________________ |      |

_B_a_c_k _q_u_o_t_e_d text (as  in `text`) is mapped to a list of  character codes
in version 7.   The settings for  the flags that control how double  and
back quoted  text is  read is  summarised in table  ????.   Programs  that
aim for compatibility should realise that the ISO  standard defines back
quoted text,  but does not define  the back_quotes Prolog flag and  does
not define the term that is produced by back quoted text.

             _______________________________________________MMooddeedouble_quotesback_quotes
             _______________________________________________Versions7tdefaultringcodes

             _--traditional_________codes_______symbol_char_

  Table 5.1:  Mapping of double and back quoted text in the two modes.

Section  ???? motivates  the introduction  of strings  and mapping  double
quoted text to this type.


55..22..11 PPrreeddiiccaatteess tthhaatt ooppeerraattee oonn ssttrriinnggss

Strings may  be manipulated by  a set of predicates  that is similar  to
the manipulation  of atoms.   In  addition to the  list below,  string/1
performs the type check for this type and is described in section ????.

SWI-Prolog's   string    primitives   are   being   synchronized    with
http://eclipseclp.org/wiki/Prolog/StringsECLiPSe.       We  expect   the
set of  predicates documented  in this  section to  be stable,  although
it  might be  expanded.    In  general, SWI-Prolog's  text  manipulation
predicates accept  any form of  text as input  argument and produce  the
type indicated by the predicate name as output.   This policy simplifies
migration and  writing programs that  can run  unmodified or with  minor
modifications  on systems  that do  not support  strings.   Code  should
avoid relying on  this feature as much  as possible for clarity as  well
as  to facilitate  a more  strict mode  and/or type  checking in  future
releases.


aattoomm__ssttrriinngg((_?_A_t_o_m_, _?_S_t_r_i_n_g))
    Bi-directional  conversion between an atom and  a string.  At  least
    one of the two  arguments must be instantiated.  _A_t_o_m can also be an
    integer or floating point number.


nnuummbbeerr__ssttrriinngg((_?_N_u_m_b_e_r_, _?_S_t_r_i_n_g))
    Bi-directional  conversion between a number and a string.   At least
    one  of the two  arguments must be instantiated.   Besides the  type
    used  to represent the text, this predicate differs in  several ways
    from its ISO cousin:

      o  If _S_t_r_i_n_g  does not  represent a  number,  the predicate  _f_a_i_l_s
         rather than throwing a syntax error exception.

      o  Leading white space and Prolog comments are _n_o_t allowed.

      o  Numbers may start with '+' or '-'.

      o  It is _n_o_t allowed to have white space between a  leading '+' or
         '-' and the number.

      o  Floating point numbers  in exponential notation do not  require
         a dot before exponent, i.e., "1e10" is a valid number.


tteerrmm__ssttrriinngg((_?_T_e_r_m_, _?_S_t_r_i_n_g))
    Bi-directional  conversion between a term and  a string.  If  _S_t_r_i_n_g
    is  instantiated, it is parsed and the result is unified  with _T_e_r_m.
    Otherwise  _T_e_r_m is `written' using  the option quoted(_t_r_u_e) and  the
    result is converted to _S_t_r_i_n_g.


tteerrmm__ssttrriinngg((_?_T_e_r_m_, _?_S_t_r_i_n_g_, _+_O_p_t_i_o_n_s))
    As   term_string/2,  passing   _O_p_t_i_o_n_s  to  either   read_term/2  or
    write_term/2.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- term_string(Term, 'a(A)', [variable_names(VNames)]).            |

    | Term = a(_G1466),                                                  |
    ||VNames_=_['A'=_G1466].____________________________________________ ||


ssttrriinngg__cchhaarrss((_?_S_t_r_i_n_g_, _?_C_h_a_r_s))
    Bi-directional conversion between  a string and a list of characters
    (one-character  atoms).  At least  one of the two arguments must  be
    instantiated.


ssttrriinngg__ccooddeess((_?_S_t_r_i_n_g_, _?_C_o_d_e_s))
    Bi-directional  conversion between a string and a list  of character
    codes.  At least one of the two arguments must be instantiated.


tteexxtt__ttoo__ssttrriinngg((_+_T_e_x_t_, _-_S_t_r_i_n_g))                                     _[_d_e_t_]
    Converts  _T_e_x_t to  a string.   _T_e_x_t is  an atom,  string or list  of
    characters  (codes or chars).   When running in --traditional  mode,
    '[]' is ambiguous and interpreted as an empty string.


ssttrriinngg__lleennggtthh((_+_S_t_r_i_n_g_, _-_L_e_n_g_t_h))
    Unify  _L_e_n_g_t_h  with  the number  of  characters  in _S_t_r_i_n_g.     This
    predicate  is  functionally  equivalent  to atom_length/2  and  also
    accepts atoms, integers and floats as its first argument.


ssttrriinngg__ccooddee((_?_I_n_d_e_x_, _+_S_t_r_i_n_g_, _?_C_o_d_e))
    True  when  _C_o_d_e  represents  the character  at  the  1-based  _I_n_d_e_x
    position in _S_t_r_i_n_g.   If _I_n_d_e_x is unbound the string is scanned from
    index  1.    Raises a  domain error  if _I_n_d_e_x  is negative.    Fails
    silently  if _I_n_d_e_x  is zero or  greater than  the length of  _S_t_r_i_n_g.
    The  mode string_code(_-_,_+_,_+)  is deterministic  if the  searched-for
    _C_o_d_e appears only once in _S_t_r_i_n_g.  See also sub_string/5.


ggeett__ssttrriinngg__ccooddee((_+_I_n_d_e_x_, _+_S_t_r_i_n_g_, _-_C_o_d_e))
    Semi-deterministic  version  of string_code/3.   In  addition,  this
    version  provides strict range checking, throwing a domain  error if
    _I_n_d_e_x is less than  1 or greater than the length of _S_t_r_i_n_g.  ECLiPSe
    provides this to support String[Index] notation.


ssttrriinngg__ccoonnccaatt((_?_S_t_r_i_n_g_1_, _?_S_t_r_i_n_g_2_, _?_S_t_r_i_n_g_3))
    Similar  to atom_concat/3,  but the unbound argument will  be unified
    with  a string object rather  than an atom.   Also, if both  _S_t_r_i_n_g_1
    and  _S_t_r_i_n_g_2 are  unbound and _S_t_r_i_n_g_3  is bound to  text, it  breaks
    _S_t_r_i_n_g_3,  unifying the start with  _S_t_r_i_n_g_1 and the end with  _S_t_r_i_n_g_2
    as  append does  with lists.   Note  that this  is not  particularly
    fast  on long strings,  as for  each redo the  system has to  create
    two  entirely new strings, while the list equivalent only  creates a
    single new list-cell and moves some pointers around.


sspplliitt__ssttrriinngg((_+_S_t_r_i_n_g_, _+_S_e_p_C_h_a_r_s_, _+_P_a_d_C_h_a_r_s_, _-_S_u_b_S_t_r_i_n_g_s))           _[_d_e_t_]
    Break  _S_t_r_i_n_g into _S_u_b_S_t_r_i_n_g_s.   The _S_e_p_C_h_a_r_s argument provides  the
    characters that act  as separators and thus the length of _S_u_b_S_t_r_i_n_g_s
    is  one more  than the number  of separators  found if _S_e_p_C_h_a_r_s  and
    _P_a_d_C_h_a_r_s  do not have common characters.   If _S_e_p_C_h_a_r_s and  _P_a_d_C_h_a_r_s
    are  equal,  sequences  of  adjacent  separators  act  as  a  single
    separator.    Leading  and trailing  characters  for each  substring
    that  appear  in _P_a_d_C_h_a_r_s  are  removed from  the  substring.    The
    input  arguments can be  either atoms,  strings or char/code  lists.
    Compatible with ECLiPSe.  Below are some examples:

    ____________________________________________________________________|                                                                    |
    | % a simple split                                                   |

    | ?- split_string("a.b.c.d", ".", "", L).                            |
    | L = ["a", "b", "c", "d"].                                          |
    | % Consider sequences of separators as a single one                 |
    | ?- split_string("/home//jan///nice/path", "/", "/", L).            |
    | L = ["home", "jan", "nice", "path"].                               |
    | % split and remove white space                                     |
    | ?- split_string("SWI-Prolog, 7.0", ",", " ", L).                   |
    | L = ["SWI-Prolog", "7.0"].                                         |

    | % only remove leading and trailing white space                     |
    | ?- split_string("  SWI-Prolog  ", "", "\s\t\n", L).                |
    ||L_=_["SWI-Prolog"]._______________________________________________ ||

    In the typical  use cases, _S_e_p_C_h_a_r_s either does not overlap _P_a_d_C_h_a_r_s
    or is equivalent  to handle multiple adjacent separators as a single
    (often white space).   The behaviour with partially overlapping sets
    of padding and  separators should be considered undefined.  See also
    read_string/5.


ssuubb__ssttrriinngg((_+_S_t_r_i_n_g_, _?_B_e_f_o_r_e_, _?_L_e_n_g_t_h_, _?_A_f_t_e_r_, _?_S_u_b_S_t_r_i_n_g))
    _S_u_b_S_t_r_i_n_g is a substring  of _S_t_r_i_n_g.  There are _B_e_f_o_r_e characters in
    _S_t_r_i_n_g before _S_u_b_S_t_r_i_n_g,  _S_u_b_S_t_r_i_n_g contains _L_e_n_g_t_h character and is
    followed  by _A_f_t_e_r characters in _S_t_r_i_n_g.  If not  enough information
    is  provided to compute  the start of the  match, _S_t_r_i_n_g is  scanned
    left-to-right.     This  predicate  is  functionally  equivalent  to
    sub_atom/5, but operates  on strings.  The following  example splits
    a string  of the form <_n_a_m_e>=<_v_a_l_u_e> into the name part (an atom) and
    the value (a string).

    ____________________________________________________________________|                                                                    |
    | name_value(String, Name, Value) :-                                 |

    |         sub_string(String, Before, _, After, "="), !,              |
    |         sub_string(String, 0, Before, _, NameString),              |
    |         atom_string(Name, NameString),                             |
    ||________sub_string(String,__,_After,_0,_Value).___________________ ||


aattoommiiccss__ttoo__ssttrriinngg((_+_L_i_s_t_, _-_S_t_r_i_n_g))
    _L_i_s_t  is  a  list of  strings,  atoms,  integers or  floating  point
    numbers.   Succeeds if _S_t_r_i_n_g  can be unified with the  concatenated
    elements  of  _L_i_s_t.     Equivalent  to  atomics_to_string(_L_i_s_t_,  _'_'_,
    _S_t_r_i_n_g).


aattoommiiccss__ttoo__ssttrriinngg((_+_L_i_s_t_, _+_S_e_p_a_r_a_t_o_r_, _-_S_t_r_i_n_g))
    Creates  a string just like atomics_to_string/2, but  inserts _S_e_p_a_r_a_-
    _t_o_r between each pair of inputs.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- atomics_to_string([gnu, "gnat", 1], ', ', A).                   |

    |                                                                    |
    ||A_=_"gnu,_gnat,_1"________________________________________________ ||


ssttrriinngg__uuppppeerr((_+_S_t_r_i_n_g_, _-_U_p_p_e_r_C_a_s_e))
    Convert _S_t_r_i_n_g to upper case and unify the result with _U_p_p_e_r_C_a_s_e.


ssttrriinngg__lloowweerr((_+_S_t_r_i_n_g_, _L_o_w_e_r_C_a_s_e))
    Convert _S_t_r_i_n_g to lower case and unify the result with _L_o_w_e_r_C_a_s_e.


rreeaadd__ssttrriinngg((_+_S_t_r_e_a_m_, _?_L_e_n_g_t_h_, _-_S_t_r_i_n_g))
    Read  at most _L_e_n_g_t_h characters from  _S_t_r_e_a_m and return them in  the
    string _S_t_r_i_n_g.   If _L_e_n_g_t_h is unbound, _S_t_r_e_a_m is read to the end and
    _L_e_n_g_t_h is unified with the number of characters read.


rreeaadd__ssttrriinngg((_+_S_t_r_e_a_m_, _+_S_e_p_C_h_a_r_s_, _+_P_a_d_C_h_a_r_s_, _-_S_e_p_, _-_S_t_r_i_n_g))
    Read  a  string  from _S_t_r_e_a_m,  providing  functionality  similar  to
    split_string/4.  The predicate performs the following steps:

     1.  Skip all characters that match _P_a_d_C_h_a_r_s

     2.  Read up to a character that matches _S_e_p_C_h_a_r_s or end of file

     3.  Discard  trailing  characters  that  match  _P_a_d_C_h_a_r_s  from  the
         collected input

     4.  Unify _S_t_r_i_n_g with a string created from the input  and _S_e_p with
         the separator character read.   If input was terminated  by the
         end of the input, _S_e_p is unified with -1.

    The predicate  read_string/5called repeatedly on  an input until _S_e_p
    is  -1 (end of file) is  equivalent to reading the entire file  into
    a  string  and calling  split_string/4,  provided  that _S_e_p_C_h_a_r_s  and
    _P_a_d_C_h_a_r_s are not _p_a_r_t_i_a_l_l_y _o_v_e_r_l_a_p_p_i_n_g.  Below are some examples:

    ____________________________________________________________________|                                                                    |

    | % Read a line                                                      |
    | read_string(Input, "\n", "\r", End, String)                        |
    | % Read a line, stripping leading and trailing white space          |
    | read_string(Input, "\n", "\r\t ", End, String)                     |
    | % Read upto , or ), unifying End with 0', or 0')                   |

    ||read_string(Input,_",)",_"\t_",_End,_String)______________________ ||


ooppeenn__ssttrriinngg((_+_S_t_r_i_n_g_, _-_S_t_r_e_a_m))
    True  when _S_t_r_e_a_m is  an input stream  that accesses the content  of
    _S_t_r_i_n_g.  _S_t_r_i_n_g  can be any text representation, i.e., string, atom,
    list of codes or list of characters.


55..22..22 RReepprreesseennttiinngg tteexxtt::  ssttrriinnggss,, aattoommss aanndd ccooddee lliissttss

With  the introduction  of strings  as  a Prolog  data type,  there  are
three  main ways  to  represent text:    using strings,  atoms  or  code
lists.   This section explains  what to choose for  what purpose.   Both
strings and  atoms are _a_t_o_m_i_c  objects:  you can  only look inside  them
using  dedicated predicates.    Lists of  character  codes are  compound
datastructures.

LLiissttss ooff cchhaarraacctteerr ccooddeess  is what  you need if  you want  to _p_a_r_s_e  text
    using  Prolog grammar rules (DCGs, see phrase/3).  Most of  the text
    reading  predicates  (e.g., read_line_to_codes/2)  return  a list  of
    character codes because  most applications need to parse these lines
    before the data can be processed.

AAttoommss  are  _i_d_e_n_t_i_f_i_e_r_s.    They  are  typically  used  in  cases  where
    identity  comparison is  the main operation  and that are  typically
    not  composed nor  taken apart.   Examples  are RDF resources  (URIs
    that  identify something), system identifiers (e.g.,  'Boeing 747'),
    but  also individual words in a natural language  processing system.
    They  are  also  used where  other  languages would  use  _e_n_u_m_e_r_a_t_e_d
    _t_y_p_e_s,  such as the names  of days in the  week.  Unlike  enumerated
    types,  Prolog atoms do not form not  a fixed set and the  same atom
    can represent different things in different contexts.

SSttrriinnggss  typically represents text that is  processed as a unit most  of
    the  time, but  which is not  an identifier for  something.   Format
    specifications  for format/3  is a  good example.   Another  example
    is  a  descriptive  text  provided  in  an  application.     Strings
    may  be  composed and  decomposed  using e.g.,  string_concat/3  and
    sub_string/5  or  converted  for  parsing  using  string_codes/2  or
    created  from codes  generated by  a generative  grammar rule,  also
    using string_codes/2.


55..22..33 AAddaappttiinngg ccooddee ffoorr ddoouubbllee qquuootteedd ssttrriinnggss

The predicates  in this section  can help adapting  your program to  the
new convention for  handling double quoted strings.   We have adapted  a
huge code base with which we were not familiar in about half a day.


lliisstt__ssttrriinnggss
    This  predicate  may  be used  to  assess compatibility  issues  due
    to  the  representation of  double quoted  text  as string  objects.
    See  section  ???? and  section ????.    To use  it,  load your  program
    into  Prolog and  run list_strings/0.   The  predicate lists  source
    locations of string  objects encountered in the program that are not
    considered  safe.  Such string  need to be examined manually,  after
    which one of the actions below may be appropriate:

      o  Rewrite the code.  For example, change [X] = "a" into X = 0'a.

      o  If a particular  module relies heavily on representing  strings
         as  lists of  character  code,  consider adding  the  following
         directive to the module.   Note that this flag only  applies to
         the module in which it appears.

         _______________________________________________________________|                                                               |

         ||_________:-_set_prolog_flag(double_quotes,_codes).___________ ||

      o  Use a  back  quoted string  (e.g.,  `text`).   Note  that  this
         will not  make your  code run regardless  of the  --traditional
         command line option  and code exploiting  this mapping is  also
         not portable to ISO compliant systems.

      o  If the strings appear in facts and usage is safe,  add a clause
         to the multifile  predicate check:string_predicate/1 to  silence
         list_strings/0 on all clauses of that predicate.

      o  If the strings  appear as an argument  to a predicate that  can
         handle string objects, add a clause to  the multifile predicate
         check:valid_string_goal/1 to silence list_strings/0.


cchheecckk::ssttrriinngg__pprreeddiiccaattee((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))
    Declare  that _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r has  clauses that contain  strings,
    but  that  this is  safe.   For  example, if  there  is a  predicate
    help_info/2,  where the  second argument  contains  a double  quoted
    string   that  is  handled  properly   by  the  predicates  of   the
    applications'  help system,  add the  following declaration to  stop
    list_strings/0 from complaining:

    ____________________________________________________________________|                                                                    |
    | :- multifile check:string_predicate/1.                             |

    |                                                                    |
    ||check:string_predicate(user:help_info/2)._________________________ ||


cchheecckk::vvaalliidd__ssttrriinngg__ggooaall((_:_G_o_a_l))
    Declare  that calls to _G_o_a_l are  safe.  The module qualification  is
    the  actual module in which  _G_o_a_l is defined.   For example, a  call
    to  format/3 is  resolved  by the  predicate system:format/3.    and
    the  code below specifies that the  second argument may be a  string
    (system predicates that accept strings are defined in the library).

    ____________________________________________________________________|                                                                    |
    | :- multifile check:valid_string_goal/1.                            |

    |                                                                    |
    ||check:valid_string_goal(system:format(_,S,_))_:-_string(S)._______ ||


55..22..44 WWhhyy hhaass tthhee rreepprreesseennttaattiioonn ooff ddoouubbllee qquuootteedd tteexxtt cchhaannggeedd??

Prolog defines two forms  of quoted text.  Traditionally,  single quoted
text is  mapped to atoms while  double quoted text  is mapped to a  list
of _c_h_a_r_a_c_t_e_r _c_o_d_e_s  (integers) or characters represented as  1-character
atoms.   Representing text  using atoms  is often considered  inadequate
for several reasons:

  o It  hides  the   conceptual  difference  between  text  and  program
    symbols.   Where  content of text often  matters because it is  used
    in  I/O, program symbols are merely identifiers that match  with the
    same  symbol elsewhere.   Program symbols can often be  consistently
    replaced, for example to obfuscate or compact a program.

  o Atoms are globally unique  identifiers.  They are stored in a shared
    table.   Volatile strings represented as atoms come at a significant
    price  due to the required cooperation between threads  for creating
    atoms.   Reclaiming temporary atoms using _A_t_o_m _g_a_r_b_a_g_e _c_o_l_l_e_c_t_i_o_n is
    a costly process that requires significant synchronisation.

  o Many Prolog systems  (not SWI-Prolog) put severe restrictions on the
    length of atoms or the maximum number of atoms.

Representing text  as a  list of  character codes  or 1-character  atoms
also comes at a price:

  o It  is not possible to distinguish  (at runtime) a list of  integers
    or  atoms from a string.  Sometimes this information can  be derived
    from  (implicit) typing.  In  other cases the list must be  embedded
    in  a compound  term to  distinguish the two  types.   For  example,
    s("hello world") could be  used to indicate that we are dealing with
    a string.

    Lacking  runtime information,  debuggers and  the toplevel can  only
    use  heuristics to  decide whether to  print a  list of integers  as
    such or as a string (see portray_text/1).

    While  experienced  Prolog programmers  have  learned to  cope  with
    this, we still consider this an unfortunate situation.

  o Lists are expensive  structures, taking 2 cells per character (3 for
    SWI-Prolog  in its current form).  This stresses  memory consumption
    on the stacks while  pushing them on the stack and dealing with them
    during garbage collection is unnecessarilly expensive.

We observe  that in many  programs, most strings are  only handled as  a
single unit during  their lifetime.   Examining real code tells us  that
double quoted strings typically appear in one of the following roles:

 AA DDCCGG lliitteerraall   Although represented as a list of codes is  the correct
    representation  for  handling  in  DCGs,   the  DCG  translator  can
    recognise  the literal and convert it to the  proper representation.
    Such code need not be modified.

 AA ffoorrmmaatt ssttrriinngg   This  is   a  typical   example  of   text  that   is
    conceptually  not a program identifier.  Format is designed  to deal
    with  alternative representations of the  format string.  Such  code
    need not be modified.

 GGeettttiinngg aa cchhaarraacctteerr ccooddee   The construct [X] = "a"  is a commonly  used
    template  for getting the  character code  of the letter  'a'.   ISO
    Prolog  defines the syntax  0'a for this purpose.   Code using  this
    must  be modified.  The modified code will run on any  ISO compliant
    processor.

 AAss aarrgguummeenntt ttoo lliisstt pprreeddiiccaatteess ttoo ooppeerraattee oonn ssttrriinnggss   Here,   we   see
    code  such as append("name:", Rest, Codes).   Such code needs to  be
    modified.    In this  particular example,  the following  is a  good
    portable alternative:  phrase("name:", Codes, Rest)

 CChheecckkss ffoorr aa cchhaarraacctteerr ttoo bbee iinn aa sseett   Such tests are often  performed
    with  code  such  as  this:   memberchk(C, "~!@#$").     This  is  a
    rather  inefficient check in a traditional Prolog system  because it
    pushes  a list of character codes cell-by-cell the Prolog  stack and
    then  traverses this  list cell-by-cell  to see whether  one of  the
    cells  unifies with _C.  If the test is  successful, the string  will
    eventually  be subject  to garbage collection.    The best code  for
    this  is to write a predicate  as below, which pushes noting  on the
    stack  and performs an indexed  lookup to see whether the  character
    code is in `my_class'.

    ____________________________________________________________________|                                                                    |

    | my_class(0'~).                                                     |
    | my_class(0'!).                                                     |
    ||..._______________________________________________________________ ||

    An alternative to reach  the same effect is to use term expansion to
    create the clauses:

    ____________________________________________________________________|                                                                    |
    | term_expansion(my_class(_), Clauses) :-                            |
    |         findall(my_class(C),                                       |
    |                 string_code(_, "~!@#$", C),                        |
    |                 Clauses).                                          |

    |                                                                    |
    ||my_class(_).______________________________________________________ ||

    Finally,  the predicate string_code/3can be  exploited directly as a
    replacement  for the memberchk/2 on a  list of codes.  Although  the
    string  is still pushed onto the stack, it is more compact  and only
    a single entity.

We offer the predicate list_strings/0 to help porting your program.


55..33 SSyynnttaaxx cchhaannggeess


55..33..11 OOppeerraattoorrss aanndd qquuootteedd aattoommss

As of SWI-Prolog version 7, quoted atoms loose  their operator property.
This means  that expressions such as  A = 'dynamic'/1 are valid  syntax,
regardless  of  the  operator  definitions.     From  questions  on  the
mailinglist  this  is what  people  expect.    To  accomodate  for  real
quoted operators, a  quoted atom that _n_e_e_d_s  quotes can still act as  an
operator.  A good use-case for this is a unit  library, which allows for
expressions such as below.

________________________________________________________________________|                                                                        |
|?- Y isu 600kcal - 1h*200'W'.                                           |

|Y|=_1790400.0'J'.______________________________________________________ | |


55..33..22 CCoommppoouunndd tteerrmmss wwiitthh zzeerroo aarrgguummeennttss

As of  SWI-Prolog version  7, the  system supports  compound terms  that
have no  arguments.   This implies  that e.g.,  name() is valid  syntax.
This  extension aims  at functions  on dicts  (see section  ????) as  well
as  the  implementation  of  domain  specific  languages  (DSLs).     To
minimise the  consequences, the classic  predicates functor/3 and  =../2
have  not  been modified.     The  predicates compound_name_arity/3  and
compound_name_arguments/3 have  been added.    These predicates  operate
only on compound  terms and behave consistently for compounds  with zero
arguments.    Code that  _g_e_n_e_r_a_l_i_s_e_s  a term  using the  sequence  below
should generally be changed to use compound_name_arity/3.

________________________________________________________________________|                                                                        |
|    ...,                                                                |

|    functor(Specific, Name, Arity),                                     |
|    functor(General, Name, Arity),                                      |
||___...,_______________________________________________________________ ||

Replacement of =../2 by compound_name_arguments/3 is typically needed to
deal with code that follow the skeleton below.

________________________________________________________________________|                                                                        |
|    ...,                                                                |
|    Term0 =.. [Name|Args0],                                             |
|    maplist(convert, Args0, Args),                                      |
|    Term =.. [Name|Args],                                               |
||___...,_______________________________________________________________ ||

For predicates, goals and arithmetic functions (evaluable terms), <_n_a_m_e>
and <_n_a_m_e>()  are _e_q_u_i_v_a_l_e_n_t.   Below are some  examples that illustrate
this behaviour.

________________________________________________________________________|                                                                        |

|go() :- format('Hello world~n').                                        |
|                                                                        |
|?- go().                                                                |
|Hello world                                                             |
|                                                                        |
|?- go.                                                                  |
|Hello world                                                             |

|                                                                        |
|?- Pi is pi().                                                          |
|Pi = 3.141592653589793.                                                 |
|                                                                        |
|?- Pi is pi.                                                            |
|Pi|=_3.141592653589793.________________________________________________ |  |

Note  that  the   _c_a_n_n_o_n_i_c_a_l  representation  of  predicate  heads   and
functions  without arguments  is  an atom.    Thus,  clause(_g_o_(_)_,  _B_o_d_y)
returns the  clauses for  go/0, but clause(_-_H_e_a_d_,  _-_B_o_d_y_, _+_R_e_f)  unifies
_H_e_a_d with an atom if the clause specified by _R_e_f is  part of a predicate
with zero arguments.


55..33..33 BBlloocckk ooppeerraattoorrss

Introducing curly bracket  and array subscripting.   The symbols []  and
{} may be declared as an operator, which has the following effect:

[[ ]]
    This  operator is  typically declared as  a low-priority yf  postfix
    operator,  which  allows for  array[index] notation.    This  syntax
    produces a term []([index],array).

{ }
    This  operator is  typically declared as  a low-priority xf  postfix
    operator,  which  allows  for  head(arg) { body } notation.     This
    syntax produces a term {}({body},head(arg)).

Below is  an example that  illustrates the  representation of a  typical
`curly bracket language' in Prolog.

________________________________________________________________________|                                                                        |

|?- op(100, xf, {}).                                                     |
|?- op(100, yf, []).                                                     |
|?- op(1100, yf, ;).                                                     |
|                                                                        |
|?- displayq(func(arg)                                                   |

|            { a[10] = 5;                                                |
|              update();                                                 |
|            }).                                                         |
|{}({;(=([]([10],a),5),;(update()))},func(arg))|________________________ |                                              |


55..44 DDiiccttss::  ssttrruuccttuurreess wwiitthh nnaammeedd aarrgguummeennttss

SWI-Prolog  version 7  introduces dicts  as an  abstract  object with  a
concrete modern  syntax and  functional notation  for accessing  members
and as  well as access functions  defined by the user.   The syntax  for
a dict  is illustrated  below.   _T_a_g is  either a variable  or an  atom.
As  with compound  terms, there  is nnoo  space  between the  tag and  the
opening brace.    The keys  are either atoms  or small  integers (up  to
max_tagged_integer).   The  values are arbitrary  Prolog terms which  are
parsed using the same rules as used for arguments in compound terms.

    Tag{Key1:Value1, Key2:Value2, ...}

A  dict can  _n_o_t hold  duplicate keys.    The dict  is transformed  into
an opaque  internal representation that  does _n_o_t  respect the order  in
which the  key-value pairs  appear in  the input  text.   If  a dict  is
written, the keys are  written according to the standard order  of terms
(see section  ????).   Here are  some examples,  where the second  example
illustrates that the  order is not maintained and the  third illustrates
an anonymous dict.

________________________________________________________________________|                                                                        |

|?- A = point{x:1, y:2}.                                                 |
|A = point{x:1, y:2}.                                                    |
|                                                                        |
|?- A = point{y:2, x:1}.                                                 |
|A = point{x:1, y:2}.                                                    |

|                                                                        |
|?- A = _{first_name:"Mel", last_name:"Smith"}.                          |
|A|=__G1476{first_name:"Mel",_last_name:"Smith"}._______________________ | |

Dicts  can   be  unified   following  the   standard  symmetric   Prolog
unification  rules.    As dicts  use  an internal  canonical  form,  the
order in  which the named keys  are represented is  not relevant.   This
behaviour is illustrated by the following example.

________________________________________________________________________|                                                                        |
|?- point{x:1, y:2} = Tag{y:2, x:X}.                                     |
|Tag = point,                                                            |
|X|=_1._________________________________________________________________ | |

NNoottee In the  current implementation, two dicts  unify only if they  have
the same set  of keys and the tags  and values associated with the  keys
unify.   In  future versions,  the notion of  unification between  dicts
could  be modified  such that  two dicts  unify if  their  tags and  the
values associated with _c_o_m_m_o_n keys unify, turning both  dicts into a new
dict that has the union of the keys of the two original dicts.


55..44..11 FFuunnccttiioonnss oonn ddiiccttss

The infix operator dot (op(_1_0_0_,  _y_f_x_, _.)  is used to extract  values and
evaluate functions on  dicts.  Functions  are recognised if they  appear
in the  argument of  a _g_o_a_l  in the source  text, possibly  nested in  a
term.   The keys  act as field  selector, which  is illustrated in  this
example.

________________________________________________________________________|                                                                        |
|?- X = point{x:1,y:2}.x.                                                |

|X = 1.                                                                  |
|                                                                        |
|?- Pt = point{x:1,y:2}, write(Pt.y).                                    |
|2                                                                       |
|Pt = point{x:1,y:2}.                                                    |
|                                                                        |
|?- X = point{x:1,y:2}.C.                                                |
|X = 1,                                                                  |

|C = x ;                                                                 |
|X = 2,                                                                  |
|C|=_y._________________________________________________________________ | |

The compiler translates a goal that contains ./2 terms  in its arguments
into a conjunction of calls to ./3 defined in the system  module.  Terms
functor.2 that  appears in  the head  are replaced with  a variable  and
calls to  ./3 are  inserted at the  start of the  body.   Below are  two
examples, where the first extracts the x key from a  dict and the second
extends  a dict  containing an  address with  the postal  code, given  a
find_postal_code/4predicate.

________________________________________________________________________|                                                                        |
|dict_x(X, X.x).                                                         |
|                                                                        |
|add_postal_code(Dict, Dict.put(postal_code, Code)) :-                   |

|        find_postal_code(Dict.city,                                     |
|                         Dict.street,                                   |
|                         Dict.house_number,                             |
||________________________Code).________________________________________ ||

Note  that expansion  of ./2  terms implies  that such  terms cannot  be
created by  writing them  explicitly in your  source code.   Such  terms
can still  be created  with functor/3, =../2,  compound_name_arity/3 and
compound_name_arguments/3.


.((_+_D_i_c_t_, _+_F_u_n_c_t_i_o_n_, _-_R_e_s_u_l_t))
    This  predicate  is  called  to  evaluate ./2  terms  found  in  the
    arguments of a  goal.  This predicate evaluates the field extraction
    described  above, which is mapped to get_dict_ex/3.  If  _F_u_n_c_t_i_o_n is
    a  compound term, it  checks for the  predefined functions on  dicts
    described  in section  ????  or executes  a user  defined function  as
    described in section ????.


55..44..11..11 UUsseerr ddeeffiinneedd ffuunnccttiioonnss oonn ddiiccttss

The tag of a dict associates the dict to a module.   If the dot notation
uses a compound term, this calls the goal below.

    <_m_o_d_u_l_e>:<_n_a_m_e>(Arg1, ..., +Dict, -Value)

Functions  are  normal  Prolog predicates.     The  dict  infrastructure
provides a  more convenient  syntax for  representing the  head of  such
predicates  without worrying  about  the argument  calling  conventions.
The  code below  defines  a function  multiply(_T_i_m_e_s)  on a  point  that
creates  a new  point  by multiplying  both coordinates.    and  len  to
compute the length  from the origin.  The  .  and := operators  are used
to abstract the location  of the predicate arguments.  It is  allowed to
define multiple a function with multiple clauses,  providing overloading
and non-determinism.

________________________________________________________________________|                                                                        |

|:- module(point, []).                                                   |
|                                                                        |
|M.multiply(F) := point{x:X, y:Y} :-                                     |
|        X is M.x*F,                                                     |
|        Y is M.y*F.                                                     |
|                                                                        |
|M.len() := Len :-                                                       |

||_______Len_is_sqrt(M.x**2_+_M.y**2).__________________________________ ||

After these definitions, we can evaluate the following functions:

________________________________________________________________________|                                                                        |
|?- X = point{x:1, y:2}.multiply(2).                                     |
|X = point{x:2, y:4}.                                                    |
|                                                                        |
|?- X = point{x:1, y:2}.multiply(2).len().                               |

|X|=_4.47213595499958.__________________________________________________ | |


55..44..11..22 PPrreeddeeffiinneedd ffuunnccttiioonnss oonn ddiiccttss

Dicts currently define the following reserved functions:


ggeett((_?_K_e_y))
    Same  as _D_i_c_t._K_e_y, but maps  to get_dict/3 instead of get_dict_ex/3.
    This  implies that  the function  evaluation fails  silently if  _K_e_y
    does  not appear in _D_i_c_t.  See also :</2, which can be  used to test
    for  existence and  unify  multiple key  values from  a dict.    For
    example:

    ____________________________________________________________________|                                                                    |
    | ?- write(t{a:x}.get(a)).                                           |

    | x                                                                  |
    | ?- write(t{a:x}.get(b)).                                           |
    ||false.____________________________________________________________ ||


ppuutt((_+_N_e_w))
    Evaluates  to a  new dict  where the  key-values in  _N_e_w replace  or
    extend the key-values in the original dict.  See put_dict/3.


ppuutt((_+_K_e_y_P_a_t_h_, _+_V_a_l_u_e))
    Evaluates to a  new dict where the _K_e_y_P_a_t_h-_V_a_l_u_e replaces or extends
    the  key-values in  the  original dict.    _K_e_y_P_a_t_h is  either a  key
    or  a  term _K_e_y_P_a_t_h/_K_e_y,  replacing the  value  associated with  _K_e_y
    in  a sub-dict  of the dict  on which  the function operates.    See
    put_dict/4.  Below are some examples:

    ____________________________________________________________________|                                                                    |
    | ?- A = _{}.put(a, 1).                                              |

    | A = _G7359{a:1}.                                                   |
    |                                                                    |
    | ?- A = _{a:1}.put(a, 2).                                           |
    | A = _G7377{a:2}.                                                   |
    |                                                                    |
    | ?- A = _{a:1}.put(b/c, 2).                                         |
    | A = _G1395{a:1, b:_G1584{c:2}}.                                    |
    |                                                                    |

    | ?- A = _{a:_{b:1}}.put(a/b, 2).                                    |
    | A = _G1429{a:_G1425{b:2}}.                                         |
    |                                                                    |
    | ?- A = _{a:1}.put(a/b, 2).                                         |
    ||A_=__G1395{a:_G1578{b:2}}.________________________________________ ||


55..44..22 PPrreeddiiccaatteess ffoorr mmaannaaggiinngg ddiiccttss

This section  documents the predicates  that are defined on  dicts.   We
use the naming and argument conventions of the traditional assoc.


iiss__ddiicctt((_@_T_e_r_m))
    True if _T_e_r_m is a dict.  This is the same as is_dict(Term,_).


iiss__ddiicctt((_@_T_e_r_m_, _-_T_a_g))
    True if _T_e_r_m is a dict of _T_a_g.


ggeett__ddiicctt((_?_K_e_y_, _+_D_i_c_t_, _-_V_a_l_u_e))
    Unify  the value associated  with _K_e_y in  dict with _V_a_l_u_e.   If  _K_e_y
    is  unbound, all associations in _D_i_c_t are returned  on backtracking.
    The  order  in which  the associations  are  returned is  undefined.
    This  predicate is normally  accessed using the functional  notation
    Dict.Key.  See section ????.

    Fails  silently if Key does not appear  in Dict.  This  is different
    from  the behavior of the  functional `.`-notation, which throws  an
    existence error in that case.


ggeett__ddiicctt((_+_K_e_y_, _+_D_i_c_t_, _-_V_a_l_u_e_, _-_N_e_w_D_i_c_t_, _+_N_e_w_V_a_l_u_e))             _[_s_e_m_i_d_e_t_]
    Create a new dict  after updating the value for _K_e_y.  Fails if _V_a_l_u_e
    does not unify with  the current value associated with _K_e_y.  _D_i_c_t is
    either a dict or a list the can be converted into a dict.

    Has the behavior as if defined in the following way:

    ____________________________________________________________________|                                                                    |
    | get_dict(Key, Dict, Value, NewDict, NewValue) :-                   |

    |         get_dict(Key, Dict, Value),                                |
    ||________put_dict(Key,_Dict,_NewValue,_NewDict).___________________ ||


ddiicctt__ccrreeaattee((_-_D_i_c_t_, _+_T_a_g_, _+_D_a_t_a))
    Create  a dict in _T_a_g from _D_a_t_a.  _D_a_t_a is a  list of attribute-value
    pairs   using  the   syntax  Key:Value,   Key=Value,  Key-Value   or
    Key(Value).   An exception is raised  if _D_a_t_a is not a  proper list,
    one  of the elements is not of the shape above, a key  is neither an
    atom nor a small integer or there is a duplicate key.


ddiicctt__ppaaiirrss((_?_D_i_c_t_, _?_T_a_g_, _?_P_a_i_r_s))
    Bi-directional  mapping between a dict and an ordered list  of pairs
    (see section ????).


ppuutt__ddiicctt((_+_N_e_w_, _+_D_i_c_t_I_n_, _-_D_i_c_t_O_u_t))
    _D_i_c_t_O_u_t  is a  new  dict created  by replacing  or adding  key-value
    pairs  from _N_e_w to  _D_i_c_t.   _N_e_w is  either a dict  or a valid  input
    for  dict_create/3.   This predicate  is normally accessed using  the
    functional notation.  Below are some examples:

    ____________________________________________________________________|                                                                    |
    | ?- A = point{x:1, y:2}.put(_{x:3}).                                |

    | A = point{x:3, y:2}.                                               |
    |                                                                    |
    | ?- A = point{x:1, y:2}.put([x=3]).                                 |
    | A = point{x:3, y:2}.                                               |
    |                                                                    |
    | ?- A = point{x:1, y:2}.put([x=3,z=0]).                             |
    ||A_=_point{x:3,_y:2,_z:0}._________________________________________ ||


ppuutt__ddiicctt((_+_K_e_y_, _+_D_i_c_t_I_n_, _+_V_a_l_u_e_, _-_D_i_c_t_O_u_t))
    _D_i_c_t_O_u_t  is a new dict created  by replacing or adding _K_e_y-_V_a_l_u_e  to
    _D_i_c_t_I_n.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- A = point{x:1, y:2}.put(x, 3).                                  |

    ||A_=_point{x:3,_y:2}.______________________________________________ ||

    This  predicate  can  also  be  accessed  by  using  the  functional
    notation,  in which  case Key can  also be a  *path* of  keys.   For
    example:

    ____________________________________________________________________|                                                                    |
    | ?- Dict = _{}.put(a/b, c).                                         |
    ||Dict_=__6096{a:_6200{b:c}}._______________________________________ ||


ddeell__ddiicctt((_+_K_e_y_, _+_D_i_c_t_I_n_, _?_V_a_l_u_e_, _-_D_i_c_t_O_u_t))
    True   when  _K_e_y-_V_a_l_u_e  is  in  _D_i_c_t_I_n  and  _D_i_c_t_O_u_t   contains  all
    associations of _D_i_c_t_I_n except for _K_e_y.


_+_S_e_l_e_c_t :< _+_F_r_o_m                                              _[_s_e_m_i_d_e_t_]
    True  when _S_e_l_e_c_t is  a `sub dict'  of _F_r_o_m:   the tages must  unify
    and  all keys in  _S_e_l_e_c_t must appear  with unifying values in  _F_r_o_m.
    _F_r_o_m  may contain  keys  that are  not in  _S_e_l_e_c_t.   This  operation
    is  frequently used to  _m_a_t_c_h a  dict and at  the same time  extract
    relevant values from it.  For example:

    ____________________________________________________________________|                                                                    |
    | plot(Dict, On) :-                                                  |

    |         _{x:X, y:Y, z:Z} :< Dict, !,                               |
    |         plot_xyz(X, Y, Z, On).                                     |
    | plot(Dict, On) :-                                                  |
    |         _{x:X, y:Y} :< Dict, !,                                    |
    ||________plot_xy(X,_Y,_On).________________________________________ ||

    The  goal Select :< From is equivalent to  select_dict(_S_e_l_e_c_t_,  _F_r_o_m_,
    __).


sseelleecctt__ddiicctt((_+_S_e_l_e_c_t_, _+_F_r_o_m_, _-_R_e_s_t))                             _[_s_e_m_i_d_e_t_]
    True  when the tags of _S_e_l_e_c_t  and _F_r_o_m have been unified,  all keys
    in  _S_e_l_e_c_t appear  in _F_r_o_m  and the corresponding  values have  been
    unified.   The key-value pairs of _F_r_o_m that do not appear  in _S_e_l_e_c_t
    are  used to  form an anonymous  dict, which  us unified with  _R_e_s_t.
    For example:

    ____________________________________________________________________|                                                                    |
    | ?- select_dict(P{x:0, y:Y}, point{x:0, y:1, z:2}, R).              |

    | P = point,                                                         |
    | Y = 1,                                                             |
    ||R_=__G1705{z:2}.__________________________________________________ ||

    See  also select_dict/2 to  ignore _R_e_s_t  and >:</2  for a  symmetric
    partial unification of two dicts.


_+_D_i_c_t_1 >:< _+_D_i_c_t_2
    This  operator specifies  a  _p_a_r_t_i_a_l _u_n_i_f_i_c_a_t_i_o_n  between _D_i_c_t_1  and
    _D_i_c_t_2.  It  is true when the tags and the values associated with all
    _c_o_m_m_o_n  keys have been unified.  The values associated to  keys that
    do  not appear in the other  dict are ignored.  Partial  unification
    is  symmetric.  For example, given a list of dicts, find  dicts that
    represent a point with X equal to zero:

    ____________________________________________________________________|                                                                    |
    |     member(Dict, List),                                            |

    ||____Dict_>:<_point{x:0,_y:Y}._____________________________________ ||

    See also :</2  and select_dict/3.


55..44..22..11 DDeessttrruuccttiivvee aassssiiggnnmmeenntt iinn ddiiccttss

This  section describes  the destructive  update  operations defined  on
dicts.    These actions  can  only _u_p_d_a_t_e  keys and  not  add or  remove
keys.    If  the  requested key  does  not  exist the  predicate  raises
existence_error(_k_e_y_, _K_e_y_, _D_i_c_t).  Note the additional argument.

Destructive assignment  is a  non-logical operation and  should be  used
with care because  the system may copy  or share identical Prolog  terms
at  any time.    Some of  this behaviour  can be  avoided  by adding  an
additional unbound value  to the dict.   This prevents unwanted  sharing
and ensures that copy_term/2 actually copies the dict.   This pitfall is
demonstrated in the example below:

________________________________________________________________________|                                                                        |
|?- A = a{a:1}, copy_term(A,B), b_set_dict(a, A, 2).                     |

|A = B, B = a{a:2}.                                                      |
|                                                                        |
|?- A = a{a:1,dummy:_}, copy_term(A,B), b_set_dict(a, A, 2).             |
|A = a{a:2, dummy:_G3195},                                               |
|B|=_a{a:1,_dummy:_G3391}.______________________________________________ | |


bb__sseett__ddiicctt((_+_K_e_y_, _!_D_i_c_t_, _+_V_a_l_u_e))                                    _[_d_e_t_]
    Destructively  update  the  value associated  with  _K_e_y in  _D_i_c_t  to
    _V_a_l_u_e.   The  update is trailed  and undone on  backtracking.   This
    predicate raises an  existence error if _K_e_y does not appear in _D_i_c_t.
    The update semantics are equivalent to setarg/3 and b_setval/2.


nnbb__sseett__ddiicctt((_+_K_e_y_, _!_D_i_c_t_, _+_V_a_l_u_e))                                   _[_d_e_t_]
    Destructively  update the  value associated  with _K_e_y in  _D_i_c_t to  a
    copy  of _V_a_l_u_e.   The update  is _n_o_t undone on  backtracking.   This
    predicate raises an  existence error if _K_e_y does not appear in _D_i_c_t.
    The update semantics are equivalent to nb_setarg/3 and nb_setval/2.


nnbb__lliinnkk__ddiicctt((_+_K_e_y_, _!_D_i_c_t_, _+_V_a_l_u_e))                                  _[_d_e_t_]
    Destructively  update  the  value associated  with  _K_e_y in  _D_i_c_t  to
    _V_a_l_u_e.   The update is _n_o_t  undone on backtracking.   This predicate
    raises  an existence  error if _K_e_y  does not  appear in _D_i_c_t.    The
    update  semantics are  equivalent to nb_linkarg/3  and nb_linkval/2.
    Use with  extreme care and consult the documentation of nb_linkval/2
    before use.


55..44..33 WWhheenn ttoo uussee ddiiccttss??

Dicts are  a new type in  the Prolog world.   They compete with  several
other types  and libraries.   In the  list below we  have a closer  look
at these  relations.   We will see that  dicts are first  of all a  good
replacement for compound terms  with a high or not clearly  fixed arity,
library record and option processing.

CCoommppoouunndd tteerrmmss  Compound  terms  with  positional  arguments   form  the
    traditional  way to package data in Prolog.  This  representation is
    well  understood, fast  and compound  terms are stored  efficiently.
    Compound  terms are  still the  representation  of choice,  provided
    that  the number  of arguments is  low and  fixed or compactness  or
    performance are of utmost importance.

    A  good example  of a  compound term  is the  representation of  RDF
    triples  using  the  term rdf(_S_u_b_j_e_c_t_,  _P_r_e_d_i_c_a_t_e_,  _O_b_j_e_c_t)  because
    RDF  triples are  defined to  have precisely  these three  arguments
    and  they are  always referred  to in this  order.   An  application
    processing  information  about  persons should  probably  use  dicts
    because  the  information that  is related  to a  person  is not  so
    fixed.    Typically  we see  first and  last name.    But there  may
    also  be  title, middle  name,  gender, date  of birth,  etc.    The
    number of arguments  becomes unmanagable when using a compound term,
    while  adding or removing an argument  leads to many changes in  the
    program.

LLiibbrraarryy record  Using library  record  relieves the  maintenance  issues
    associated  with using  compound terms significantly.   The  library
    generates  access and  modification predicates for  each field in  a
    compound  term  from a  declaration.    The library  provides  sound
    access  to compound terms with many arguments.  One of  its problems
    is  the  verbose syntax  needed  to access  or modify  fields  which
    results  from  long  names  for the  generated  predicates  and  the
    restriction  that each field needs  to be extracted with a  separate
    goal.    Consider the example  below, where  the first uses  library
    record and the second uses dicts.

    ____________________________________________________________________|                                                                    |
    |     ...,                                                           |

    |     person_first_name(P, FirstName),                               |
    |     person_last_name(P, LastName),                                 |
    |     format('Dear ~w ~w,~n~n', [FirstName, LastName]).              |
    |                                                                    |
    |     ...,                                                           |
    ||____format('Dear_~w_~w,~n~n',_[Dict.first_name,_Dict.last_name])._ ||

    Records  have a  fixed number  of arguments  and (non-)existence  of
    an  argument must be represented using  a value that is outside  the
    normal  domain.  This lead to unnatural code.  For  example, suppose
    our person also has a  title.  If we know the first name we use this
    and else we use the title.  The code samples below illustrate this.

    ____________________________________________________________________|                                                                    |

    | salutation(P) :-                                                   |
    |     person_first_name(P, FirstName), nonvar(FirstName), !,         |
    |     person_last_name(P, LastName),                                 |
    |     format('Dear ~w ~w,~n~n', [FirstName, LastName]).              |
    | salutation(P) :-                                                   |
    |     person_title(P, Title), nonvar(Title), !,                      |
    |     person_last_name(P, LastName),                                 |

    |     format('Dear ~w ~w,~n~n', [Title, LastName]).                  |
    |                                                                    |
    | salutation(P) :-                                                   |
    |     _{first_name:FirstName, last_name:LastName} :< P, !,           |
    |     format('Dear ~w ~w,~n~n', [FirstName, LastName]).              |
    | salutation(P) :-                                                   |
    |     _{title:Title, last_name:LastName} :< P, !,                    |
    ||____format('Dear_~w_~w,~n~n',_[Title,_LastName])._________________ ||

LLiibbrraarryy assoc  This library implements  a balanced binary  tree.   Dicts
    can  replace the use  of this library  if the association is  fairly
    static  (i.e.,  there  are  few update  operations),  all  keys  are
    atoms  or (small)  integers and the  code does  not rely on  ordered
    operations.

LLiibbrraarryy option  Option lists are introduced  by ISO Prolog, for  example
    for  read_term/3,  open/4,   etc.     The  option  library  provides
    operations to extract options,  merge options lists, etc.  Dicts are
    well  suited to replace option  lists because they are cheaper,  can
    be processed faster and have a more natural syntax.

LLiibbrraarryy pairs  This library  is  commonly used  to process  large  name-
    value  associations.     In many  cases  this  concerns  short-lived
    datastructures  that result  from findall/3,  maplist/3 and  similar
    list  processing predicates.    Dicts may  play a  role if  frequent
    random  key lookups are  needed on the  resulting association.   For
    example,  the skeleton  `create a pairs  list', `use list_to_assoc/2
    to  create an assoc', followed  by frequent usage of  get_assoc/3 to
    extract  key values can be replaced using  dict_pairs/3and  the dict
    access  functions.  Using dicts  in this scenario is more  efficient
    and provides a more pleasant access syntax.


55..44..44 AA mmoottiivvaattiioonn ffoorr ddiiccttss aass pprriimmaarryy cciittiizzeennss

Dicts, or key-value associations,  are a common data structure.   A good
old example  are _p_r_o_p_e_r_t_y _l_i_s_t_s  as found in Lisp,  while a good  recent
example is formed  by JavaScript _o_b_j_e_c_t_s.   Traditional Prolog does  not
offer native  property lists.    As a result,  people are  using a  wide
range of data structures for key-value associations:

  o Using compound terms and positional arguments, e.g., point(1,2).

  o Using   compound  terms   with  library   record,  which   generates
    access  predicates  for a  term using  positional  arguments from  a
    description.

  o Using   lists  of  terms  Name=Value,   Name-Value,  Name:Value   or
    Name(Value).

  o Using library assoc  which represents the associations as a balanced
    binary tree.

This situation  is unfortunate.    Each of these  have their  advantages
and disadvantages.    E.g.,  compound terms  are compact  and fast,  but
inflexible and using positional arguments quickly breaks down.   Library
record fixes this, but the syntax is considered hard to use.   Lists are
flexible, but  expensive and  the alternative key-value  representations
that  are  used  complicate  the  matter  even  more.     Library  assoc
allows  for efficient  manipulation of  changing associations,  but  the
syntactical  representation of  an assoc  is complex,  which makes  them
unsuitable  for e.g.,  _o_p_t_i_o_n_s  _l_i_s_t_s  as  seen in  predicates  such  as
open/4.


55..44..55 IImmpplleemmeennttaattiioonn nnootteess aabboouutt ddiiccttss

Although  dicts   are  designed  as  an   abstract  data  type  and   we
deliberately reserve  the possibility to  change the representation  and
even use  multiple representations, this  section describes the  current
implementation.

Dicts are  currently represented as  a compound  term using the  functor
`dict`.  The first argument is the tag.   The remaining arguments create
an array of sorted key-value pairs.  This  representation is compact and
guarantees good locality.  Lookup is order log(N),  while adding values,
deleting values  and merging with  other dicts has  order N.   The main
disadvantage is that changing  values in large dicts is costly,  both in
terms of memory and time.

Future versions may share  keys in a separate structure or use  a binary
trees to  allow for  cheaper updates.   One  of the issues  is that  the
representation must  either be  kept cannonical or  unification must  be
extended to compensate for alternate representations.


55..55 IInntteeggrraattiioonn ooff ssttrriinnggss aanndd ddiiccttss iinn tthhee lliibbrraarriieess

While  lacking proper  string  support  and dicts  when  designed,  many
predicates  and libraries  use  interfaces that  must be  classified  as
suboptimal.   Changing  these interfaces  is likely to  break much  more
code  than  the  changes  described in  this  chapter.     This  section
discusses  some  of  these issues.     Roughly,  there  are  two  cases.
There where  key-value associations  or text  is required  as _i_n_p_u_t,  we
can  facilitate the  new  features by  overloading the  accepted  types.
Interfaces that produce  text or key-value associations as their  _o_u_t_p_u_t
however  must make  a choice.    We plan  to resolve  that using  either
options  that specify  the  desired  output or  provide  an  alternative
library.


55..55..11 DDiiccttss aanndd ooppttiioonn pprroocceessssiinngg

System predicates and predicates based on library  options process dicts
as an alternative to traditional option lists.


55..55..22 DDiiccttss iinn ccoorree ddaattaa ssttrruuccttuurreess

Some predicates  now produce  structured data using  compound terms  and
access predicates.   We consider migrating these  to dicts.  Below is  a
tentative list  of candidates.   Portable code  should use the  provided
access predicates and not rely on the term representation.

  o Stream position terms

  o Date and time records


55..55..33 DDiiccttss,, ssttrriinnggss aanndd XXMMLL

The  XML  representation  could  benefit  significantly   from  the  new
features.    In  due time  we  plan to  provide  an set  of  alternative
predicates  and options  to  existing predicates  that  can be  used  to
exploit the  new types.   We propose the  following changes to the  data
representation:

  o The  attribute list of the  element(_N_a_m_e_, _A_t_t_r_i_b_u_t_e_s_, _C_o_n_t_e_n_t)  will
    become a dict.

  o Attribute values will remain atoms

  o CDATA in element content will be represented as strings


55..55..44 DDiiccttss,, ssttrriinnggss aanndd JJSSOONN

The  JSON  representation  could  benefit  significantly  from  the  new
features.    In  due time  we  plan to  provide  an set  of  alternative
predicates  and options  to  existing predicates  that  can be  used  to
exploit the  new types.   We propose the  following changes to the  data
representation:

  o Instead   of  using  json(_K_e_y_V_a_l_u_e_L_i_s_t),  the  new   interface  will
    translate  JSON objects to a  dict.  The  type of this dict will  be
    json.

  o String values in JSON will be mapped to strings.

  o The values true, false and null will be represented as atoms.


55..55..55 DDiiccttss,, ssttrriinnggss aanndd HHTTTTPP

The  HTTP  library  and  related  data  structures   would  profit  from
exploiting dicts.   Below  is a  list of data  structures that might  be
affected by future changes.   Code can be made more robust by  using the
option library functions for extracting values from these structures.

  o The HTTP request structure

  o The HTTP parameter interface

  o URI components

  o Attributes to HTML elements


55..66 RReemmaaiinniinngg iissssuueess

The changes  and extensions  described in  this chapter  resolve a  many
limitations of the  Prolog language we have  encountered.  Still,  there
are remaining issues for which we seek solutions in the future.

TTeexxtt  rreepprreesseennttaattiioonn Although  strings  resolve  this  issue   for  many
applications,  we are still  faced with  the representation  of text  as
lists  of  characters which  we  need  for  parsing using  DCGs.     The
ISO standard  provides two  representations, a list  of _c_h_a_r_a_c_t_e_r  _c_o_d_e_s
(`codes'  for short)  and a  list of  _o_n_e_-_c_h_a_r_a_c_t_e_r  _a_t_o_m_s (`chars'  for
short).     There  are  two  sets of  predicates,  named  *_code(s)  and
*_char(s)  that provide  the same  functionality (e.g.,  atom_codes/2 and
atom_chars/2) using  their  own representation  of  characters.    Codes
can be  used in arithmetic expressions,  while chars are more  readable.
Neither can  unambiguously be interpreted as  a representation for  text
because codes can  be interpreted as a list  of integers and chars as  a
list of atoms.

We have  not found  a convincing  way out.    One of  the options  could
be the  introduction of  a `char' type.    This type can  be allowed  in
arithmetic and with  the 0'<char> syntax we  have a concrete syntax  for
it.

AArrrraayyss Although  lists are  generally  a  much cleaner  alternative  for
Prolog, real  arrays with direct  access to elements  can be useful  for
particular tasks.  The problem of integrating arrays is  twofold.  First
of  all, there  is  no good  one-size-fits-all data  representation  for
arrays.   Many tasks that involve  arrays require _m_u_t_a_b_l_e arrays,  while
Prolog data  is immutable  by design.   Second,  standard Prolog has  no
good  syntax support  for  arrays.    SWI-Prolog  version 7  has  `block
operators'  (see section  ????) which  can resolve  the syntactic  issues.
Block operators have been adopted by YAP.

LLaammbbddaa  eexxpprreessssiioonnss Although many  alternatives have  been proposed,  we
still feel uneasy with them.

LLooooppss Many people have  explored routes to avoid the need  for recursion
in  Prolog for  simple iterations  over  data.   ECLiPSe  have  proposed
_l_o_g_i_c_a_l _l_o_o_p_s [??], while B-Prolog introduced _d_e_c_l_a_r_a_t_i_v_e  _l_o_o_p_s and _l_i_s_t
_c_o_m_p_r_e_h_e_n_s_i_o_n.   The above mentioned  lambda expressions, combined  with
maplist/2 can achieve similar results.


CChhaapptteerr 66..  MMOODDUULLEESS

A Prolog  module is a  collection of predicates  which defines a  public
interface  by means  of  a set  of  provided predicates  and  operators.
Prolog  modules are  defined by  an ISO  standard.   Unfortunately,  the
standard  is considered  a failure  and, as  far as  we are  aware,  not
implemented  by any  concrete  Prolog implementation.    The  SWI-Prolog
module system syntax  is derived from the Quintus Prolog  module system.
The Quintus  module system has  been the starting  point for the  module
systems  of a  number of  mainstream Prolog  systems,  such as  SICStus,
Ciao and YAP. The underlying primitives of the  SWI-Prolog module system
differ from the mentioned systems.  These primitives  allow for multiple
modules in  a file,  hierarchical  modules, emulation  of other  modules
interfaces, etc.

This  chapter motivates  and  describes  the SWI-Prolog  module  system.
Novices  can start  using the  module system  after  reading section  ????
and section ????.   The primitives  defined in these sections suffice  for
basic usage  until one needs  to export predicates  that call or  manage
other predicates dynamically (e.g.,  use call/1, assert/1, etc.).   Such
predicates are called  _m_e_t_a _p_r_e_d_i_c_a_t_e_s and are discussed in  section ????.
Section ???? to section  ???? describe more advanced issues.   Starting with
section ????, we  discuss more low-level aspects of the  SWI-Prolog module
system that are used to implement the visible module  system, and can be
used to build other code reuse mechanisms.


66..11 WWhhyy UUssee MMoodduulleess??

In classic  Prolog systems,  all predicates  are organised  in a  single
namespace  and any  predicate can  call  any predicate.    Because  each
predicate  in  a file  can  be  called  from anywhere  in  the  program,
it  becomes  very  hard  to  find  the  dependencies   and  enhance  the
implementation  of a  predicate  without risking  to break  the  overall
application.  This  is true for any language, but even worse  for Prolog
due to its frequent need for `helper predicates'.

A  Prolog  module  encapsulates a  set  of  predicates  and  defines  an
_i_n_t_e_r_f_a_c_e.     Modules  can  import  other  modules,   which  makes  the
dependencies explicit.   Given explicit dependencies and a  well-defined
interface, it  becomes much easier  to change the internal  organisation
of a module without breaking the overall application.

Explicit dependencies can  also be used by the development  environment.
The SWI-Prolog library  prolog_xref  can be used to analyse  completeness
and  consistency of  modules.   This  library is  used  by the  built-in
editor PceEmacs for syntax highlighting, jump-to-definition, etc.


66..22 DDeeffiinniinngg aa MMoodduullee

Modules are normally  created by loading a _m_o_d_u_l_e  _f_i_l_e.  A module  file
is a file holding a module/2 directive as its first term.   The module/2
directive declares  the name and the  public (i.e., externally  visible)
predicates of  the module.   The  rest of  the file is  loaded into  the
module.   Below is an example of  a module file, defining reverse/2  and
hiding  the helper  predicate rev/3.    A module  can  use all  built-in
predicates and, by default, cannot redefine system predicates.

________________________________________________________________________|                                                                        |
|:- module(reverse, [reverse/2]).                                        |

|                                                                        |
|reverse(List1, List2) :-                                                |
|        rev(List1, [], List2).                                          |
|                                                                        |
|rev([], List, List).                                                    |
|rev([Head|List1], List2, List3) :-                                      |
||_______rev(List1,_[Head|List2],_List3)._______________________________ ||

The  module is  named reverse.    Typically,  the name  of  a module  is
the same  as the name  of the file  by which it  is defined without  the
filename  extension, but  this  naming is  not enforced.    Modules  are
organised in  a single  and flat  namespace and  therefore module  names
must be  chosen with  some care to  avoid conflicts.   As  we will  see,
typical  applications of  the module  system rarely  use the  name of  a
module explicitly in the source text.


::-- mmoodduullee((_+_M_o_d_u_l_e_, _+_P_u_b_l_i_c_L_i_s_t))
    This  directive can  only  be used  as the  first term  of a  source
    file.    It  declares  the file  to be  a  _m_o_d_u_l_e _f_i_l_e,  defining  a
    module  named _M_o_d_u_l_e.   Note  that a module  name is an  atom.   The
    module  exports  the predicates  of  _P_u_b_l_i_c_L_i_s_t.   _P_u_b_l_i_c_L_i_s_t  is  a
    list  of predicate indicators  (name/arity or name//arity pairs)  or
    operator  declarations using the format op(_P_r_e_c_e_d_e_n_c_e_, _T_y_p_e_,  _N_a_m_e).
    Operators  defined  in  the export  list  are available  inside  the
    module  as well  as  to modules  importing this  module.   See  also
    section ????.

    Compatible to Ciao Prolog,  if _M_o_d_u_l_e is unbound, it is unified with
    the basename without extension of the file being loaded.


::-- mmoodduullee((_+_M_o_d_u_l_e_, _+_P_u_b_l_i_c_L_i_s_t_, _+_D_i_a_l_e_c_t))
    Same  as  module/2.     The  additional  _D_i_a_l_e_c_t  argument  provides
    a  list  of  _l_a_n_g_u_a_g_e  _o_p_t_i_o_n_s.    Each  atom in  the  list  _D_i_a_l_e_c_t
    is  mapped  to  a  use_module/1 goal  as  given  below.    See  also
    section ????.   The third argument is supported for compatibility with
    the http://prolog-commons.org/Prolog Commons project.

    ____________________________________________________________________|                                                                    |
    ||:-_use_module(library(dialect/LangOption))._______________________ ||


66..33 IImmppoorrttiinngg PPrreeddiiccaatteess iinnttoo aa MMoodduullee

Predicates  can be  added to  a module  by _i_m_p_o_r_t_i_n_g  them from  another
module.   Importing adds predicates  to the namespace of  a module.   An
imported predicate can be  called exactly the same as a  locally defined
predicate, although  its implementation  remains part of  the module  in
which it has been defined.

Importing  the predicates  from  another module  is achieved  using  the
directives use_module/1 or use_module/2.  Note that both directives take
_f_i_l_e_n_a_m_e_(_s_) as arguments.  That is, modules are  imported based on their
filename rather than their module name.


uussee__mmoodduullee((_+_F_i_l_e_s))
    Load  the file(s)  specified with  _F_i_l_e_s just  like ensure_loaded/1.
    The  files  must all  be  module files.    All  exported  predicates
    from  the  loaded files  are  imported into  the module  from  which
    this  predicate  is  called.     This  predicate  is  equivalent  to
    ensure_loaded/1,  except that it  raises an error  if _F_i_l_e_s are  not
    module files.

    The  imported predicates  act  as _w_e_a_k  _s_y_m_b_o_l_s in  the module  into
    which  they are imported.   This implies that a local definition  of
    a  predicate overrides (clobbers) the  imported definition.  If  the
    flag  warn_override_implicit_importis true  (default), a warning  is
    printed.  Below  is an example of a module that uses library(lists),
    but redefines flatten/2, giving it a totally different meaning:

    ____________________________________________________________________|                                                                    |
    | :- module(shapes, []).                                             |

    | :- use_module(library(lists)).                                     |
    |                                                                    |
    | flatten(cube, square).                                             |
    ||flatten(ball,_circle).____________________________________________ ||

    Loading the above file prints the following message:

    ____________________________________________________________________|                                                                    |
    | Warning: /home/janw/Bugs/Import/t.pl:5:                            |
    |         Local definition of shapes:flatten/2                       |

    ||________overrides_weak_import_from_lists__________________________ ||

    This  warning  can be  avoided  by (1)  using  use_module/2 to  only
    import the predicates  from the lists library that are actually used
    in  the `shapes'  module, (2)  using the except([flatten/2])  option
    of  use_module/2, (3)  use :- abolish(flatten/2).  before the  local
    definition  or (4)  setting warn_override_implicit_import to  false.
    Globally  disabling this warning  is only recommended if  overriding
    imported  predicates is common as a result of design choices  or the
    program  is ported  from a system  that silently overrides  imported
    predicates.

    Note  that  it  is  always  an error  to  import  two  modules  with
    use_module/1 that  export the same predicate.   Such conflicts  must
    be resolved with use_module/2 as described above.


uussee__mmoodduullee((_+_F_i_l_e_, _+_I_m_p_o_r_t_L_i_s_t))
    Load  _F_i_l_e, which must be a  module file, and import the  predicates
    as  specified by  _I_m_p_o_r_t_L_i_s_t.   _I_m_p_o_r_t_L_i_s_t  is a  list of  predicate
    indicators   specifying  the  predicates   that  will  be   imported
    from  the  loaded  module.    _I_m_p_o_r_t_L_i_s_t  also allows  for  renaming
    or  import-everything-except.     See  also  the  import  option  of
    load_files/2.    The first  example below  loads  member/2 from  the
    lists  library and  append/2 under  the name  list_concat, which  is
    how  this predicate is  named in YAP.  The second example loads  all
    exports  from  library  option except  for  meta_options/3.    These
    renaming  facilities are  generally  used to  deal with  portability
    issues  with as few  changes as possible  to the actual  code.   See
    also section ???? and section ????.

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(lists), [ member/2,                          |
    |                                 append/2 as list_concat            |
    |                               ]).                                  |

    ||:-_use_module(library(option),_except([meta_options/3]))._________ ||

In most cases  a module is imported  because some of its predicates  are
being used.  However, sometimes a module is  imported for other reasons,
e.g., for its  declarations.  In such  cases it is best practice to  use
use_module/2 with  empty ImportList.    This  distinguishes an  imported
module that  is used,  although not  for its predicates,  from a  module
that is needlessly imported.

The module/2,  use_module/1 and  use_module/2 directives are  sufficient
to  partition a  simple Prolog  program into  modules.   The  SWI-Prolog
graphical  cross-referencing tool  gxref/0 can  be used  to analyse  the
dependencies between  non-module files  and propose module  declarations
for each file.


66..44 DDeeffiinniinngg aa mmeettaa--pprreeddiiccaattee

A   meta-predicate  is   a  predicate   that   calls  other   predicates
dynamically,  modifies  a  predicate,  or reasons  about  properties  of
a  predicate.     Such predicates  use  either  a  compound  term  or  a
_p_r_e_d_i_c_a_t_e  _i_n_d_i_c_a_t_o_r  to describe  the  predicate  they  address,  e.g.,
assert(name(jan))  or  abolish(name/1).     With  modules,  this  simple
schema  no longer  works as  each module  defines its  own mapping  from
name+arity to  predicate.   This  is resolved by  wrapping the  original
description in a term <_m_o_d_u_l_e>:<_t_e_r_m>,  e.g., assert(person:name(jan)) or
abolish(person:name/1).

Of course,  when calling  assert/1 from  inside a module,  we expect  to
assert to  a predicate  local to this  module.   In other  words, we  do
not wish  to provide  this :/2 wrapper  by hand.    The meta_predicate/1
directive tells the compiler that certain arguments are  terms that will
be used to look  up a predicate and thus need to be  wrapped (qualified)
with <_m_o_d_u_l_e>:<_t_e_r_m>, unless they are already wrapped.

In  the  example  below,  we  use this  to  define  maplist/3  inside  a
module.   The argument `2' in the  meta_predicate declaration means  that
the  argument is  module-sensitive and  refers to  a  predicate with  an
arity that is  two more than the term that  is passed in.   The compiler
only distinguishes the values 0..9 and :,  which denote module-sensitive
arguments,  from +,  -  and ?,  which denote  _m_o_d_e_s.    The values  0..9
are used  by the _c_r_o_s_s_-_r_e_f_e_r_e_n_c_e_r  and syntax highlighting.   Note  that
the  helper predicate  maplist_/3 does  not  need to  be declared  as  a
meta-predicate because the  maplist/3 wrapper already ensures that  _G_o_a_l
is qualified as <_m_o_d_u_l_e>:_G_o_a_l.   See the description of  meta_predicate/1
for details.

________________________________________________________________________|                                                                        |
|:- module(maplist, [maplist/3]).                                        |
|:- meta_predicate maplist(2, ?, ?).                                     |
|                                                                        |

|%%      maplist(:Goal, +List1, ?List2)                                  |
|%                                                                       |
|%       True if Goal can successfully be applied to all                 |
|%       successive pairs of elements from List1 and List2.              |
|                                                                        |
|maplist(Goal, L1, L2) :-                                                |
|        maplist_(L1, L2, Goal).                                         |
|                                                                        |

|maplist_([], [], _).                                                    |
|maplist_([H0|T0], [H|T], Goal) :-                                       |
|        call(Goal, H0, H),                                              |
||_______maplist_(T0,_T,_Goal)._________________________________________ ||


mmeettaa__pprreeddiiccaattee _+_H_e_a_d_, _._._.
    Define  the predicates referenced  by the comma-separated list  _H_e_a_d
    as  _m_e_t_a_-_p_r_e_d_i_c_a_t_e_s.  Each argument of each head is a  _m_e_t_a _a_r_g_u_m_e_n_t
    _s_p_e_c_i_f_i_e_r.  Defined  specifiers are given below.  Only 0..9, : and ^
    are interpreted; the mode declarations +, -  and ? are ignored.

    00....99
         The argument is  a term that is  used to reference a  predicate
         with N  more  arguments than  the given  argument  term.   For
         example:  call(0) or maplist(1, +).

    :
         The argument is  module-sensitive, but does not directly  refer
         to a predicate.  For example:  consult(:).

    -
         The argument is not module-sensitive and unbound on entry.

    ?
         The argument is not  module-sensitive and the mode is  unspeci-
         fied.

    *
         The argument is not  module-sensitive and the mode is  unspeci-
         fied.  The specification * is equivalent to ?.   It is accepted
         for compatibility reasons.   The predicate predicate_property/2
         reports arguments declared using * with ?.

    +
         The argument is  not module-sensitive and bound (i.e.,  nonvar)
         on entry.

    ^
         This extension is used to denote the  possibly ^-annotated goal
         of  setof/3, bagof/3,  aggregate/3  and  aggregate/4.    It  is
         processed similar to `0', but leaving the ^/2 intact.

    //
         The argument is a DCG body.  See phrase/3.

    Each  argument that is module-sensitive (i.e., marked 0..9, :  or ^)
    is  qualified with the  context module  of the caller  if it is  not
    already qualified.   The implementation ensures that the argument is
    passed  as <_m_o_d_u_l_e>:<_t_e_r_m>,  where <_m_o_d_u_l_e>  is an  atom denoting  the
    name  of a  module and  <_t_e_r_m> itself  is not a  :/2 term  where the
    first  argument is an  atom.   Below is a  simple declaration and  a
    number of queries.

    ____________________________________________________________________|                                                                    |

    | :- meta_predicate                                                  |
    |         meta(0, +).                                                |
    |                                                                    |
    | meta(Module:Term, _Arg) :-                                         |
    ||________format('Module=~w,_Term_=_~q~n',_[Module,_Term])._________ ||

    ____________________________________________________________________|                                                                    |
    | ?- meta(test, x).                                                  |
    | Module=user, Term = test                                           |

    | ?- meta(m1:test, x).                                               |
    | Module=m1, Term = test                                             |
    | ?- m2:meta(test, x).                                               |
    | Module=m2, Term = test                                             |
    | ?- m1:meta(m2:test, x).                                            |
    | Module=m2, Term = test                                             |
    | ?- meta(m1:m2:test, x).                                            |

    | Module=m2, Term = test                                             |
    | ?- meta(m1:42:test, x).                                            |
    ||Module=42,_Term_=_test____________________________________________ ||

    The   meta_predicate/1  declaration   is   the  portable   mechanism
    for  defining   meta-predicates  and  replaces  the  old  SWI-Prolog
    specific   mechanism   provided   by   the   deprecated   predicates
    module_transparent/1, context_module/1 and strip_module/3.  See also
    section ????.


66..55 OOvveerrrruulliinngg MMoodduullee BBoouunnddaarriieess

The module system described so far is sufficient  to distribute programs
over multiple  modules.   There are,  however, cases  in which we  would
like to be able to overrule this schema and  explicitly call a predicate
in  some module  or assert  explicitly into  some module.    Calling  in
a  particular  module  is useful  for  debugging  from  the  user's  top
level  or to  access  multiple  implementations of  the  same  interface
that reside  in multiple  modules.   Accessing the  same interface  from
multiple modules cannot be achieved using importing  because importing a
predicate with  the same name  and arity from two  modules results in  a
name conflict.   Asserting in a different  module can be used to  create
models dynamically in a new module.  See section ????.

Direct addressing  of modules is  achieved using a  :/2 explicitly in  a
program and  relies on the module  qualification mechanism described  in
section ????.  Here are a few examples:

________________________________________________________________________|                                                                        |
|?- assert(world:done).   % asserts done/0 into module world             |

|?- world:asserta(done).  % the same                                     |
|?-|world:done.___________%_calls_done/0_in_module_world________________ |  |

Note  that the  second  example  is the  same  due  to the  Prolog  flag
colon_sets_calling_context.   The  system predicate  asserta/1 is  called
in the  module world,  which is possible  because system predicates  are
_v_i_s_i_b_l_e  in all  modules.   At  the same  time, the  _c_a_l_l_i_n_g _c_o_n_t_e_x_t  is
set to  world.   Because meta arguments are  qualified with the  calling
context, the resulting call is the same as the first example.


66..55..11 EExxpplliicciitt mmaanniippuullaattiioonn ooff tthhee ccaalllliinngg ccoonntteexxtt

Quintus'  derived  module   systems  have  no  means  to  separate   the
lookup module  (for finding  predicates) from the  calling context  (for
qualifying meta  arguments).  Some  other Prolog implementations  (e.g.,
ECLiPSe  and IF/Prolog)  distinguish  these operations,  using  @/2  for
setting the calling context of a goal.  This  is provided by SWI-Prolog,
currently mainly to support compatibility layers.


@@((_:_G_o_a_l_, _+_M_o_d_u_l_e))
    Execute  _G_o_a_l,  setting the  calling  context to  _M_o_d_u_l_e.    Setting
    the   calling  context  affects  meta-predicates,  for   which  meta
    arguments  are  qualified  with _M_o_d_u_l_e  and  transparent  predicates
    (see  module_transparent/1).    It  has  no implications  for  other
    predicates.

    For   example,   the  code  asserta(done)@world   is  the  same   as
    asserta(world:done).   Unlike  in world:asserta(done), asserta/1  is
    resolved  in the current module rather than the module world.   This
    makes  no difference for system predicates, but usually does  make a
    difference for user predicates.

    Not that SWI-Prolog does  not define @ as an operator.  Some systems
    define this construct using op(900, xfx, @).


66..66 IInntteerraaccttiinngg wwiitthh mmoodduulleess ffrroomm tthhee ttoopp lleevveell

Debugging  often requires  interaction with  predicates  that reside  in
modules:   running them,  setting spy  points on them,  etc.   This  can
be achieved using  the <_m_o_d_u_l_e>:<_t_e_r_m> construct explicitly  as described
above.     In  SWI-Prolog,  you  may   also  wish  to  omit  the  module
qualification.   Setting a spy point  (spy/1) on a plain predicate  sets
a spy  point on any  predicate with that  name in any  module.   Editing
(edit/1)  or calling  an  unqualified  predicate invokes  the  DWIM  (Do
What I Mean)  mechanism, which generally suggests the  correct qualified
query.

Mainly for compatibility, we provide module/1 to switch  the module with
which the interactive top level interacts:


mmoodduullee((_+_M_o_d_u_l_e))
    The  call module(_M_o_d_u_l_e) may be  used to switch the default  working
    module  for the interactive top level  (see prolog/0).  This may  be
    used  when debugging a module.  The example below lists  the clauses
    of file_of_label/2 in the module tex.

    ____________________________________________________________________|                                                                    |
    | 1 ?- module(tex).                                                  |
    | true.                                                              |
    | tex: 2 ?- listing(file_of_label/2).                                |

    ||..._______________________________________________________________ ||


66..77 CCoommppoossiinngg mmoodduulleess ffrroomm ootthheerr mmoodduulleess

The  predicates in  this  section are  intended  to create  new  modules
from  the content  of other  modules.   Below  is an  example to  define
a  _c_o_m_p_o_s_i_t_e module.    The  example exports  all public  predicates  of
module_1, module_2 and  module_3, pred/1  from module_4, all  predicates
from module_5 except do_not_use/1 and all predicates from module_6 while
renaming pred/1 into mypred/1.

________________________________________________________________________|                                                                        |
|:- module(my_composite, []).                                            |

|:- reexport([ module_1,                                                 |
|              module_2,                                                 |
|              module_3                                                  |
|            ]).                                                         |
|:- reexport(module_4, [ pred/1 ]).                                      |
|:- reexport(module_5, except([do_not_use/1])).                          |
|:-|reexport(module_6,_except([pred/1_as_mypred]))._____________________ |  |


rreeeexxppoorrtt((_+_F_i_l_e_s))
    Load  and  import  predicates  as  use_module/1  and  re-export  all
    imported  predicates.   The reexport  declarations must  immediately
    follow the module declaration.


rreeeexxppoorrtt((_+_F_i_l_e_, _+_I_m_p_o_r_t))
    Import  from   _F_i_l_e  as  use_module/2 and   re-export  the  imported
    predicates.   The reexport declarations must immediately  follow the
    module declaration.


66..88 OOppeerraattoorrss aanndd mmoodduulleess

Operators  (section  ????)  are  local  to  modules,   where  the  initial
table  behaves  as   if  it  is  copied   from  the  module  user   (see
section  ????).   A  specific operator  can be  disabled  inside a  module
using :- op(0, Type, Name).   Inheritance from  the public table can  be
restored using :- op(-1, Type, Name).

In addition to  using the op/3 directive,  operators can be declared  in
the  module/2 directive  as shown  below.    Such operator  declarations
are  visible inside  the  module,  and  importing such  a  module  makes
the operators  visible in  the target  module.   Exporting operators  is
typically used by modules that implement sub-languages such  as chr (see
chapter ????).  The example below is copied from the library clpfd.

________________________________________________________________________|                                                                        |
|:- module(clpfd,                                                        |

|          [ op(760, yfx, #<==>),                                        |
|            op(750, xfy, #==>),                                         |
|            op(750, yfx, #<==),                                         |
|            op(740, yfx, #\/),                                          |
|            ...                                                         |
|            (#<==>)/2,                                                  |
|            (#==>)/2,                                                   |
|            (#<==)/2,                                                   |

|            (#\/)/2,                                                    |
|            ...                                                         |
||_________]).__________________________________________________________ ||


66..99 DDyynnaammiicc iimmppoorrttiinngg uussiinngg iimmppoorrtt mmoodduulleess

Until now  we discussed the  public module interface  that is, at  least
to some  extent, portable between  Prolog implementations with a  module
system that  is derived  from Quintus  Prolog.   The  remainder of  this
chapter describes the underlying mechanisms that can be  used to emulate
other module systems or implement other code-reuse mechanisms.

In  addition to  built-in predicates,  imported  predicates and  locally
defined predicates,  SWI-Prolog modules  can also  call predicates  from
its _i_m_p_o_r_t _m_o_d_u_l_e_s.   Each module has a (possibly empty) list  of import
modules.   In the  default setup,  each new module  has a single  import
module, which  is user for  all normal user modules  and system for  all
system  library modules.    Module user  imports from  system where  all
built-in predicates  reside.   These  special modules  are described  in
more detail in section ????.

The list  of import  modules can  be manipulated and  queried using  the
following predicates, as well as using set_module/1.


iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _-_I_m_p_o_r_t))                                 _[_n_o_n_d_e_t_]
    True  if  _M_o_d_u_l_e   inherits  directly  from  _I_m_p_o_r_t.     All  normal
    modules  only import  from user,  which imports  from system.    The
    predicates  add_import_module/3  and delete_import_module/2  can  be
    used to manipulate the import list.  See also default_module/2.


ddeeffaauulltt__mmoodduullee((_+_M_o_d_u_l_e_, _-_D_e_f_a_u_l_t))                                _[_m_u_l_t_i_]
    True  if predicates and operators in _D_e_f_a_u_l_t are visible  in _M_o_d_u_l_e.
    Modules  are returned in the  same search order used for  predicates
    and  operators.   That  is, _D_e_f_a_u_l_t  is first  unified with  _M_o_d_u_l_e,
    followed by the depth-first transitive closure of import_module/2.


aadddd__iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _+_I_m_p_o_r_t_, _+_S_t_a_r_t_O_r_E_n_d))
    If  _I_m_p_o_r_t is not  already an  import module for  _M_o_d_u_l_e, add it  to
    this  list at the start  or end depending on  _S_t_a_r_t_O_r_E_n_d.  See  also
    import_module/2 and delete_import_module/2.


ddeelleettee__iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _+_I_m_p_o_r_t))
    Delete  _I_m_p_o_r_t from the  list of import modules  for _M_o_d_u_l_e.   Fails
    silently if _I_m_p_o_r_t is not in the list.

One usage  scenario of import modules  is to define  a module that is  a
copy of another,  but where one or  more predicates have an  alternative
definition.


66..1100 RReesseerrvveedd MMoodduulleess aanndd uussiinngg tthhee ``uusseerr'' mmoodduullee

As  mentioned above,  SWI-Prolog  contains two  special  modules.    The
first one  is the  module system.    This module  contains all  built-in
predicates.   Module system has  no import module.   The second  special
module is the module user.  This module forms  the initial working space
of the user.   Initially it is empty.  The import module of  module user
is system, making all built-in predicates available.

All  other modules  import from  the module  user.    This implies  they
can use all  predicates imported into user without explicitly  importing
them.   If an application loads all  modules from the user module  using
use_module/1, one achieves a  scoping system similar to the  C-language,
where  every module  can  access  all exported  predicates  without  any
special precautions.


66..1111 AAnn aalltteerrnnaattiivvee iimmppoorrtt//eexxppoorrtt iinntteerrffaaccee

The use_module/1  predicate from section  ???? defines  import and  export
relations based  on the  filename from  which a module  is loaded.    If
modules are created differently, such as by asserting  predicates into a
new module as  described in section ????,  this interface cannot be  used.
The interface  below provides  for import/export from  modules that  are
not created using a module file.


eexxppoorrtt((_+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.))
    Add  predicates to  the public  list of the  context module.    This
    implies  the predicate will be imported into another module  if this
    module is  imported with use_module/[1,2].   Note that predicates are
    normally  exported using the directive module/2.  export/1  is meant
    to handle export from dynamically created modules.


iimmppoorrtt((_+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.))
    Import  predicates   _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r  into  the  current  context
    module.    _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r must specify  the source module  using
    the  <_m_o_d_u_l_e>:<_p_i>construct.    Note  that predicates  are  normally
    imported  using  one  of  the  directives  use_module/[1,2].     The
    import/1 alternative is  meant for handling imports into dynamically
    created modules.  See also export/1 and export_list/2.


66..1122 DDyynnaammiicc MMoodduulleess

So  far, we  discussed modules  that were  created by  loading a  module
file.  These modules have been introduced to  facilitate the development
of large applications.   The modules  are fully defined at load-time  of
the application and normally  will not change during execution.   Having
the  notion  of a  set  of  predicates  as a  self-contained  world  can
be  attractive for  other purposes  as well.    For example,  assume  an
application that  can reason about  multiple worlds.   It is  attractive
to store  the data  of a  particular world in  a module,  so we  extract
information from a world simply by invoking goals in this world.

Dynamic modules  can easily  be created.   Any  built-in predicate  that
tries  to locate  a predicate  in  a specific  module will  create  this
module as a side-effect if it did not yet exist.  For example:

________________________________________________________________________|                                                                        |
|?- assert(world_a:consistent),                                          |

||__set_prolog_flag(world_a:unknown,_fail)._____________________________ ||

These  calls  create  a  module  called  `world_a'  and  make  the  call
`world_a:consistent'  succeed.   Undefined predicates  will not raise  an
exception for this module (see unknown).

Import  and export  from a  dynamically created  world  can be  achieved
using  import/1 and  export/1  or by  specifying  the import  module  as
described in section ????.

________________________________________________________________________|                                                                        |

|?- world_b:export(solve/2).          % exports solve/2 from world_b     |
|?-|world_c:import(world_b:solve/2).__%_and_import_it_to_world_c________ |  |


66..1133 TTrraannssppaarreenntt pprreeddiiccaatteess::  ddeeffiinniittiioonn aanndd ccoonntteexxtt mmoodduullee

_T_h_e  _`_m_o_d_u_l_e_-_t_r_a_n_s_p_a_r_e_n_t_'  _m_e_c_h_a_n_i_s_m  _i_s  _s_t_i_l_l  _u_n_d_e_r_l_y_i_n_g  _t_h_e  _a_c_t_u_a_l
_i_m_p_l_e_m_e_n_t_a_t_i_o_n_.  _D_i_r_e_c_t _u_s_a_g_e _b_y _p_r_o_g_r_a_m_m_e_r_s _i_s _d_e_p_r_e_c_a_t_e_d_.   _P_l_e_a_s_e _u_s_e
meta_predicate/1 _t_o _d_e_a_l _w_i_t_h _m_e_t_a_-_p_r_e_d_i_c_a_t_e_s_.

The qualification of module-sensitive arguments described  in section ????
is  realised  using  _t_r_a_n_s_p_a_r_e_n_t predicates.     It  is  now  deprecated
to  use this  mechanism  directly.    However, studying  the  underlying
mechanism  helps   to  understand  SWI-Prolog's  modules.      In   some
respect, the transparent mechanism is more  powerful than meta-predicate
declarations.

Each  predicate  of  the  program  is  assigned  a  module,  called  its
_d_e_f_i_n_i_t_i_o_n _m_o_d_u_l_e.   The definition module of a predicate is  always the
module in which the predicate was originally defined.   Each active goal
in the Prolog system has a _c_o_n_t_e_x_t _m_o_d_u_l_e assigned to it.

The context  module is used to  find predicates for a  Prolog term.   By
default, the  context module is the  definition module of the  predicate
running the  goal.   For transparent  predicates, however,  this is  the
context module  of the  goal inherited  from the  parent goal.    Below,
we implement  maplist/3 using the  transparent mechanism.   The code  of
maplist/3 and maplist_/3 is the same  as in section ????, but now  we must
declare both the main  predicate and the helper as transparent  to avoid
changing the context module when calling the helper.

________________________________________________________________________|                                                                        |
|:- module(maplist, maplist/3).                                          |

|                                                                        |
|:- module_transparent                                                   |
|        maplist/3,                                                      |
|        maplist_/3.                                                     |
|                                                                        |
|maplist(Goal, L1, L2) :-                                                |
|        maplist_(L1, L2, G).                                            |
|                                                                        |

|maplist_([], [], _).                                                    |
|maplist_([H0|T0], [H|T], Goal) :-                                       |
|        call(Goal, H0, H),                                              |
||_______maplist_(T0,_T,_Goal)._________________________________________ ||

Note  that   _a_n_y  call   that  translates  terms   into  predicates   is
subject  to  the  transparent  mechanism,  not  just  the  terms  passed
to  module-sensitive  arguments.      For  example,  the   module  below
counts  the  number   of  unique  atoms  returned  as  bindings   for  a
variable.     It   works  as  expected.     If  we  use   the  directive
:- module_transparent count_atom_results/3. instead,   atom_result/2  is
called wrongly  in the  module _c_a_l_l_i_n_g  count_atom_results/3.   This  can
be  solved  using  strip_module/3 to  create  a  qualified  goal  and  a
non-transparent helper predicate that is defined in the same module.

________________________________________________________________________|                                                                        |
|:- module(count_atom_results,                                           |
|          [ count_atom_results/3                                        |

|          ]).                                                           |
|:- meta_predicate count_atom_results(-,0,-).                            |
|                                                                        |
|count_atom_results(A, Goal, Count) :-                                   |
|        setof(A, atom_result(A, Goal), As), !,                          |
|        length(As, Count).                                              |
|count_atom_results(_, _, 0).                                            |

|                                                                        |
|atom_result(Var, Goal) :-                                               |
|        call(Goal),                                                     |
||_______atom(Var)._____________________________________________________ ||

The following predicates support the module-transparent interface:


::-- mmoodduullee__ttrraannssppaarreenntt((_+_P_r_e_d_s))
    _P_r_e_d_s   is  a  comma-separated   list  of  name/arity  pairs   (like
    dynamic/1).     Each  goal associated  with  a  transparent-declared
    predicate will inherit the _c_o_n_t_e_x_t _m_o_d_u_l_e from its parent goal.


ccoonntteexxtt__mmoodduullee((_-_M_o_d_u_l_e))
    Unify   _M_o_d_u_l_e  with  the  context  module  of  the   current  goal.
    context_module/1 itself is, of course, transparent.


ssttrriipp__mmoodduullee((_+_T_e_r_m_, _-_M_o_d_u_l_e_, _-_P_l_a_i_n))
    Used in  module-transparent predicates or meta-predicates to extract
    the   referenced  module   and  plain   term.      If   _T_e_r_m  is   a
    module-qualified  term, i.e. of the format _M_o_d_u_l_e:_P_l_a_i_n,  _M_o_d_u_l_e and
    _P_l_a_i_n  are unified to these values.  Otherwise, _P_l_a_i_n is  unified to
    _T_e_r_m and _M_o_d_u_l_e to the context module.


66..1144 MMoodduullee pprrooppeerrttiieess

The following  predicates can  be used  to query the  module system  for
reflexive programming:


ccuurrrreenntt__mmoodduullee((_?_M_o_d_u_l_e))                                         _[_n_o_n_d_e_t_]
    True  if  _M_o_d_u_l_e is  a currently  defined module.    This  predicate
    enumerates  all  modules,  whether loaded  from  a file  or  created
    dynamically.   Note that modules cannot be destroyed in  the current
    version of SWI-Prolog.


mmoodduullee__pprrooppeerrttyy((_?_M_o_d_u_l_e_, _?_P_r_o_p_e_r_t_y))
    True if _P_r_o_p_e_r_t_y is a property of _M_o_d_u_l_e.  Defined properties are:

    ccllaassss((_-_C_l_a_s_s))
         True when _C_l_a_s_s  is the class of  the module.  Defined  classes
         are

         uusseerr
             Default for user-defined modules.

         ssyysstteemm
             Module system and modules from <_h_o_m_e>/boot.

         lliibbrraarryy
             Other modules from the system directories.

         tteemmppoorraarryy
             Module is temporary.

         tteesstt
             Modules that create tests.

         ddeevveellooppmmeenntt
             Modules that only support the development environment.

    ffiillee((_?_F_i_l_e))
         True if _M_o_d_u_l_e was loaded from _F_i_l_e.

    lliinnee__ccoouunntt((_-_L_i_n_e))
         True if _M_o_d_u_l_e was loaded from the N-th line of file.

    eexxppoorrttss((_-_L_i_s_t_O_f_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_s))
         True  if  _M_o_d_u_l_e exports  the  given  predicates.     Predicate
         indicators  are   in  canonical   form  (i.e.,   always   using
         name/arity  and  never the  DCG  form  name//arity).     Future
         versions  may  also  use  the  DCG  form   and  include  public
         operators.  See also predicate_property/2.

    eexxppoorrtteedd__ooppeerraattoorrss((_-_L_i_s_t_O_f_O_p_e_r_a_t_o_r_s))
         True if  _M_o_d_u_l_e exports  the given  operators.   Each  exported
         operator is represented as a term op(_P_r_i_,_A_s_s_o_c_,_N_a_m_e).

    pprrooggrraamm__ssiizzee((_-_B_y_t_e_s))
         Memory  (in bytes)  used for  storing  the predicates  of  this
         module.     This  figure  includes  the  predicate  header  and
         clauses.   Future versions  might give  a more precise  number,
         including e.g., the clause index tables.

    pprrooggrraamm__ssppaaccee((_-_B_y_t_e_s))
         If  present,  this  number   limits  the  program_size.      See
         set_module/1.

    llaasstt__mmooddiiffiieedd__ggeenneerraattiioonn((_-_G_e_n_e_r_a_t_i_o_n))
         Integer expression the last database generation where  a clause
         was added or  removed from a  predicate that is implemented  in
         this module.  See also predicate_property/2.


sseett__mmoodduullee((_:_P_r_o_p_e_r_t_y))
    Modify  properties  of  the  module.     Currently,   the  following
    properties may be modified:

    bbaassee((_+_B_a_s_e))
         Set the default import module of the current  module to _M_o_d_u_l_e.
         Typically, _M_o_d_u_l_e is one of user or system.  See section ????.

    ccllaassss((_+_C_l_a_s_s))
         Set the class of the module.  See module_property/2.

    pprrooggrraamm__ssppaaccee((_+_B_y_t_e_s))
         Maximum amount of memory  used to store the predicates  defined
         inside  the  module.     Raises  a  permission   error  if  the
         current  usage is  above  the requested  limit.    Setting  the
         limit  to  0  (zero)  removes  the  limit.      An  attempt  to
         assert clauses  that causes  the  limit to  be exceeded  causes
         a resource_error(_p_r_o_g_r_a_m___s_p_a_c_e)  exception.   See assertz/1  and
         module_property/2.


66..1155 CCoommppaattiibbiilliittyy ooff tthhee MMoodduullee SSyysstteemm

The  SWI-Prolog  module  system is  largely  derived  from  the  Quintus
Prolog module system,  which is also adopted  by SICStus, Ciao and  YAP.
Originally,  the mechanism  for defining  meta-predicates in  SWI-Prolog
was  based on  the  module_transparent/1 directive  and  strip_module/3.
Since  5.7.4   it  supports   the  de-facto   standard  meta_predicate/1
directive  for  implementing  meta-predicates,   providing  much  better
compatibility.

The   support  for   the   meta_predicate/1  mechanism,    however,   is
considerably  different.       On  most   systems,  the   _c_a_l_l_e_r  of   a
meta-predicate  is   compiled  differently   to  provide  the   required
<_m_o_d_u_l_e>:<_t_e_r_m> qualification.   This  implies that  the meta-declaration
must  be available  to the  compiler when  compiling code  that calls  a
meta-predicate.  In  practice, this implies that other systems  pose the
following restrictions on meta-predicates:

  o Modules  that provide  meta-predicates for a  module to be  compiled
    must be loaded explicitly by that module.

  o The  meta-predicate directives  of exported  predicates must  follow
    the module/2 directive immediately.

  o After  changing  a  meta-declaration,  all  modules  that  _c_a_l_l  the
    modified predicates need to be recompiled.

In  SWI-Prolog,   meta-predicates  are   also  _m_o_d_u_l_e_-_t_r_a_n_s_p_a_r_e_n_t,   and
qualifying  the module-sensitive  arguments  is  done inside  the  meta-
predicate.    As a  result, the  caller need  not  be aware  that it  is
calling a  meta-predicate and none  of the  above restrictions hold  for
SWI-Prolog.  However, code that aims at portability  must obey the above
rules.

Other differences are listed below.

  o If  a module does not define a predicate, it is searched for  in the
    _i_m_p_o_r_t  _m_o_d_u_l_e_s.  By default, the import module of  any user-defined
    module  is the user module.   In turn, the user module  imports from
    the  module  system that  provides  all built-in  predicates.    The
    auto-import  hierarchy can be changed  using add_import_module/3 and
    delete_import_module/2.

    This  mechanism  can be  used to  realise  a simple  object-oriented
    system or a hierarchical module system.

  o Operator  declarations are local  to a module  and may be  exported.
    In  Quintus and  SICStus all  operators are global.    YAP and  Ciao
    also  use  local operators.    SWI-Prolog  provides global  operator
    declarations  from  within a  module  by explicitly  qualifying  the
    operator  name with the user module.  I.e., operators  are inherited
    from the _i_m_p_o_r_t _m_o_d_u_l_e_s (see above).

    ____________________________________________________________________|                                                                    |
    ||:-_op(precedence,_type,_user:(operatorname))._____________________ ||


CChhaapptteerr 77..  TTAABBLLEEDD EEXXEECCUUTTIIOONN ((SSLLGG RREESSOOLLUUTTIIOONN))

This chapter  describes SWI-Prolog's  support for  _T_a_b_l_e_d _e_x_e_c_u_t_i_o_n  for
one or more  Prolog predicates, also called  _S_L_G _r_e_s_o_l_u_t_i_o_n.  Tabling  a
predicate provides two properties:

 1. Re-evaluation  of a  tabled predicate  is avoided  by _m_e_m_o_i_z_i_n_g  the
    answers.     This  can  realise  huge  performance  enhancements  as
    illustrated  in section ????.  It also comes with two downsides:   the
    memoized  answers are  not automatically updated  or invalidated  if
    the  world (set of predicates  on which the answers depend)  changes
    and the answer tables must be stored (in memory).

 2. _L_e_f_t  _r_e_c_u_r_s_i_o_n, a goal calling a _v_a_r_i_a_n_t of itself  recursively and
    thus  _l_o_o_p_i_n_g under the normal  Prolog SLD resolution is avoided  by
    suspending  the variant call and  resuming it with answers from  the
    table.  This is illustrated in section ????.

Tabling  is particularly  suited  to simplify  inference over  a  highly
entangled set of  predicates that express axioms  and rules in a  static
(not changing)  world.   When  using SLD resolution  for such  problems,
it is  hard to ensure  termination and  avoid frequent recomputation  of
intermediate results.    A solution  is to use  Datalog style  bottom-up
evaluation, i.e., applying  rules on the axioms and derived  facts until
a  fixed point  is reached.    However,  bottom-up evaluation  typically
derives  many facts  that  are never  used.    Tabling provides  a  _g_o_a_l
_o_r_i_e_n_t_e_d resolution strategy for such problems and is  enabled simply by
adding a table/1 directive to the program.


77..11 EExxaammppllee 11::  uussiinngg ttaabblliinngg ffoorr mmeemmooiizziinngg

As a first  classical example we use tabling for  _m_e_m_o_i_z_i_n_g intermediate
results.   We use  Fibonacci numbers  to illustrate the  approach.   The
Fibonacci number I  is defined as  the sum of the Fibonacci  numbers for
I- 1 and I- 2, while the Fibonacci number of 0 and 1 are both defined to
be 1.  This can be translated naturally into Prolog:

________________________________________________________________________|                                                                        |
|fib(0, 1) :- !.                                                         |

|fib(1, 1) :- !.                                                         |
|fib(N, F) :-                                                            |
|        N > 1,                                                          |
|        N1 is N-1,                                                      |
|        N2 is N-2,                                                      |
|        fib(N1, F1),                                                    |
|        fib(N2, F2),                                                    |
||_______F_is_F1+F2.____________________________________________________ ||

The complexity  of executing  this using  SLD resolution  however is 2N
and thus becomes prohibitively slow rather quickly,  e.g., the execution
time  for N = 30  is already  0.4  seconds.    Using tabling,  fib(_N_,_F)
for each  value of N  is computed  only once and  the algorithm becomes
linear.  Tabling effectively inverts the execution order  for this case:
it suspends  the final addition  (F is F1+F2)  until the two  preceeding
Fibonacci numbers have  been added to the answer  tables.  Thus, we  can
reduce the complexity  from the show-stopping 2N  to linear by  adding a
tabling directive and  otherwise not changing the  algorithm.  The  code
becomes:

________________________________________________________________________|                                                                        |

|:- use_module(library(tabling)).                                        |
|:- table fib/2.                                                         |
|                                                                        |
|fib(0, 1) :- !.                                                         |
|fib(1, 1) :- !.                                                         |
|fib(N, F) :-                                                            |
|        N > 1,                                                          |

|        N1 is N-1,                                                      |
|        N2 is N-2,                                                      |
|        fib(N1, F1),                                                    |
|        fib(N2, F2),                                                    |
||_______F_is_F1+F2.____________________________________________________ ||

The price  that we  pay is  that a table  fib(_I_,_F) is  created for  each
I  in 0::N.   The  execution time  for N = 30 is now  1 millisecond  and
computing the Fibonacci number for N =1000 is doable (output edited for
readability).

________________________________________________________________________|                                                                        |
|1 ?- time(fib(1000, X)).                                                |

|% 52,991 inferences, 0.013 CPU in 0.013 seconds                         |
|X = 70330367711422815821835254877183549770181269836358                  |
|    73274260490508715453711819693357974224949456261173                  |
|    34877504492417659910881863632654502236471060120533                  |
|    74121273867339111198139373125598767690091902245245                  |
||___323403501._________________________________________________________ ||

In the  case of  Fibonacci numbers  we can still  rather easily  achieve
linear complexity using  program transformation, where we use  bottom-up
instead of  top-down evaluation, i.e.,  we compute fib(_N_,_F) for  growing
N, where we pass the last  two Fibonacci numbers to the next iteration.
Not having  to create the  tables and not having  to suspend and  resume
goals makes  this implementation about 25  times faster than the  tabled
one.    However, even  in this  simple  case the  transformation is  not
obvious and it  is far more difficult  to recognise the algorithm as  an
implementation of Fibonacci numbers.

________________________________________________________________________|                                                                        |

|fib(0, 1) :- !.                                                         |
|fib(1, 1) :- !.                                                         |
|fib(N, F) :-                                                            |
|        fib(1,1,1,N,F).                                                 |
|                                                                        |
|fib(_F, F1, N, N, F1) :- !.                                             |
|fib(F0, F1, I, N, F) :-                                                 |

|        F2 is F0+F1,                                                    |
|        I2 is I + 1,                                                    |
||_______fib(F1,_F2,_I2,_N,_F)._________________________________________ ||


77..22 EExxaammppllee 22::  aavvooiiddiinngg nnoonn--tteerrmmiinnaattiioonn

SLD  resolution  easily  results  in  an  infinite  loop   due  to  _l_e_f_t
_r_e_c_u_r_s_i_o_n,  a  goal that  (indirectly)  calls  a variant  of  itself  or
cycles in  the input data.   Thus, if we  have a series of  connection/2
statements  that  define railway  connections  between  two  cities,  we
cannot use the  most natural logical definition  to express that we  can
travel between two cities:

________________________________________________________________________|                                                                        |
|% :- use_module(library(tabling)).                                      |
|% :- table connection/2.                                                |
|                                                                        |

|connection(X, Y) :-                                                     |
|        connection(X, Z),                                               |
|        connection(Z, Y).                                               |
|connection(X, Y) :-                                                     |
|        connection(Y, X).                                               |
|                                                                        |
|connection('Amsterdam', 'Schiphol').                                    |
|connection('Amsterdam', 'Haarlem').                                     |

|connection('Schiphol', 'Leiden').                                       |
|connection('Haarlem',|'Leiden')._______________________________________ |                     |

After  enabling   tabling  however,  the   above  works  just  fine   as
illustrated  in the  session below.    Where is  the magic  and what  is
the price  we paid?   The magic is,  again, the fact  that new goals  to
the tabled predicate  suspend.  So,  all recursive goals are  suspended.
Eventually, a table  for connection(_'_A_m_s_t_e_r_d_a_m_'_, _X) is created  with the
two  direct connections  from Amsterdam.    Now,  it resumes  the  first
clause  using the  tabled solutions,  continuing  the last  connection/2
subgoal  with connection(_'_S_c_h_i_p_h_o_l_'_,  _X) and  connection(_'_H_a_a_r_l_e_m_'_,  _X).
These two go through the same process, creating  new suspended recursive
calls  and  creating  tables  for  the  connections  from  Schiphol  and
Haarlem.   Eventually,  we end up  with a  set of tables  for each  call
variant that  is involved  in computing  the transitive  closure of  the
network starting in  Amsterdam.  However,  if the Japanese rail  network
would have been in  our data as well, we would not have  produced tables
for that.

________________________________________________________________________|                                                                        |
|1 ?- connection('Amsterdam', X).                                        |
|X = 'Haarlem' ;                                                         |
|X = 'Schiphol' ;                                                        |
|X = 'Amsterdam' ;                                                       |
|X|=_'Leiden'.__________________________________________________________ | |

Again, the fact that  a simple table/1 directive turns the  pure logical
specification into  a fairly efficient algorithm  is a clear  advantage.
Without tabling the program  needs to be _s_t_r_a_t_i_f_i_e_d, introducing  a base
layer  with the  raw connections,  a second  layer  that introduces  the
_c_o_m_m_u_t_a_t_i_v_e  property of  a railway  (if you  can  travel from  A to  B
you  can also  travel from  B  to A  and  a final  layer that  realises
_t_r_a_n_s_i_t_i_v_i_t_y (if you  can travel from A to  B and from B  to C you can
also travel from  A to C).   The third and final layer  must keep track
which cities  you have already  visited to  avoid traveling in  circles.
The transformed program however uses little memory (the  list of already
visited cities  and the still  open choices) and does  not need to  deal
with maintaining consistency between the tables and ground facts.


77..33 MMooddee ddiirreecctteedd ttaabblliinngg

Tabling  as defined  above  has a  serious  limitation.    Although  the
definition  of connection/2  from  section section  ???? can  compute  the
transitive closure  of connected cities,  it cannot  provide you with  a
route to travel.   The reason is  that there are infinitely many  routes
if there  are cycles in  the network  and each new  route found will  be
added to  the answer table and  cause the tabled execution's  completion
algorithm to search for more routes, eventually running out of memory.

The solution to this  problem is called _m_o_d_e _d_i_r_e_c_t_e_d _t_a_b_l_i_n_g  or _a_n_s_w_e_r
_s_u_b_s_u_m_p_t_i_o_n.   In  this execution model  one or  more arguments are  _n_o_t
added to the table.  Instead, we remember a  single _a_g_g_r_e_g_a_t_e_d value for
these arguments.    The example  below is  derived from  section ????  and
returns the connection  as a list of cities.   This argument is  defined
as  a _m_o_d_e_d  argument  using the  lattice(_P_I) mode.    This  causes  the
tabling engine each  time that it finds  an new path to call  shortest/3
and keep the shortest route.

________________________________________________________________________|                                                                        |
|:- use_module(library(tabling)).                                        |

|:- table                                                                |
|    connection(_,_,lattice(shortest/3)).                                |
|                                                                        |
|shortest(P1, P2, P):-                                                   |
|    length(P1, L1),                                                     |
|    length(P2, L2),                                                     |
|    (   L1 < L2                                                         |
|    ->  P = P1                                                          |

|    ;   P = P2                                                          |
|    ).                                                                  |
|                                                                        |
|connection(X, Y, [X,Y]) :-                                              |
|    connection(X, Y).                                                   |
|connection(X, Y, P) :-                                                  |
|    connection(X, Z, P0),                                               |

|    connection(Z, Y),                                                   |
||___append(P0,_[Y],_P).________________________________________________ ||

The  mode   declation  scheme   is  equivalent  to   XSB  with   partial
compatibility support  for YAP and  B-Prolog.   The lattice(_P_I) mode  is
the  most general  mode.   The  YAP all  (B-Prolog @)  mode  is not  yet
supported.  The  list below describes the supported modes  and indicates
the portability.

VVaarr
+

iinnddeexx
    A  variable  (XSB), the  atom index  (YAP) or  a +  (B-Prolog,  YAP)
    declare that the argument is tabled normally.

llaattttiiccee((_P_I))
    _P_I  must be  the predicate indicator  of a  predicate with arity  3.
    On  each answer,  _P_I is called  with three  arguments:  the  current
    aggregated answer and the  new answer are inputs.  The last argument
    must  be unified  with  a term  that represents  the new  aggregated
    answer.    In SWI-Prolog  the arity  (3) may be  omitted.   See  the
    example above.

ppoo((_P_I))
    _P_a_r_t_i_a_l  _O_r_d_e_n_i_n_g.    The new  answer is  added  iff call(_P_I_,  _+_O_l_d_,
    _+_A_n_s_w_e_r)  succeeds.  For example, po('<'/2) accumulates  the largest
    result.   In SWI-Prolog the  arity (2) may be omitted,  resulting in
    po(<).

-
ffiirrsstt
    The  atom -  (B-Prolog, YAP)  and first  (YAP) declare  to keep  the
    first answer for this argument.

llaasstt
    The atom last (YAP) declares to keep the last answer.

mmiinn
    The  atom min (YAP) declares  to keep the smallest answer  according
    to the standard order of terms  (see @</2).  Note that in SWI-Prolog
    the standard order of terms orders numbers by value.

mmaaxx
    The atom max  (YAP) declares to keep the largest answer according to
    the  standard order of terms  (see @>/2).   Note that in  SWI-Prolog
    the standard order of terms orders numbers by value.

ssuumm
    The atom sum (YAP) declares to sum numeric answers.


77..44 TTaabblliinngg pprreeddiiccaattee rreeffeerreennccee


::-- ttaabbllee((_+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_s))
    Prepare  the given  _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_s for  tabling.   The  example
    below   prepares   the  predicate   edge/2  and   the   non-terminal
    statement//1 for tabled execution.

    ____________________________________________________________________|                                                                    |
    ||:-_table_edge/2,_statement//1.____________________________________ ||

    In  addition  to using  _p_r_e_d_i_c_a_t_e  _i_n_d_i_c_a_t_o_r_s,  a predicate  can  be
    declared for _m_o_d_e  _d_i_r_e_c_t_e_d _t_a_b_l_i_n_g using a term where each argument
    declares the intended mode.  For example:

    ____________________________________________________________________|                                                                    |

    ||:-_table_connection(_,_,min)._____________________________________ ||

    _M_o_d_e  _d_i_r_e_c_t_e_d  _t_a_b_l_i_n_g is  discussed  in the  general  introduction
    section of chapter ????.


ccuurrrreenntt__ttaabbllee((_:_V_a_r_i_a_n_t_, _-_T_r_i_e))
    True when _T_r_i_e is the answer table for _V_a_r_i_a_n_t.


aabboolliisshh__aallll__ttaabblleess
    Remove  all tables.  This is  normally used to free up the  space or
    recompute  the result after predicates on which the result  for some
    tabled  predicates depend.   Raises a  permission_error when  tabling
    is in progress.


aabboolliisshh__ttaabbllee__ssuubbggooaallss((_:_S_u_b_g_o_a_l))
    Abolish all tables that unify with _S_u_b_G_o_a_l.


77..55 AAbboouutt tthhee ttaabblliinngg iimmpplleemmeennttaattiioonn

The  SWI-Prolog   implementation  uses   _D_e_l_i_m_i_t_e_d  _c_o_n_t_i_n_u_a_t_i_o_n_s   (see
section ???? to realise suspension of variant calls.   The initial version
was written  by Benoit  Desouter and  described in [??].    We moved  the
main  data structures  required  for  tabling,  the _a_n_s_w_e_r  _t_a_b_l_e_s  (see
section ????)  and the  _w_o_r_k_l_i_s_t to SWI-Prolog's  C core.   _M_o_d_e  _d_i_r_e_c_t_e_d
_t_a_b_l_i_n_g (section ????) is based on a prototype  implementation by Fabrizio
Riguzzi.

The  table/1 directive  causes the  creation of  a  wrapper calling  the
renamed original  predicate.   For example,  the program  in section  ????
is translated  into the  following program.   We  give this  information
to improve  your understanding  of the  current tabling  implementation.
Future versions are likely  to use a more low-level translation  that is
not based on wrappers.

________________________________________________________________________|                                                                        |
|connection(A, B) :-                                                     |

|        start_tabling(user:connection(A, B),                            |
|                      'connection tabled'(A, B)).                       |
|                                                                        |
|'connection tabled'(X, Y) :-                                            |
|        connection(X, Z),                                               |
|        connection(Z, Y).                                               |
|'connection tabled'(X, Y) :-                                            |
|        connection(Y, X).                                               |

|                                                                        |
|'connection tabled'('Amsterdam', 'Schiphol').                           |
|'connection tabled'('Amsterdam', 'Haarlem').                            |
|'connection tabled'('Schiphol', 'Leiden').                              |
|'connection|tabled'('Haarlem',_'Leiden').______________________________ |           |


77..55..00..11 SSttaattuuss ooff ttaabblliinngg

The  current implementation  is merely  a  first prototype.    It  needs
several enhancements before  we can consider it a serious  competitor to
Prolog systems with  mature tabling such as XSB,  YAP and B-Prolog.   In
particular,

  o The performance needs to be improved.

  o Memory usage needs to be reduced.

  o Tables  must be  shared between  threads, both to  reduce space  and
    avoid recomputation.

  o Tables must be invalidated and reclaimed automatically.

  o Notably   XSB   supports  incremental   tabeling  and   well-founded
    semantics under negation.


CChhaapptteerr 88..  CCOONNSSTTRRAAIINNTT LLOOGGIICC PPRROOGGRRAAMMMMIINNGG

This   chapter   describes  the   extensions   primarily   designed   to
support  ccoonnssttrraaiinntt llooggiicc  pprrooggrraammmmiinngg (CLP),  an important  declarative
programming paradigm with countless practical applications.

CLP(X)  stands for  constraint logic  programming  over the  domain X.
Plain  Prolog  can   be  regarded  as  CLP(H),   where  H  stands   for
_H_e_r_b_r_a_n_d _t_e_r_m_s.  Over this domain, =/2 and dif/2  are the most important
constraints  that  express,   respectively,  equality   and  disequality
of terms.  Plain Prolog can thus be regarded as a special case of CLP.

There are dedicated constraint solvers for several important domains:

  o CLP(FD) for iinntteeggeerrss (section ????)

  o CLP(B) for BBoooolleeaann variables (section ????)

  o CLP(Q) for rraattiioonnaall numbers (section ????)

  o CLP(R) for ffllooaattiinngg ppooiinntt numbers (section ????).

In  addition, CHR  (chapter ????)  provides a  general purpose  constraint
handling language to reason over user-defined constraints.

Constraints blend in naturally into Prolog programs,  and behave exactly
like plain Prolog predicates  in those cases that can also  be expressed
without constraints.   However,  there are  two key differences  between
constraints and plain Prolog predicates:

  o Constraints  can  _d_e_l_a_y  checks  until their  truth  can  be  safely
    decided.   This feature can significantly increase the _g_e_n_e_r_a_l_i_t_y of
    your programs, and preserves their relational nature.

  o Constraints  can  take  into  account  everything  you  state  about
    the  entities  you  reason  about,   independent  of  the  order  in
    which  you state  it, both  _b_e_f_o_r_e and  also _d_u_r_i_n_g  any search  for
    concrete  solutions.   Using  available information  to prune  parts
    of  the search  space is  called constraint _p_r_o_p_a_g_a_t_i_o_n,  and it  is
    performed  automatically  by the  available constraint  solvers  for
    their  respective domains.  This feature can  significantly increase
    the _p_e_r_f_o_r_m_a_n_c_e of your programs.

Due to  these two key  advantages over plain Prolog,  CLP has become  an
extremely important declarative programming paradigm in practice.

Among its  most important and typical  instances is CLP(FD),  constraint
logic programming  over _i_n_t_e_g_e_r_s.   For example, using constraints,  you
can  state in  the most  general way  that a  variable _X  is an  integer
greater than  0.   If,  later, _X  is bound  to a  concrete integer,  the
constraint  solver automatically  ensures  this.    If you  in  addition
constrain _X to integers less than 3, the  constraint solver combines the
existing knowledge to  infer that _X is  either 1 or 2  (see below).   To
obtain concrete  values for _X,  you can  ask the solver  to _l_a_b_e_l _X  and
produce 1 and 2 on backtracking.  See section ????.

________________________________________________________________________|                                                                        |
|?- use_module(library(clpfd)).                                          |

|...                                                                     |
|true.                                                                   |
|                                                                        |
|?- X #> 0, X #< 3.                                                      |
|X in 1..2.                                                              |
|                                                                        |
|?- X #> 0, X #< 3, indomain(X).                                         |
|X = 1 ;                                                                 |

|X|=_2._________________________________________________________________ | |

Contrast this with  plain Prolog, which has  no efficient means to  deal
with (integer)  X> 0 and X < 3.   At best it could  translate X >0 to
between(_1_,  _i_n_f_i_n_i_t_e_, _X)  and a similar  primitive for  X <3.    If the
two are  combined it has no  choice but to  generate and test over  this
infinite two-dimensional space.

Using constraints therefore makes your program more  _d_e_c_l_a_r_a_t_i_v_e in that
it frees you from some procedural aspects and limitations of Prolog.

When working with constraints, keep in mind the following:

  o As  with plain Prolog, !/0  also destroys the declarative  semantics
    of  constraints.      A  cut  after  a  goal  that  is  delayed  may
    prematurely  prune the search  space, because  the truth of  delayed
    goals  is not  yet established.   There  are several  ways to  avoid
    cuts  in constraint  logic programs,  retaining both generality  and
    determinism of your programs.  See for example zcompare/3.

  o Term-copying    operations   (assertz/1,    retract/1,    findall/3,
    copy_term/2,  etc.)      generally  also  copy  constraints.     The
    effect  varies from ok, silent  copying of huge constraint  networks
    to  violations of the  internal consistency of constraint  networks.
    As  a  rule  of thumb,  copying  terms  holding attributes  must  be
    deprecated.   If you  need to reason about  a term that is  involved
    in constraints,  use copy_term/3to obtain  the constraints as Prolog
    goals, and use these goals for further processing.

All  of the  mentioned  constraint  solvers are  implemented  using  the
attributed  variables interface  described in  section ????.    These  are
lower-level predicates  that are  mainly intended  for library  authors,
not for typical Prolog programmers.


88..11 AAttttrriibbuutteedd vvaarriiaabblleess

_A_t_t_r_i_b_u_t_e_d  _v_a_r_i_a_b_l_e_s  provide  a technique  for  extending  the  Prolog
unification  algorithm  [??]   by  hooking  the  binding  of   attributed
variables.    There  is no  consensus in  the  Prolog community  on  the
exact definition and interface to attributed variables.   The SWI-Prolog
interface is identical  to the one realised  by Bart Demoen for  hProlog
[??].   This  interface is  simple and  available on  all Prolog  systems
that  can run  the Leuven  CHR system  (see chapter  ????  and the  Leuven
https://dtai.cs.kuleuven.be/CHR/CHR page).

Binding  an attributed  variable  schedules a  goal  to be  executed  at
the  first possible  opportunity.   In  the  current implementation  the
hooks are  executed immediately  after a successful  unification of  the
clause-head or  successful completion of  a foreign language  (built-in)
predicate.   Each  attribute is  associated to  a module,  and the  hook
(attr_unify_hook/2)  is  executed in  this  module.   The  example  below
realises a very simple and incomplete finite domain reasoner:

________________________________________________________________________|                                                                        |
|:- module(domain,                                                       |

|          [ domain/2                    % Var, ?Domain                  |
|          ]).                                                           |
|:- use_module(library(ordsets)).                                        |
|                                                                        |
|domain(X, Dom) :-                                                       |
|        var(Dom), !,                                                    |
|        get_attr(X, domain, Dom).                                       |
|domain(X, List) :-                                                      |

|        list_to_ord_set(List, Domain),                                  |
|        put_attr(Y, domain, Domain),                                    |
|        X = Y.                                                          |
|                                                                        |
|%       An attributed variable with attribute value Domain has been     |
|%       assigned the value Y                                            |
|                                                                        |

|attr_unify_hook(Domain, Y) :-                                           |
|        (   get_attr(Y, domain, Dom2)                                   |
|        ->  ord_intersection(Domain, Dom2, NewDomain),                  |
|            (   NewDomain == []                                         |
|            ->  fail                                                    |
|            ;   NewDomain = [Value]                                     |
|            ->  Y = Value                                               |
|            ;   put_attr(Y, domain, NewDomain)                          |

|            )                                                           |
|        ;   var(Y)                                                      |
|        ->  put_attr( Y, domain, Domain )                               |
|        ;   ord_memberchk(Y, Domain)                                    |
|        ).                                                              |
|                                                                        |
|%       Translate attributes from this module to residual goals         |

|                                                                        |
|attribute_goals(X) -->                                                  |
|        { get_attr(X, domain, List) },                                  |
||_______[domain(X,_List)]._____________________________________________ ||

Before explaining the code we give some example queries:

     ?- domain(X, [a,b]), X = c                fail
     ?- domain(X, [a,b]), domain(X, [a,c]).    X = a
     ?- domain(X, [a,b,c]), domain(X, [a,c]).  domain(X, [a, c])

The  predicate  domain/2  fetches  (first  clause)  or  assigns  (second
clause) the  variable a  _d_o_m_a_i_n, a  set of  values the  variable can  be
unified  with.   In  the second  clause, domain/2  first associates  the
domain with a fresh variable (Y) and then unifies X  to this variable to
deal with the  possibility that X already has  a domain.  The  predicate
attr_unify_hook/2 (see below) is a hook  called after a variable with  a
domain is assigned  a value.  In  the simple case where the variable  is
bound to a concrete value, we simply check whether this  value is in the
domain.   Otherwise we take the  intersection of the domains and  either
fail if the intersection  is empty (first example), assign the  value if
there is only one value in the intersection (second  example), or assign
the intersection  as the  new domain  of the  variable (third  example).
The  nonterminal  attribute_goals//1  is  used  to  translate  remaining
attributes to  user-readable goals  that, when  called, reinstate  these
attributes or attributes that correspond to equivalent constraints.

Implementing constraint  solvers (chapter  ????) is the  most common,  but
not  the only  use case  for  attributed variables:   If  you  implement
algorithms that require efficient destructive modifications,  then using
attributed  variables is  often  a  more convenient  and  somewhat  more
declarative  alternative  for  setarg/3  and  related  predicates  whose
sharing semantics are harder  to understand.  In particular,  attributed
variables  make it  easy to  express graph  networks and  graph-oriented
algorithms, since each variable can store pointers  to further variables
in its  attributes.   In  such cases,  the use  of attributed  variables
should be  confined within a module  that exposes its functionality  via
more declarative interface predicates.


88..11..11 AAttttrriibbuuttee mmaanniippuullaattiioonn pprreeddiiccaatteess


aattttvvaarr((_@_T_e_r_m))
    Succeeds  if _T_e_r_m is an attributed  variable.  Note that var/1  also
    succeeds on attributed  variables.  Attributed variables are created
    with put_attr/3.


ppuutt__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e_, _+_V_a_l_u_e))
    If  _V_a_r is  a variable  or attributed  variable, set  the value  for
    the  attribute named _M_o_d_u_l_e  to _V_a_l_u_e.   If  an attribute with  this
    name  is already  associated with  _V_a_r, the old  value is  replaced.
    Backtracking  will  restore the  old value  (i.e.,  an attribute  is
    a  mutable  term; see  also setarg/3).    This  predicate raises  an
    uninstantiation error if _V_a_r  is not a variable, and a type error if
    _M_o_d_u_l_e is not an atom.


ggeett__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e_, _-_V_a_l_u_e))
    Request  the  current _v_a_l_u_e  for the  attribute named  _M_o_d_u_l_e.    If
    _V_a_r  is not  an attributed variable  or the  named attribute is  not
    associated  to _V_a_r this predicate fails silently.  If _M_o_d_u_l_e  is not
    an atom, a type error is raised.


ddeell__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e))
    Delete  the named attribute.    If _V_a_r loses  its last attribute  it
    is  transformed back into a traditional Prolog variable.   If _M_o_d_u_l_e
    is  not an atom, a  type error is raised.   In all other cases  this
    predicate succeeds regardless  of whether or not the named attribute
    is present.


88..11..22 AAttttrriibbuutteedd vvaarriiaabbllee hhooookkss

Attribute  names  are linked  to  modules.    This  means  that  certain
operations  on attributed  variables cause  _h_o_o_k_s to  be  called in  the
module whose name matches the attribute name.


aattttrr__uunniiffyy__hhooookk((_+_A_t_t_V_a_l_u_e_, _+_V_a_r_V_a_l_u_e))
    A  hook that must  be defined in the  module to which an  attributed
    variable  refers.   It is called  _a_f_t_e_r the attributed variable  has
    been  unified  with  a non-var  term,  possibly  another  attributed
    variable.    _A_t_t_V_a_l_u_e is the  attribute that  was associated to  the
    variable  in  this module  and  _V_a_r_V_a_l_u_e is  the  new value  of  the
    variable.    If this  predicate fails,  the unification fails.    If
    _V_a_r_V_a_l_u_e is another  attributed variable the hook often combines the
    two  attributes and associates the combined attribute  with _V_a_r_V_a_l_u_e
    using put_attr/3.

         TToo bbee ddoonnee The  way  in  which this  hook  currently works
             makes   the   implementation   of  important   classes
             of   constraint   solvers  impossible   or   at  least
             extremely  impractical.     For  increased  generality
             and  convenience,   simultaneous  unifications  as  in
             [X,Y]=[0,1]  should be  processed sequentially  by the
             Prolog   engine,  or   a  more   general  hook  should
             be  provided  in  the  future.     See  [??]  for  more
             information.


aattttrriibbuuttee__ggooaallss((_+_V_a_r)) //
    This  nonterminal  is  the main  mechanism  in which  residual  con-
    straints  are obtained.    It  is called  in every  module where  it
    is  defined,  and  _V_a_r has  an  attribute.    Its argument  is  that
    variable.   In each module, attribute_goals//1 must describe  a list
    of Prolog goals  that are declaratively equivalent to the goals that
    caused  the attributes  of that module  to be  present and in  their
    current  state.    It is  always possible  to do  this (since  these
    attributes  stem from such goals),  and it is the responsibility  of
    constraint library authors  to provide this mapping without exposing
    any  library internals.   Ideally and typically, remaining  relevant
    attributes  are mapped  to  _p_u_r_e and  potentially simplified  Prolog
    goals that satisfy both of the following:

      o  They are declaratively equivalent to the constraints  that were
         originally posted.

      o  They  use only  predicates  that  are themselves  exported  and
         documented in the modules they stem from.

    The  latter property  ensures that users  can reason about  residual
    goals,  and see for themselves whether a constraint  library behaves
    correctly.     It  is  this  property  that  makes  it  possible  to
    thoroughly test  constraint solvers by contrasting obtained residual
    goals with expected answers.

    This  nonterminal is used  by copy_term/3, on  which the Prolog  top
    level relies to  ensure the basic invariant of pure Prolog programs:
    The answer is _d_e_c_l_a_r_a_t_i_v_e_l_y _e_q_u_i_v_a_l_e_n_t to the query.

    Note  that instead  of _d_e_f_a_u_l_t_y  representations, a  Prolog _l_i_s_t  is
    used  to represent residual goals.   This simplifies processing  and
    reasoning  about residual  goals throughout all  programs that  need
    this functionality.


pprroojjeecctt__aattttrriibbuutteess((_+_Q_u_e_r_y_V_a_r_s_, _+_R_e_s_i_d_u_a_l_V_a_r_s))
    A hook that can  be defined in each module to project constraints on
    newly  introduced variables back to the query variables.   _Q_u_e_r_y_V_a_r_s
    is  the list of  variables occurring in  the query and  _R_e_s_i_d_u_a_l_V_a_r_s
    is  a  list of  variables  that have  attributes  attached.    There
    may  be  variables   that  occur  in  both  lists.     If  possible,
    project_attributes/2  should  change  the  attributes  so  that  all
    constraints  are  expressed as  residual goals  that  refer only  to
    _Q_u_e_r_y_V_a_r_s, while other variables are existentially quantified.


aattttrr__ppoorrttrraayy__hhooookk((_+_A_t_t_V_a_l_u_e_, _+_V_a_r))                          _[_d_e_p_r_e_c_a_t_e_d_]
    Called  by  write_term/2  and  friends for  each  attribute  if  the
    option  attributes(_p_o_r_t_r_a_y) is  in  effect.   If  the hook  succeeds
    the  attribute is  considered printed.    Otherwise Module = ...  is
    printed to indicate the  existence of a variable.  This predicate is
    deprecated  because it  cannot work with  pure interface  predicates
    like  copy_term/3.   Use attribute_goals//1instead  to map attributes
    to residual goals.


88..11..33 OOppeerraattiioonnss oonn tteerrmmss wwiitthh aattttrriibbuutteedd vvaarriiaabblleess


ccooppyy__tteerrmm((_+_T_e_r_m_, _-_C_o_p_y_, _-_G_s))
    Create  a  regular  term  _C_o_p_y  as  a  copy  of  _T_e_r_m  (without  any
    attributes), and a  list _G_s of goals that represents the attributes.
    The  goal maplist(call, Gs) recreates the attributes for _C_o_p_y.   The
    nonterminal  attribute_goals//1,  as  defined  in  the  modules  the
    attributes  stem from,  is used  to convert attributes  to lists  of
    goals.

    This  building block  is used  by the  top level  to report  pending
    attributes  in  a   portable  and  understandable  fashion.     This
    predicate  is  the preferred  way to  reason  about and  communicate
    terms with constraints.

    The  form copy_term(Term, Term, Gs)  can be used to reason  about the
    constraints in which Term is involved.


ccooppyy__tteerrmm__nnaatt((_+_T_e_r_m_, _-_C_o_p_y))
    As  copy_term/2.   Attributes, however,  are _n_o_t copied but  replaced
    by fresh variables.


tteerrmm__aattttvvaarrss((_+_T_e_r_m_, _-_A_t_t_V_a_r_s))
    _A_t_t_V_a_r_s  is  a   list  of  all  attributed  variables  in  _T_e_r_m  and
    its   attributes.     That  is,   term_attvars/2  works  recursively
    through  attributes.    This  predicate is  cycle-safe.    The  goal
    term_attvars(_T_e_r_m_,  _[_])  in  an  efficient test  that  _T_e_r_m  has  _n_o
    attributes; scanning the  term is aborted after the first attributed
    variable is found.


88..11..44 SSppeecciiaall ppuurrppoossee pprreeddiiccaatteess ffoorr aattttrriibbuutteess

Normal user code should deal with put_attr/3, get_attr/3 and del_attr/2.
The routines in this  section fetch or set the entire attribute  list of
a variable.  Use of these predicates is anticipated  to be restricted to
printing and other special purpose operations.


ggeett__aattttrrss((_+_V_a_r_, _-_A_t_t_r_i_b_u_t_e_s))
    Get  all  attributes of  _V_a_r.   _A_t_t_r_i_b_u_t_e_s  is a  term  of the  form
    att(_M_o_d_u_l_e_,  _V_a_l_u_e_, _M_o_r_e_A_t_t_r_i_b_u_t_e_s), where _M_o_r_e_A_t_t_r_i_b_u_t_e_s is  [] for
    the last attribute.


ppuutt__aattttrrss((_+_V_a_r_, _-_A_t_t_r_i_b_u_t_e_s))
    Set  all attributes of  _V_a_r.  See  get_attrs/2 for a description  of
    _A_t_t_r_i_b_u_t_e_s.


ddeell__aattttrrss((_+_V_a_r))
    If  _V_a_r is an attributed  variable, delete _a_l_l  its attributes.   In
    all other cases, this predicate succeeds without side-effects.


88..22 CCoorroouuttiinniinngg

Coroutining  allows us  to delay  the execution  of  Prolog goals  until
their truth can be safely decided.

Among  the  most  important  coroutining  predicates  is  dif/2,   which
expresses _d_i_s_e_q_u_a_l_i_t_y  of terms  in a  sound way.   The  actual test  is
delayed  until the  terms are  sufficiently  different, or  have  become
identical.  For example:

________________________________________________________________________|                                                                        |
|?- dif(X, Y), X = a, Y = b.                                             |

|X = a,                                                                  |
|Y = b.                                                                  |
|                                                                        |
|?- dif(X, Y), X = a, Y = a.                                             |
|false.|________________________________________________________________ |      |

There are also  lower-level coroutining predicates that are intended  as
building blocks for higher-level  constraints.  For example, we  can use
freeze/2 to define a variable that can only be assigned an atom:

________________________________________________________________________|                                                                        |
|?- freeze(X, atom(X)), X = a.                                           |

|X|=_a._________________________________________________________________ | |

In this case, calling atom/1 earlier causes the whole query to fail:

________________________________________________________________________|                                                                        |
|?- atom(X), X = a.                                                      |
|false.|________________________________________________________________ |      |

If available, domain-specific constraints should be used  in such cases.
For example,  to state that  a variable can  only assume even  integers,
use the CLP(FD) constraint #=/2:

________________________________________________________________________|                                                                        |
|?- X mod 2 #= 0.                                                        |
|X|mod_2#=0.____________________________________________________________ | |

Importantly, domain-specific constraints can apply  stronger propagation
by  exploiting logical  properties of  their respective  domains.    For
example:

________________________________________________________________________|                                                                        |

|?- X mod 2 #= 0, X in 1..3.                                             |
|X|=_2._________________________________________________________________ | |

Remaining constraints,  such  as X mod 2#=0  in the  example above,  are
called _r_e_s_i_d_u_a_l goals.   They are said to _f_l_o_u_n_d_e_r, because  their truth
is  not yet  decided.   Declaratively,  the query  is only  true if  all
residual goals are satisfiable.   Use call_residue_vars/2to  collect all
variables that are involved in constraints.


ddiiff((_@_A_, _@_B))
    The  dif/2 predicate is  a _c_o_n_s_t_r_a_i_n_t  that is true  if and only  if
    _A  and _B are  different terms.   If _A and _B  can never unify,  dif/2
    succeeds  deterministically.   If _A  and _B are  identical, it  fails
    immediately.  Finally,  if _A and _B can unify, goals are delayed that
    prevent  _A and _B  to become equal.   It is  this last property  that
    makes  dif/2 a  more general  and more  declarative alternative  for
    \=/2 and related predicates.

    This    predicate   behaves   as   if   defined    by   dif(X, Y) :-
    when(?=(X,Y), X \== Y).   See  also  ?=/2.      The   implementation
    can deal with cyclic terms.

    The   dif/2  predicate  is   realised  using  attributed   variables
    associated with the module  dif.  It is an autoloaded predicate that
    is defined in the library dif.


ffrreeeezzee((_+_V_a_r_, _:_G_o_a_l))
    Delay  the execution  of  _G_o_a_l until  _V_a_r is  bound (i.e.  is not  a
    variable  or  attributed  variable).    If  _V_a_r is  bound  on  entry
    freeze/2  is  equivalent  to call/1.     The freeze/2  predicate  is
    realised  using an  attributed variable associated  with the  module
    freeze.   Use frozen(Var, Goal) to find out whether and  which goals
    are delayed on _V_a_r.


ffrroozzeenn((_@_V_a_r_, _-_G_o_a_l))
    Unify  _G_o_a_l with the  goal or conjunction  of goals delayed on  _V_a_r.
    If no goals are frozen on _V_a_r, _G_o_a_l is unified to true.


wwhheenn((_@_C_o_n_d_i_t_i_o_n_, _:_G_o_a_l))
    Execute  _G_o_a_l when  _C_o_n_d_i_t_i_o_n becomes  true.   _C_o_n_d_i_t_i_o_n  is one  of
    ?=(_X_, _Y), nonvar(_X), ground(_X),  ,(_C_o_n_d_1_, _C_o_n_d_2) or ;(_C_o_n_d_1_, _C_o_n_d_2).
    See  also freeze/2  and dif/2.    The implementation  can deal  with
    cyclic terms in _X and _Y.

    The   when/2  predicate  is  realised  using   attributed  variables
    associated  with the module  when.   It is  defined in the  autoload
    library when.


ccaallll__rreessiidduuee__vvaarrss((_:_G_o_a_l_, _-_V_a_r_s))
    Find  residual attributed variables  left by _G_o_a_l.   This  predicate
    is  intended  for   reasoning  about  and  debugging  programs  that
    use  coroutining  or  constraints.     To  see  why  this  predicate
    is   necessary,  consider  a  predicate  that   poses  contradicting
    constraints  on  a  variable,  and  where  that  variable  does  not
    appear  in  any  argument  of  the  predicate  and  hence  does  not
    yield  any residual  goals  on the  toplevel when  the predicate  is
    invoked.   Such programs should fail, but sometimes  succeed because
    the  constraint  solver is  too weak  to  detect the  contradiction.
    Ideally,  delayed  goals and  constraints are  all  executed at  the
    end  of  the computation.    The meta  predicate call_residue_vars/2
    finds  variables that are given  attributes or whose attributes  are
    modified  by _G_o_a_l, regardless of whether or not these  variables are
    reachable from the arguments of _G_o_a_l..


CChhaapptteerr 99..  CCHHRR:: CCOONNSSTTRRAAIINNTT HHAANNDDLLIINNGG RRUULLEESS

This chapter is written by Tom Schrijvers, K.U.  Leuven, and adjustments
by Jan Wielemaker.

The CHR system of SWI-Prolog is the _K_._U_._L_e_u_v_e_n _C_H_R _s_y_s_t_e_m.   The runtime
environment is  written by Christian Holzbaur  and Tom Schrijvers  while
the compiler  is written by  Tom Schrijvers.   Both are integrated  with
SWI-Prolog  and licensed  under  compatible conditions  with  permission
from the authors.

The main reference for the K.U.Leuven CHR system is:

  o T.   Schrijvers,  and   B.  Demoen,   _T_h_e  _K_._U_._L_e_u_v_e_n  _C_H_R   _S_y_s_t_e_m_:
    _I_m_p_l_e_m_e_n_t_a_t_i_o_n   _a_n_d  _A_p_p_l_i_c_a_t_i_o_n,  First  Workshop   on  Constraint
    Handling Rules:   Selected Contributions (Fr"uhwirth, T. and Meister,
    M., eds.), pp.  1--5, 2004.

On the K.U.Leuven CHR website (http://dtai.cs.kuleuven.be/CHR/)  you can
find more related papers, references and example programs.


99..11 IInnttrroodduuccttiioonn

Constraint  Handling  Rules  (CHR)  is  a   committed-choice  rule-based
language embedded  in Prolog.    It is designed  for writing  constraint
solvers and  is particularly  useful for providing  application-specific
constraints.   It  has been  used in  many kinds  of applications,  like
scheduling,  model checking, abduction,  and type  checking, among  many
others.

CHR has  previously been implemented in  other Prolog systems  (SICStus,
Eclipse,  Yap), Haskell  and Java.    This CHR  system is  based on  the
compilation scheme and runtime environment of CHR in SICStus.

In this documentation  we restrict ourselves to giving a  short overview
of  CHR  in general  and  mainly  focus  on elements  specific  to  this
implementation.  For  a more thorough review of CHR we refer  the reader
to [??].  More background on CHR can be found at [??].

In  section ????  we  present the  syntax of  CHR  in Prolog  and  explain
informally  its operational  semantics.   Next,  section  ???? deals  with
practical issues  of writing  and compiling  Prolog programs  containing
CHR.  Section  ????  explains  the  (currently  primitive)  CHR  debugging
facilities.   Section  ???? provides  a few useful  predicates to  inspect
the constraint  store, and section ????  illustrates CHR with two  example
programs.   Section ????  describes some  compatibility issues with  older
versions of this  system and SICStus' CHR  system.  Finally, section  ????
concludes with a few practical guidelines for using CHR.


99..22 SSyynnttaaxx aanndd SSeemmaannttiiccss


99..22..11 SSyynnttaaxx ooff CCHHRR rruulleess

________________________________________________________________________________________________________________________________________________||                                                                        ||
||rules --> rule, rules ; [].                                             |
|                                                                        |
|rule --> name, actual_rule, pragma, [atom('.')].                        |

|                                                                        |
|name --> atom, [atom('@')] ; [].                                        |
|                                                                        |
|actual_rule --> simplification_rule.                                    |
|actual_rule --> propagation_rule.                                       |
|actual_rule --> simpagation_rule.                                       |
|                                                                        |
|simplification_rule --> head, [atom('<=>')], guard, body.               |

|propagation_rule --> head, [atom('==>')], guard, body.                  |
|simpagation_rule --> head, [atom('\')], head, [atom('<=>')],            |
|                     guard, body.                                       |
|                                                                        |
|head --> constraints.                                                   |
|                                                                        |
|constraints --> constraint, constraint_id.                              |

|constraints --> constraint, constraint_id,                              |
|                [atom(',')], constraints.                               |
|                                                                        |
|constraint --> compound_term.                                           |
|                                                                        |
|constraint_id --> [].                                                   |
|constraint_id --> [atom('#')], variable.                                |
|constraint_id --> [atom('#')], [atom('passive')] .                      |

|                                                                        |
|guard --> [] ; goal, [atom('|')].                                       |
|                                                                        |
|body --> goal.                                                          |
|                                                                        |
|pragma --> [].                                                          |
|pragma --> [atom('pragma')], actual_pragmas.                            |

|                                                                        |
|actual_pragmas --> actual_pragma.                                       |
|actual_pragmas --> actual_pragma, [atom(',')], actual_pragmas.          |
|                                                                        |
|actual_pragma|-->_[atom('passive(')],_variable,_[atom(')')].___________ |             |

Note that  the guard of  a rule may  not contain any  goal that binds  a
variable in  the head of  the rule with a  non-variable or with  another
variable in  the head  of the  rule.   It may,  however, bind  variables
that do not appear  in the head of the rule, e.g. an  auxiliary variable
introduced in the guard.


99..22..22 SSeemmaannttiiccss

In  this subsection  the  operational semantics  of  CHR in  Prolog  are
presented informally.   They  do not differ  essentially from other  CHR
systems.

When a constraint is  called, it is considered an active  constraint and
the system  will try  to apply the  rules to it.    Rules are tried  and
executed sequentially in the order they are written.

A rule is conceptually  tried for an active constraint in  the following
way.  The active constraint is matched with a constraint  in the head of
the rule.  If  more constraints appear in the head, they are  looked for
among the  suspended constraints, which  are called passive  constraints
in this context.  If the necessary passive constraints  can be found and
all match with the head of the rule and the guard  of the rule succeeds,
then the rule  is committed and the body of  the rule executed.   If not
all the  necessary passive  constraints can  be found,  or the  matching
or the  guard fails, then the  body is not  executed and the process  of
trying and  executing simply  continues with  the following rules.    If
for  a rule  there are  multiple  constraints in  the head,  the  active
constraint  will try  the rule  sequentially multiple  times, each  time
trying to match with another constraint.

This process ends either when the active constraint  disappears, i.e. it
is removed by some rule, or after the last rule has  been processed.  In
the latter case the active constraint becomes suspended.

A  suspended constraint  is  eligible as  a  passive constraint  for  an
active constraint.   The other way it may interact again with  the rules
is when a variable  appearing in the constraint becomes bound  to either
a non-variable or another variable involved in one  or more constraints.
In that  case the  constraint is triggered,  i.e. it  becomes an  active
constraint and all the rules are tried.

RRuullee  TTyyppeess There are  three different  kinds of  rules,  each with  its
specific semantics:

  o _s_i_m_p_l_i_f_i_c_a_t_i_o_n
    The  simplification rule  removes the  constraints in  its head  and
    calls its body.

  o _p_r_o_p_a_g_a_t_i_o_n
    The   propagation  rule  calls  its   body  exactly  once  for   the
    constraints in its head.

  o _s_i_m_p_a_g_a_t_i_o_n
    The  simpagation rule removes the constraints in its head  after the
    \ and then  calls its body.  It is an optimization of simplification
    rules of the form:

                  constraints1;constraints2<=> constraints1;body

    Namely, in the simpagation form:

                       constraints1\constraints2<=> body
    The constraints1constraints are not called in the body.

RRuullee NNaammeess

Naming  a rule  is  optional and  has  no semantic  meaning.    It  only
functions as documentation for the programmer.

PPrraaggmmaass The semantics of the pragmas are:

ppaassssiivvee((_I_d_e_n_t_i_f_i_e_r))
    The  constraint in the  head of a rule  _I_d_e_n_t_i_f_i_e_r can only match  a
    passive  constraint in that  rule.   There is an abbreviated  syntax
    for this pragma.  Instead of:

    ____________________________________________________________________|                                                                    |

    ||________________...,_c_#_Id,_..._<=>_..._pragma_passive(Id)_______ ||

    you can also write

    ____________________________________________________________________|                                                                    |
    ||________________...,_c_#_passive,_..._<=>_..._____________________ ||

Additional pragmas may be released in the future.


::-- cchhrr__ooppttiioonn((_+_O_p_t_i_o_n_, _+_V_a_l_u_e))
    It  is  possible  to specify  options  that  apply to  all  the  CHR
    rules  in the module.   Options are specified  with the chr_option/2
    declaration:

    ____________________________________________________________________|                                                                    |
    ||:-_chr_option(Option,Value).______________________________________ ||

    and  may appear  in the  file anywhere after  the first  constraints
    declaration.

    Available options are:

    cchheecckk__gguuaarrdd__bbiinnddiinnggss
         This  option controls  whether  guards  should be  checked  for
         (illegal) variable bindings or  not.  Possible values  for this
         option are  on to  enable the checks,  and off  to disable  the
         checks.   If this option is on,  any guard fails when it  binds
         a variable  that appears in  the head of  the rule.   When  the
         option is  off (default),  the behaviour  of a  binding in  the
         guard is undefined.

    ooppttiimmiizzee
         This option  controls the  degree  of optimization.    Possible
         values are  full  to enable  all available  optimizations,  and
         off  (default) to  disable  all  optimizations.    The  default
         is derived  from the  SWI-Prolog flag optimise,  where true  is
         mapped to full.  Therefore the command line  option -O provides
         full CHR optimization.   If optimization is enabled,  debugging
         must be disabled.

    ddeebbuugg
         This option enables  or disables the  possibility to debug  the
         CHR code.    Possible values  are on (default)  and off.    See
         section ????  for more  details  on debugging.    The default  is
         derived  from the  Prolog  flag  generate_debug_info,  which  is
         true by  default.   See  -nodebug.   If  debugging is  enabled,
         optimization must be disabled.


99..33 CCHHRR iinn SSWWII--PPrroolloogg PPrrooggrraammss


99..33..11 EEmmbbeeddddiinngg iinn PPrroolloogg PPrrooggrraammss

The CHR constraints defined in a .pl file are  associated with a module.
The default module is  user.  One should never load different  .pl files
with the same CHR module name.


99..33..22 CCoonnssttrraaiinntt ddeeccllaarraattiioonn


::-- cchhrr__ccoonnssttrraaiinntt((_+_S_p_e_c_i_f_i_e_r))
    Every  constraint  used in  CHR  rules has  to  be declared  with  a
    chr_constraint/1  declaration  by the  _c_o_n_s_t_r_a_i_n_t  _s_p_e_c_i_f_i_e_r.    For
    convenience  multiple constraints may be  declared at once with  the
    same  chr_constraint/1  declaration followed  by  a  comma-separated
    list of constraint specifiers.

    A  constraint specifier is,  in its compact form,  F/A where F  and
    A  are respectively the  functor name and arity  of the constraint,
    e.g.:

    ____________________________________________________________________|                                                                    |
    | :- chr_constraint foo/1.                                           |

    ||:-_chr_constraint_bar/2,_baz/3.___________________________________ ||

    In  its extended form, a constraint specifier is c(A1,...,An) where
    c  is the constraint's functor, n its arity and  the Aiare  argument
    specifiers.   An argument  specifier is a mode, optionally  followed
    by a type.  Example:

    ____________________________________________________________________|                                                                    |
    | :- chr_constraint get_value(+,?).                                  |
    | :- chr_constraint domain(?int, +list(int)),                        |
    ||__________________alldifferent(?list(int))._______________________ ||

MMooddeess

A mode is one of:

-
    The corresponding argument  of every occurrence of the constraint is
    always unbound.

+
    The corresponding argument  of every occurrence of the constraint is
    always ground.

?
    The  corresponding argument  of every occurrence  of the  constraint
    can  have any instantiation,  which may change over  time.  This  is
    the default value.

TTyyppeess

A type can be a user-defined type or one of the built-in  types.  A type
comprises a  (possibly infinite) set  of values.   The type  declaration
for  a  constraint  argument means  that  for  every  instance  of  that
constraint the  corresponding argument is only  ever bound to values  in
that set.   It does  not state that the  argument necessarily has to  be
bound to a value.

The built-in types are:

iinntt
    The corresponding argument  of every occurrence of the constraint is
    an integer number.

ddeennssee__iinntt
    The corresponding argument  of every occurrence of the constraint is
    an  integer that can be used as an  array index.  Note that  if this
    argument takes values in [0; n], the array takes O(n) space.

ffllooaatt
    ...a floating point number.

nnuummbbeerr
    ...a number.

nnaattuurraall
    ...a positive integer.

aannyy
    The  corresponding argument  of every occurrence  of the  constraint
    can have any type.  This is the default value.


::-- cchhrr__ttyyppee((_+_T_y_p_e_D_e_c_l_a_r_a_t_i_o_n))
    User-defined  types are algebraic  data types,  similar to those  in
    Haskell  or the discriminated unions in Mercury.  An  algebraic data
    type is defined using chr_type/1:

    ____________________________________________________________________|                                                                    |
    ||:-_chr_type_type_--->_body._______________________________________ ||

    If  the type term is a functor  of arity zero (i.e. one  having zero
    arguments),  it names  a monomorphic type.   Otherwise,  it names  a
    polymorphic  type;  the arguments of  the functor  must be  distinct
    type  variables.     The body  term  is  defined as  a  sequence  of
    constructor definitions separated by semi-colons.

    Each  constructor  definition  must  be a  functor  whose  arguments
    (if  any)  are  types.    Discriminated  union definitions  must  be
    transparent:   all type  variables occurring in  the body must  also
    occur in the type.

    Here are some examples of algebraic data type definitions:

    ____________________________________________________________________|                                                                    |

    | :- chr_type color ---> red ; blue ; yellow ; green.                |
    |                                                                    |
    | :- chr_type tree --->  empty ; leaf(int) ; branch(tree, tree).     |
    |                                                                    |
    | :- chr_type list(T) ---> [] ; [T | list(T)].                       |
    |                                                                    |

    ||:-_chr_type_pair(T1,_T2)_--->_(T1_-_T2).__________________________ ||

    Each  algebraic data  type  definition introduces  a distinct  type.
    Two  algebraic data types that  have the same bodies are  considered
    to be distinct types (name equivalence).

    Constructors may be  overloaded among different types:  there may be
    any  number of constructors with a given name and arity, so  long as
    they all have different types.

    Aliases can be defined  using ==.  For example, if your program uses
    lists of lists of integers, you can define an alias as follows:

    ____________________________________________________________________|                                                                    |
    ||:-_chr_type_lli_==_list(list(int))._______________________________ ||

TTyyppee CChheecckkiinngg

Currently two complementary forms of type checking are performed:

 1. Static  type checking is  always performed by the  compiler.  It  is
    limited to CHR rule heads and CHR constraint calls in rule bodies.

    Two  kinds  of type  error  are detected.    The  first is  where  a
    variable has to belong to two types.  For example, in the program:

    ____________________________________________________________________|                                                                    |
    | :-chr_type foo ---> foo.                                           |
    | :-chr_type bar ---> bar.                                           |

    |                                                                    |
    | :-chr_constraint abc(?foo).                                        |
    | :-chr_constraint def(?bar).                                        |
    |                                                                    |
    ||foobar_@_abc(X)_<=>_def(X)._______________________________________ ||

    the  variable  X has  to be  of both  type foo  and bar.    This  is
    reported as a type clash error:

    ____________________________________________________________________|                                                                    |
    | CHR compiler ERROR:                                                |
    |     `--> Type clash for variable _ in rule foobar:                 |

    |                 expected type foo in body goal def(_, _)           |
    ||________________expected_type_bar_in_head_def(_,__)_______________ ||

    The  second kind of error is where  a functor is used that  does not
    belong to the declared type.  For example in:

    ____________________________________________________________________|                                                                    |
    | :- chr_type foo ---> foo.                                          |
    | :- chr_type bar ---> bar.                                          |
    |                                                                    |
    | :- chr_constraint abc(?foo).                                       |

    |                                                                    |
    ||foo_@_abc(bar)_<=>_true.__________________________________________ ||

    bar  appears in the head of the rule where something of type  foo is
    expected.  This is reported as:

    ____________________________________________________________________|                                                                    |
    | CHR compiler ERROR:                                                |
    |     `--> Invalid functor in head abc(bar) of rule foo:             |
    |                 found `bar',                                       |

    ||________________expected_type_`foo'!______________________________ ||

    No runtime overhead is incurred in static type checking.

 2. Dynamic  type checking checks at runtime, during  program execution,
    whether  the arguments  of  CHR constraints  respect their  declared
    types.   The  when/2 co-routining library  is used to delay  dynamic
    type checks until variables are instantiated.

    The  kind of  error detected  by dynamic  type checking  is where  a
    functor  is used that  does not belong  to the declared  type.   For
    example, for the program:

    ____________________________________________________________________|                                                                    |

    | :-chr_type foo ---> foo.                                           |
    |                                                                    |
    ||:-chr_constraint_abc(?foo)._______________________________________ ||

    we get the following error in an erroneous query:

    ____________________________________________________________________|                                                                    |
    | ?- abc(bar).                                                       |
    | ERROR: Type error: `foo' expected, found `bar'                     |
    ||_______(CHR_Runtime_Type_Error)___________________________________ ||

    Dynamic  type checking is  weaker than static  type checking in  the
    sense  that it only checks the particular program execution  at hand
    rather  than all possible executions.   It is stronger in the  sense
    that it tracks types throughout the whole program.

    Note  that it  is enabled  only in  debug  mode, as  it incurs  some
    (minor) runtime overhead.


99..33..33 CCoommppiillaattiioonn

The  SWI-Prolog   CHR  compiler   exploits  term_expansion/2  rules   to
translate the constraint  handling rules to plain  Prolog.  These  rules
are loaded  from the library chr.   They  are activated if the  compiled
file  has the  .chr extension  or  after finding  a declaration  in  the
following format:

________________________________________________________________________|                                                                        |
|:-|chr_constraint_...__________________________________________________ |  |

It is  advised to define CHR  rules in a  module file, where the  module
declaration  is  immediately  followed  by  including  the  library(chr)
library as exemplified below:

________________________________________________________________________|                                                                        |

|:- module(zebra, [ zebra/0 ]).                                          |
|:- use_module(library(chr)).                                            |
|                                                                        |
|:-|chr_constraint_...__________________________________________________ |  |

Using this style, CHR rules can be defined in  ordinary Prolog .pl files
and the operator  definitions required by CHR  do not leak into  modules
where they might cause conflicts.


99..44 DDeebbuuggggiinngg

The  CHR  debugging facilities  are  currently  rather limited.     Only
tracing is  currently available.   To use  the CHR debugging  facilities
for a  CHR file it  must be  compiled for debugging.   Generating  debug
info is  controlled by the  CHR option debug,  whose default is  derived
from the SWI-Prolog  flag generate_debug_info.   Therefore debug info  is
provided unless the -nodebug is used.


99..44..11 PPoorrttss

For CHR constraints the four standard ports are defined:

ccaallll
    A new constraint is called and becomes active.

eexxiitt
    An  active  constraint  exits:    it has  either  been  inserted  in
    the  store  after trying  all rules  or has  been  removed from  the
    constraint store.

ffaaiill
    An active constraint fails.

rreeddoo
    An active constraint starts looking for an alternative solution.

In addition  to the above  ports, CHR  constraints have five  additional
ports:

wwaakkee
    A suspended constraint is woken and becomes active.

iinnsseerrtt
    An  active constraint has  tried all rules  and is suspended in  the
    constraint store.

rreemmoovvee
    An  active  or passive  constraint is  removed  from the  constraint
    store.

ttrryy
    An  active  constraint  tries  a rule  with  possibly  some  passive
    constraints.  The  try port is entered just before committing to the
    rule.

aappppllyy
    An  active constraint commits to  a rule with possibly some  passive
    constraints.   The  apply port is  entered just after committing  to
    the rule.


99..44..22 TTrraacciinngg

Tracing is enabled with the chr_trace/0 predicate and disabled  with the
chr_notrace/0 predicate.

When enabled  the tracer will  step through the  call, exit, fail,  wake
and apply  ports, accepting  debug commands,  and simply  write out  the
other ports.

The following debug commands are currently supported:

        CHR debug options:

                <cr>    creep           c       creep
                s       skip
                g       ancestors
                n       nodebug
                b       break
                a       abort
                f       fail
                ?       help            h       help

Their meaning is:

ccrreeeepp
    Step to the next port.

sskkiipp
    Skip to exit port of this call or wake port.

aanncceessttoorrss
    Print list of ancestor call and wake ports.

nnooddeebbuugg
    Disable the tracer.

bbrreeaakk
    Enter a recursive Prolog top level.  See break/0.

aabboorrtt
    Exit to the top level.  See abort/0.

ffaaiill
    Insert failure in execution.

hheellpp
    Print the above available debug options.


99..44..33 CCHHRR DDeebbuuggggiinngg PPrreeddiiccaatteess

The chr  module contains  several predicates that  allow inspecting  and
printing the content of the constraint store.


cchhrr__ttrraaccee
    Activate  the CHR tracer.   By default  the CHR tracer is  activated
    and  deactivated automatically by the Prolog predicates  trace/0 and
    notrace/0.


cchhrr__nnoottrraaccee
    Deactivate  the CHR tracer.  By default the CHR tracer  is activated
    and  deactivated automatically by the Prolog predicates  trace/0 and
    notrace/0.


cchhrr__lleeaasshh((_+_S_p_e_c))
    Define  the set of CHR ports on  which the CHR tracer asks  for user
    intervention  (i.e. stops).    _S_p_e_c  is either  a list  of ports  as
    defined  in section  ???? or a  predefined `alias'.   Defined  aliases
    are:   full to  stop at all ports,  none or off  to never stop,  and
    default to stop at  the call, exit, fail, wake and apply ports.  See
    also leash/1.


cchhrr__sshhooww__ssttoorree((_+_M_o_d))
    Prints  all  suspended constraints  of module  _M_o_d  to the  standard
    output.   This predicate  is automatically called by the  SWI-Prolog
    top  level at the end of  each query for every CHR module  currently
    loaded.    The Prolog flag  chr_toplevel_show_store controls  whether
    the  top level shows the constraint stores.  The value  true enables
    it.  Any other value disables it.


ffiinndd__cchhrr__ccoonnssttrraaiinntt((_-_C_o_n_s_t_r_a_i_n_t))
    Returns  a constraint in  the constraint store.   Via  backtracking,
    all constraints in the store can be enumerated.


99..55 EExxaammpplleess

Here are two example constraint solvers written in CHR.

  o The  program below  defines a  solver with  one constraint,  leq/2/,
    which  is a less-than-or-equal constraint,  also known as a  partial
    order constraint.

    ____________________________________________________________________|                                                                    |
    | :- module(leq,[leq/2]).                                            |

    | :- use_module(library(chr)).                                       |
    |                                                                    |
    | :- chr_constraint leq/2.                                           |
    | reflexivity  @ leq(X,X) <=> true.                                  |
    | antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.                       |
    | idempotence  @ leq(X,Y) \ leq(X,Y) <=> true.                       |
    ||transitivity_@_leq(X,Y),_leq(Y,Z)_==>_leq(X,Z).___________________ ||

    When the above program  is saved in a file and loaded in SWI-Prolog,
    you can call the leq/2 constraints in a query, e.g.:

    ____________________________________________________________________|                                                                    |

    | ?- leq(X,Y), leq(Y,Z).                                             |
    | leq(_G23837, _G23841)                                              |
    | leq(_G23838, _G23841)                                              |
    | leq(_G23837, _G23838)                                              |
    ||true_.____________________________________________________________ ||

    When  the  query  succeeds,  the  SWI-Prolog top  level  prints  the
    content  of  the  CHR constraint  store  and displays  the  bindings
    generated  during  the query.    Some  of  the query  variables  may
    have  been bound to  attributed variables, as  you see in the  above
    example.

  o The  program  below implements  a  simple finite  domain  constraint
    solver.

    ____________________________________________________________________|                                                                    |
    | :- module(dom,[dom/2]).                                            |

    | :- use_module(library(chr)).                                       |
    |                                                                    |
    | :- chr_constraint dom(?int,+list(int)).                            |
    | :- chr_type list(T) ---> [] ; [T|list(T)].                         |
    |                                                                    |
    | dom(X,[]) <=> fail.                                                |
    | dom(X,[Y]) <=> X = Y.                                              |
    | dom(X,L) <=> nonvar(X) | memberchk(X,L).                           |

    ||dom(X,L1),_dom(X,L2)_<=>_intersection(L1,L2,L3),_dom(X,L3)._______ ||

    When the above program  is saved in a file and loaded in SWI-Prolog,
    you can call the dom/2 constraints in a query, e.g.:

    ____________________________________________________________________|                                                                    |
    | ?- dom(A,[1,2,3]), dom(A,[3,4,5]).                                 |
    ||A_=_3.____________________________________________________________ ||


99..66 BBaacckkwwaarrddss CCoommppaattiibbiilliittyy


99..66..11 TThhee OOlldd SSIICCSSttuuss CCHHRR iimmpplleemmeennaattiioonn

There are  small differences between the  current K.U.Leuven CHR  system
in  SWI-Prolog, older  versions of  the same  system,  and SICStus'  CHR
system.

The  current  system maps  old  syntactic  elements onto  new  ones  and
ignores a number  of no longer required elements.   However, for each  a
_d_e_p_r_e_c_a_t_e_d warning  is issued.   You  are strongly  urged to replace  or
remove deprecated features.

Besides  differences in  available options  and pragmas,  the  following
differences should be noted:

  o _T_h_e constraints/1 _d_e_c_l_a_r_a_t_i_o_n
    This  declaration is  deprecated.   It  has been  replaced with  the
    chr_constraint/1 declaration.

  o _T_h_e option/2 _d_e_c_l_a_r_a_t_i_o_n
    This  declaration is  deprecated.   It  has been  replaced with  the
    chr_option/2 declaration.

  o _T_h_e handler/1 _d_e_c_l_a_r_a_t_i_o_n
    In  SICStus  every  CHR  module  requires  a  handler/1  declaration
    declaring  a unique handler name.  This declaration is  valid syntax
    in  SWI-Prolog, but will have  no effect.   A warning will be  given
    during compilation.

  o _T_h_e rules/1 _d_e_c_l_a_r_a_t_i_o_n
    In  SICStus, for every  CHR module it is  possible to only enable  a
    subset of the  available rules through the rules/1 declaration.  The
    declaration  is valid syntax in  SWI-Prolog, but has  no effect.   A
    warning is given during compilation.

  o _G_u_a_r_d _b_i_n_d_i_n_g_s
    The   check_guard_bindings  option   only  turns  invalid  calls   to
    unification  into failure.   In SICStus this  option does more:   it
    intercepts  instantiation errors from Prolog built-ins such  as is/2
    and turns them into  failure.  In SWI-Prolog, we do not go this far,
    as we like to  separate concerns more.  The CHR compiler is aware of
    the CHR code,  the Prolog system, and the programmer should be aware
    of  the appropriate meaning of the  Prolog goals used in guards  and
    bodies of CHR rules.


99..66..22 TThhee OOlldd EECCLLiiPPSSee CCHHRR iimmpplleemmeennaattiioonn

The old  ECLiPSe CHR  implementation features  a label_with/1  construct
for  labeling variables  in CHR  constraints.    This feature  has  long
since been abandoned.   However, a simple transformation is all  that is
required to port the functionality.

________________________________________________________________________|                                                                        |
|label_with Constraint1 if Condition1.                                   |
|...                                                                     |
|label_with ConstraintN if ConditionN.                                   |

|Constraint1 :- Body1.                                                   |
|...                                                                     |
|ConstraintN|:-_BodyN.__________________________________________________ |           |

is transformed into

________________________________________________________________________|                                                                        |
|:- chr_constraint my_labeling/0.                                        |

|                                                                        |
|my_labeling \ Constraint1 <=> Condition1 | Body1.                       |
|...                                                                     |
|my_labeling \ ConstraintN <=> ConditionN | BodyN.                       |
|my_labeling|<=>_true.__________________________________________________ |           |

Be sure to  put this code after all other  rules in your program!   With
my_labeling/0 (or another predicate name of your choosing)  the labeling
is initiated, rather than ECLiPSe's chr_labeling/0.


99..77 PPrrooggrraammmmiinngg TTiippss aanndd TTrriicckkss

In this section we  cover several guidelines on how to use CHR  to write
constraint solvers and how to do so efficiently.

  o _C_h_e_c_k _g_u_a_r_d _b_i_n_d_i_n_g_s _y_o_u_r_s_e_l_f
    It  is considered bad practice  to write guards that bind  variables
    of  the head and to  rely on the system  to detect this at  runtime.
    It is inefficient and obscures the working of the program.

  o _S_e_t _s_e_m_a_n_t_i_c_s
    The  CHR system allows the  presence of identical constraints,  i.e.
    multiple  constraints with  the same functor,  arity and  arguments.
    For  most constraint  solvers, this  is not desirable:   it  affects
    efficiency and possibly  termination.  Hence appropriate simpagation
    rules should be added of the form:

                         constraint\constraint <=>true

  o _M_u_l_t_i_-_h_e_a_d_e_d _r_u_l_e_s
    Multi-headed   rules  are   executed  more   efficiently  when   the
    constraints share one or more variables.

  o _M_o_d_e _a_n_d _t_y_p_e _d_e_c_l_a_r_a_t_i_o_n_s
    Provide  mode and  type declarations to  get more efficient  program
    execution.     Make sure  to  disable  debug (-nodebug)  and  enable
    optimization (-O).

  o _C_o_m_p_i_l_e _o_n_c_e_, _r_u_n _m_a_n_y _t_i_m_e_s
    Does  consulting your CHR  program take a  long time in  SWI-Prolog?
    Probably  it  takes the  CHR compiler  a long  time  to compile  the
    CHR  rules into  Prolog code.   When  you disable optimizations  the
    CHR  compiler will be a lot  quicker, but you may lose  performance.
    Alternatively, you  can just use SWI-Prolog's qcompile/1 to generate
    a  .qlf  file once  from your  .pl file.    This  .qlf contains  the
    generated  code of  the CHR  compiler (be  it in  a binary  format).
    When you consult the  .qlf file, the CHR compiler is not invoked and
    consultation is much faster.

  o _F_i_n_d_i_n_g _C_o_n_s_t_r_a_i_n_t_s
    The  find_chr_constraint/1 predicate  is fairly  expensive.    Avoid
    it,  if  possible.   If  you must  use it,  try  to use  it with  an
    instantiated top-level constraint symbol.


99..88 CCoommppiilleerr EErrrroorrss aanndd WWaarrnniinnggss

In  this section  we  summarize the  most  important error  and  warning
messages of the CHR compiler.


99..88..11 CCHHRR CCoommppiilleerr EErrrroorrss

TTyyppee ccllaasshh  for variable ...  in rule ...

    This  error indicates  an inconsistency  between declared  types;  a
    variable can not belong to two types.  See static type checking.

IInnvvaalliidd ffuunnccttoorr  in head ...  of rule ...

    This  error indicates an inconsistency  between a declared type  and
    the use of a functor in a rule.  See static type checking.

CCyycclliicc aalliiaass  definition:  ...  == ...

    You  have defined a type alias  in terms of itself, either  directly
    or indirectly.

AAmmbbiigguuoouuss ttyyppee aalliiaasseess  You have defined two overlapping type aliases.

MMuullttiippllee ddeeffiinniittiioonnss  for type

    You have defined the same type multiple times.

NNoonn--ggrroouunndd ttyyppee  in constraint definition:  ...

    You have declared a non-ground type for a constraint argument.

CCoouulldd nnoott ffiinndd ttyyppee ddeeffiinniittiioonn  for ...

    You have used an undefined type in a type declaration.

IIlllleeggaall mmooddee//ttyyppee ddeeccllaarraattiioonn  You  have  used   invalid  syntax  in   a
    constraint declaration.

CCoonnssttrraaiinntt mmuullttiippllyy ddeeffiinneedd  There is more than one declaration  for the
    same constraint.

UUnnddeeccllaarreedd ccoonnssttrraaiinntt  ...  in head of ...

    You have used an  undeclared constraint in the head of a rule.  This
    often  indicates a  misspelled constraint  name or  wrong number  of
    arguments.

IInnvvaalliidd pprraaggmmaa  ...  in ...  Pragma should not be a variable.

    You  have used  a variable  as a  pragma in  a rule.    This is  not
    allowed.

IInnvvaalliidd iiddeennttiiffiieerr  ...  in pragma passive in ...

    You  have  used an  identifier in  a passive  pragma  that does  not
    correspond  to an identifier in  the head of the  rule.  Likely  the
    identifier name is misspelled.

UUnnkknnoowwnn pprraaggmmaa  ...  in ...

    You  have used an unknown  pragma in a rule.   Likely the pragma  is
    misspelled or not supported.

SSoommeetthhiinngg uunneexxppeecctteedd  happened in the CHR compiler

    You have most likely  bumped into a bug in the CHR compiler.  Please
    contact Tom Schrijvers to notify him of this error.


CChhaapptteerr 1100..  MMUULLTTIITTHHRREEAADDEEDD AAPPPPLLIICCAATTIIOONNSS

SWI-Prolog multithreading is  based on standard C language  multithread-
ing support.   It is not  like _P_a_r_L_o_g or other parallel  implementations
of the Prolog language.   Prolog threads have their own stacks  and only
share the  Prolog _h_e_a_p:   predicates,  records, flags  and other  global
non-backtrackable data.  SWI-Prolog thread support is  designed with the
following goals in mind.

  o _M_u_l_t_i_t_h_r_e_a_d_e_d _s_e_r_v_e_r _a_p_p_l_i_c_a_t_i_o_n_s
    Today's   computing  services  often  focus  on   (internet)  server
    applications.   Such applications often have need  for communication
    between  services  and/or  fast  non-blocking  service  to  multiple
    concurrent  clients.  The  shared heap provides fast  communication,
    and thread creation is relatively cheap.

  o _I_n_t_e_r_a_c_t_i_v_e _a_p_p_l_i_c_a_t_i_o_n_s
    Interactive   applications   often   need   to   perform   extensive
    computation.   If  such computations are  executed in a new  thread,
    the  main thread  can process events  and allow  the user to  cancel
    the  ongoing computation.    User interfaces can  also use  multiple
    threads,  each thread dealing  with input from  a distinct group  of
    windows.  See also section ????.

  o _N_a_t_u_r_a_l _i_n_t_e_g_r_a_t_i_o_n _w_i_t_h _f_o_r_e_i_g_n _c_o_d_e
    Each Prolog thread  runs in a native thread of the operating system,
    automatically  making them cooperate with _M_T_-_s_a_f_e foreign code.   In
    addition,  any foreign thread can  create its own Prolog engine  for
    dealing with calling Prolog from C code.

SWI-Prolog  multithreading is  based on  the POSIX  thread standard  [??]
used on most popular systems except for MS-Windows.   On Windows it uses
the http://sources.redhat.com/pthreads-win32/pthread-win32 emulation  of
POSIX threads mixed with the Windows native API for  smoother and faster
operation.   The SWI-Prolog thread implementation has been  discussed in
the  ISO WG17  working group  and is  largely addopted  by  YAP and  XSB
Prolog.


1100..11 CCrreeaattiinngg aanndd ddeessttrrooyyiinngg PPrroolloogg tthhrreeaaddss


tthhrreeaadd__ccrreeaattee((_:_G_o_a_l_, _-_I_d))
    Shorthand for thread_create(Goal, Id, []).  See thread_create/3.


tthhrreeaadd__ccrreeaattee((_:_G_o_a_l_, _-_I_d_, _+_O_p_t_i_o_n_s))
    Create a new  Prolog thread (and underlying operating system thread)
    and  start  it  by  executing  _G_o_a_l.    If  the  thread  is  created
    successfully,   the thread  identifier  of  the  created  thread  is
    unified to _I_d.

    _I_d is the _a_l_i_a_s  name if the option alias(_n_a_m_e) is given.  Otherwise
    it  is a  _b_l_o_b of  type thread.    The anonymous  blobs are  subject
    to  atom  garbage  collection.    If  a  thread  handle  is  garbage
    collected  and  the thread  is  not _d_e_t_a_c_h_e_d,  it  is _j_o_i_n_e_d  if  it
    has  already terminated  (see thread_join/2) and detached  otherwise
    (see  thread_detach/1).   The  thread identifier  blobs are  printed
    as  <thread>(_I,_P_t_r),  where  _I  is the  internal  thread  identifier
    and  _P_t_r  is  the unique  address  of the  identifier.    The  _I  is
    accepted as input  argument for all thread APIs that accept a thread
    identifier  for convenient interaction from the toplevel.   See also
    thread_property/2.

    _O_p_t_i_o_n_s  is  a list  of  options.    The currently  defined  options
    are  below.   Stack  size options  can also  take the  value inf  or
    infinite,  which is mapped  to the maximum  stack size supported  by
    the platform.

    aaffffiinniittyy((_+_C_p_u_S_e_t))
         Specify that the thread  should only on any of the  listed CPUs
         (cores).   _C_p_u_S_e_t is a  list of integers  between 0 (zero)  and
         the known number of CPUs (see cpu_count).  If _C_p_u_S_e_t is empty a
         domain_error is raised.   Referring to CPUs equal to or  higher
         than the known number of CPUs returns a existence_error.

         This option is  currently implemented for systems that  provide
         pthread_attr_setaffinity_np().   The  option is silently  ignored
         on other systems.

    aalliiaass((_A_l_i_a_s_N_a_m_e))
         Associate an `alias  name' with the thread.   This name may  be
         used to refer to the thread and remains valid  until the thread
         is joined (see  thread_join/2).   If  the OS supports it  (e.g.,
         Linux), the operating system thread is named as well.

    aatt__eexxiitt((_:_A_t_E_x_i_t))
         Register _A_t_E_x_i_t  as using thread_at_exit/1 before entering  the
         thread  goal.    Unlike  calling  thread_at_exit/1 as  part  of
         the normal  _G_o_a_l, this  _e_n_s_u_r_e_s the  _A_t_E_x_i_t is called.    Using
         thread_at_exit/1,  the thread  may be  signalled or  run out  of
         resources before thread_at_exit/1is reached.

    ddeebbuugg((_+_B_o_o_l))
         Enable/disable debugging  the new  thread.   If false  (default
         true),   the  new   thread  is   created   with  the   property
         debug(_f_a_l_s_e) and  debugging is disabled  before the new  thread
         is started.   The  thread debugging  predicates such as  tspy/1
         and tdebug/0 do not signal threads with the  debug property set
         to false.

    ddeettaacchheedd((_B_o_o_l))
         If  false  (default),  the  thread  can  be  waited  for  using
         thread_join/2.   thread_join/2 must  be called  on this  thread
         to  reclaim all  resources  associated with  the  thread.    If
         true,  the   system  will  reclaim  all  associated   resources
         automatically after  the thread  finishes.    Please note  that
         thread identifiers are freed for reuse after  a detached thread
         finishes  or a  normal  thread  has  been joined.     See  also
         thread_join/2 and thread_detach/1.

         If  a  detached  thread  dies  due  to   failure  or  exception
         of  the  initial  goal,  the  thread  prints  a  message  using
         print_message/2.  If such termination is considered normal, the
         code must be  wrapped using ignore/1  and/or catch/3 to  ensure
         successful completion.

    iinnhheerriitt__ffrroomm((_+_T_h_r_e_a_d_I_d))
         Inherit  defaults  from  the  given  _T_h_r_e_a_d_I_d  instead  of  the
         calling thread.    This  option was  added to  ensure that  the
         __thread_pool_manager  (see thread_create_in_pool/4),  which  is
         created  lazily,  has  a predictable  state.     The  following
         properties are inherited:

           o The prompt (see prompt/2)

           o The _t_y_p_e_i_n module (see module/1)

           o The standard streams (user_input, etc.)

           o The default encoding (see encoding)

           o The default locale (see setlocale/1)

           o All prolog flags

           o The stack limit (see Prolog flag stack_limit).

    ssttaacckk__lliimmiitt((_B_y_t_e_s))
         Set the size limit for the Prolog stacks.  See  the Prolog flag
         stack_limit.  The default is inherited from the  calling thread
         or the thread specified using inherit_from(_T_h_r_e_a_d_I_d).

    cc__ssttaacckk((_K_-_B_y_t_e_s))
         Set the  limit to which the  C stack of  this thread may  grow.
         The default, minimum and maximum values are system-dependent.

    The _G_o_a_l argument is  _c_o_p_i_e_d to the new Prolog engine.  This implies
    that  further instantiation of this  term in either thread does  not
    have  consequences for  the  other thread:   Prolog  threads do  not
    share data from their stacks.


tthhrreeaadd__sseellff((_-_I_d))
    Get  the Prolog thread  identifier of  the running thread.   If  the
    thread has an alias, the alias name is returned.


tthhrreeaadd__jjooiinn((_+_I_d))
    Calls  thread_join/2  and  succeeds if  thread  _I_d  terminated  with
    success.   Otherwise the exception error(thread_error_(_S_t_a_t_u_s_)_, __) is
    raised.


tthhrreeaadd__jjooiinn((_+_I_d_, _-_S_t_a_t_u_s))
    Wait  for the termination  of the thread  with the given  _I_d.   Then
    unify  the result  status of  the thread with  _S_t_a_t_u_s.   After  this
    call,  _I_d  becomes invalid  and all  resources  associated with  the
    thread  are  reclaimed.     Note that  threads  with  the  attribute
    detached(_t_r_u_e) cannot be joined.  See also thread_property/2.

    A thread  that has been completed without thread_join/2 being called
    on  it is partly reclaimed:  the Prolog stacks are released  and the
    C  thread is  destroyed.   A small  data structure representing  the
    exit status  of the thread is retained until thread_join/2 is called
    on the thread.  Defined values for _S_t_a_t_u_s are:

    ttrruuee
         The goal has been proven successfully.

    ffaallssee
         The goal has failed.

    eexxcceeppttiioonn((_T_e_r_m))
         The thread is terminated on an  exception.  See print_message/2
         to turn system exceptions into readable messages.

    eexxiitteedd((_T_e_r_m))
         The thread  is terminated on  thread_exit/1 using the  argument
         _T_e_r_m.


tthhrreeaadd__ddeettaacchh((_+_I_d))
    Switch  thread into  detached  state (see  detached(_B_o_o_l) option  at
    thread_create/3) at  runtime.   _I_d is the  identifier of the  thread
    placed in detached state.  This may be the result of thread_self/1.

    One   of  the  possible  applications  is  to   simplify  debugging.
    Threads  that  are  created as  _d_e_t_a_c_h_e_d  leave  no traces  if  they
    crash.   For non-detached threads the status can be  inspected using
    thread_property/2.   Threads  nobody is waiting  for may be  created
    normally  and detach themselves  just before completion.   This  way
    they  leave no  traces  on normal  completion and  their reason  for
    failure can be inspected.


tthhrreeaadd__eexxiitt((_+_T_e_r_m))                                          _[_d_e_p_r_e_c_a_t_e_d_]
    Terminates  the thread immediately,  leaving exited(_T_e_r_m) as  result
    state  for   thread_join/2.     If  the   thread  has  the  attribute
    detached(_t_r_u_e)  it  terminates,   but  its  exit  status  cannot  be
    retrieved using  thread_join/2, making the value  of _T_e_r_m irrelevant.
    The Prolog stacks and C thread are reclaimed.

    The  current  implementation  does not  guarantee  proper  releasing
    of  all  mutexes and  proper cleanup  in  setup_call_cleanup/3,  etc.
    Please  use the  exception  mechanism (throw/1)  to abort  execution
    using non-standard control.


tthhrreeaadd__iinniittiiaalliizzaattiioonn((_:_G_o_a_l))
    Run  _G_o_a_l when  thread is  started.   This predicate  is similar  to
    initialization/1,  but is intended for initialization  operations of
    the  runtime stacks, such as  setting global variables as  described
    in  section ????.   _G_o_a_l  is run on  four occasions:   at the call  to
    this  predicate,  after loading  a saved  state, on  starting a  new
    thread  and on  creating a  Prolog engine through  the C  interface.
    On  loading  a  saved state,  _G_o_a_l  is  executed _a_f_t_e_r  running  the
    initialization/1 hooks.


tthhrreeaadd__aatt__eexxiitt((_:_G_o_a_l))
    Run  _G_o_a_l  just before  releasing the  thread resources.    This  is
    to  be  compared to  at_halt/1, but  only  for the  current  thread.
    These  hooks are run regardless of  why the execution of the  thread
    has  been completed.    When these hooks  are run,  the return  code
    is  already  available through  thread_property/2 using  the  result
    of  thread_self/1  as  thread  identifier.    Note  that  there  are
    two  scenarios  for using  exit hooks.    Using  thread_at_exit/1 is
    typically  used if  the thread  creates a side-effect  that must  be
    reverted if the thread  dies.  Another scenario is where the creator
    of  the thread  wants to be  informed when  the thread ends.    That
    cannot  be  guaranteed by  means of  thread_at_exit/1 because it  is
    possible that the  thread cannot be created or dies almost instantly
    due  to a  signal or resource  error.   The at_exit(_G_o_a_l) option  of
    thread_create/3 is designed to deal with this scenario.


tthhrreeaadd__sseettccoonnccuurrrreennccyy((_-_O_l_d_, _+_N_e_w))
    Determine  the concurrency of the  process, which is defined as  the
    maximum number of  concurrently active threads.  `Active' here means
    they  are using CPU  time.   This option is  provided if the  thread
    implementation  provides  pthread_setconcurrency().    Solaris  is  a
    typical  example of this  family.   On other systems this  predicate
    unifies _O_l_d to 0 (zero) and succeeds silently.


tthhrreeaadd__aaffffiinniittyy((_+_T_h_r_e_a_d_I_D_, _-_C_u_r_r_e_n_t_, _+_N_e_w))
    True  when  _C_u_r_r_e_n_t  is unified  with  the current  thread  affinity
    and  the thread affinity  is successfully  set to _N_e_w.   The  _t_h_r_e_a_d
    _a_f_f_i_n_i_t_y  specifies  the  set  of  CPUs  on  which  this  thread  is
    allowed  to  run.     The  affinity is  represented  as  a  list  of
    non-negative  integers.  See also the option  affinity(_+_A_f_f_i_n_i_t_y) of
    thread_create/3.

    This  predicate  is  only  present  if  this  functionality  can  be
    supported  and  has  been ported  to  the target  operating  system.
    Currently, only Linux support is provided.


1100..22 MMoonniittoorriinngg tthhrreeaaddss

Normal multithreaded  applications should not  need the predicates  from
this section  because almost any  usage of  these predicates is  unsafe.
For example checking the  existence of a thread before signalling  it is
of no use as it  may vanish between the two calls.   Catching exceptions
using  catch/3  is the  only  safe  way to  deal  with  thread-existence
errors.

These predicates are provided  for diagnosis and monitoring tasks.   See
also section ????, describing more high-level primitives.


iiss__tthhrreeaadd((_@_T_e_r_m))
    True if _T_e_r_m is a handle to an existing thread.


tthhrreeaadd__pprrooppeerrttyy((_?_I_d_, _?_P_r_o_p_e_r_t_y))
    True  if thread  _I_d  has _P_r_o_p_e_r_t_y.    Either or  both arguments  may
    be  unbound, enumerating  all relations  on backtracking.    Calling
    thread_property/2  does  not  influence  any  thread.      See  also
    thread_join/2.   For threads that have  an alias name, this name  is
    returned  in _I_d instead  of the opaque  thread identifier.   Defined
    properties are:

    aalliiaass((_A_l_i_a_s))
         _A_l_i_a_s is the alias name of thread _I_d.

    ddeettaacchheedd((_B_o_o_l_e_a_n))
         Current detached status of the thread.

    iidd((_I_n_t_e_g_e_r))
         Integer identifier  for the thread.   Can  be used as  argument
         to the thread predicates,  but applications must be aware  that
         these references are reused.

    ssttaattuuss((_S_t_a_t_u_s))
         Current status of the thread.  _S_t_a_t_u_s is one of:

         rruunnnniinngg
             The  thread is running.   This is  the initial status of  a
             thread.   Please  note that  threads waiting for  something
             are considered running too.

         ssuussppeennddeedd
             Only  if  the  thread  is   an  engine  (see  section  ????).
             Indicates that the engine is  currently not associated with
             an OS thread.

         ffaallssee
             The _G_o_a_l of the thread has been completed and failed.

         ttrruuee
             The _G_o_a_l of the thread has been completed and succeeded.

         eexxiitteedd((_T_e_r_m))
             The   _G_o_a_l  of  the  thread   has  been  terminated   using
             thread_exit/1 with  _T_e_r_m as  argument.   If the  underlying
             native  thread has  exited  (using pthread_exit()) _T_e_r_m  is
             unbound.

         eexxcceeppttiioonn((_T_e_r_m))
             The  _G_o_a_l  of the  thread has  been  terminated due  to  an
             uncaught exception (see throw/1 and catch/3).

    eennggiinnee((_B_o_o_l_e_a_n))
         If the thread is  an engine (see chapter ????), _B_o_o_l_e_a_n  is true.
         Othwerwise the property is not present.

    tthhrreeaadd((_T_h_r_e_a_d_I_d))
         If the  thread is  an engine that  is currently  attached to  a
         thread, _T_h_r_e_a_d_I_d is the thread that executes the engine.

    ssyysstteemm__tthhrreeaadd__iidd((_I_n_t_e_g_e_r))
         Thread identifier used by the operating system  for the calling
         thread.  Not  available on all OSes.   This is the same as  the
         Prolog flag  system_thread_idfor  the calling  thread.   Access
         to the system thread  identifier can, on some systems,  be used
         to gain  additional control  over or  information about  Prolog
         threads.

    See  also thread_statistics/3 to  obtain resource usage  information
    and  message_queue_property/2 to get the  number of queued  messages
    for a thread.


tthhrreeaadd__ssttaattiissttiiccss((_+_I_d_, _+_K_e_y_, _-_V_a_l_u_e))
    Obtains  statistical information on  thread _I_d as statistics/2  does
    in  single-threaded applications.   This call  supports all keys  of
    statistics/2,  although only  stack sizes,  cputime, inferences  and
    epoch yield different values for each thread.


mmuutteexx__ssttaattiissttiiccss
    Print  usage statistics on  internal mutexes and mutexes  associated
    with  dynamic predicates.  For  each mutex two numbers are  printed:
    the  number  of times  the  mutex was  acquired  and the  number  of
    _c_o_l_l_i_s_i_o_n_s:   the  number of times  the calling  thread has to  wait
    for  the mutex.    Generally  collision count  is close  to zero  on
    single-CPU hardware.


1100..33 TThhrreeaadd ccoommmmuunniiccaattiioonn


1100..33..11 MMeessssaaggee qquueeuueess

Prolog  threads can  exchange data  using dynamic  predicates,  database
records,  and other globally  shared data.   These  provide no  suitable
means to wait for data or a condition as they can  only be checked in an
expensive polling loop.   _M_e_s_s_a_g_e _q_u_e_u_e_s provide a means for  threads to
wait for data or conditions without using the CPU.

Each thread  has a message  queue attached to it  that is identified  by
the thread.  Additional queues are created using message_queue_create/1.
Explicitly  created  queues  come  in two  flavours.     When  given  an
_a_l_i_a_s, they  must be destroyed  by the user.   _A_n_o_n_y_m_o_u_s message  queues
are  identified by  a  _b_l_o_b (see  section  ????)  and subject  to  garbage
collection.


tthhrreeaadd__sseenndd__mmeessssaaggee((_+_Q_u_e_u_e_O_r_T_h_r_e_a_d_I_d_, _+_T_e_r_m))
    Place  _T_e_r_m in  the given queue  or default  queue of the  indicated
    thread  (which  can  even  be  the  message  queue  of  itself,  see
    thread_self/1).   Any  term can be  placed in a  message queue,  but
    note  that the term is copied  to the receiving thread and  variable
    bindings are thus lost.  This call returns immediately.

    If  more than one thread is waiting for messages on the  given queue
    and  at least one of these is waiting with a  partially instantiated
    _T_e_r_m, the waiting  threads are _a_l_l sent a wake-up signal, starting a
    rush  for the available messages in  the queue.  This behaviour  can
    seriously  harm performance  with many threads  waiting on the  same
    queue  as all-but-the-winner  perform a useless  scan of the  queue.
    If  there is  only one waiting  thread or  all waiting threads  wait
    with  an unbound variable, an arbitrary thread is restarted  to scan
    the queue.


tthhrreeaadd__sseenndd__mmeessssaaggee((_+_Q_u_e_u_e_, _+_T_e_r_m_, _+_O_p_t_i_o_n_s))                   _[_s_e_m_i_d_e_t_]
    As  thread_send_message/2, but  providing additional _O_p_t_i_o_n_s.   These
    are  to deal  with  the case  that the  queue has  a finite  maximum
    size  and is full:   whereas thread_send_message/2 will block  until
    the  queue  has  drained  sufficiently  to  accept  a  new  message,
    thread_send_message/3 can accept a time-out or  deadline analogously
    to thread_get_message/3.  The options are:

    ddeeaaddlliinnee((_+_A_b_s_T_i_m_e))
         The call  fails (silently)  if  no space  has become  available
         before  _A_b_s_T_i_m_e.    See get_time/1  for the  representation  of
         absolute time.   If _A_b_s_T_i_m_e is  earlier then the current  time,
         thread_send_message/3 fails immediately.   Both resolution  and
         maximum wait time is platform-dependent.

    ttiimmeeoouutt((_+_T_i_m_e))
         _T_i_m_e is a  float or integer and  specifies the maximum time  to
         wait in  seconds.    This  is a  relative-time version  of  the
         deadline option.   If  both options are  provided, the  earlier
         time is effective.

         If _T_i_m_e is  0 or 0.0, thread_send_message/3 examines the  queue
         and sends  the  message if  space is  availabel,  but does  not
         suspend if no space is available, failing immediately instead.

         If _T_i_m_e  < 0, thread_send_message/3 fails  immediately without
         sending the message.


tthhrreeaadd__ggeett__mmeessssaaggee((_?_T_e_r_m))
    Examines the thread  message queue and if necessary blocks execution
    until  a term that unifies  to _T_e_r_m arrives in  the queue.  After  a
    term  from the queue has been  unified to _T_e_r_m, the term  is deleted
    from the queue.

    Please  note that non-unifying messages remain in the queue.   After
    the  following has been  executed, thread 1  has the term b(_g_n_u)  in
    its queue and continues execution using _A = gnat.

    ____________________________________________________________________|                                                                    |
    |    <thread 1>                                                      |

    |    thread_get_message(a(A)),                                       |
    |                                                                    |
    |    <thread 2>                                                      |
    |    thread_send_message(Thread_1, b(gnu)),                          |
    ||___thread_send_message(Thread_1,_a(gnat)),________________________ ||

    See also thread_peek_message/1.


tthhrreeaadd__ppeeeekk__mmeessssaaggee((_?_T_e_r_m))
    Examines  the thread  message queue  and compares  the queued  terms
    with   _T_e_r_m  until  one  unifies  or  the  end  of  the   queue  has
    been  reached.    In  the first  case  the call  succeeds,  possibly
    instantiating  _T_e_r_m.  If no  term from the queue unifies,  this call
    fails.   I.e., thread_peek_message/1never waits and  does not remove
    any term from the queue.  See also thread_get_message/3.


mmeessssaaggee__qquueeuuee__ccrreeaattee((_?_Q_u_e_u_e))
    Equivalent  to  message_queue_create(Queue,[]).     For  compatibil-
    ity,    calling   message_queue_create(_+_A_t_o_m)   is   equivalent   to
    message_queue_create(_Q_u_e_u_e_,  _[_a_l_i_a_s_(_A_t_o_m_)_]).   New  code should  use
    message_queue_create/2 to create a named queue.


mmeessssaaggee__qquueeuuee__ccrreeaattee((_-_Q_u_e_u_e_, _+_O_p_t_i_o_n_s))
    Create a message queue from _O_p_t_i_o_n_s.  Defined options are:

    aalliiaass((_+_A_l_i_a_s))
         Create  a  message  queue  that  is  identified   by  the  atom
         _A_l_i_a_s.   Message  queues created  this way  must be  explicitly
         destroyed by  the user.   If  the alias option  is omitted,  an
         _A_n_o_n_y_m_o_u_s queue is created  that is indentified by a  _b_l_o_b (see
         section ????) and subject to garbage collection.

    mmaaxx__ssiizzee((_+_S_i_z_e))
         Maximum number  of  terms in  the queue.    If  this number  is
         reached,  thread_send_message/2 will  suspend until  the  queue
         is drained.   The  option can  be used if  the source,  sending
         messages to the queue, is faster than the  drain, consuming the
         messages.


mmeessssaaggee__qquueeuuee__ddeessttrrooyy((_+_Q_u_e_u_e))                                      _[_d_e_t_]
    Destroy  a  message queue  created with  message_queue_create/1.    A
    permission  error is raised  if _Q_u_e_u_e refers  to (the default  queue
    of)  a thread.    Other  threads that  are waiting  for _Q_u_e_u_e  using
    thread_get_message/2 receive an existence error.


tthhrreeaadd__ggeett__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m))                                  _[_d_e_t_]
    As  thread_get_message/1, operating on a given queue.   It is allowed
    (but  not advised) to get messages from the queue of  other threads.
    This predicate raises  an existence error exception if _Q_u_e_u_e doesn't
    exist  or  is  destroyed  using  message_queue_destroy/1 while  this
    predicate is waiting.


tthhrreeaadd__ggeett__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m_, _+_O_p_t_i_o_n_s))                    _[_s_e_m_i_d_e_t_]
    As thread_get_message/2, but providing additional _O_p_t_i_o_n_s:

    ddeeaaddlliinnee((_+_A_b_s_T_i_m_e))
         The call  fails (silently)  if  no message  has arrived  before
         _A_b_s_T_i_m_e.   See  get_time/1 for the  representation of  absolute
         time.     If   _A_b_s_T_i_m_e  is  earlier  then  the   current  time,
         thread_get_message/3 fails immediately.    Both resolution  and
         maximum wait time is platform-dependent.

    ttiimmeeoouutt((_+_T_i_m_e))
         _T_i_m_e is a  float or integer and  specifies the maximum time  to
         wait in  seconds.    This  is a  relative-time version  of  the
         deadline option.   If  both options are  provided, the  earlier
         time is effective.

         If _T_i_m_e  is 0 or  0.0, thread_get_message/3 examines the  queue
         but does not  suspend if no matching  term is available.   Note
         that unlike  thread_peek_message/2, a  matching term is  removed
         from the queue.

         If  _T_i_m_e < 0,  thread_get_message/3 fails  immediately without
         removing any message from the queue.


tthhrreeaadd__ppeeeekk__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m))                             _[_s_e_m_i_d_e_t_]
    As  thread_peek_message/1,  operating on  a  given  queue.    It  is
    allowed  to peek into another  thread's message queue, an  operation
    that  can be used to check whether a thread has swallowed  a message
    sent to it.


mmeessssaaggee__qquueeuuee__pprrooppeerrttyy((_?_Q_u_e_u_e_, _?_P_r_o_p_e_r_t_y))
    True if _P_r_o_p_e_r_t_y is a property of _Q_u_e_u_e.  Defined properties are:

    aalliiaass((_A_l_i_a_s))
         Queue has the given alias name.

    mmaaxx__ssiizzee((_S_i_z_e))
         Maximum  number of  terms  that  can be  in  the queue.     See
         message_queue_create/2.   This property is not present  if there
         is no limit (default).

    ssiizzee((_S_i_z_e))
         Queue  currently  contains  _S_i_z_e terms.     Note  that  due  to
         concurrent access the returned value may be  outdated before it
         is returned.  It can be used for debugging purposes  as well as
         work distribution purposes.

    The  size(_S_i_z_e)  property  is always  present  and  may be  used  to
    enumerate  the created  message queues.   Note  that this  predicate
    does _n_o_t _e_n_u_m_e_r_a_t_e  threads, but can be used to query the properties
    of the default queue of a thread.

Explicit  message queues  are  designed with  the _w_o_r_k_e_r_-_p_o_o_l  model  in
mind,  where  multiple  threads wait  on  a  single queue  and  pick  up
the first  goal to  execute.   Below  is a  simple implementation  where
the workers  execute arbitrary  Prolog goals.   Note  that this  example
provides no means to tell when all work is done.   This must be realised
using additional synchronisation.

________________________________________________________________________|                                                                        |
|%%      create_workers(?Id, +N)                                         |
|%                                                                       |
|%       Create a pool with Id and number of workers.                    |

|%       After the pool is created, post_job/1 can be used to            |
|%       send jobs to the pool.                                          |
|                                                                        |
|create_workers(Id, N) :-                                                |
|        message_queue_create(Id),                                       |
|        forall(between(1, N, _),                                        |
|               thread_create(do_work(Id), _, [])).                      |
|                                                                        |

|do_work(Id) :-                                                          |
|        repeat,                                                         |
|          thread_get_message(Id, Goal),                                 |
|          (   catch(Goal, E, print_message(error, E))                   |
|          ->  true                                                      |
|          ;   print_message(error, goal_failed(Goal, worker(Id)))       |
|          ),                                                            |

|        fail.                                                           |
|                                                                        |
|%%      post_job(+Id, +Goal)                                            |
|%                                                                       |
|%       Post a job to be executed by one of the pool's workers.         |
|                                                                        |
|post_job(Id, Goal) :-                                                   |
||_______thread_send_message(Id,_Goal)._________________________________ ||


1100..33..22 SSiiggnnaalllliinngg tthhrreeaaddss

These  predicates provide  a mechanism  to make  another thread  execute
some  goal as  an  _i_n_t_e_r_r_u_p_t.    Signalling  threads  is safe  as  these
interrupts  are only  checked at  safe points  in  the virtual  machine.
Nevertheless,   signalling  in  multithreaded  environments  should   be
handled  with  care as  the  receiving  thread  may hold  a  _m_u_t_e_x  (see
with_mutex/2).  Signalling probably only makes sense to  start debugging
threads and to  cancel no-longer-needed threads with throw/1,  where the
receiving thread  should be designed carefully  to handle exceptions  at
any point.


tthhrreeaadd__ssiiggnnaall((_+_T_h_r_e_a_d_I_d_, _:_G_o_a_l))
    Make thread _T_h_r_e_a_d_I_d execute  _G_o_a_l at the first opportunity.  In the
    current  implementation, this implies at the first pass  through the
    _C_a_l_l  _p_o_r_t.  The  predicate thread_signal/2 itself places _G_o_a_l  into
    the signalled thread's signal queue and returns immediately.

    Signals  (interrupts)  do  not  cooperate well  with  the  world  of
    multithreading,  mainly  because  the status  of mutexes  cannot  be
    guaranteed  easily.   At the call port,  the Prolog virtual  machine
    holds no locks and therefore the asynchronous execution is safe.

    _G_o_a_l  can  be  any valid  Prolog  goal,  including throw/1  to  make
    the  receiving thread generate  an exception,  and trace/0 to  start
    tracing the receiving thread.

    In  the Windows version,  the receiving thread immediately  executes
    the  signal  if  it  reaches  a  Windows  GetMessage()  call,  which
    generally happens if the thread is waiting for (user) input.


1100..33..33 TThhrreeaaddss aanndd ddyynnaammiicc pprreeddiiccaatteess

Besides queues  (section ????) threads can  share and exchange data  using
dynamic predicates.   The  multithreaded version  knows about two  types
of  dynamic predicates.     By default,  a  predicate  declared  _d_y_n_a_m_i_c
(see dynamic/1)  is shared  by all  threads.   Each  thread may  assert,
retract and  run the dynamic predicate.   Synchronisation inside  Prolog
guarantees  the consistency  of the  predicate.    Updates are  _l_o_g_i_c_a_l:
visible  clauses  are  not affected  by  assert/retract  after  a  query
started on  the predicate.   In  many cases  primitives from section  ????
should be  used to ensure that  application invariants on the  predicate
are maintained.

Besides shared predicates,  dynamic predicates can be declared  with the
thread_local/1 directive.   Such predicates share their attributes,  but
the clause list is different in each thread.


tthhrreeaadd__llooccaall _+_F_u_n_c_t_o_r_/_+_A_r_i_t_y_, _._._.
    This  directive is  related to the  dynamic/1 directive.   It  tells
    the  system  that  the predicate  may  be modified  using  assert/1,
    retract/1,  etc., during  execution of the program.   Unlike  normal
    shared  dynamic data, however, each  thread has its own clause  list
    for  the predicate.  As a thread starts, this clause list  is empty.
    If  there are still  clauses when the  thread terminates, these  are
    automatically  reclaimed by the system  (see also volatile/1).   The
    thread_local property implies the properties _d_y_n_a_m_i_c and _v_o_l_a_t_i_l_e.

    Thread-local   dynamic  predicates  are  intended  for   maintaining
    thread-specific state or intermediate results of a computation.

    It  is not recommended to  put clauses for a thread-local  predicate
    into  a file, as  in the example below,  because the clause is  only
    visible  from the thread  that loaded  the source file.   All  other
    threads start with an empty clause list.

    ____________________________________________________________________|                                                                    |
    | :- thread_local                                                    |

    |         foo/1.                                                     |
    |                                                                    |
    ||foo(gnat).________________________________________________________ ||

    DDIISSCCLLAAIIMMEERR  Whether or  not this declaration  is appropriate in  the
    sense  of the proper mechanism to  reach the goal is still  debated.
    If you have  strong feelings in favour or against, please share them
    in the SWI-Prolog mailing list.


1100..44 TThhrreeaadd ssyynncchhrroonniissaattiioonn

All  internal Prolog  operations are  thread-safe.    This implies  that
two Prolog  threads can operate  on the  same dynamic predicate  without
corrupting the consistency  of the predicate.   This section deals  with
user-level  _m_u_t_e_x_e_s (called  _m_o_n_i_t_o_r_s  in ADA  or _c_r_i_t_i_c_a_l  _s_e_c_t_i_o_n_s  by
Microsoft).   A mutex is a  MMUUTTual EEXXclusive device, which implies  that
at most one thread can _h_o_l_d a mutex.

Mutexes are  used to  realise related  updates to  the Prolog  database.
With `related', we refer to the situation where  a `transaction' implies
two  or more  changes to  the Prolog  database.   For  example, we  have
a  predicate address/2,  representing the  address of  a  person and  we
want  to change  the address  by retracting  the old  and asserting  the
new address.    Between these  two operations the  database is  invalid:
this person  has either no  address or two  addresses, depending on  the
assert/retract order.

The  code   below  provides  a  solution   to  this  problem  based   on
with_mutex/2.    It  also illustrates  the  problem  of mutexes.     The
predicate with_mutex/2  behaves as once/1  with respect  to the  guarded
goal.   This  means that  our predicate address/2  is no  longer a  nice
logical non-deterministic  relation.  This  could be solved by  explicit
locking and  unlocking a  mutex using  setup_call_cleanup/2,  but at  the
risk of  deadlocking the  program if the  choice point  is left open  by
accident.

________________________________________________________________________|                                                                        |
|change_address(Id, Address) :-                                          |
|        with_mutex(addressbook,                                         |
|                   ( retractall(address(Id, _)),                        |

|                     asserta(address_db(Id, Address))                   |
|                   )).                                                  |
|                                                                        |
|address(Id, Address) :-                                                 |
|        with_mutex(addressbook,                                         |
||__________________address_db(Id,_Address)).___________________________ ||

Message queues  (see message_queue_create/3) often  provide simpler  and
more robust ways  for threads to communicate.   Still, mutexes can be  a
sensible solution and are therefore provided.


mmuutteexx__ccrreeaattee((_?_M_u_t_e_x_I_d))
    Create  a mutex.  If _M_u_t_e_x_I_d  is an atom, a _n_a_m_e_d mutex  is created.
    If  it is  a variable,  an  anonymous mutex  reference is  returned.
    Anonymous mutexes are subject to (atom) garbage collection.


mmuutteexx__ccrreeaattee((_-_M_u_t_e_x_I_d_, _+_O_p_t_i_o_n_s))
    Create a mutex using options.  Defined options are:

    aalliiaass((_A_l_i_a_s))
         Set the  alias name.   Using mutex_create(_X_, _[_a_l_i_a_s_(_n_a_m_e_)_])  is
         preferred over the equivalent mutex_create(_n_a_m_e).


mmuutteexx__ddeessttrrooyy((_+_M_u_t_e_x_I_d))
    Destroy  a mutex.  If the  mutex is not locked, it is  destroyed and
    further  access yields an existence_error exception.  As  of version
    7.1.19,  this behaviour is  reliable.  If  the mutex is locked,  the
    mutex  is sheduled for  _d_e_l_a_y_e_d _d_e_s_t_r_u_c_t_i_o_n:   it will be  destroyed
    when it becomes unlocked.


wwiitthh__mmuutteexx((_+_M_u_t_e_x_I_d_, _:_G_o_a_l))
    Execute  _G_o_a_l  while  holding  _M_u_t_e_x_I_d.     If  _G_o_a_l  leaves  choice
    points,   these are  destroyed  (as  in  once/1).     The  mutex  is
    unlocked  regardless of whether  _G_o_a_l succeeds,  fails or raises  an
    exception.    An exception  thrown by  _G_o_a_l is  re-thrown after  the
    mutex  has been successfully unlocked.   See also mutex_create/1 and
    setup_call_cleanup/3.

    Although  described in the  thread section,  this predicate is  also
    available  in the single-threaded  version, where it behaves  simply
    as once/1.


mmuutteexx__lloocckk((_+_M_u_t_e_x_I_d))
    Lock the mutex.   Prolog mutexes are _r_e_c_u_r_s_i_v_e mutexes:  they can be
    locked  multiple times by the same thread.  Only after  unlocking it
    as  many times as it is  locked does the mutex become available  for
    locking  by other threads.   If another thread has locked the  mutex
    the calling thread is suspended until the mutex is unlocked.

    If  _M_u_t_e_x_I_d is  an atom,  and there  is no current  mutex with  that
    name,  the  mutex  is  created automatically  using  mutex_create/1.
    This implies named mutexes need not be declared explicitly.

    Please  note that  locking and  unlocking mutexes  should be  paired
    carefully.     Especially  make  sure  to  unlock  mutexes  even  if
    the  protected  code  fails  or  raises an  exception.     For  most
    common  cases,  use with_mutex/2,  which provides  a  safer way  for
    handling  Prolog-level mutexes.   The predicate setup_call_cleanup/3
    is  another  way  to guarantee  that  the  mutex is  unlocked  while
    retaining non-determinism.


mmuutteexx__ttrryylloocckk((_+_M_u_t_e_x_I_d))
    As  mutex_lock/1,  but if the mutex  is held by another thread,  this
    predicates fails immediately.


mmuutteexx__uunnlloocckk((_+_M_u_t_e_x_I_d))
    Unlock  the mutex.  This can only be called if the mutex  is held by
    the  calling thread.   If this is  not the case,  a permission_error
    exception is raised.


mmuutteexx__uunnlloocckk__aallll                                            _[_d_e_p_r_e_c_a_t_e_d_]
    Unlock  all mutexes  held by  the current  thread.   This  predicate
    should  not  be   needed  if  mutex  unlocking  is  guaranteed  with
    with_mutex/2 or setup_call_cleanup/3.


mmuutteexx__pprrooppeerrttyy((_?_M_u_t_e_x_I_d_, _?_P_r_o_p_e_r_t_y))
    True if _P_r_o_p_e_r_t_y is a property of _M_u_t_e_x_I_d.  Defined properties are:

    aalliiaass((_A_l_i_a_s))
         Mutex has the defined alias name.  See mutex_create/2 using the
         `alias' option.

    ssttaattuuss((_S_t_a_t_u_s))
         Current status  of the mutex.    One of unlocked  if the  mutex
         is currently not  locked, or locked(_O_w_n_e_r_,  _C_o_u_n_t) if mutex  is
         locked _C_o_u_n_t times by thread _O_w_n_e_r.  Note that  unless _O_w_n_e_r is
         the calling thread, the  locked status can change at  any time.
         There is  no useful  application of this  property, except  for
         diagnostic purposes.


1100..55 TThhrreeaadd ssuuppppoorrtt lliibbrraarryy((tthhrreeaadduuttiill))

This library  defines a  couple of useful  predicates for  demonstrating
and debugging  multithreaded applications.   This  library is  certainly
not complete.


tthhrreeaaddss
    Lists all current threads and their status.


jjooiinn__tthhrreeaaddss
    Join all terminated  threads.  For normal applications, dealing with
    terminated  threads must be  part of  the application logic,  either
    detaching  the thread before termination  or making sure it will  be
    joined.   The  predicate join_threads/0 is intended for  interactive
    sessions  to reclaim resources  from threads that died  unexpectedly
    during development.


iinntteerraaccttoorr
    Create  a new  console  and run  the Prolog  top level  in this  new
    console.   See also attach_console/0.  In the Windows version  a new
    interactor can also be created from the Run/New thread menu.


1100..55..11 DDeebbuuggggiinngg tthhrreeaaddss

Support for debugging  threads is still very  limited.  Debug and  trace
mode are flags  that are local to each  thread.  Individual threads  can
be debugged either using the graphical debugger described  in section ????
(see tspy/1  and friends) or  by attaching a console  to the thread  and
running the  traditional command  line debugger  (see attach_console/0).
When using the graphical debugger, the debugger must  be _l_o_a_d_e_d from the
main thread (for example using guitracer) before gtrace/0  can be called
from a thread.


aattttaacchh__ccoonnssoollee
    If  the  current thread  has no  console  attached yet,  attach  one
    and  redirect the  user streams (input,  output, and  error) to  the
    new  console  window.   On  Unix  systems the  console is  an  xterm
    application.    On  Windows systems  this requires  the GUI  version
    swipl-win.exe rather than the console-based swipl.exe.

    This  predicate has  a couple  of useful applications.    One is  to
    separate (debugging) I/O  of different threads.  Another is to start
    debugging  a thread that  is running in the  background.  If  thread
    10  is running,  the following  sequence starts the  tracer on  this
    thread:

    ____________________________________________________________________|                                                                    |
    ||?-_thread_signal(10,_(attach_console,_trace)).____________________ ||


ttddeebbuugg((_+_T_h_r_e_a_d_I_d))
    Prepare  _T_h_r_e_a_d_I_d for debugging  using the graphical  tracer.   This
    implies installing the  tracer hooks in the thread and switching the
    thread  to debug  mode using  debug/0.   The call  is injected  into
    the  thread using thread_signal/2.   We  refer to the  documentation
    of  this predicate for asynchronous  interaction with threads.   New
    threads  created  inherit  their debug  mode  from the  thread  that
    created them.


ttddeebbuugg
    Call tdebug/1 in all running threads.


ttnnooddeebbuugg((_+_T_h_r_e_a_d_I_d))
    Disable debugging thread _T_h_r_e_a_d_I_d.


ttnnooddeebbuugg
    Disable debugging in all threads.


ttssppyy((_:_S_p_e_c_, _+_T_h_r_e_a_d_I_d))
    Set  a spy point as spy/1 and enable the thread for  debugging using
    tdebug/1.   Note that  a spy point is  a global flag on a  predicate
    that  is visible from all threads.   Spy points are honoured  in all
    threads  that are in debug mode  and ignored in threads that are  in
    nodebug mode.


ttssppyy((_:_S_p_e_c))
    Set  a  spy point  as  spy/1 and  enable  debugging in  all  threads
    using  tdebug/0.   Note that removing spy  points can be done  using
    nospy/1.   Disabling spy points in a specific thread is  achieved by
    tnodebug/1.


1100..55..22 PPrrooffiilliinngg tthhrreeaaddss

In the  current implementation, at  most one thread  can be profiled  at
any moment.   Any thread can call profile/1 to profile the  execution of
some part of  its code.   The predicate tprofile/1 allows for  profiling
the execution of another thread until the user  stops collecting profile
data.


ttpprrooffiillee((_+_T_h_r_e_a_d_I_d))
    Start  collecting profile data in _T_h_r_e_a_d_I_d  and ask the user to  hit
    <_r_e_t_u_r_n>  to stop the profiler.   See section ????  for details on the
    execution profiler.


1100..66 MMuullttiitthhrreeaaddeedd mmiixxeedd CC aanndd PPrroolloogg aapppplliiccaattiioonnss

All  foreign code  linked to  the multithreading  version of  SWI-Prolog
should  be   thread-safe  (_r_e_e_n_t_r_a_n_t)   or  guarded   in  Prolog   using
with_mutex/2 from  simultaneous  access  from multiple  Prolog  threads.
If  you want  to write  mixed multithreaded  C  and Prolog  applications
you  should  first  familiarise  yourself  with   writing  multithreaded
applications in C (C++).

If you  are using SWI-Prolog  as an embedded  engine in a  multithreaded
application you  can access the Prolog  engine from multiple threads  by
creating an _e_n_g_i_n_e in  each thread from which you call Prolog.   Without
creating an engine, a thread can only use functions that  do _n_o_t use the
term_t type (for example PL_new_atom()).

The  system supports  two models.    Section ????  describes the  original
one-to-one mapping.   In this schema  a native thread attaches a  Prolog
thread if  it needs  to call Prolog  and detaches it  when finished,  as
opposed to the  model from section ????,  where threads temporarily use  a
Prolog engine.


1100..66..11 AA PPrroolloogg tthhrreeaadd ffoorr eeaacchh nnaattiivvee tthhrreeaadd ((oonnee--ttoo--oonnee))

In  the  one-to-one  model,   the  thread  that  called  PL_initialise()
has  a  Prolog   engine  attached.      If  another  C  thread  in   the
system  wishes to  call Prolog  it  must first  attach an  engine  using
PL_thread_attach_engine() and call  PL_thread_destroy_engine()after  all
Prolog work is  finished.  This  model is especially suitable with  long
running threads that need  to do Prolog work regularly.  See  section ????
for the alternative many-to-many model.


int PPLL__tthhrreeaadd__sseellff()
    Returns  the  integer  Prolog identifier  of  the  engine or  -1  if
    the  calling thread has  no Prolog  engine.   This function is  also
    provided  in the  single-threaded version  of  SWI-Prolog, where  it
    returns -2.


int PPLL__uunniiffyy__tthhrreeaadd__iidd(_t_e_r_m___t _t_, _i_n_t _i)
    Unify  _t with the  Prolog thread  identifier for thread  _i.   Thread
    identifiers  are normally returned  from PL_thread_self().   Returns
    -1 if the thread does not exist or the unification fails.


int PPLL__tthhrreeaadd__aattttaacchh__eennggiinnee(_c_o_n_s_t _P_L___t_h_r_e_a_d___a_t_t_r___t _*_a_t_t_r)
    Creates  a new Prolog engine in the calling thread.  If  the calling
    thread  already has an engine the  reference count of the engine  is
    incremented.  The  _a_t_t_r argument can be NULL to create a thread with
    default  attributes.  Otherwise it is a pointer to a  structure with
    the  definition below.   For any field  with value `0', the  default
    is  used.    The cancel  field may  be filled  with a  pointer to  a
    function  that is  called when  PL_cleanup() terminates the  running
    Prolog  engines.  If this  function is not present or returns  FALSE
    pthread_cancel() is  used.   The flags  field defines the  following
    flags:

    PPLL__TTHHRREEAADD__NNOO__DDEEBBUUGG
         If this flag is  present, the thread starts in  normal no-debug
         status.   By default,  the debug status  is inherited from  the
         main thread.

    ____________________________________________________________________|                                                                    |
    | typedef struct                                                     |

    | { size_t    stack_limit;                /* Total stack limit (bytes)|*/
    |   size_t    table_space;                /* Total tabling space limit|(bytes) */
    |   char *    alias;                      /* alias name */           |
    |   int       (*cancel)(int thread);                                 |
    |   intptr_t  flags;                                                 |
    ||}_PL_thread_attr_t;_______________________________________________ ||

    The  structure may be  destroyed after PL_thread_attach_engine() has
    returned.    On success  it returns  the Prolog  identifier for  the
    thread  (as returned by PL_thread_self()).   If an error occurs,  -1
    is returned.   If this Prolog is not compiled for multithreading, -2
    is returned.


int PPLL__tthhrreeaadd__ddeessttrrooyy__eennggiinnee()
    Destroy  the  Prolog engine  in  the calling  thread.    Only  takes
    effect  if  PL_thread_destroy_engine() is called  as many  times  as
    PL_thread_attach_engine() in this thread.   Returns TRUE on  success
    and  FALSE if the calling thread  has no engine or this Prolog  does
    not support threads.

    Please  note  that  construction  and  destruction  of  engines  are
    relatively  expensive  operations.     Only  destroy  an  engine  if
    performance is not critical and memory is a critical resource.


int PPLL__tthhrreeaadd__aatt__eexxiitt(_v_o_i_d _(_*_f_u_n_c_t_i_o_n_)_(_v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e_, _i_n_t _g_l_o_b_a_l)
    Register  a handle to be called  as the Prolog engine is  destroyed.
    The  handler function  is called  with one  void * argument  holding
    _c_l_o_s_u_r_e.    If  _g_l_o_b_a_l is  TRUE, the  handler is  installed _f_o_r  _a_l_l
    _t_h_r_e_a_d_s.     Globally  installed handlers  are  executed  after  the
    thread-local  handlers.  If the  handler is installed local for  the
    current thread only (_g_l_o_b_a_l  == FALSE) it is stored in the same FIFO
    queue as used by thread_at_exit/1.


1100..66..22 PPoooolliinngg PPrroolloogg eennggiinneess ((mmaannyy--ttoo--mmaannyy))

In this model Prolog engines live as entities that  are independent from
threads.  If a  thread needs to call Prolog it takes one of  the engines
from the pool and returns the engine when done.   This model is suitable
in the following identified cases:

  o _C_o_m_p_a_t_i_b_i_l_i_t_y _w_i_t_h _t_h_e _s_i_n_g_l_e_-_t_h_r_e_a_d_e_d _v_e_r_s_i_o_n
    In  the  single-threaded  version,  foreign threads  must  serialise
    access  to the  one and  only thread engine.    Functions from  this
    section allow sharing one engine among multiple threads.

  o _M_a_n_y _n_a_t_i_v_e _t_h_r_e_a_d_s _w_i_t_h _i_n_f_r_e_q_u_e_n_t _P_r_o_l_o_g _w_o_r_k
    Prolog  threads are expensive in terms of memory and time  to create
    and  destroy them.  For systems  that use a large number  of threads
    that only infrequently need  to call Prolog, it is better to take an
    engine from a pool and return it there.

  o _P_r_o_l_o_g _s_t_a_t_u_s _m_u_s_t _b_e _h_a_n_d_e_d _t_o _a_n_o_t_h_e_r _t_h_r_e_a_d
    This  situation  has  been identified  by  Uwe Lesta  when  creating
    a  .NET interface  for SWI-Prolog.    .NET distributes  work for  an
    active  internet connection over  a pool  of threads.   If a  Prolog
    engine  contains the state for a connection, it must be  possible to
    detach  the engine from a thread and re-attach it to  another thread
    handling the same connection.


PL_engine_t PPLL__ccrreeaattee__eennggiinnee(_P_L___t_h_r_e_a_d___a_t_t_r___t _*_a_t_t_r_i_b_u_t_e_s)
    Create  a  new   Prolog  engine.     _a_t_t_r_i_b_u_t_e_s  is  described  with
    PL_thread_attach_engine().   Any  thread can  make  this call  after
    PL_initialise()  returns  success.    The  returned  engine  is  not
    attached  to any thread and lives  until PL_destroy_engine()is  used
    on the returned handle.

    In  the  single-threaded  version  this call  always  returns  NULL,
    indicating failure.


int PPLL__ddeessttrrooyy__eennggiinnee(_P_L___e_n_g_i_n_e___t _e)
    Destroy  the given engine.  Destroying an engine is only  allowed if
    the engine is not  attached to any thread or attached to the calling
    thread.    On success  this function  returns TRUE,  on failure  the
    return value is FALSE.


int PPLL__sseett__eennggiinnee(_P_L___e_n_g_i_n_e___t _e_n_g_i_n_e_, _P_L___e_n_g_i_n_e___t _*_o_l_d)
    Make  the calling thread ready  to use _e_n_g_i_n_e.   If _o_l_d is  non-NULL
    the  current engine  associated with  the calling  thread is  stored
    at  the  given  location.     If  _e_n_g_i_n_e equals  PL_ENGINE_MAIN  the
    initial  engine is attached  to the  calling thread.   If _e_n_g_i_n_e  is
    PL_ENGINE_CURRENT the  engine is  not  changed.   This  can be  used
    to  query the current  engine.   This call  returns PL_ENGINE_SET  if
    the  engine was switched successfully,  PL_ENGINE_INVAL if _e_n_g_i_n_e  is
    not  a  valid engine  handle and  PL_ENGINE_INUSE  if  the engine  is
    currently in use by another thread.

    Engines  can be changed  at any time.   For  example, it is  allowed
    to  select an engine to initiate a  Prolog goal, detach it and  at a
    later  moment execute the goal from another thread.   Note, however,
    that  the term_t, qid_t and fid_t types are interpreted relative  to
    the  engine for which they are created.  Behaviour when  passing one
    of these types from one engine to another is undefined.

    In  the single-threaded  version this call  only succeeds if  _e_n_g_i_n_e
    refers to the main engine.


1100..77 MMuullttiitthhrreeaaddiinngg aanndd tthhee XXPPCCEE ggrraapphhiiccss ssyysstteemm

GUI applications  written in  XPCE can  benefit from  Prolog threads  if
they need  to do expensive computations  that would otherwise block  the
UI. The  XPCE message  passing system  is guarded with  a single  _m_u_t_e_x,
which synchronises  both access from Prolog  and activation through  the
GUI. In MS-Windows, GUI events are processed by  the thread that created
the  window in  which  the  event occurred,  whereas  in  Unix/X11  they
are processed  by the  thread that  dispatches messages.   In  practice,
the most  feasible approach  to graphical Prolog  implementations is  to
control XPCE from  a single thread and  deploy other threads for  (long)
computations.

Traditionally,  XPCE runs  in  the foreground  (main) thread.    We  are
working  towards  a  situation where  XPCE  can  run  comfortably  in  a
separate  thread.     A  separate  XPCE  thread  can  be  created  using
pce_dispatch/1.  It is also possible to create this thread  as the (pce)
is loaded by setting the xpce_threaded to true.

Threads other than the  thread in which XPCE runs are provided  with two
predicates to communicate with XPCE.


iinn__ppccee__tthhrreeaadd((_:_G_o_a_l))                                               _[_d_e_t_]
    Assuming  XPCE is running in the foreground thread, this  call gives
    background  threads  the  opportunity  to make  calls  to  the  XPCE
    thread.    A call to  in_pce_thread/1 succeeds immediately,  copying
    _G_o_a_l  to the XPCE  thread.   _G_o_a_l is added to  the XPCE event  queue
    and  executed  synchronous to  normal user  events  like typing  and
    clicking.


iinn__ppccee__tthhrreeaadd__ssyynncc((_:_G_o_a_l))                                       _[_s_e_m_i_d_e_t_]
    Same  as  in_pce_thread/1,  but  wait  for  _G_o_a_l  to  be  completed.
    Success  depends  on  the  success  of executing  _G_o_a_l.     Variable
    bindings  inside  _G_o_a_l are  visible to  the  caller, but  it  should
    be  noted that  the values  are being  _c_o_p_i_e_d.   If  _G_o_a_l throws  an
    exception,  this exception is re-thrown by  in_pce_thread/1.   If the
    calling  thread is the `pce thread', in_pce_thread_sync/1 executes a
    direct meta-call.  See also pce_thread/1.

    Note   that  in_pce_thread_sync/1  is  expensive   because  it   re-
    quires   copying   and  thread   communication.       For   example,
    in_pce_thread_synctrue runs at approximately 50,000 calls per second
    (AMD Phenom 9600B, Ubuntu 11.04).


ppccee__ddiissppaattcchh((_+_O_p_t_i_o_n_s))
    Create  a  Prolog thread  with the  alias name  pce  for XPCE  event
    handling.    In  the X11  version this  call creates  a thread  that
    executes  the X11  event-dispatch loop.   In  MS-Windows it  creates
    a  thread that  executes a windows  event-dispatch loop.   The  XPCE
    event-handling  thread has  the alias  pce.   _O_p_t_i_o_n_s specifies  the
    thread attributes as thread_create/3.


CChhaapptteerr 1111..  CCOORROOUUTTIINNIINNGG UUSSIINNGG PPRROOLLOOGG EENNGGIINNEESS

Where the  term _c_o_r_o_u_t_i_n_e in Prolog  typically refer to hooks  triggered
by  _a_t_t_r_i_b_u_t_e_d _v_a_r_i_a_b_l_e_s  (section ????),  SWI-Prolog  provides two  other
forms of  coroutines.   Delimited continuations  (see section ????)  allow
creating coroutines  that run  in the  same Prolog  engine by  capturing
and restarting the _c_o_n_t_i_n_u_a_t_i_o_n.   This section discusses _e_n_g_i_n_e_s,  also
known as _i_n_t_e_r_a_c_t_o_r_s.   The idea was pinned by Paul Tarau [??].   The API
described in this chapter has been established together  with Paul Tarau
and Paulo Moura.

Engines are  closely related to _t_h_r_e_a_d_s  (section ????).   An engine is  a
Prolog virtual  machine that has  its own  stacks and (virtual)  machine
state.   Unlike normal  Prolog threads though,  they are not  associated
with an operating system thread.  Instead, you _a_s_k an  engine for a next
answer (engine_next/2).  Asking  an engine for the next  answer attaches
the engine to  the calling operating system  thread and cause it to  run
until the engine  calls engine_yield/1 or its associated goal  completes
with an  answer, failure or an  exception.   After the engine yields  or
completes,  it is  detached from  the operating  system  thread and  the
answer term  is made  available to  the calling thread.    Communicating
with an engine is  similar to communicating with a Prolog  system though
the  terminal.    In  this sense  engines  are  related to  _P_e_n_g_i_n_e_s  as
provided  by library  pengines,  but  where  Pengines aim  primarily  at
accessing Prolog  engines through  the network,  engines are  in-process
entities.


1111..11 EExxaammpplleess uussiinngg eennggiinneess

We  introduce engines  by  describing  application areas  and  providing
simple example programs.  The predicates are defined in section  ????.  We
identify the following application areas for engines.

 1. Aggregating solutions from one or more goals.  See section ????.

 2. Access the terms  produced in _f_o_r_w_a_r_d _e_x_e_c_u_t_i_o_n through backtracking
    without  collecting all of them first.  Section ????  illustrates this
    as well.

 3. State accumulation and sharing.  See section ????.

 4. Scalable many-agent applications.  See section ????.


1111..11..11 AAggggrreeggaattiioonn uussiinngg eennggiinneess

Engines  can be  used  to reason  about  solutions  produced by  a  goal
through backtracking.   In  this scenario we create  an engine with  the
goal we wish to  backtrack over and we enumerate all its  solution using
engine_next/1.    This usage  scenario competes  with the  all  solution
predicates (findall/3, bagof/3,  etc.)  and the predicates  from library
aggregate.  Below we implement findall/3 using engines.

________________________________________________________________________|                                                                        |
|findall(Templ, Goal, List) :-                                           |

|        setup_call_cleanup(                                             |
|            engine_create(Templ, Goal, E),                              |
|            get_answers(E, List),                                       |
|            engine_destroy(E)).                                         |
|                                                                        |
|get_answers(E, [H|T]) :-                                                |
|        engine_next(E, H), !,                                           |
|        get_answers(E, T).                                              |

|get_answers(_,|[]).____________________________________________________ |              |

The above is not a particularly attractive alternative  for the built-in
findall/3.    It  is  mostly  slower  due to  time  required  to  create
and  destroy the  engine  as well  as  the (currently)  higher  overhead
of  copying terms  between engines  than the  overhead  required by  the
dedicated representation used by findall/3.

It gets  more interesting if  we wish to  combine answers from  multiple
backtracking  predicates.    Assume  we have  two  predicates  that,  on
backtracking,  return ordered solutions  and we  wish to  merge the  two
answer streams into  a single ordered stream  of answers.  The  solution
in classical  Prolog is  below.   It collects both  answer sets,  merges
them  using ordered  set merging  and extract  the answers.    The  code
is  clean and  short, but  it doesn't  produce any  answers before  both
generaters are fully enumerated and it uses memory  that is proportional
to the combined set of answers.

________________________________________________________________________|                                                                        |

|:- meta_predicate merge(?,0, ?,0, -).                                   |
|                                                                        |
|merge_answers(T1,G1, T2,G2, A) :-                                       |
|        findall(T1, G1, L1),                                            |
|        findall(T2, G2, L2),                                            |
|        ord_union(L1, L2, Ordered),                                     |

||_______member(A,_Ordered).____________________________________________ ||

We  can achieve  the same  using  engines.   We  create  two engines  to
generate the  solutions to both our  generators.   Now, we cas ask  both
for an  answer, put the smallest  in the answer  set and ask the  engine
that created  the smallest for its  next answer, etc.   This way we  can
create an  ordered list of  answers as above,  but now without  creating
intermediate lists.    We can  avoid creating the  intermediate list  by
introducing a third  engine that controls the two generators  and _y_i_e_l_d_s
the answers  rather than  putting them in  a list.   This  is a  general
example  of turning  a  predicate that  builds a  set  of terms  into  a
non-deterministic predicate that  produces the results on  backtracking.
The full  code is below.   Merging the  answers of two generators,  each
generating a set of  10,000 integers is currently about 20%  slower than
the code  above, but  the engine-based solution  runs in constant  space
and generates the  first solution immediately after both our  generators
have produced their first solution.

________________________________________________________________________|                                                                        |
|:- meta_predicate merge(?,0, ?,0, -).                                   |
|                                                                        |
|merge(T1,G1, T2,G2, A) :-                                               |
|        engine_create(A, merge(T1,G1, T2,G2), E),                       |
|        repeat,                                                         |

|            (   engine_next(E, A)                                       |
|            ->  true                                                    |
|            ;   !, fail                                                 |
|            ).                                                          |
|                                                                        |
|merge(T1,G1, T2,G2) :-                                                  |
|        engine_create(T1, G1, E1),                                      |

|        engine_create(T2, G2, E2),                                      |
|        (   engine_next(E1, S1)                                         |
|        ->  (   engine_next(E2, S2)                                     |
|            ->  order_solutions(S1, S2, E1, E2)                         |
|            ;   yield_remaining(S1, E1)                                 |
|            )                                                           |
|        ;   engine_next(E2, S2),                                        |
|            yield_remaining(S2, E2)                                     |

|        ).                                                              |
|                                                                        |
|order_solutions(S1, S2, E1, E2) :- !,                                   |
|        (   S1 @=< S2                                                   |
|        ->  engine_yield(S1),                                           |
|            (   engine_next(E1, S11)                                    |
|            ->  order_solutions(S11, S2, E1, E2)                        |

|            ;   yield_remaining(S2, E2)                                 |
|            )                                                           |
|        ;   engine_yield(S2),                                           |
|            (   engine_next(E2, S21)                                    |
|            ->  order_solutions(S1, S21, E1, E2)                        |
|            ;   yield_remaining(S1, E1)                                 |
|            )                                                           |
|        ).                                                              |

|                                                                        |
|yield_remaining(S, E) :-                                                |
|        engine_yield(S),                                                |
|        engine_next(E, S1),                                             |
||_______yield_remaining(S1,_E).________________________________________ ||


1111..11..22 SSttaattee aaccccuummuullaattiioonn uussiinngg eennggiinneess

Applications that need to manage a state can do so  by passing the state
around in  an additional argument,  storing it in  a global variable  or
update it in the  dynamic database using assertz/1 and retract/1.   Both
using an  additional argument  and a  global variable  (see b_setval/2),
make  the state  subject  to backtracking.    This  may  or may  not  be
desirable.    If  having a  state is  that  subject to  backtracking  is
required, using an additional argument or  backtrackable global variable
is the  right approach.   Otherwise, non-backtrackable global  variables
(nb_setval/2) and dynamic database  come into the picture, where  global
variables are always local  to a thread and the dynamic database  may or
may not be shared between threads (see thread_local/1).

Engines bring  an alternative that  packages a  state inside the  engine
where it is typically represented in a (threaded) Prolog  variable.  The
state may be updated, while controlled backtracking to  a previous state
belongs to the possibilities.  It can be accessed  and updated by anyone
with access to the engines' handle.  Using an  engine to represent state
has the following advantages:

  o The  programming  style  needed  inside  the  engine  is  much  more
    `Prolog  friendly',  using  engine_fetch/1  to read  a  request  and
    engine_yield/1 to reply to it.

  o The state is packaged and subject to (atom) garbage collection.

  o The  state may be  accessed from  multiple threads.   Access to  the
    state is synchronized without the need for explicit locks.

The example  below implements a  shared priority  heap based on  library
heaps.   The predicate update_heap/1 shows  the typical update loop  for
maintaining state inside an engine:  fetch a command,  update the state,
yield with  the reply  and call  the updater  recursively.   The  update
step is  guarded against  failure.   For robustness  one may also  guard
it against  exceptions using catch/3.   Note that heap_get/2 passes  the
_P_r_i_o_r_i_t_y and  _K_e_y it wishes  to delete  from the heap  such that if  the
unification fails, the heap remains unchanged.

The resulting heap is  a global object with either a named  or anonymous
handle that evolves independently from the Prolog  thread(s) that access
it.    If  the  heap is  anonymous,  it  is subject  to  (atom)  garbage
collection.

________________________________________________________________________|                                                                        |

|:- use_module(library(heaps)).                                          |
|                                                                        |
|create_heap(E) :-                                                       |
|        empty_heap(H),                                                  |
|        engine_create(_, update_heap(H), E).                            |
|                                                                        |
|update_heap(H) :-                                                       |

|        engine_fetch(Command),                                          |
|        (   update_heap(Command, Reply, H, H1)                          |
|        ->  true                                                        |
|        ;   H1 = H,                                                     |
|            Reply = false                                               |
|        ),                                                              |
|        engine_yield(Reply),                                            |

|        update_heap(H1).                                                |
|                                                                        |
|update_heap(add(Priority, Key), true, H0, H) :-                         |
|        add_to_heap(H0, Priority, Key, H).                              |
|update_heap(get(Priority, Key), Priority-Key, H0, H) :-                 |
|        get_from_heap(H0, Priority, Key, H).                            |
|                                                                        |
|heap_add(Priority, Key, E) :-                                           |

|        engine_post(E, add(Priority, Key), true).                       |
|                                                                        |
|heap_get(Priority, Key, E) :-                                           |
||_______engine_post(E,_get(Priority,_Key),_Priority-Key).______________ ||


1111..11..33 SSccaallaabbllee mmaannyy--aaggeenntt aapppplliiccaattiioonnss

The final application  area we touch are  agent systems were we wish  to
capture an  agent in a  Prolog goal.   Such  systems can be  implemented
using  threads  (see  section  ????)  that use  thread_send_message/2  and
thread_get_message/1 to communicate.    The  main problem  is that  each
thread is  associated by an  operating system thread.   OS threads  are,
depending on the OS,  relatively expensive.  Scalability of  this design
typically ends,  depending on OS and  hardware, somewhere between  1,000
and 100,000 agents.

Engines provide  an alternative.    A detached  Prolog engine  currently
requires  approximately 20  Kbytes memory  on 64  bit hardware,  growing
with the size of the Prolog stacks.  The Prolog  stacks may be minimised
by calling garbage_collect/0 followed by trim_stacks/0, providing a _d_e_e_p
_s_l_e_e_p mode.   The set  of agents, each represented  by an engine can  be
controlled by  a static  or dynamic  pool of  threads.   Scheduling  the
execution of agents  and their communication is completely open  and can
be optimised to satisfy the requirements of the application.

    This  section needs an example.  Preferably something that fits
    on  one page and would not scale using  threads.  Engines might
    work  nice to implement  _A_n_t_r_a_n_k_:  _A_n _a_n_t  _c_o_l_o_n_y _a_l_g_o_r_i_t_h_m _f_o_r
    _r_a_n_k_i_n_g _w_e_b _p_a_g_e_s.


1111..22 EEnnggiinnee rreessoouurrccee uussaaggee

A  Prolog engine  consists  of a  virtual  machine state  that  includes
the  Prolog  stacks.     An  `empty'  engine  requires  aout  20  KBytes
of  memory.    This grows  when  the  engine requires  additional  stack
space.   Anonymous engines are subject  to atom garbage collection  (see
garbage_collect_atoms/0).    Engines may be  reclaimed immediately  using
engine_destroy/1.  Calling engine_destroy/1 destroys the virtual machine
state,  while the  handle itself  is left  to  atom garbage  collection.
The  virtual machine  is reclaimed  as soon  as an  engine produced  its
last result,  failed or raised an  exception.   This implies that it  is
only advantageous  to call  engine_destroy/1 explicitly if  you are  not
interested in further answers.

Engines that are expected  to be left in inactive state for  a prelonged
time can  be minimized  by calling garbage_collect/0  and trimm_stacks/0
(in that order) before calling engine_yield/1 or succeeding.


1111..33 EEnnggiinnee pprreeddiiccaattee rreeffeerreennccee

This section documents  the built-in predicates that deal with  engines.
In addition to these,  most predicates dealing with threads  and message
queue can be used to access engines.


eennggiinnee__ccrreeaattee((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _?_E_n_g_i_n_e))                           _[_d_e_t_]


eennggiinnee__ccrreeaattee((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_E_n_g_i_n_e_, _+_O_p_t_i_o_n_s))                 _[_d_e_t_]
    Create a new engine  and unify _E_n_g_i_n_e with a handle to it.  _T_e_m_p_l_a_t_e
    and  _G_o_a_l  form a  pair  similar to  findall/3:   the  instantiation
    of  _T_e_m_p_l_a_t_e  becomes  available  though  engine_next/2  after  _G_o_a_l
    succeeds.    _O_p_t_i_o_n_s  is  a list  of  the following  options.    See
    thread_create/3 for details.

    aalliiaass((_+_N_a_m_e))
         Give the engine a name.  _N_a_m_e must be an atom.   If this option
         is provided, _E_n_g_i_n_e is unified  with _N_a_m_e.  The name  space for
         engines is shared with threads and mutexes.

    ssttaacckk((_+_B_y_t_e_s))
         Set the stack limit for  the engine.  The default  is inherited
         from the calling thread.

    The  _E_n_g_i_n_e argument  of engine_create/3 may  be instantiated to  an
    atom, creating an engine with the given alias.


eennggiinnee__ddeessttrrooyy((_+_E_n_g_i_n_e))                                            _[_d_e_t_]
    Destroy _E_n_g_i_n_e.


eennggiinnee__nneexxtt((_+_E_n_g_i_n_e_, _-_T_e_r_m))                                    _[_s_e_m_i_d_e_t_]
    Ask the engine _E_n_g_i_n_e  to produce a next answer.  On this first call
    on  a specific  engine, the _G_o_a_l  of the engine  is started.   If  a
    previous  call returned  an answer through  completion, this  causes
    the  engine  to backtrack  and finally,  if  the engine  produces  a
    previous  result using engine_yield/1, execution proceeds after  the
    engine_yield/1 call.


eennggiinnee__nneexxtt__rreeiiffiieedd((_+_E_n_g_i_n_e_, _-_T_e_r_m))                                _[_d_e_t_]
    Similar  to  engine_next/2,  but  instead  of  success,  failure  or
    or  raising  an  exception,  _T_e_r_m  is  unified  with  one  of  terms
    below.   This predicate is provided primarily for compatibility with
    Lean Prolog.

    tthhee((_A_n_s_w_e_r))
         Goal succeeded with  _T_e_m_p_l_a_t_e bound to  _A_n_s_w_e_r or Goal  yielded
         with a term _A_n_s_w_e_r.

    nnoo
         Goal failed.

    eexxcceeppttiioonn((_E_x_c_e_p_t_i_o_n))
         Goal raises the error _E_x_c_e_p_t_i_o_n.


eennggiinnee__ppoosstt((_+_E_n_g_i_n_e_, _+_T_e_r_m))                                        _[_d_e_t_]
    Make _T_e_r_m  available to engine_fetch/1inside the _E_n_g_i_n_e.   This call
    must  be followed  by a call  to engine_next/2 and  the engine  must
    call engine_fetch/1.


eennggiinnee__ppoosstt((_+_E_n_g_i_n_e_, _+_T_e_r_m_, _-_R_e_p_l_y))                                _[_d_e_t_]
    Combines engine_post/2 and engine_next/2.


eennggiinnee__yyiieelldd((_+_T_e_r_m))                                                _[_d_e_t_]
    Called  from within the engine, causing engine_next/2 in  the caller
    to  return with  _T_e_r_m.   A subsequent  call to  engine_next/2 causes
    engine_yield/1 to  `return'.  This  predicate can only be called  if
    the  engine is not  involved in  a callback from  C, i.e., when  the
    engine  calls a predicate defined in C that calls back Prolog  it is
    not  possible to use this predicate.   Trying to do so results  in a
    permission_error exception.


eennggiinnee__ffeettcchh((_-_T_e_r_m))                                                _[_d_e_t_]
    Called  from within  the  engine to  fetch the  term made  available
    through  engine_post/2or engine_post/3.  If no term  is available an
    existence_error exception is raised.


eennggiinnee__sseellff((_-_E_n_g_i_n_e))                                               _[_d_e_t_]
    Called  from within the  engine to get access  to the handle to  the
    engine itself.


iiss__eennggiinnee((_@_T_e_r_m))                                               _[_s_e_m_i_d_e_t_]
    True  if _T_e_r_m is  a reference to  or the alias  name of an  existing
    engine.


ccuurrrreenntt__eennggiinnee((_-_E_n_g_i_n_e))                                         _[_n_o_n_d_e_t_]
    True when _E_n_g_i_n_e is an existing engine.


CChhaapptteerr 1122..  FFOORREEIIGGNN LLAANNGGUUAAGGEE IINNTTEERRFFAACCEE

SWI-Prolog  offers a  powerful interface  to C  [??].    The main  design
objectives  of  the  foreign  language  interface  are  flexibility  and
performance.   A foreign  predicate is  a C function  that has the  same
number  of arguments  as the  predicate represented.    C functions  are
provided to analyse the  passed terms, convert them to basic C  types as
well as to  instantiate arguments using unification.   Non-deterministic
foreign predicates are supported, providing the foreign  function with a
handle to control backtracking.

C can call  Prolog predicates, providing both  a query interface and  an
interface to extract multiple solutions from  a non-deterministic Prolog
predicate.    There is  no limit  to the  nesting of  Prolog calling  C,
calling Prolog, etc.   It is also possible to write the `main' in  C and
use Prolog as an embedded logical engine.


1122..11 OOvveerrvviieeww ooff tthhee IInntteerrffaaccee

A special include file called SWI-Prolog.h should be included  with each
C source  file that  is to be  loaded via  the foreign interface.    The
installation process installs this file in the directory  include in the
SWI-Prolog home directory (?- current_prolog_flag(home, Home).).  This C
header file  defines various data types,  macros and functions that  can
be used  to communicate with  SWI-Prolog.  Functions  and macros can  be
divided into the following categories:

  o Analysing Prolog terms

  o Constructing new terms

  o Unifying terms

  o Returning control information to Prolog

  o Registering foreign predicates with Prolog

  o Calling Prolog from C

  o Recorded database interactions

  o Global actions on Prolog (halt, break, abort, etc.)


1122..22 LLiinnkkiinngg FFoorreeiiggnn MMoodduulleess

Foreign modules  may be  linked to  Prolog in two  ways.   Using  _s_t_a_t_i_c
_l_i_n_k_i_n_g, the extensions,  a (short) file defining main()  which attaches
the extension  calls to  Prolog, and the  SWI-Prolog kernel  distributed
as a  C library, are linked  together to form a  new executable.   Using
_d_y_n_a_m_i_c _l_i_n_k_i_n_g,  the extensions  are linked  to a  shared library  (.so
file  on most  Unix  systems) or  dynamic  link  library (.DLL  file  on
Microsoft platforms) and loaded into the running Prolog process.


1122..22..11 WWhhaatt lliinnkkiinngg iiss pprroovviiddeedd??

The _s_t_a_t_i_c  _l_i_n_k_i_n_g schema can  be used on  all versions of  SWI-Prolog.
Whether or  not dynamic  linking is  supported can be  deduced from  the
Prolog  flag open_shared_object (see  current_prolog_flag/2).    If  this
Prolog flag yields true, open_shared_object/2 and related predicates are
defined.   See section ???? for  a suitable high-level interface to  these
predicates.


1122..22..22 WWhhaatt kkiinndd ooff llooaaddiinngg sshhoouulldd II bbee uussiinngg??

All  described  approaches  have  their  advantages  and  disadvantages.
Static linking  is portable and allows  for debugging on all  platforms.
It is relatively  cumbersome and the libraries  you need to pass to  the
linker  may vary  from  system to  system,  though the  utility  program
swipl-ld described  in section ????  often hides  these problems from  the
user.

Loading  shared objects  (DLL  files on  Windows) provides  sharing  and
protection  and is  generally the  best choice.    If a  saved state  is
created using qsave_program/[1,2], an initialization/1 directive  may be
used to load the appropriate library at startup.

Note  that  the  definition of  the  foreign  predicates  is  the  same,
regardless of the linking type used.


1122..22..33 lliibbrraarryy((sshhlliibb))::   UUttiilliittyy  lliibbrraarryy  ffoorr llooaaddiinngg  ffoorreeiiggnn  oobbjjeeccttss
       ((DDLLLLss,, sshhaarreedd oobbjjeeccttss))

This   section   discusses   the   functionality   of   the   (autoload)
library(shlib), providing an  interface to manage shared libraries.   We
describe the procedure for using a foreign resource (DLL  in Windows and
shared object in Unix) called mylib.

First,  one  must  assemble  the resource  and  make  it  compatible  to
SWI-Prolog.    The  details  for  this  vary between  platforms.     The
swipl-ld(1) utility can be used to deal with this  in a portable manner.
The typical commandline is:

________________________________________________________________________|                                                                        |
|swipl-ld|-o_mylib_file.{c,o,cc,C}_...__________________________________ |        |

Make  sure   that  one  of   the  files   provides  a  global   function
install_mylib()   that   initialises   the   module   using   calls   to
PL_register_foreign().   Here  is a  simple example  file mylib.c,  which
creates a Windows MessageBox:

________________________________________________________________________|                                                                        |

|#include <windows.h>                                                    |
|#include <SWI-Prolog.h>                                                 |
|                                                                        |
|static foreign_t                                                        |
|pl_say_hello(term_t to)                                                 |
|{ char *a;                                                              |

|                                                                        |
|  if ( PL_get_atom_chars(to, &a) )                                      |
|  { MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);                |
|                                                                        |
|    PL_succeed;                                                         |
|  }                                                                     |
|                                                                        |
|  PL_fail;                                                              |

|}                                                                       |
|                                                                        |
|install_t                                                               |
|install_mylib()                                                         |
|{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);                 |
|}|_____________________________________________________________________ | |

Now write a file mylib.pl:

________________________________________________________________________|                                                                        |

|:- module(mylib, [ say_hello/1 ]).                                      |
|:-|use_foreign_library(foreign(mylib)).________________________________ |  |

The file  mylib.pl can be  loaded as a normal  Prolog file and  provides
the predicate defined in C.


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_:_F_i_l_e_S_p_e_c))                                    _[_d_e_t_]


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_:_F_i_l_e_S_p_e_c_, _+_E_n_t_r_y_:_a_t_o_m))                       _[_d_e_t_]
    Load  a  _s_h_a_r_e_d _o_b_j_e_c_t  or  _D_L_L. After  loading the  _E_n_t_r_y  function
    is  called  without  arguments.    The  default  entry  function  is
    composed  from =install_=, followed by  the file  base-name.   E.g.,
    the  load-call below  calls the  function install_mylib().   If  the
    platform  prefixes extern functions  with =_=,  this prefix is  added
    before calling.

    ____________________________________________________________________|                                                                    |
    |       ...                                                          |

    |       load_foreign_library(foreign(mylib)),                        |
    ||______..._________________________________________________________ ||

    ___________________________________________________________Arguments_
     _F_i_l_e_S_p_e_c  is  a  specification  for  absolute_file_name/3.
               If  searching  the file  fails, the  plain  name

               is   passed  to  the  OS  to  try  the   default
               method  of the OS for locating foreign  objects.
               The  default  definition  of  file_search_path/2
               searches  <prolog home>/lib/<arch> on Unix and
               <prolog home>/bin on Windows.

         SSeeee aallssoo use_foreign_library/1,2 are  intended for  use in
             directives.


uussee__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c))                                     _[_d_e_t_]


uussee__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c_, _+_E_n_t_r_y_:_a_t_o_m))                        _[_d_e_t_]
    Load  and install a foreign  library as load_foreign_library/1,2  and
    register  the installation  using initialization/2  with the  option
    now.  This is similar to using:

    ____________________________________________________________________|                                                                    |
    ||:-_initialization(load_foreign_library(foreign(mylib))).__________ ||

    but  using the  initialization/1 wrapper  causes the  library to  be
    loaded  _a_f_t_e_r loading of the file in which it appears  is completed,
    while  use_foreign_library/1 loads the  library _i_m_m_e_d_i_a_t_e_l_y.    I.e.
    the  difference is only relevant if  the remainder of the file  uses
    functionality of the C-library.


uunnllooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c))                                  _[_d_e_t_]


uunnllooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c_, _+_E_x_i_t_:_a_t_o_m))                      _[_d_e_t_]
    Unload  a _s_h_a_r_e_d  _o_b_j_e_c_t or  _D_L_L. After calling  the _E_x_i_t  function,
    the  shared  object  is removed  from  the  process.    The  default
    exit  function is composed  from =uninstall_=,  followed by the  file
    base-name.


ccuurrrreenntt__ffoorreeiiggnn__lliibbrraarryy((_?_F_i_l_e_, _?_P_u_b_l_i_c))
    Query currently loaded shared libraries.


rreellooaadd__ffoorreeiiggnn__lliibbrraarriieess
    Reload  all  foreign  libraries loaded  (after  restore of  a  state
    created using qsave_program/2.


1122..22..44 LLooww--lleevveell ooppeerraattiioonnss oonn sshhaarreedd lliibbrraarriieess

The interface  defined in this  section allows the  user to load  shared
libraries  (.so files  on most  Unix systems,  .dll  files on  Windows).
This  interface is  portable to  Windows  as well  as to  Unix  machines
providing  dlopen(2)  (Solaris,  Linux,  FreeBSD, Irix  and  many  more)
or  shl_open(2) (HP/UX).  It  is  advised to  use  the  predicates  from
section ???? in your application.


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _-_H_a_n_d_l_e))
    _F_i_l_e  is  the name  of a  shared object  file  (DLL in  MS-Windows).
    This   file  is  attached  to   the  current  process,  and   _H_a_n_d_l_e
    is   unified  with  a  handle  to  the  library.      Equivalent  to
    open_shared_object(File, Handle, []).  See also open_shared_object/3
    and load_foreign_library/1.

    On  errors, an  exception shared_object(_A_c_t_i_o_n_, _M_e_s_s_a_g_e) is  raised.
    _M_e_s_s_a_g_e is the return value from dlerror().


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _-_H_a_n_d_l_e_, _+_O_p_t_i_o_n_s))
    As  open_shared_object/2, but  allows  for  additional flags  to  be
    passed.   _O_p_t_i_o_n_s is a list of  atoms.  now implies the  symbols are
    resolved  immediately rather  than lazy (default).   global  implies
    symbols of the  loaded object are visible while loading other shared
    objects (by default they  are local).  Note that these flags may not
    be  supported by your operating system.  Check the  documentation of
    dlopen() or equivalent  on your operating system.  Unsupported flags
    are silently ignored.


cclloossee__sshhaarreedd__oobbjjeecctt((_+_H_a_n_d_l_e))
    Detach the shared object identified by _H_a_n_d_l_e.


ccaallll__sshhaarreedd__oobbjjeecctt__ffuunnccttiioonn((_+_H_a_n_d_l_e_, _+_F_u_n_c_t_i_o_n))
    Call the named function  in the loaded shared library.  The function
    is  called  without  arguments  and the  return  value  is  ignored.
    Normally  this function installs  foreign language predicates  using
    calls to PL_register_foreign().


1122..22..55 SSttaattiicc LLiinnkkiinngg

Below  is an  outline  of the  file  structure required  for  statically
linking SWI-Prolog  with foreign extensions.    .../swipl refers to  the
SWI-Prolog home directory (see the  Prolog flag home).  <_a_r_c_h> refers to
the architecture identifier  that may be obtained using the  Prolog flag
arch.

   .../swipl/runtime/<_a_r_c_h>/libswipl.a SWI-Library
   .../swipl/include/SWI-Prolog.h      Include file
   .../swipl/include/SWI-Stream.h      Stream I/O include file
   .../swipl/include/SWI-Exports       Export declarations (AIX only)
   .../swipl/include/stub.c            Extension stub

The definition  of the  foreign predicates  is the same  as for  dynamic
linking.      Unlike  with  dynamic  linking,   however,  there  is   no
initialisation  function.   Instead,  the file  .../swipl/include/stub.c
may  be copied  to  your project  and  modified  to define  the  foreign
extensions.   Below is  stub.c, modified to  link the lowercase  example
described later in this chapter:

________________________________________________________________________|                                                                        |
|#include <stdio.h>                                                      |
|#include <SWI-Prolog.h>                                                 |

|                                                                        |
|extern foreign_t pl_lowercase(term, term);                              |
|                                                                        |
|PL_extension predicates[] =                                             |
|{                                                                       |
|/*{ "name",      arity,  function,      PL_FA_<flags> },*/              |
|                                                                        |

|  { "lowercase", 2       pl_lowercase,  0 },                            |
|  { NULL,        0,      NULL,          0 } /* terminating line */      |
|};                                                                      |
|                                                                        |
|                                                                        |
|int                                                                     |
|main(int argc, char **argv)                                             |
|{ PL_register_extensions(predicates);                                   |

|                                                                        |
|  if ( !PL_initialise(argc, argv) )                                     |
|    PL_halt(1);                                                         |
|                                                                        |
|  PL_halt(PL_toplevel() ? 0 : 1);                                       |
|}|_____________________________________________________________________ | |

Now,  a  new  executable may  be  created  by compiling  this  file  and
linking  it to  libpl.a from  the runtime  directory  and the  libraries
required  by both  the  extensions and  the  SWI-Prolog  kernel.    This
may be  done by  hand, or  by using  the swipl-ld  utility described  in
section ????.    If the  linking is performed  by hand,  the command  line
option -dump-runtime-variables  (see section ????) can  be used to  obtain
the  required paths,  libraries  and linking  options  to link  the  new
executable.


1122..33 IInntteerrffaaccee DDaattaa TTyyppeess


1122..33..11 TTyyppee term_t::  aa rreeffeerreennccee ttoo aa PPrroolloogg tteerrmm

The principal data  type is term_t.   Type term_t is what Quintus  calls
QP_term_ref.   This name indicates  better what the type represents:   it
is a _h_a_n_d_l_e for a  term rather than the term itself.  Terms can  only be
represented and manipulated  using this type, as  this is the only  safe
way to  ensure the  Prolog kernel is  aware of  all terms referenced  by
foreign code  and thus allows the  kernel to perform garbage  collection
and/or stack-shifts while foreign  code is active, for example  during a
callback from C.

A term  reference is  a C unsigned  long, representing  the offset of  a
variable on the Prolog environment stack.  A  foreign function is passed
term references for the predicate arguments, one for each  argument.  If
references for intermediate  results are needed, such references  may be
created using PL_new_term_ref() or PL_new_term_refs().   These references
normally live till the foreign function returns control  back to Prolog.
Their scope can  be explicitly limited using PL_open_foreign_frame() and
PL_close_foreign_frame()/PL_discard_foreign_frame().

A term_t always refers to a valid Prolog term (variable,  atom, integer,
float  or compound  term).    A  term  lives either  until  backtracking
takes  us back  to a  point before  the term  was created,  the  garbage
collector  has collected  the term,  or  the term  was created  after  a
PL_open_foreign_frame()and PL_discard_foreign_frame()has been called.

The  foreign interface  functions can  either _r_e_a_d,  _u_n_i_f_y  or _w_r_i_t_e  to
term references.   In  this document we use  the following notation  for
arguments of type term_t:

     term_t +t  Accessed in  read-mode.  The  `+' indicates the
                argument is `input'.
     term_t -t  Accessed in write-mode.
     term_t ?t  Accessed in unify-mode.

WWAARRNNIINNGG  Term references  that are  accessed in  `write'  (-) mode  will
refer to an  invalid term if the term  is allocated on the global  stack
and backtracking takes us  back to a point before the term  was written.
Compounds, large integers,  floats and strings are all allocated  on the
global stack.  Below  is a typical scenario where this may happen.   The
first solution writes a term extracted from the solution into  _a.  After
the system backtracks  due to PL_next_solution(), _a becomes a  reference
to a term that no longer exists.

________________________________________________________________________|                                                                        |
|term_t a = PL_new_term_ref();                                           |

|...                                                                     |
|query = PL_open_query(...);                                             |
|while(PL_next_solution(query))                                          |
|{ PL_get_arg(i, ..., a);                                                |
|}                                                                       |
|PL_close_query(query);|________________________________________________ |                      |

There are  two solutions  to this problem.    One is to  scope the  term
reference using  PL_open_foreign_frame()and PL_close_foreign_frame() and
makes  sure it  goes out  of scope  before backtracking  happens.    The
other  is to  clear the  term reference  using  PL_put_variable() before
backtracking.

Term references are obtained in any of the following ways:

  o _P_a_s_s_e_d _a_s _a_r_g_u_m_e_n_t
    The  C functions  implementing foreign predicates  are passed  their
    arguments  as term  references.   These  references may  be read  or
    unified.  Writing to these variables causes undefined behaviour.

  o _C_r_e_a_t_e_d _b_y PL_new_term_ref()
    A  term  created  by  PL_new_term_ref() is normally  used  to  build
    temporary terms or  to be written by one of the interface functions.
    For  example, PL_get_arg() writes a reference  to the term  argument
    in its last argument.

  o _C_r_e_a_t_e_d _b_y PL_new_term_refs(_i_n_t _n)
    This  function  returns  a set  of  term  references with  the  same
    characteristics as PL_new_term_ref().  See PL_open_query().

  o _C_r_e_a_t_e_d _b_y PL_copy_term_ref(_t_e_r_m___t _t)
    Creates a new term  reference to the same term as the argument.  The
    term may be written to.  See figure ????.

Term  references can  safely be  copied  to other  C variables  of  type
term_t, but all copies will always refer to the same term.


term_t PPLL__nneeww__tteerrmm__rreeff()
    Return  a fresh reference  to a  term.   The reference is  allocated
    on  the _l_o_c_a_l  stack.   Allocating a  term reference  may trigger  a
    stack-shift  on machines  that cannot use  sparse memory  management
    for  allocation  of  the Prolog  stacks.    The  returned  reference
    describes a variable.


term_t PPLL__nneeww__tteerrmm__rreeffss(_i_n_t _n)
    Return  _n  new  term  references.    The  first  term  reference  is
    returned.   The others are _t +1, _t +2, etc.   There are two reasons
    for  using this function.   PL_open_query()expects the  arguments as
    a  set of consecutive term  references, and _v_e_r_y time-critical  code
    requiring a number of term references can be written as:

    ____________________________________________________________________|                                                                    |
    | pl_mypredicate(term_t a0, term_t a1)                               |

    | { term_t t0 = PL_new_term_refs(2);                                 |
    |   term_t t1 = t0+1;                                                |
    |                                                                    |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


term_t PPLL__ccooppyy__tteerrmm__rreeff(_t_e_r_m___t _f_r_o_m)
    Create a new term  reference and make it point initially to the same
    term  as _f_r_o_m.  This function  is commonly used to copy  a predicate
    argument to a term reference that may be written.


void PPLL__rreesseett__tteerrmm__rreeffss(_t_e_r_m___t _a_f_t_e_r)
    Destroy  all term  references that  have been  created after  _a_f_t_e_r,
    including  _a_f_t_e_r itself.    Any  reference to  the invalidated  term
    references after this call results in undefined behaviour.

    Note  that  returning  from  the  foreign  context  to  Prolog  will
    reclaim  all references  used in  the foreign  context.   This  call
    is  only necessary  if  references are  created inside  a loop  that
    never  exits  back to  Prolog.    See  also  PL_open_foreign_frame(),
    PL_close_foreign_frame() and PL_discard_foreign_frame().


1122..33..11..11 IInntteerraaccttiioonn wwiitthh tthhee ggaarrbbaaggee ccoolllleeccttoorr aanndd ssttaacckk--sshhiifftteerr

Prolog implements two  mechanisms for avoiding stack overflow:   garbage
collection and stack expansion.   On machines that allow for  it, Prolog
will use virtual  memory management to detect stack overflow  and expand
the  runtime stacks.    On  other machines  Prolog will  reallocate  the
stacks and  update all  pointers to them.    To do so,  Prolog needs  to
know which data  is referenced by C code.   As all Prolog data  known by
C is  referenced through  term references (term_t),  Prolog has all  the
information necessary to  perform its memory management without  special
precautions from the C programmer.


1122..33..22 OOtthheerr ffoorreeiiggnn iinntteerrffaaccee ttyyppeess

aattoomm__tt An atom in Prolog's internal representation.   Atoms are pointers
    to  an  opaque structure.    They are  a  unique representation  for
    represented  text, which  implies that  atom A  represents the same
    text as atom B  if and only if A and B are the same pointer.

    Atoms  are  the  central  representation for  textual  constants  in
    Prolog.    The transformation of  a character  string C  to an atom
    implies  a hash-table lookup.  If the same atom is needed  often, it
    is  advised to  store its reference  in a  global variable to  avoid
    repeated lookup.

ffuunnccttoorr__tt A  functor is  the  internal  representation of  a  name/arity
    pair.   They are used to find the name and arity of  a compound term
    as  well as to construct new compound  terms.  Like atoms  they live
    for the whole Prolog session and are unique.

pprreeddiiccaattee__tt Handle  to a  Prolog  predicate.    Predicate  handles  live
    forever (although they can lose their definition).

qqiidd__tt Query identifier.  Used by  PL_open_query(), PL_next_solution() and
    PL_close_query() to handle backtracking from C.

ffiidd__tt Frame   identifier.       Used   by   PL_open_foreign_frame()  and
    PL_close_foreign_frame().

mmoodduullee__tt A module is  a unique handle to a  Prolog module.  Modules  are
    used only to call predicates in a specific module.

ffoorreeiiggnn__tt Return type for a C function implementing a Prolog predicate.

ccoonnttrrooll__tt Passed  as additional  argument to  non-deterministic  foreign
    functions.  See PL_retry*() and PL_foreign_context*().

iinnssttaallll__tt Type for the install() and uninstall() functions  of shared or
    dynamic link libraries.  See section ????.

iinntt6644__tt Actually  part of  the C99  standard  rather than  Prolog.    As
    of  version  5.5.6,  Prolog integers  are  64-bit on  all  hardware.
    The  C99 type  int64_t is defined  in the  stdint.h standard  header
    and  provides platform-independent 64-bit  integers.  Portable  code
    accessing  Prolog should use this  type to exchange integer  values.
    Please  note that PL_get_long() can return FALSE on Prolog  integers
    that  cannot be represented  as a C  long.   Robust code should  not
    assume  any of the  integer fetching functions  to succeed, _e_v_e_n  if
    the Prolog term is known to be an integer.


1122..33..22..11 PPLL__AARRIITTYY__AASS__SSIIZZEE

As of  SWI-Prolog 7.3.12,  the arity of  terms has  changed from int  to
size_t.   To deal  with this  transition, all  affecting functions  have
two versions, where  the old name exchanges the  arity as int and a  new
function  with name  *_sz() exchanges  the arity  as size_t.    If the  C
macro PL_ARITY_AS_SIZE is defined before loading SWI-Prolog.h,  macros are
put in  place that  map the old  names to  the new functions.    Without
precautions, the  old code is compatible,  but the following warning  is
printed when compiling:

________________________________________________________________________|                                                                        |
|#warning "Term arity has changed from int to size_t."                   |

|#warning|"Please_update_your_code_and_use_#define_PL_ARITY_AS_SIZE_1."_ |        |

To make the code  compile silently again, include SWI-Prolog.h as  below
and change  the types  you use to  represent arity  from int  to size_t.
Please be aware that size_t is _u_n_s_i_g_n_e_d.

________________________________________________________________________|                                                                        |
|#define PL_ARITY_AS_SIZE                                                |
|#include|<SWI-Prolog.h>________________________________________________ |        |


1122..44 TThhee FFoorreeiiggnn IInncclluuddee FFiillee


1122..44..11 AArrgguummeenntt PPaassssiinngg aanndd CCoonnttrrooll

If  Prolog encounters  a foreign  predicate  at run  time it  will  call
a  function  specified  in  the  predicate  definition  of  the  foreign
predicate.   The arguments 1;:::; <_a_r_i_t_y>pass the  Prolog arguments to the
goal as  Prolog terms.   Foreign  functions should  be declared of  type
foreign_t.   Deterministic foreign  functions have  two alternatives  to
return control back to Prolog:


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__ssuucccceeeedd(())
    Succeed deterministically.  PL_succeed is defined as return TRUE.


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__ffaaiill(())
    Fail  and  start  Prolog  backtracking.     PL_fail  is  defined  as
    return FALSE.


1122..44..11..11 NNoonn--ddeetteerrmmiinniissttiicc FFoorreeiiggnn PPrreeddiiccaatteess

By  default   foreign  predicates   are  deterministic.      Using   the
PL_FA_NONDETERMINISTIC   attribute  (see   PL_register_foreign())  it   is
possible  to register  a  predicate  as a  non-deterministic  predicate.
Writing   non-deterministic   foreign  predicates   is   slightly   more
complicated  as  the  foreign function  needs  context  information  for
generating  the next  solution.   Note  that the  same foreign  function
should  be  prepared  to be  simultaneously  active  in  more  than  one
goal.     Suppose  the  natural_number_below_n/2  is  a  non-deterministic
foreign predicate, backtracking over all natural numbers  lower than the
first argument.  Now consider the following predicate:

________________________________________________________________________|                                                                        |
|quotient_below_n(Q, N) :-                                               |

|        natural_number_below_n(N, N1),                                  |
|        natural_number_below_n(N, N2),                                  |
||_______Q_=:=_N1_/_N2,_!.______________________________________________ ||

In  this predicate  the function  natural_number_below_n/2  simultaneously
generates solutions for both its invocations.

Non-deterministic foreign functions  should be prepared to handle  three
different calls from Prolog:

  o _I_n_i_t_i_a_l _c_a_l_l _(PL_FIRST_CALL_)
    Prolog  has just created a frame  for the foreign function and  asks
    it to produce the first answer.

  o _R_e_d_o _c_a_l_l _(PL_REDO_)
    The previous invocation  of the foreign function associated with the
    current  goal indicated it was possible  to backtrack.  The  foreign
    function should produce the next solution.

  o _T_e_r_m_i_n_a_t_e _c_a_l_l _(PL_PRUNED_)
    The choice point  left by the foreign function has been destroyed by
    a  cut.  The foreign function is given the opportunity to  clean the
    environment.

Both  the  context  information  and  the  type  of   call  is  provided
by  an  argument  of  type  control_t  appended  to  the  argument  list
for  deterministic foreign  functions.   The  macro PL_foreign_control()
extracts  the   type  of  call   from  the  control   argument.      The
foreign  function  can  pass  a context  handle  using  the  PL_retry*()
macros  and  extract  the handle  from  the  extra  argument  using  the
PL_foreign_context*() macro.


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__rreettrryy((_i_n_t_p_t_r___t _v_a_l_u_e))
    The  foreign function  succeeds while leaving  a choice  point.   On
    backtracking  over this  goal the  foreign function  will be  called
    again,  but  the  control argument  now  indicates  it is  a  `Redo'
    call  and the macro  PL_foreign_context() returns the handle  passed
    via  PL_retry().   This handle is  a signed  value two bits  smaller
    than  a  pointer,  i.e.,  30  or 62  bits  (two bits  are  used  for
    status  indication).    Defined as  return _PL_retry(_n).    See  also
    PL_succeed().


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__rreettrryy__aaddddrreessss((_v_o_i_d _*))
    As  PL_retry(),  but ensures  an address as  returned by malloc()  is
    correctly  recovered  by PL_foreign_context_address().    Defined  as
    return  _PL_retry_address(_n).  See also PL_succeed().


_i_n_t PPLL__ffoorreeiiggnn__ccoonnttrrooll((_c_o_n_t_r_o_l___t))
    Extracts  the type of  call from the control  argument.  The  return
    values  are  described above.    Note that  the  function should  be
    prepared  to handle the PL_PRUNED case and should be aware  that the
    other arguments are not valid in this case.


_i_n_t_p_t_r___t PPLL__ffoorreeiiggnn__ccoonntteexxtt((_c_o_n_t_r_o_l___t))
    Extracts  the context from the context  argument.  If the call  type
    is  PL_FIRST_CALL the context value is 0L. Otherwise it  is the value
    returned  by the last PL_retry() associated with this goal  (both if
    the call type is PL_REDO or PL_PRUNED).


_v_o_i_d _* PPLL__ffoorreeiiggnn__ccoonntteexxtt__aaddddrreessss((_c_o_n_t_r_o_l___t))
    Extracts an address as passed in by PL_retry_address().


_p_r_e_d_i_c_a_t_e___t PPLL__ffoorreeiiggnn__ccoonntteexxtt__pprreeddiiccaattee((_c_o_n_t_r_o_l___t))
    Fetch  the Prolog predicate that is  executing this function.   Note
    that if the  predicate is imported, the returned predicate refers to
    the  final definition rather than the imported predicate,  i.e., the
    module  reported by PL_predicate_info() is the  module in which  the
    predicate  is defined rather  than the module  where it was  called.
    See also PL_predicate_info().

Note:     If  a   non-deterministic  foreign   function  returns   using
PL_succeed() or  PL_fail(),  Prolog  assumes the  foreign  function  has
cleaned its environment.   NNoo call with control  argument PL_PRUNED will
follow.

The code of figure  ???? shows a skeleton for a  non-deterministic foreign
predicate definition.
________________________________________________________________________|                                                                        |
|typedef struct                  /* define a context structure */        |

|{ ...                                                                   |
|} context;                                                              |
|                                                                        |
|foreign_t                                                               |
|my_function(term_t a0, term_t a1, control_t handle)                     |
|{ struct context * ctxt;                                                |
|                                                                        |
|  switch( PL_foreign_control(handle) )                                  |

|  { case PL_FIRST_CALL:                                                 |
|        ctxt = malloc(sizeof(struct context));                          |
|        ...                                                             |
|        PL_retry_address(ctxt);                                         |
|    case PL_REDO:                                                       |
|        ctxt = PL_foreign_context_address(handle);                      |
|        ...                                                             |

|        PL_retry_address(ctxt);                                         |
|    case PL_PRUNED:                                                     |
|        ctxt = PL_foreign_context_address(handle);                      |
|        ...                                                             |
|        free(ctxt);                                                     |
|        PL_succeed;                                                     |
|  }                                                                     |
|}|_____________________________________________________________________ | |

     Figure 12.1:  Skeleton for non-deterministic foreign functions


1122..44..22 AAttoommss aanndd ffuunnccttoorrss

The  following  functions  provide for  communication  using  atoms  and
functors.


atom_t PPLL__nneeww__aattoomm(_c_o_n_s_t _c_h_a_r _*)
    Return an atom handle  for the given C-string.  This function always
    succeeds.    The returned handle  is valid  as long as  the atom  is
    referenced  (see section ????).   The following atoms are provided  as
    macros,  giving access  to the  empty list  symbol and  the name  of
    the  list constructor.   Prior  to version 7,  ATOM_nil is the  same
    as  PL_new_atom(_"_[_]_") and ATOM_dot is the  same as PL_new_atom(_"_._").
    This is no long the case in SWI-Prolog version 7.


_a_t_o_m___t AATTOOMM__nniill((_A))
     tomic  constant  that  represents  the  empty  list.     It  is
     adviced  to  use  PL_get_nil(),  PL_put_nil() or  PL_unify_nil()
     where applicable.


_a_t_o_m___t AATTOOMM__ddoott((_A))
     tomic  constant that  represents  the  name of  the  list  con-
     structor.    The  list  constructor  itself  is  created  using
     PL_new_functor(_A_T_O_M___d_o_t_,_2).  It is adviced to use PL_get_list(),
     PL_put_list()or PL_unify_list() where applicable.


atom_t PPLL__nneeww__aattoomm__mmbbcchhaarrss(_i_n_t _r_e_p_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    This  function  generalizes  PL_new_atom()  and  PL_new_atom_nchars()
    while  allowing for  multiple encodings.   The  _r_e_p argument is  one
    of  REP_ISO_LATIN_1, REP_UTF8 or REP_MB. If _l_e_n is  (size_t)-1,  it is
    computed from _s using strlen().


const char* PPLL__aattoomm__cchhaarrss(_a_t_o_m___t _a_t_o_m)
    Return  a C-string for the text represented by the given atom.   The
    returned  text will not be changed by Prolog.  It is  not allowed to
    modify  the contents, not even `temporary' as the string  may reside
    in  read-only memory.   The returned  string becomes invalid if  the
    atom  is garbage  collected  (see section  ????).   Foreign  functions
    that  require the text from an atom passed in  a term_t  normally use
    PL_get_atom_chars() or PL_get_atom_nchars().


functor_t PPLL__nneeww__ffuunnccttoorr(_a_t_o_m___t _n_a_m_e_, _i_n_t _a_r_i_t_y)
    Returns  a _f_u_n_c_t_o_r  _i_d_e_n_t_i_f_i_e_r, a  handle for  the name/arity  pair.
    The returned handle is valid for the entire Prolog session.


atom_t PPLL__ffuunnccttoorr__nnaammee(_f_u_n_c_t_o_r___t _f)
    Return an atom representing the name of the given functor.


size_t PPLL__ffuunnccttoorr__aarriittyy(_f_u_n_c_t_o_r___t _f)
    Return the arity of the given functor.


1122..44..22..11 AAttoommss aanndd aattoomm ggaarrbbaaggee ccoolllleeccttiioonn

With  the introduction  of  atom garbage  collection in  version  3.3.0,
atoms  no  longer  live  as  long  as  the  process.    Instead,   their
lifetime is  guaranteed only as  long as  they are referenced.   In  the
single-threaded version,  atom garbage collections  are only invoked  at
the _c_a_l_l_-_p_o_r_t.    In the multithreaded  version (see  chapter ????),  they
appear asynchronously, except for the invoking thread.

For dealing with  atom garbage collection, two additional  functions are
provided:


void PPLL__rreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Increment  the reference count  of the  atom by one.   PL_new_atom()
    performs  this automatically,  returning  an atom  with a  reference
    count of at least one.


void PPLL__uunnrreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Decrement  the reference count of the atom.  If the  reference count
    drops below zero, an assertion error is raised.

Please note that the  following two calls are different with  respect to
atom garbage collection:

________________________________________________________________________|                                                                        |

|PL_unify_atom_chars(t, "text");                                         |
|PL_unify_atom(t,|PL_new_atom("text"));_________________________________ |                |

The  latter increments  the  reference count  of  the atom  text,  which
effectively ensures the atom will never be collected.   It is advised to
use the *_chars() or *_nchars() functions whenever applicable.


1122..44..33 AAnnaallyyssiinngg TTeerrmmss vviiaa tthhee FFoorreeiiggnn IInntteerrffaaccee

Each argument  of a foreign function  (except for the control  argument)
is of type term_t, an opaque  handle to a Prolog term.  Three  groups of
functions are  available for  the analysis  of terms.    The first  just
validates the  type,  like the  Prolog predicates var/1,  atom/1,  etc.,
and are  called PL_is_*().   The second  group attempts to translate  the
argument into a C primitive type.   These predicates take a term_t and a
pointer to the appropriate C type and return TRUE  or FALSE depending on
successful or unsuccessful translation.   If the translation fails,  the
pointed-to data is never modified.


1122..44..33..11 TTeessttiinngg tthhee ttyyppee ooff aa tteerrmm


int PPLL__tteerrmm__ttyyppee(_t_e_r_m___t)
    Obtain  the type  of a  term,  which should  be a  term returned  by
    one  of the  other interface  predicates or passed  as an  argument.
    The  function  returns the  type  of  the Prolog  term.    The  type
    identifiers  are listed below.   Note that the extraction  functions
    PL_get_*() also validate  the type and  thus the two sections  below
    are equivalent.

    ____________________________________________________________________|                                                                    |
    |         if ( PL_is_atom(t) )                                       |

    |         { char *s;                                                 |
    |                                                                    |
    |           PL_get_atom_chars(t, &s);                                |
    |           ...;                                                     |
    |         }                                                          |
    |                                                                    |
    | or                                                                 |
    |                                                                    |

    |         char *s;                                                   |
    |         if ( PL_get_atom_chars(t, &s) )                            |
    |         { ...;                                                     |
    ||________}_________________________________________________________ ||

    VVeerrssiioonn  77  added PL_NIL, PL_BLOB,  PL_LIST_PAIR  and PL_DICT.  Older
    versions  classify  PL_NIL  and PL_BLOB  as PL_ATOM,  PL_LIST_PAIR  as
    PL_TERM and do not have dicts.

    _______________________________________________________________
    | PL_VARIABLE            |A variable or attributed variable    |
    | PL_ATOM                |A Prolog atom                        |
    | PL_NIL                 |The constant []                      |
    | PL_BLOB                |A blob (see section ????)              |
    | PL_STRING              |A string (see section ????)            |
    | PL_INTEGER             |A integer                            |

    | PL_FLOAT               |A floating point number              |
    | PL_TERM                |A compound term                      |
    | PL_LIST_PAIR           |A list cell ([H|T])                  |
    |_PL_DICT________________|A_dict_(see_section_????))_____________|

The functions PL_is_<_t_y_p_e> are an alternative to PL_term_type().  The test
PL_is_variable(_t_e_r_m) is equivalent to  PL_term_type(_t_e_r_m)== PL_VARIABLE,
but  the first  is considerably  faster.   On  the other  hand, using  a
switch over  PL_term_type() is faster  and more readable  then using  an
if-then-else using  the functions  below.   All  these functions  return
either TRUE or FALSE.


int PPLL__iiss__vvaarriiaabbllee(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a variable.


int PPLL__iiss__ggrroouunndd(_t_e_r_m___t)
    Returns  non-zero if  _t_e_r_m is  a ground term.    See also  ground/1.
    This function is cycle-safe.


int PPLL__iiss__aattoomm(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an atom.


int PPLL__iiss__ssttrriinngg(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a string.


int PPLL__iiss__iinntteeggeerr(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an integer.


int PPLL__iiss__ffllooaatt(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a float.


int PPLL__iiss__ccaallllaabbllee(_t_e_r_m___t)
    Returns  non-zero if _t_e_r_m  is a callable term.   See callable/1  for
    details.


int PPLL__iiss__ccoommppoouunndd(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a compound term.


int PPLL__iiss__ffuunnccttoorr(_t_e_r_m___t_, _f_u_n_c_t_o_r___t)
    Returns  non-zero if _t_e_r_m  is compound and  its functor is  _f_u_n_c_t_o_r.
    This  test is  equivalent to  PL_get_functor(),  followed by  testing
    the functor, but easier to write and faster.


int PPLL__iiss__lliisstt(_t_e_r_m___t)
    Returns  non-zero  if  _t_e_r_m  is  a  compound  term  using  the  list
    constructor  or  the list  terminator.    See also  PL_is_pair() and
    PL_skip_list().


int PPLL__iiss__ppaaiirr(_t_e_r_m___t)
    Returns  non-zero  if  _t_e_r_m  is  a  compound  term  using  the  list
    constructor.  See also PL_is_list() and PL_skip_list().


int PPLL__iiss__aattoommiicc(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is atomic (not variable or compound).


int PPLL__iiss__nnuummbbeerr(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an integer or float.


int PPLL__iiss__aaccyycclliicc(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is acyclic (i.e. a finite tree).


1122..44..33..22 RReeaaddiinngg ddaattaa ffrroomm aa tteerrmm

The functions PL_get_*() read information from  a Prolog term.  Most  of
them take two arguments.  The first is the input  term and the second is
a pointer to the output value or a term reference.


int PPLL__ggeett__aattoomm(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_a)
    If _t is an atom,  store the unique atom identifier over _a.  See also
    PL_atom_chars() and PL_new_atom().   If there is  no need to  access
    the data (characters)  of an atom, it is advised to manipulate atoms
    using  their handle.  As the  atom is referenced by _t, it  will live
    at  least as long as _t does.   If longer live-time is required,  the
    atom should be locked using PL_register_atom().


int PPLL__ggeett__aattoomm__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s)
    If  _t is an atom, store a  pointer to a 0-terminated C-string  in _s.
    It is explicitly  nnoott allowed to modify the contents of this string.
    Some  built-in  atoms may  have the  string  allocated in  read-only
    memory, so `temporary manipulation' can cause an error.


int PPLL__ggeett__ssttrriinngg__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _s_i_z_e___t _*_l_e_n)
    If  _t  is  a  string  object,  store a  pointer  to  a  0-terminated
    C-string  in _s  and the  length of  the string in  _l_e_n.   Note  that
    this pointer is  invalidated by backtracking, garbage collection and
    stack-shifts,  so generally the only save operations are to  pass it
    immediately to a C function that doesn't involve Prolog.


int PPLL__ggeett__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Convert  the argument term _t to  a 0-terminated C-string.  _f_l_a_g_s  is
    a  bitwise disjunction  from two  groups of  constants.   The  first
    specifies  which  term  types should  be  converted and  the  second
    how  the argument  is stored.   Below  is a  specification of  these
    constants.   BUF_RING implies, if the data is  not static (as from an
    atom), that the data  is copied to the next buffer from a ring of 16
    buffers.   This is a convenient way of converting multiple arguments
    passed  to a foreign predicate to C-strings.  If BUF_MALLOC is used,
    the data must be freed using PL_free() when no longer needed.

    With  the introduction of wide characters (see section ????),  not all
    atoms  can be converted into a char*.   This function fails if  _t is
    of the wrong type,  but also if the text cannot be represented.  See
    the REP_* flags below for details.

    CCVVTT__AATTOOMM
         Convert if term is an atom.

    CCVVTT__SSTTRRIINNGG
         Convert if term is a string.

    CCVVTT__LLIISSTT
         Convert if term is a list of of character codes.

    CCVVTT__IINNTTEEGGEERR
         Convert if term is an integer.

    CCVVTT__FFLLOOAATT
         Convert if term  is a float.   The characters returned are  the
         same as write/1 would write for the floating point number.

    CCVVTT__NNUUMMBBEERR
         Convert if term is an integer or float.

    CCVVTT__AATTOOMMIICC
         Convert if term is atomic.

    CCVVTT__VVAARRIIAABBLLEE
         Convert variable to print-name

    CCVVTT__WWRRIITTEE
         Convert any  term that  is not converted  by any  of the  other
         flags using  write/1.   If  no BUF_* is  provided, BUF_RING  is
         implied.

    CCVVTT__WWRRIITTEE__CCAANNOONNIICCAALL
         As CVT_WRITE, but using write_canonical/2.

    CCVVTT__WWRRIITTEEQQ
         As CVT_WRITE, but using writeq/2.

    CCVVTT__AALLLL
         Convert if term  is any of  the above, except  for CVT_VARIABLE
         and CVT_WRITE*.

    CCVVTT__EEXXCCEEPPTTIIOONN
         If conversion fails  due to a type  error, raise a Prolog  type
         error exception in addition to failure

    BBUUFF__DDIISSCCAARRDDAABBLLEE
         Data must copied immediately

    BBUUFF__RRIINNGG
         Data is stored in a ring of buffers

    BBUUFF__MMAALLLLOOCC
         Data is copied to a new buffer  returned by PL_malloc(3).   When
         no longer needed the user must call PL_free() on the data.

    RREEPP__IISSOO__LLAATTIINN__11
         Text is  in ISO  Latin-1 encoding and  the call  fails if  text
         cannot be represented.   This flag has the value 0 and  is thus
         the default.

    RREEPP__UUTTFF88
         Convert the text to a UTF-8 string.  This works for all text.

    RREEPP__MMBB
         Convert  to  default locale-defined  8-bit  string.     Success
         depends on the locale.  Conversion is done  using the wcrtomb()
         C library function.


int PPLL__ggeett__lliisstt__cchhaarrss(_+_t_e_r_m___t _l_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Same  as PL_get_chars(_l_, _s_, _C_V_T___L_I_S_T___f_l_a_g_s), provided _f_l_a_g_s  contains
    none of the CVT_* flags.


int PPLL__ggeett__iinntteeggeerr(_+_t_e_r_m___t _t_, _i_n_t _*_i)
    If  _t is  a Prolog  integer, assign  its value over  _i.   On  32-bit
    machines,  this is the  same as PL_get_long(), but avoids a  warning
    from the compiler.  See also PL_get_long().


int PPLL__ggeett__lloonngg(_t_e_r_m___t _+_t_, _l_o_n_g _*_i)
    If  _t is a Prolog integer that can be represented as a  long, assign
    its value over _i.   If _t is an integer that cannot be represented by
    a  C long,  this function returns  FALSE. If _t  is a floating  point
    number that can  be represented as a long, this function succeeds as
    well.  See also PL_get_int64().


int PPLL__ggeett__iinntt6644(_t_e_r_m___t _+_t_, _i_n_t_6_4___t _*_i)
    If  _t is  a Prolog integer  or float  that can be  represented as  a
    int64_t, assign its value over _i.


int PPLL__ggeett__iinnttppttrr(_t_e_r_m___t _+_t_, _i_n_t_p_t_r___t _*_i)
    Get  an integer that  is at  least as wide  as a pointer.   On  most
    platforms  this is the same as PL_get_long(), but on  Win64 pointers
    are  8 bytes and longs  only 4.  Unlike  PL_get_pointer(), the  value
    is not modified.


int PPLL__ggeett__bbooooll(_t_e_r_m___t _+_t_, _i_n_t _*_v_a_l)
    If _t has the value  true or false, set _v_a_l to the C constant TRUE or
    FALSE and return success, otherwise return failure.


int PPLL__ggeett__ppooiinntteerr(_t_e_r_m___t _+_t_, _v_o_i_d _*_*_p_t_r)
    In the current  system, pointers are represented by Prolog integers,
    but  need some manipulation to make  sure they do not get  truncated
    due  to  the limited  Prolog integer  range.    PL_put_pointer() and
    PL_get_pointer() guarantee  pointers in  the range  of malloc()  are
    handled without truncating.


int PPLL__ggeett__ffllooaatt(_t_e_r_m___t _+_t_, _d_o_u_b_l_e _*_f)
    If _t is a float or integer, its value is assigned over _f.


int PPLL__ggeett__ffuunnccttoorr(_t_e_r_m___t _+_t_, _f_u_n_c_t_o_r___t _*_f)
    If  _t  is  compound  or  an  atom,   the  Prolog  representation  of
    the   name-arity  pair  will  be  assigned   over  _f.     See   also
    PL_get_name_arity() and PL_is_functor().


int PPLL__ggeett__nnaammee__aarriittyy(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_n_a_m_e_, _s_i_z_e___t _*_a_r_i_t_y)
    If  _t is  compound or  an atom,  the functor name  will be  assigned
    over  _n_a_m_e and the arity over _a_r_i_t_y.   See also PL_get_functor() and
    PL_is_functor().  See section ????.


int PPLL__ggeett__ccoommppoouunndd__nnaammee__aarriittyy(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_n_a_m_e_, _s_i_z_e___t _*_a_r_i_t_y)
    If  _t is compound term, the functor name will be assigned  over _n_a_m_e
    and  the arity over _a_r_i_t_y.  This is the same as  PL_get_name_arity(),
    but this function fails if _t is an atom.


int PPLL__ggeett__mmoodduullee(_t_e_r_m___t _+_t_, _m_o_d_u_l_e___t _*_m_o_d_u_l_e)
    If   _t  is  an  atom,  the  system  will  look  up   or  create  the
    corresponding  module  and  assign  an opaque  pointer  to  it  over
    _m_o_d_u_l_e.


int PPLL__ggeett__aarrgg(_s_i_z_e___t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    If  _t is  compound and  index is  between 1  and arity  (inclusive),
    assign _a with a term reference to the argument.


int _PPLL__ggeett__aarrgg(_s_i_z_e___t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    Same  as PL_get_arg(), but no checking is performed,  neither whether
    _t is actually a term nor whether _i_n_d_e_x is a valid argument index.


1122..44..33..33 EExxcchhaannggiinngg tteexxtt uussiinngg lleennggtthh aanndd ssttrriinngg

All  internal text  representation in  SWI-Prolog  is represented  using
char * plus length and  allow for _0_-_b_y_t_e_s in them.  The  foreign library
supports this by implementing  a *_nchars() function for  each applicable
*_chars()  function.   Below we briefly present  the signatures of  these
functions.  For full documentation consult the *_chars() function.


int PPLL__ggeett__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s)
    See PL_get_atom_chars().


int PPLL__ggeett__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s)
    See PL_get_list_chars().


int PPLL__ggeett__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _i_n_t _f_l_a_g_s)
    See PL_get_chars().


int PPLL__ppuutt__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_atom_chars().


int PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_string_chars().


int PPLL__ppuutt__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_list_codes().


int PPLL__ppuutt__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_list_chars().


int PPLL__uunniiffyy__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_atom_chars().


int PPLL__uunniiffyy__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_string_chars().


int PPLL__uunniiffyy__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_codes().


int PPLL__uunniiffyy__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_list_chars().

In  addition, the  following functions  are available  for creating  and
inspecting atoms:


atom_t PPLL__nneeww__aattoomm__nncchhaarrss(_s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    Create  a new atom as PL_new_atom(), but using the given  length and
    characters.    If _l_e_n  is (size_t)-1, it  is computed  from _s  using
    strlen().


const char * PPLL__aattoomm__nncchhaarrss(_a_t_o_m___t _a_, _s_i_z_e___t _*_l_e_n)
    Extract the text and length of an atom.


1122..44..33..44 WWiiddee--cchhaarraacctteerr vveerrssiioonnss

Support  for   exchange  of  wide-character   strings  is  still   under
consideration.    The  functions dealing  with 8-bit  character  strings
return failure when operating on a wide-character atom  or Prolog string
object.  The  functions below can extract and unify both 8-bit  and wide
atoms and  string objects.   Wide character  strings are represented  as
C arrays  of objects of the  type pl_wchar_t,  which is guaranteed to  be
the same as wchar_t on platforms supporting this type.   For example, on
MS-Windows, this represents 16-bit UCS2 characters, while  using the GNU
C library (glibc) this represents 32-bit UCS4 characters.


atom_t PPLL__nneeww__aattoomm__wwcchhaarrss(_s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Create  atom from wide-character string as PL_new_atom_nchars() does
    for ISO-Latin-1 strings.   If _s only contains ISO-Latin-1 characters
    a  normal byte-array atom is created.   If _l_e_n is  (size_t)-1, it  is
    computed from _s using wcslen().


pl_wchar_t* PPLL__aattoomm__wwcchhaarrss(_a_t_o_m___t _a_t_o_m_, _i_n_t _*_l_e_n)
    Extract  characters from  a wide-character  atom.   Succeeds on  any
    atom  marked as `text'.  If the underlying atom is  a wide-character
    atom,  the returned pointer  is a pointer  into the atom  structure.
    If  it is an ISO-Latin-1 character, the returned pointer  comes from
    Prolog's `buffer ring' (see PL_get_chars()).


int PPLL__ggeett__wwcchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _p_l___w_c_h_a_r___t _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Wide-character  version of  PL_get_chars().   The  _f_l_a_g_s argument  is
    the same as for PL_get_chars().


int PPLL__uunniiffyy__wwcchhaarrss(_t_e_r_m___t _t_, _i_n_t _t_y_p_e_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Unify _t with  a textual representation of the C wide-character array
    _s.   The _t_y_p_e argument defines the Prolog representation and  is one
    of PL_ATOM, PL_STRING, PL_CODE_LIST or PL_CHAR_LIST.


int PPLL__uunniiffyy__wwcchhaarrss__ddiiffff(_t_e_r_m___t _+_t_, _t_e_r_m___t _-_t_a_i_l_, _i_n_t _t_y_p_e_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Difference  list version  of PL_unify_wchars(),  only supporting  the
    types  PL_CODE_LIST  and PL_CHAR_LIST. It serves  two purposes.    It
    allows  for returning very long lists  from data read from a  stream
    without  the need  for a  resizing buffer  in  C. Also,  the use  of
    difference  lists  is  often  practical for  further  processing  in
    Prolog.   Examples can be found in packages/clib/readutil.c from the
    source distribution.


1122..44..33..55 RReeaaddiinngg aa lliisstt

The functions from this section are intended to read  a Prolog list from
C. Suppose we expect a list of atoms; the following  code will print the
atoms, each on a line:

________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_write_atoms(term_t l)                                                |

|{ term_t head = PL_new_term_ref();   /* the elements */                 |
|  term_t list = PL_copy_term_ref(l); /* copy (we modify list) */        |
|                                                                        |
|  while( PL_get_list(list, head, list) )                                |
|  { char *s;                                                            |
|                                                                        |
|    if ( PL_get_atom_chars(head, &s) )                                  |
|      Sprintf("%s\n", s);                                               |

|    else                                                                |
|      PL_fail;                                                          |
|  }                                                                     |
|                                                                        |
|  return PL_get_nil(list);            /* test end for [] */             |
|}|_____________________________________________________________________ | |

Note that as  of version 7, lists  have a new representation unless  the
option --traditional is used.  see section ????.


int PPLL__ggeett__lliisstt(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    If  _l is a list and not  the empty list, assign a term  reference to
    the head to _h and to the tail to _t.


int PPLL__ggeett__hheeaadd(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h)
    If  _l is a list and not  the empty list, assign a term  reference to
    the head to _h.


int PPLL__ggeett__ttaaiill(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_t)
    If  _l is a list and not  the empty list, assign a term  reference to
    the tail to _t.


int PPLL__ggeett__nniill(_t_e_r_m___t _+_l)
    Succeeds if _l represents the list termination constant.


int PPLL__sskkiipp__lliisstt(_t_e_r_m___t _+_l_i_s_t_, _t_e_r_m___t _-_t_a_i_l_, _s_i_z_e___t _*_l_e_n)
    This is a multi-purpose  function to deal with lists.  It allows for
    finding the length  of a list, checking whether something is a list,
    etc.   The reference  _t_a_i_l is set to point  to the end of the  list,
    _l_e_n is filled  with the number of list-cells skipped, and the return
    value indicates the status of the list:

    PPLL__LLIISSTT
         The  list is  a `proper'  list:   one  that  ends in  the  list
         terminator constant  and  _t_a_i_l is  filled with  the  terminator
         constant.

    PPLL__PPAARRTTIIAALL__LLIISSTT
         The list is a `partial' list:  one that ends in  a variable and
         _t_a_i_l is a reference to this variable.

    PPLL__CCYYCCLLIICC__TTEERRMM
         The list  is  cyclic (e.g.    X  = [a_X]).  _t_a_i_l points  to  an
         arbitrary cell of the list  and _l_e_n is at most twice  the cycle
         length of the list.

    PPLL__NNOOTT__AA__LLIISSTT
         The  term _l_i_s_t  is  not a  list  at all.     _t_a_i_l is  bound  to
         the non-list term  and _l_e_n is set  to the number of  list-cells
         skipped.

    It is allowed to pass 0 for _t_a_i_l and NULL for _l_e_n.


1122..44..33..66 AAnn eexxaammppllee::  ddeeffiinniinngg write/1 iinn CC

Figure ????  shows a simplified  definition of  write/1 to illustrate  the
described  functions.    This  simplified  version does  not  deal  with
operators.    It is  called  display/1, because  it mimics  closely  the
behaviour of this Edinburgh predicate.
________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_display(term_t t)                                                    |
|{ functor_t functor;                                                    |

|  int arity, len, n;                                                    |
|  char *s;                                                              |
|                                                                        |
|  switch( PL_term_type(t) )                                             |
|  { case PL_VARIABLE:                                                   |
|    case PL_ATOM:                                                       |
|    case PL_INTEGER:                                                    |
|    case PL_FLOAT:                                                      |

|      PL_get_chars(t, &s, CVT_ALL);                                     |
|      Sprintf("%s", s);                                                 |
|      break;                                                            |
|    case PL_STRING:                                                     |
|      PL_get_string_chars(t, &s, &len);                                 |
|      Sprintf("\"%s\"", s);                                             |
|      break;                                                            |

|    case PL_TERM:                                                       |
|    { term_t a = PL_new_term_ref();                                     |
|                                                                        |
|      PL_get_name_arity(t, &name, &arity);                              |
|      Sprintf("%s(", PL_atom_chars(name));                              |
|      for(n=1; n<=arity; n++)                                           |
|      { PL_get_arg(n, t, a);                                            |
|        if ( n > 1 )                                                    |

|          Sprintf(", ");                                                |
|        pl_display(a);                                                  |
|      }                                                                 |
|      Sprintf(")");                                                     |
|      break;                                                            |
|    default:                                                            |
|      PL_fail;                          /* should not happen */         |

|    }                                                                   |
|  }                                                                     |
|                                                                        |
|  PL_succeed;                                                           |
|}|_____________________________________________________________________ | |

            Figure 12.2:  A Foreign definition of display/1


1122..44..44 CCoonnssttrruuccttiinngg TTeerrmmss

Terms  can  be  constructed  using  functions from  the  PL_put_*()  and
PL_cons_*()  families.    This  approach  builds the  term  `inside-out',
starting  at  the  leaves  and  subsequently  creating  compound  terms.
Alternatively,   terms  may  be  created   `top-down',  first   creating
a  compound  holding  only  variables  and   subsequently  unifying  the
arguments.   This section  discusses functions  for the first  approach.
This approach  is generally  used for  creating arguments  for PL_call()
and PL_open_query().


void PPLL__ppuutt__vvaarriiaabbllee(_t_e_r_m___t _-_t)
    Put  a fresh variable in the  term, resetting the term reference  to
    its initial state.


void PPLL__ppuutt__aattoomm(_t_e_r_m___t _-_t_, _a_t_o_m___t _a)
    Put  an  atom  in the  term  reference from  a  handle.    See  also
    PL_new_atom() and PL_atom_chars().


void PPLL__ppuutt__bbooooll(_t_e_r_m___t _-_t_, _i_n_t _v_a_l)
    Put  one of the atoms true or  false in the term reference  See also
    PL_put_atom(), PL_unify_bool()and PL_get_bool().


int PPLL__ppuutt__cchhaarrss(_t_e_r_m___t _-_t_, _i_n_t _f_l_a_g_s_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    New  function  to  deal  with  setting a  term  from  a  char*  with
    various  encodings.  The _f_l_a_g_s  argument is a bitwise _o_r  specifying
    the  Prolog  target type  and  the  encoding of  _c_h_a_r_s.    A  Prolog
    type  is one of  PL_ATOM,  PL_STRING, PL_CODE_LIST  or PL_CHAR_LIST.  A
    representation  is one  of REP_ISO_LATIN_1,  REP_UTF8 or  REP_MB.  See
    PL_get_chars() for  a definition of  the representation  types.   If
    _l_e_n  is -1 _c_h_a_r_s must be zero-terminated and the length  is computed
    from _c_h_a_r_s using strlen().


int PPLL__ppuutt__aattoomm__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  an  atom  in the  term  reference  constructed from  the  zero-
    terminated  string.  The string  itself will never be referenced  by
    Prolog after this function.


int PPLL__ppuutt__ssttrriinngg__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  a zero-terminated string in the term reference.  The  data will
    be copied.  See also PL_put_string_nchars().


int PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _-_t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  a string,  represented by  a length/start pointer  pair in  the
    term  reference.  The data will be copied.  This  interface can deal
    with 0-bytes in the string.  See also section ????.


int PPLL__ppuutt__lliisstt__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put a list of ASCII values in the term reference.


int PPLL__ppuutt__iinntteeggeerr(_t_e_r_m___t _-_t_, _l_o_n_g _i)
    Put a Prolog integer in the term reference.


int PPLL__ppuutt__iinntt6644(_t_e_r_m___t _-_t_, _i_n_t_6_4___t _i)
    Put a Prolog integer in the term reference.


int PPLL__ppuutt__ppooiinntteerr(_t_e_r_m___t _-_t_, _v_o_i_d _*_p_t_r)
    Put a Prolog integer  in the term reference.  Provided _p_t_r is in the
    `malloc()-area', PL_get_pointer() will get the pointer back.


int PPLL__ppuutt__ffllooaatt(_t_e_r_m___t _-_t_, _d_o_u_b_l_e _f)
    Put a floating-point value in the term reference.


int PPLL__ppuutt__ffuunnccttoorr(_t_e_r_m___t _-_t_, _f_u_n_c_t_o_r___t _f_u_n_c_t_o_r)
    Create  a new compound  term from _f_u_n_c_t_o_r and  bind _t to this  term.
    All arguments of the  term will be variables.  To create a term with
    instantiated  arguments, either instantiate the arguments  using the
    PL_unify_*() functions or use PL_cons_functor().


int PPLL__ppuutt__lliisstt(_t_e_r_m___t _-_l)
    As  PL_put_functor(),  using  the list-cell  functor.     Note  that
    on  classical  Prolog  systems or  in  SWI-Prolog using  the  option
    --traditional,  this is ./2, while  on SWI-Prolog version 7 this  is
    [|]/2.


int PPLL__ppuutt__nniill(_t_e_r_m___t _-_l)
    Put  the list terminator constant in  _l.  Always returns TRUE.  Note
    that  in classical Prolog systems or in SWI-Prolog using  the option
    --traditional,  this is  the same  as PL_put_atom_chars(_"_[_]_").    See
    section ????.


void PPLL__ppuutt__tteerrmm(_t_e_r_m___t _-_t_1_, _t_e_r_m___t _+_t_2)
    Make _t_1 point to the same term as _t_2.


int PPLL__ccoonnss__ffuunnccttoorr(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _._._.)
    Create  a term whose arguments  are filled from a variable  argument
    list  holding the same number of term_t objects as the arity  of the
    functor.  To create the term animal(gnu, 50), use:

    ____________________________________________________________________|                                                                    |
    | { term_t a1 = PL_new_term_ref();                                   |

    |   term_t a2 = PL_new_term_ref();                                   |
    |   term_t t  = PL_new_term_ref();                                   |
    |   functor_t animal2;                                               |
    |                                                                    |
    |   /* animal2 is a constant that may be bound to a global           |
    |      variable and re-used                                          |
    |   */                                                               |
    |   animal2 = PL_new_functor(PL_new_atom("animal"), 2);              |

    |                                                                    |
    |   PL_put_atom_chars(a1, "gnu");                                    |
    |   PL_put_integer(a2, 50);                                          |
    |   PL_cons_functor(t, animal2, a1, a2);                             |
    ||}_________________________________________________________________ ||

    After  this sequence, the term references _a_1 and _a_2 may be  used for
    other purposes.


int PPLL__ccoonnss__ffuunnccttoorr__vv(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _t_e_r_m___t _a_0)
    Create  a compound term  like PL_cons_functor(),  but _a_0 is an  array
    of  term references as  returned by PL_new_term_refs().   The  length
    of  this array should match the number of arguments required  by the
    functor.


int PPLL__ccoonnss__lliisstt(_t_e_r_m___t _-_l_, _t_e_r_m___t _+_h_, _t_e_r_m___t _+_t)
    Create  a list (cons-) cell in  _l from the head _h  and tail _t.   The
    code  below creates a  list of atoms  from a char **.   The list  is
    built  tail-to-head.    The PL_unify_*() functions  can  be used  to
    build a list head-to-tail.

    ____________________________________________________________________|                                                                    |
    | void                                                               |
    | put_list(term_t l, int n, char **words)                            |
    | { term_t a = PL_new_term_ref();                                    |

    |                                                                    |
    |   PL_put_nil(l);                                                   |
    |   while( --n >= 0 )                                                |
    |   { PL_put_atom_chars(a, words[n]);                                |
    |     PL_cons_list(l, a, l);                                         |
    |   }                                                                |
    ||}_________________________________________________________________ ||

    Note  that _l can  be redefined  within a PL_cons_list call as  shown
    here because operationally  its old value is consumed before its new
    value is set.


1122..44..55 UUnniiffyyiinngg ddaattaa

The  functions  of  this  section  _u_n_i_f_y  terms  with   other  terms  or
translated C  data structures.   Except for PL_unify(), these  functions
are specific  to SWI-Prolog.    They have been  introduced because  they
shorten the code for returning data to Prolog and at  the same time make
this more  efficient by  avoiding the  need to  allocate temporary  term
references and reduce  the number of calls  to the Prolog API.  Consider
the case  where we want a  foreign function to  return the host name  of
the machine Prolog  is running on.   Using the PL_get_*() and PL_put_*()
functions, the code becomes:

________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_hostname(term_t name)                                                |

|{ char buf[100];                                                        |
|                                                                        |
|  if ( gethostname(buf, sizeof(buf)) )                                  |
|  { term_t tmp = PL_new_term_ref();                                     |
|                                                                        |
|    PL_put_atom_chars(tmp, buf);                                        |
|    return PL_unify(name, tmp);                                         |
|  }                                                                     |

|                                                                        |
|  PL_fail;                                                              |
|}|_____________________________________________________________________ | |

Using PL_unify_atom_chars(), this becomes:

________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_hostname(term_t name)                                                |

|{ char buf[100];                                                        |
|                                                                        |
|  if ( gethostname(buf, sizeof(buf)) )                                  |
|    return PL_unify_atom_chars(name, buf);                              |
|                                                                        |
|  PL_fail;                                                              |
|}|_____________________________________________________________________ | |

Note  that unification  functions  that  perform multiple  bindings  may
leave part  of the  bindings in  case of  failure.   See  PL_unify() for
details.


int PPLL__uunniiffyy(_t_e_r_m___t _?_t_1_, _t_e_r_m___t _?_t_2)
    Unify two Prolog terms and return TRUE on success.

    Care  is needed if PL_unify() returns FAIL and the  foreign function
    does  not _i_m_m_e_d_i_a_t_e_l_y  return to Prolog  with FAIL. Unification  may
    perform multiple changes to  either _t_1 or _t_2.  A failing unification
    may  have created  bindings  before failure  is detected.    _A_l_r_e_a_d_y
    _c_r_e_a_t_e_d  _b_i_n_d_i_n_g_s _a_r_e _n_o_t _u_n_d_o_n_e.   For example,  calling PL_unify()
    on a(_X_, _a) and  a(_c_,_b) binds _X to c and fails when trying to unify a
    to b.  If  control remains in C or even if we want to return success
    to  Prolog, we  _m_u_s_t undo  such bindings.   This  is achieved  using
    PL_open_foreign_frame() and  PL_rewind_foreign_frame(),  as shown  in
    the snippet below.

    ____________________________________________________________________|                                                                    |
    |     { fid_t fid = PL_open_foreign_frame();                         |

    |                                                                    |
    |       ...                                                          |
    |       if ( !PL_unify(t1, t2) )                                     |
    |         PL_rewind_foreign_frame(fid);                              |
    |       ...                                                          |
    |                                                                    |
    |       PL_close_foreign_frame(fid);                                 |
    ||____}_____________________________________________________________ ||

    In   addition,   PL_unify()  may  have  failed   on  an   eexxcceeppttiioonn,
    typically  a  resource  (stack)  overflow.     This  can  be  tested
    using  PL_exception(),  passing 0 (zero)  for the query-id  argument.
    Foreign  functions that encounter an  exception must return FAIL  to
    Prolog  as  soon as  possible or  call PL_clear_exception() if  they
    wish to ignore the exception.


int PPLL__uunniiffyy__aattoomm(_t_e_r_m___t _?_t_, _a_t_o_m___t _a)
    Unify _t with the atom _a and return non-zero on success.


int PPLL__uunniiffyy__bbooooll(_t_e_r_m___t _?_t_, _i_n_t _a)
    Unify _t with either true or false.


int PPLL__uunniiffyy__cchhaarrss(_t_e_r_m___t _?_t_, _i_n_t _f_l_a_g_s_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    New  function  to  deal  with  unification  of  char*  with  various
    encodings  to a  Prolog representation.    The _f_l_a_g_s  argument is  a
    bitwise  _o_r specifying the  Prolog target type  and the encoding  of
    _c_h_a_r_s.   A Prolog type is one of PL_ATOM, PL_STRING, PL_CODE_LIST or
    PL_CHAR_LIST. A  representation is one  of REP_ISO_LATIN_1,  REP_UTF8
    or REP_MB. See PL_get_chars() for a definition of the representation
    types.   If _l_e_n is -1  _c_h_a_r_s must be zero-terminated and  the length
    is computed from _c_h_a_r_s using strlen().

    If  _f_l_a_g_s includes PL_DIFF_LIST and  type is one  of PL_CODE_LIST  or
    PL_CHAR_LIST, the text is converted to a _d_i_f_f_e_r_e_n_c_e _l_i_s_t.   The tail
    of the difference list is t +1.


int PPLL__uunniiffyy__aattoomm__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify  _t with  an atom  created from  _c_h_a_r_s and  return non-zero  on
    success.


int PPLL__uunniiffyy__lliisstt__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _t with a list of ASCII characters constructed from _c_h_a_r_s.


void PPLL__uunniiffyy__ssttrriinngg__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify  _t  with  a  Prolog  string  object  created  from  the  zero-
    terminated  string  _c_h_a_r_s.   The  data will  be copied.    See  also
    PL_unify_string_nchars().


int PPLL__uunniiffyy__iinntteeggeerr(_t_e_r_m___t _?_t_, _i_n_t_p_t_r___t _n)
    Unify _t with a Prolog integer from _n.


int PPLL__uunniiffyy__iinntt6644(_t_e_r_m___t _?_t_, _i_n_t_6_4___t _n)
    Unify _t with a Prolog integer from _n.


int PPLL__uunniiffyy__uuiinntt6644(_t_e_r_m___t _?_t_, _u_i_n_t_6_4___t _n)
    Unify  _t with a Prolog integer from _n.  Note that  unbounded integer
    support  is required  if _n does  not fit  in a _s_i_g_n_e_d  int64_t.    If
    unbounded  integers  are  not  supported a  representation_error  is
    raised.


int PPLL__uunniiffyy__ffllooaatt(_t_e_r_m___t _?_t_, _d_o_u_b_l_e _f)
    Unify _t with a Prolog float from _f.


int PPLL__uunniiffyy__ppooiinntteerr(_t_e_r_m___t _?_t_, _v_o_i_d _*_p_t_r)
    Unify  _t with a  Prolog integer  describing the pointer.   See  also
    PL_put_pointer() and PL_get_pointer().


int PPLL__uunniiffyy__ffuunnccttoorr(_t_e_r_m___t _?_t_, _f_u_n_c_t_o_r___t _f)
    If  _t is a compound term with  the given functor, just succeed.   If
    it  is unbound,  create a  term and  bind the  variable, else  fail.
    Note  that this function does not  create a term if the argument  is
    already instantiated.   If _f is a functor with arity 0, _t is unified
    with an atom.  See also PL_unify_compound().


int PPLL__uunniiffyy__ccoommppoouunndd(_t_e_r_m___t _?_t_, _f_u_n_c_t_o_r___t _f)
    If  _t is a compound term with  the given functor, just succeed.   If
    it  is unbound,  create a  term and  bind the  variable, else  fail.
    Note  that this function does not  create a term if the argument  is
    already instantiated.   If _f is a functor with arity 0, _t is unified
    with compound without arguments.  See also PL_unify_functor().


int PPLL__uunniiffyy__lliisstt(_t_e_r_m___t _?_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    Unify  _l with a list-cell (./2).   If successful, write  a reference
    to  the head of the list into _h  and a reference to the tail  of the
    list  into _t.   This reference may be  used for subsequent calls  to
    this  function.   Suppose we  want to  return a list  of atoms  from
    a  char **.   We could  use the example  described by PL_put_list(),
    followed by  a call to PL_unify(), or we can use  the code below.  If
    the  predicate argument is unbound,  the difference is minimal  (the
    code  based on PL_put_list() is probably slightly  faster).  If  the
    argument  is bound, the code below may fail before reaching  the end
    of  the word list, but even  if the unification succeeds, this  code
    avoids a duplicate (garbage) list and a deep unification.

    ____________________________________________________________________|                                                                    |
    | foreign_t                                                          |

    | pl_get_environ(term_t env)                                         |
    | { term_t l = PL_copy_term_ref(env);                                |
    |   term_t a = PL_new_term_ref();                                    |
    |   extern char **environ;                                           |
    |   char **e;                                                        |
    |                                                                    |
    |   for(e = environ; *e; e++)                                        |
    |   { if ( !PL_unify_list(l, a, l) ||                                |

    |          !PL_unify_atom_chars(a, *e) )                             |
    |       PL_fail;                                                     |
    |   }                                                                |
    |                                                                    |
    |   return PL_unify_nil(l);                                          |
    ||}_________________________________________________________________ ||


int PPLL__uunniiffyy__nniill(_t_e_r_m___t _?_l)
    Unify _l with the atom [].


int PPLL__uunniiffyy__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _?_t_, _t_e_r_m___t _?_a)
    Unifies the _i_n_d_e_x_-_t_h argument (1-based) of _t with _a.


int PPLL__uunniiffyy__tteerrmm(_t_e_r_m___t _?_t_, _._._.)
    Unify  _t with a (normally) compound  term.  The remaining  arguments
    are  a  sequence  of a  type  identifier  followed by  the  required
    arguments.      This  predicate  is  an  extension  to  the  Quintus
    and  SICStus foreign  interface  from which  the SWI-Prolog  foreign
    interface  has been  derived, but has  proved to  be a powerful  and
    comfortable  way to create compound terms from C. Due to  the vararg
    packing/unpacking and  the required type-switching this interface is
    slightly  slower than using the primitives.   Please note that  some
    bad  C compilers have fairly low  limits on the number of  arguments
    that may be passed to a function.

    Special  attention is required when  passing numbers.  C  `promotes'
    any  integral smaller than  int to int.   That  is, the types  char,
    short  and int are all passed as  int.  In addition, on  most 32-bit
    platforms  int and long  are the same.   Up  to version 4.0.5,  only
    PL_INTEGER  could  be specified,  which  was  taken from  the  stack
    as  long.   Such  code fails when  passing small  integral types  on
    machines  where int  is smaller than  long.   It is  advised to  use
    PL_SHORT, PL_INT or PL_LONG as appropriate.  Similarly,  C compilers
    promote  float to  double and  therefore PL_FLOAT and  PL_DOUBLE  are
    synonyms.

    The type identifiers are:

    PL_VARIABLE _n_o_n_e
         No op.  Used in arguments of PL_FUNCTOR.

    PL_BOOL _i_n_t
         Unify the argument with true or false.

    PL_ATOM _a_t_o_m___t
         Unify the argument with an atom, as in PL_unify_atom().

    PL_CHARS _c_o_n_s_t _c_h_a_r _*
         Unify the argument with an atom constructed from  the C char *,
         as in PL_unify_atom_chars().

    PL_NCHARS _s_i_z_e___t_, _c_o_n_s_t _c_h_a_r _*
         Unify the  argument with  an atom constructed  from length  and
         char* as in PL_unify_atom_nchars().

    PL_UTF8_CHARS _c_o_n_s_t _c_h_a_r _*
         Create an atom from a UTF-8 string.

    PL_UTF8_STRING _c_o_n_s_t _c_h_a_r _*
         Create a packed string object from a UTF-8 string.

    PL_MBCHARS _c_o_n_s_t _c_h_a_r _*
         Create an atom from a multi-byte string in the current locale.

    PL_MBCODES _c_o_n_s_t _c_h_a_r _*
         Create a list  of character codes  from a multi-byte string  in
         the current locale.

    PL_MBSTRING _c_o_n_s_t _c_h_a_r _*
         Create a packed string  object from a multi-byte string  in the
         current locale.

    PL_NWCHARS _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create an atom from a length and a wide character pointer.

    PL_NWCODES _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create a  list of  character  codes from  a length  and a  wide
         character pointer.

    PL_NWSTRING _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create  a  packed  string object  from  a  length  and  a  wide
         character pointer.

    PL_SHORT _s_h_o_r_t
         Unify the argument  with an integer,  as in PL_unify_integer().
         As short is promoted to int, PL_SHORT is a synonym for PL_INT.

    PL_INTEGER _l_o_n_g
         Unify the argument with an integer, as in PL_unify_integer().

    PL_INT _i_n_t
         Unify the argument with an integer, as in PL_unify_integer().

    PL_LONG _l_o_n_g
         Unify the argument with an integer, as in PL_unify_integer().

    PL_INT64 _i_n_t_6_4___t
         Unify   the   argument   with   a  64-bit   integer,    as   in
         PL_unify_int64().

    PL_INTPTR _i_n_t_p_t_r___t
         Unify the  argument with an  integer with the  same width as  a
         pointer.  On most machines this is  the same as PL_LONG. but on
         64-bit MS-Windows pointers are 64 bits while longs  are only 32
         bits.

    PL_DOUBLE _d_o_u_b_l_e
         Unify  the  argument  with a  float,  as  in  PL_unify_float().
         Note  that,  as the  argument  is  passed using  the  C  vararg
         conventions, a float must be casted to a double explicitly.

    PL_FLOAT _d_o_u_b_l_e
         Unify the argument with a float, as in PL_unify_float().

    PL_POINTER _v_o_i_d _*
         Unify the argument with a pointer, as in PL_unify_pointer().

    PL_STRING _c_o_n_s_t _c_h_a_r _*
         Unify   the   argument   with   a   string   object,    as   in
         PL_unify_string_chars().

    PL_TERM _t_e_r_m___t
         Unify a  subterm.   Note  this  may be  the return  value of  a
         PL_new_term_ref()call to get access to a variable.

    PL_FUNCTOR _f_u_n_c_t_o_r___t_, _._._.
         Unify the argument  with a compound  term.  This  specification
         should be  followed by  exactly as many  specifications as  the
         number of arguments of the compound term.

    PL_FUNCTOR_CHARS _c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _._._.
         Create a functor from the given name and arity  and then behave
         as PL_FUNCTOR.

    PL_LIST _i_n_t _l_e_n_g_t_h_, _._._.
         Create  a  list  of  the  indicated  length.     The  remaining
         arguments contain the elements of the list.

    For  example, to  unify an argument  with the term  language(dutch),
    the following skeleton may be used:

    ____________________________________________________________________|                                                                    |

    | static functor_t FUNCTOR_language1;                                |
    |                                                                    |
    | static void                                                        |
    | init_constants()                                                   |
    | { FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"),1);   |

    | }                                                                  |
    |                                                                    |
    | foreign_t                                                          |
    | pl_get_lang(term_t r)                                              |
    | { return PL_unify_term(r,                                          |
    |                        PL_FUNCTOR, FUNCTOR_language1,              |
    |                            PL_CHARS, "dutch");                     |
    | }                                                                  |

    |                                                                    |
    | install_t                                                          |
    | install()                                                          |
    | { PL_register_foreign("get_lang", 1, pl_get_lang, 0);              |
    |   init_constants();                                                |
    ||}_________________________________________________________________ ||


int PPLL__cchhaarrss__ttoo__tteerrmm(_c_o_n_s_t _c_h_a_r _*_c_h_a_r_s_, _t_e_r_m___t _-_t)
    Parse  the string _c_h_a_r_s  and put the  resulting Prolog term into  _t.
    _c_h_a_r_s  may or may not  be closed using  a Prolog full-stop (i.e.,  a
    dot  followed by  a blank).   Returns  FALSE if a  syntax error  was
    encountered  and TRUE after successful  completion.  In addition  to
    returning  FALSE, the exception-term  is returned in  _t on a  syntax
    error.  See also term_to_atom/2.

    The  following example builds  a goal term  from a string and  calls
    it.

    ____________________________________________________________________|                                                                    |
    | int                                                                |
    | call_chars(const char *goal)                                       |
    | { fid_t fid = PL_open_foreign_frame();                             |

    |   term_t g = PL_new_term_ref();                                    |
    |   BOOL rval;                                                       |
    |                                                                    |
    |   if ( PL_chars_to_term(goal, g) )                                 |
    |     rval = PL_call(goal, NULL);                                    |
    |   else                                                             |
    |     rval = FALSE;                                                  |
    |                                                                    |

    |   PL_discard_foreign_frame(fid);                                   |
    |   return rval;                                                     |
    | }                                                                  |
    |   ...                                                              |
    |   call_chars("consult(load)");                                     |
    ||__..._____________________________________________________________ ||


int PPLL__wwcchhaarrss__ttoo__tteerrmm(_c_o_n_s_t _p_l___w_c_h_a_r___t _*_c_h_a_r_s_, _t_e_r_m___t _-_t)
    Wide character version of PL_chars_to_term().


char * PPLL__qquuoottee(_i_n_t _c_h_r_, _c_o_n_s_t _c_h_a_r _*_s_t_r_i_n_g)
    Return a quoted version of  _s_t_r_i_n_g.  If _c_h_r is '\'', the result is a
    quoted  atom.  If _c_h_r  is '"', the result is  a string.  The  result
    string  is stored in the same ring of buffers as described  with the
    BUF_RING argument of PL_get_chars();

    In  the current implementation, the string is surrounded by  _c_h_r and
    any occurrence of _c_h_r  is doubled.  In the future the behaviour will
    depend on the character_escapes Prolog flag.


1122..44..66 CCoonnvveenniieenntt ffuunnccttiioonnss ttoo ggeenneerraattee PPrroolloogg eexxcceeppttiioonnss

The  typical  implementation  of a  foreign  predicate  first  uses  the
PL_get_*() functions  to  extract C  data types  from the  Prolog  terms.
Failure of any  of these functions is  normally because the Prolog  term
is of  the wrong  type.   The  *_ex()  family of  functions are  wrappers
around (mostly)  the PL_get_*() functions,  such that  we can write  code
in  the  style  below  and get  proper  exceptions  if  an  argument  is
uninstantiated or of the wrong type.

________________________________________________________________________|                                                                        |
|/** set_size(+Name:atom, +Width:int, +Height:int) is det.               |

|                                                                        |
|static foreign_t                                                        |
|set_size(term_t name, term_t width, term_t height)                      |
|{ char *n;                                                              |
|  int w, h;                                                             |
|                                                                        |
|  if ( !PL_get_chars(name, &n, CVT_ATOM|CVT_EXCEPTION) ||               |
|       !PL_get_integer_ex(with, &w) ||                                  |

|       !PL_get_integer_ex(height, &h) )                                 |
|    return FALSE;                                                       |
|                                                                        |
|  ...                                                                   |
|                                                                        |
|}|_____________________________________________________________________ | |


int PPLL__ggeett__aattoomm__eexx(_t_e_r_m___t _t_, _a_t_o_m___t _*_a)
    As  PL_get_atom(), but raises  a type or instantiation error if  _t is
    not an atom.


int PPLL__ggeett__iinntteeggeerr__eexx(_t_e_r_m___t _t_, _i_n_t _*_i)
    As  PL_get_integer(), but raises  a type or instantiation error  if _t
    is  not an integer, or a representation error if the  Prolog integer
    does not fit in a C int.


int PPLL__ggeett__lloonngg__eexx(_t_e_r_m___t _t_, _l_o_n_g _*_i)
    As  PL_get_long(), but raises  a type or instantiation error if  _t is
    not  an atom, or a representation  error if the Prolog integer  does
    not fit in a C long.


int PPLL__ggeett__iinntt6644__eexx(_t_e_r_m___t _t_, _i_n_t_6_4___t _*_i)
    As  PL_get_int64(), but raises a type or instantiation error  if _t is
    not  an atom, or a representation  error if the Prolog integer  does
    not fit in a C int64_t.


int PPLL__ggeett__iinnttppttrr__eexx(_t_e_r_m___t _t_, _i_n_t_p_t_r___t _*_i)
    As  PL_get_intptr(), but  raises a type  or instantiation error if  _t
    is  not an  atom, or a  representation error  if the Prolog  integer
    does not fit in a C intptr_t.


int PPLL__ggeett__ssiizzee__eexx(_t_e_r_m___t _t_, _s_i_z_e___t _*_i)
    As  PL_get_size(), but raises  a type or instantiation error if  _t is
    not  an atom, or a representation  error if the Prolog integer  does
    not fit in a C size_t.


int PPLL__ggeett__bbooooll__eexx(_t_e_r_m___t _t_, _i_n_t _*_i)
    As  PL_get_bool(), but raises  a type or instantiation error if  _t is
    not an boolean.


int PPLL__ggeett__ffllooaatt__eexx(_t_e_r_m___t _t_, _d_o_u_b_l_e _*_f)
    As  PL_get_float(), but raises a type or instantiation error  if _t is
    not a float.


int PPLL__ggeett__cchhaarr__eexx(_t_e_r_m___t _t_, _i_n_t _*_p_, _i_n_t _e_o_f)
    Get  a character code  from _t, where  _t is either  an integer or  an
    atom with length one.   If _e_o_f is TRUE and _t is -1, _p is filled with
    -1.  Raises an appropriate error if the conversion is not possible.


int PPLL__ggeett__ppooiinntteerr__eexx(_t_e_r_m___t _t_, _v_o_i_d _*_*_a_d_d_r_p)
    As  PL_get_pointer(), but raises  a type or instantiation error  if _t
    is not a pointer.


int PPLL__ggeett__lliisstt__eexx(_t_e_r_m___t _l_, _t_e_r_m___t _h_, _t_e_r_m___t _t)
    As  PL_get_list(), but raises  a type or instantiation error if  _t is
    not a list.


int PPLL__ggeett__nniill__eexx(_t_e_r_m___t _l)
    As  PL_get_nil(), but  raises a type or  instantiation error if _t  is
    not the empty list.


int PPLL__uunniiffyy__lliisstt__eexx(_t_e_r_m___t _l_, _t_e_r_m___t _h_, _t_e_r_m___t _t)
    As PL_unify_list(), but raises a type error if _t is  not a variable,
    list-cell or the empty list.


int PPLL__uunniiffyy__nniill__eexx(_t_e_r_m___t _l)
    As  PL_unify_nil(), but raises  a type error if _t is not  a variable,
    list-cell or the empty list.


int PPLL__uunniiffyy__bbooooll__eexx(_t_e_r_m___t _t_, _i_n_t _v_a_l)
    As  PL_unify_bool(), but raises  a type error if _t is not  a variable
    or a boolean.

The  second  family   of  functions  in  this  section  simplifies   the
generation of  ISO compatible error  terms.   Any foreign function  that
calls  this function  must return  to  Prolog with  the return  code  of
the error  function or  the constant  FALSE. If  available, these  error
functions add the  name of the calling  predicate to the error  context.
See also PL_raise_exception().


int PPLL__iinnssttaannttiiaattiioonn__eerrrroorr(_t_e_r_m___t _c_u_l_p_r_i_t)
    Raise  instantiation_error.    _C_u_l_p_r_i_t  is ignored,  but  should  be
    bound  to  the  term  that  is insufficiently  instantiated.     See
    instantiation_error/1.


int PPLL__uunniinnssttaannttiiaattiioonn__eerrrroorr(_t_e_r_m___t _c_u_l_p_r_i_t)
    Raise  uninstantiation_error(culprit).   This should be called  if an
    argument  that must be unbound at entry  is bound to _c_u_l_p_r_i_t.   This
    error  is typically  raised for a  pure output  arguments such as  a
    newly created stream handle (e.g., the third argument of open/3).


int PPLL__rreepprreesseennttaattiioonn__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_r_e_s_o_u_r_c_e)
    Raise representation_error(resource).  See representation_error/1.


int PPLL__ttyyppee__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_e_x_p_e_c_t_e_d_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise type_error(expected, culprit).  See type_error/2.


int PPLL__ddoommaaiinn__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_e_x_p_e_c_t_e_d_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise domain_error(expected, culprit).  See domain_error/2.


int PPLL__eexxiisstteennccee__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_t_y_p_e_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise existence_error(type, culprit).  See type_error/2.


int PPLL__ppeerrmmiissssiioonn__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_o_p_e_r_a_t_i_o_n_, _c_o_n_s_t _c_h_a_r _*_t_y_p_e_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise     permission_error(operation, type, culprit).            See
    permission_error/3.


int PPLL__rreessoouurrccee__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_r_e_s_o_u_r_c_e)
    Raise resource_error(resource).  See resource_error/1.


int PPLL__ssyynnttaaxx__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_m_e_s_s_a_g_e_, _I_O_S_T_R_E_A_M _*_i_n)
    Raise  syntax_error(message).   If _a_r_g  is not NULL, add  information
    about the current position of the input stream.


1122..44..77 BBLLOOBBSS:: UUssiinngg aattoommss ttoo ssttoorree aarrbbiittrraarryy bbiinnaarryy ddaattaa

SWI-Prolog atoms as well as strings can represent  arbitrary binary data
of arbitrary length.   This facility  is attractive for storing  foreign
data such  as images in an  atom.   An atom is  a unique handle to  this
data and the  atom garbage collector is  able to destroy atoms that  are
no longer  referenced by  the Prolog  engine.   This  property of  atoms
makes them  attractive as a  handle to foreign  resources, such as  Java
atoms, Microsoft's  COM objects, etc.,  providing safe combined  garbage
collection.

To  exploit   these  features  safely  and   in  an  organised   manner,
the  SWI-Prolog  foreign  interface allows  for  creating  `atoms'  with
additional type  information.   The type is  represented by a  structure
holding C  function pointers that  tell Prolog  how to handle  releasing
the  atom,  writing it,  sorting  it,  etc.    Two  atoms  created  with
different types  can represent the  same sequence of bytes.   Atoms  are
first ordered on the rank  number of the type and then on the  result of
the compare()  function.   Rank numbers  are assigned  when the type  is
registered.


1122..44..77..11 DDeeffiinniinngg aa BBLLOOBB ttyyppee

The  type PL_blob_t represents  a structure  with  the layout  displayed
below.  The structure contains additional fields at  the ...for internal
bookkeeping as well as future extensions.

________________________________________________________________________|                                                                        |
|typedef struct PL_blob_t                                                |

|{ uintptr_t     magic;          /* PL_BLOB_MAGIC */                     |
|  uintptr_t     flags;          /* Bitwise or of PL_BLOB_* */           |
|  char *        name;           /* name of the type */                  |
|  int           (*release)(atom_t a);                                   |
|  int           (*compare)(atom_t a, atom_t b);                         |
|  int           (*write)(IOSTREAM *s, atom_t a, int flags);             |
|  void          (*acquire)(atom_t a);                                   |
|  ...                                                                   |

|}|PL_blob_t;___________________________________________________________ | |

For each  type, exactly  one such structure  should be  allocated.   Its
first field must be initialised to PL_BLOB_MAGIC. The _f_l_a_g_s is a bitwise
_o_r of the following constants:

PPLL__BBLLOOBB__TTEEXXTT
    If  specified the blob is assumed to contain text and  is considered
    a normal Prolog atom.

PPLL__BBLLOOBB__UUNNIIQQUUEE
    If  specified the system  ensures that the  blob-handle is a  unique
    reference  for a blob with the given  type, length and content.   If
    this flag is not specified, each lookup creates a new blob.

PPLL__BBLLOOBB__NNOOCCOOPPYY
    By  default the  content of the  blob is  copied.   Using this  flag
    the  blob references  the external  data directly.    The user  must
    ensure  the provided  pointer is valid  as long  as the atom  lives.
    If  PL_BLOB_UNIQUE  is also  specified, uniqueness  is determined  by
    comparing the pointer rather than the data pointed at.

The _n_a_m_e  field represents the type  name as available  to Prolog.   See
also current_blob/2.  The  other fields are function pointers  that must
be initialised to proper functions or NULL to get  the default behaviour
of built-in atoms.  Below are the defined member functions:


void aaccqquuiirree(_a_t_o_m___t _a)
    Called  if a new blob of this  type is created through PL_put_blob()
    or  PL_unify_blob().   This  callback may be  used together with  the
    release hook to deal with reference-counted external objects.


int rreelleeaassee(_a_t_o_m___t _a)
    The  blob (atom)  _a is  about to  be released.    This function  can
    retrieve  the data of the blob using PL_blob_data().  If  it returns
    FALSE the atom garbage collector will _n_o_t reclaim the atom.


int ccoommppaarree(_a_t_o_m___t _a_, _a_t_o_m___t _b)
    Compare the blobs _a  and _b, both of which are of the type associated
    to  this blob type.   Return  values are, as  memcmp(), < 0 if _a is
    less than _b, = 0 if both are equal, and >0 otherwise.


int wwrriittee(_I_O_S_T_R_E_A_M _*_s_, _a_t_o_m___t _a_, _i_n_t _f_l_a_g_s)
    Write  the content  of the  blob _a to  the stream  _s respecting  the
    _f_l_a_g_s.   The _f_l_a_g_s are a bitwise _o_r  _o_f _z_e_r_o _o_r _m_o_r_e _o_f _t_h_e PL_WRT_*
    _f_l_a_g_s  _d_e_f_i_n_e_d _i_n SWI-Prolog.h_.  _T_h_i_s _p_r_o_t_o_t_y_p_e _i_s _a_v_a_i_l_a_b_l_e _i_f  _t_h_e
    _u_n_d_o_c_u_m_e_n_t_e_d SWI-Stream.h _i_s _i_n_c_l_u_d_e_d _b_e_f_o_r_e SWI-Prolog.h_.

    _I_f  _t_h_i_s _f_u_n_c_t_i_o_n _i_s _n_o_t _p_r_o_v_i_d_e_d_, write/1 _e_m_i_t_s _t_h_e _c_o_n_t_e_n_t  _o_f _t_h_e
    _b_l_o_b  _f_o_r _b_l_o_b_s _o_f _t_y_p_e PL_BLOB_TEXT _o_r _a _s_t_r_i_n_g _o_f  _t_h_e _f_o_r_m_a_t <#_h_e_x
    _d_a_t_a> _f_o_r _b_i_n_a_r_y _b_l_o_b_s_.

If  a blob  type is  registered from  a loadable  object (shared  object
or DLL)  the blob  type must be  deregistered before  the object may  be
released.


int PPLL__uunnrreeggiisstteerr__bblloobb__ttyyppee(_P_L___b_l_o_b___t _*_t_y_p_e)
    Unlink  the blob  type from  the registered type  and transform  the
    type  of possible  living blobs  to  unregistered, avoiding  further
    reference  to the type structure, functions referred by it,  as well
    as  the data.  This function  returns TRUE if no blobs of  this type
    existed  and FALSE otherwise.  PL_unregister_blob_type() is intended
    for  the  uninstall()  hook of  foreign  modules,  avoiding  further
    references to the module.


1122..44..77..22 AAcccceessssiinngg bblloobbss

The blob access  functions are similar to the atom  accessing functions.
Blobs being atoms, the  atom functions operate on blobs and  vice versa.
For clarity  and possible  future compatibility issues,  however, it  is
not advised to rely on this.


int PPLL__iiss__bblloobb(_t_e_r_m___t _t_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    Succeeds  if _t refers to a blob,  in which case _t_y_p_e is  filled with
    the type of the blob.


int PPLL__uunniiffyy__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_b_l_o_b_, _s_i_z_e___t _l_e_n_, _P_L___b_l_o_b___t _*_t_y_p_e)
    Unify  _t  to  a  new  blob  constructed  from  the  given  data  and
    associated to the given type.  See also PL_unify_atom_nchars().


int PPLL__ppuutt__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_b_l_o_b_, _s_i_z_e___t _l_e_n_, _P_L___b_l_o_b___t _*_t_y_p_e)
    Store  the described blob in _t.  The return value  indicates whether
    a  new blob  was allocated  (FALSE) or the  blob is  a reference  to
    an  existing  blob (TRUE).  Reporting new/existing  can  be used  to
    deal  with external objects having their  own reference counts.   If
    the  return is TRUE  this reference count  must be incremented,  and
    it  must be  decremented on  blob destruction  callback.   See  also
    PL_put_atom_nchars().


int PPLL__ggeett__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_*_b_l_o_b_, _s_i_z_e___t _*_l_e_n_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    If  _t holds a blob or atom,  get the data and type and  return TRUE.
    Otherwise  return FALSE. Each result  pointer may be NULL, in  which
    case the requested information is ignored.


void * PPLL__bblloobb__ddaattaa(_a_t_o_m___t _a_, _s_i_z_e___t _*_l_e_n_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    Get  the data  and type  associated to  a blob.    This function  is
    mainly used from the callback functions described in section ????.


1122..44..88 EExxcchhaannggiinngg GGMMPP nnuummbbeerrss

If  SWI-Prolog is  linked  with the  GNU Multiple  Precision  Arithmetic
Library  (GMP,  used   by  default),  the  foreign   interface  provides
functions  for   exchanging  numeric   values  to   GMP  types.       To
access  these functions  the  header  <gmp.h> must  be  included  _b_e_f_o_r_e
<SWI-Prolog.h>.   Foreign code using GMP  linked to SWI-Prolog asks  for
some considerations.

  o SWI-Prolog  normally   rebinds  the  GMP  allocation  functions  us-
    ing  mp_set_memory_functions().     This  means  SWI-Prolog  must  be
    initialised  before  the  foreign  code touches  any  GMP  function.
    You  can call \cfuncref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, TRUE}
    to   force   Prolog's   GMP   initialization   without   doing   the
    rest    of   the    Prolog   initialization.          If   you    do
    not    want   Prolog    rebinding   the   GMP    allocation,    call
    \cfuncref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, FALSE}  _b_e_f_o_r_e ini-
    tializing Prolog.

  o On  Windows, each DLL  has its own  memory pool.   To make  exchange
    of  GMP numbers between  Prolog and foreign  code possible you  must
    either  let Prolog rebind the allocation functions (default)  or you
    must  recompile  SWI-Prolog to  link to  a DLL  version  of the  GMP
    library.

Here is an example exploiting the function mpz_nextprime():

________________________________________________________________________|                                                                        |

|#include <gmp.h>                                                        |
|#include <SWI-Prolog.h>                                                 |
|                                                                        |
|static foreign_t                                                        |
|next_prime(term_t n, term_t prime)                                      |

|{ mpz_t mpz;                                                            |
|  int rc;                                                               |
|                                                                        |
|  mpz_init(mpz);                                                        |
|  if ( PL_get_mpz(n, mpz) )                                             |
|  { mpz_nextprime(mpz, mpz);                                            |
|                                                                        |
|    rc = PL_unify_mpz(prime, mpz);                                      |

|  } else                                                                |
|    rc = FALSE;                                                         |
|                                                                        |
|  mpz_clear(mpz);                                                       |
|  return rc;                                                            |
|}                                                                       |
|                                                                        |

|install_t                                                               |
|install()                                                               |
|{ PL_register_foreign("next_prime", 2, next_prime, 0);                  |
|}|_____________________________________________________________________ | |


int PPLL__ggeett__mmppzz(_t_e_r_m___t _t_, _m_p_z___t _m_p_z)
    If  _t represents an integer,  _m_p_z is filled  with the value and  the
    function  returns TRUE. Otherwise _m_p_z is untouched and  the function
    returns  FALSE.  Note that  _m_p_z must  have  been initialised  before
    calling  this  function and  must  be cleared  using  mpz_clear()  to
    reclaim any storage associated with it.


int PPLL__ggeett__mmppqq(_t_e_r_m___t _t_, _m_p_q___t _m_p_q)
    If  _t is an integer or rational number (term rdiv/2), _m_p_q  is filled
    with  the _n_o_r_m_a_l_i_s_e_d rational number and the function  returns TRUE.
    Otherwise  _m_p_q is  untouched and  the function  returns FALSE.  Note
    that  _m_p_q must  have been initialised  before calling this  function
    and  must  be  cleared  using  mpq_clear()  to  reclaim  any  storage
    associated with it.


int PPLL__uunniiffyy__mmppzz(_t_e_r_m___t _t_, _m_p_z___t _m_p_z)
    Unify  _t with the integer value  represented by _m_p_z and return  TRUE
    on success.  The _m_p_z argument is not changed.


int PPLL__uunniiffyy__mmppqq(_t_e_r_m___t _t_, _m_p_q___t _m_p_q)
    Unify  _t with a rational number  represented by _m_p_q and return  TRUE
    on  success.    Note  that  _t is  unified  with  an integer  if  the
    denominator is 1.  The _m_p_q argument is not changed.


1122..44..99 CCaalllliinngg PPrroolloogg ffrroomm CC

The  Prolog engine  can  be called  from  C.  There are  two  interfaces
for this.    For the  first, a  term is created  that could  be used  as
an  argument to  call/1,  and then  PL_call() is  used to  call  Prolog.
This  system is  simple, but  does not  allow to  inspect the  different
answers  to a  non-deterministic  goal and  is  relatively slow  as  the
runtime  system needs  to  find the  predicate.    The  other  interface
is  based on  PL_open_query(),  PL_next_solution() and  PL_cut_query() or
PL_close_query().     This mechanism  is  more powerful,  but  also  more
complicated to use.


1122..44..99..11 PPrreeddiiccaattee rreeffeerreenncceess

This  section  discusses   the  functions  used  to  communicate   about
predicates.     Though  a  Prolog  predicate  may  be  defined  or  not,
redefined,  etc.,  a  Prolog predicate  has  a handle  that  is  neither
destroyed nor moved.  This handle is known by the type predicate_t.


predicate_t PPLL__pprreedd(_f_u_n_c_t_o_r___t _f_, _m_o_d_u_l_e___t _m)
    Return  a handle to a predicate for the specified name/arity  in the
    given module.   This function always succeeds, creating a handle for
    an  undefined predicate if no handle  was available.  If the  module
    argument _m is NULL, the current context module is used.


predicate_t PPLL__pprreeddiiccaattee(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _c_o_n_s_t _c_h_a_r_* _m_o_d_u_l_e)
    Same  as PL_pred(),  but provides a more convenient interface  to the
    C programmer.


void PPLL__pprreeddiiccaattee__iinnffoo(_p_r_e_d_i_c_a_t_e___t _p_, _a_t_o_m___t _*_n_, _s_i_z_e___t _*_a_, _m_o_d_u_l_e___t _*_m)
    Return  information on the  predicate _p.   The  name is stored  over
    _n,  the  arity  over _a,  while  _m  receives the  definition  module.
    Note  that  the  latter need  not  be  the same  as  specified  with
    PL_predicate().  If the predicate is imported  into the module given
    to  PL_predicate(),  this function will  return the module where  the
    predicate is defined.  Any of the arguments _n, _a and _m can be NULL.


1122..44..99..22 IInniittiiaattiinngg aa qquueerryy ffrroomm CC

This  section discusses  the  functions  for creating  and  manipulating
queries from C. Note that a foreign context can have  at most one active
query.   This implies that it is  allowed to make strictly nested  calls
between C  and Prolog  (Prolog calls C,  calls Prolog,  calls C,  etc.),
but it  is nnoott  allowed to  open multiple queries  and start  generating
solutions for  each of them by  calling PL_next_solution().   Be sure  to
call PL_cut_query() or PL_close_query() on any  query you opened  before
opening the next or returning control back to Prolog.


qid_t PPLL__ooppeenn__qquueerryy(_m_o_d_u_l_e___t _c_t_x_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_, _t_e_r_m___t _+_t_0)
    Opens  a  query and  returns  an identifier  for  it.   _c_t_x  is  the
    _c_o_n_t_e_x_t  _m_o_d_u_l_e  of  the  goal.    When  NULL,  the  context  module
    of  the  calling context  will  be used,  or  user  if there  is  no
    calling  context  (as  may  happen  in  embedded  systems).     Note
    that  the context  module  only matters  for _m_e_t_a_-_p_r_e_d_i_c_a_t_e_s.    See
    meta_predicate/1, context_module/1 and module_transparent/1.   The _p
    argument  specifies the  predicate, and  should be the  result of  a
    call  to PL_pred() or PL_predicate().   Note that  it is allowed  to
    store  this handle as global data  and reuse it for future  queries.
    The  term reference _t_0 is the  first of a vector of term  references
    as returned by PL_new_term_refs(_n).

    The  _f_l_a_g_s  arguments provides  some additional  options  concerning
    debugging  and  exception handling.    It  is a  bitwise _o_r  of  the
    following values:

    PL_Q_NORMAL
         Normal operation.  The debugger inherits its  settings from the
         environment.   If an  exception occurs that  is not handled  in
         Prolog,  a message  is printed  and the  tracer  is started  to
         debug the error.

    PL_Q_NODEBUG
         Switch off the debugger while executing the goal.   This option
         is used by many  calls to hook-predicates to avoid  tracing the
         hooks.   An example is  print/1 calling portray/1 from  foreign
         code.

    PL_Q_CATCH_EXCEPTION
         If an  exception is  raised while  executing the  goal, do  not
         report it, but make it available for PL_exception().

    PL_Q_PASS_EXCEPTION
         As PL_Q_CATCH_EXCEPTION,  but do  not invalidate the  exception-
         term  while   calling  PL_close_query().      This  option   is
         experimental.

    PL_Q_ALLOW_YIELD
         Support the  I_YIELD  instruction for engine-based  coroutining.
         See $engine_yield/2 in boot/init.pl for details.

    PL_Q_EXT_STATUS
         Make PL_next_solution() return  extended status.    Instead  of
         only  TRUE or  FALSE  extended  status as  illustrated  in  the
         following table:

         __EExxtteennddeedd______________NNoorrmmaall____________________________________________________________________________________________________
          PL_S_EXCEPTION FALSE   Exception available through PL_exception()
          PL_S_FALSE     FALSE   Query failed
          PL_S_TRUE      TRUE    Query succeeded with choicepoint
          PL_S_LAST      TRUE    Query succeeded without choicepoint

    PL_open_query() can return the query identifier `0' if  there is not
    enough  space on  the environment  stack.   This function  succeeds,
    even  if  the  referenced  predicate  is  not  defined.     In  this
    case,  running  the query  using PL_next_solution()  will return  an
    existence_error.  See PL_exception().

    The example below opens  a query to the predicate is_a/2 to find the
    ancestor  of `me'.  The reference to the predicate is valid  for the
    duration of the process and may be cached by the client.

    ____________________________________________________________________|                                                                    |

    | char *                                                             |
    | ancestor(const char *me)                                           |
    | { term_t a0 = PL_new_term_refs(2);                                 |
    |   static predicate_t p;                                            |
    |                                                                    |
    |   if ( !p )                                                        |
    |     p = PL_predicate("is_a", 2, "database");                       |

    |                                                                    |
    |   PL_put_atom_chars(a0, me);                                       |
    |   PL_open_query(NULL, PL_Q_NORMAL, p, a0);                         |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


int PPLL__nneexxtt__ssoolluuttiioonn(_q_i_d___t _q_i_d)
    Generate the first (next)  solution for the given query.  The return
    value  is TRUE if  a solution  was found, or  FALSE to indicate  the
    query  could not be proven.  This function may be  called repeatedly
    until it fails to generate all solutions to the query.


void PPLL__ccuutt__qquueerryy(_q_i_d___t _q_i_d)
    Discards  the query, but does not delete any of the data  created by
    the  query.   It just invalidates  _q_i_d, allowing for  a new call  to
    PL_open_query() in this context.


void PPLL__cclloossee__qquueerryy(_q_i_d___t _q_i_d)
    As  PL_cut_query(), but  all data and  bindings created by the  query
    are destroyed.


qid_t PPLL__ccuurrrreenntt__qquueerryy(_v_o_i_d)
    Returns  the query id of  of the current query  or 0 if the  current
    thread is not executing any queries.


int PPLL__ccaallll__pprreeddiiccaattee(_m_o_d_u_l_e___t _m_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_r_e_d_, _t_e_r_m___t _+_t_0)
    Shorthand  for  PL_open_query(),  PL_next_solution(),  PL_cut_query(),
    generating  a single solution.   The arguments  are the same as  for
    PL_open_query(), the return value is the same as PL_next_solution().


int PPLL__ccaallll(_t_e_r_m___t _t_, _m_o_d_u_l_e___t _m)
    Call  term _t just like the Prolog predicate once/1.  _t  is called in
    the  module _m, or in the context  module if _m == NULL.  Returns TRUE
    if  the call succeeds, FALSE otherwise.  Figure ???? shows  an example
    to  obtain the number of defined atoms.   All checks are  omitted to
    improve readability.


1122..44..1100 DDiissccaarrddiinngg DDaattaa

The Prolog data  created and term references  needed to set up the  call
and/or analyse  the result can  in most cases  be discarded right  after
the  call.    PL_close_query() allows  for destroying  the  data,  while
leaving the  term references.   The calls below  may be used to  destroy
term references and data.  See figure ???? for an example.


fid_t PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee()
    Create  a  foreign frame,  holding  a mark  that allows  the  system
    to  undo bindings  and destroy  data created  after it,  as well  as
    providing  the  environment  for creating  term  references.    This
    function   is  called  by  the  kernel  before  calling   a  foreign
    predicate.


void PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Discard  all term  references created  after the  frame was  opened.
    All  other Prolog data is retained.  This function is called  by the
    kernel whenever a foreign function returns control back to Prolog.


void PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Same  as PL_close_foreign_frame(),  but also  undo all bindings  made
    since the open and destroy all Prolog data.


void PPLL__rreewwiinndd__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Undo all bindings  and discard all term references created since the
    frame  was created, but  do not pop  the frame.   That is, the  same
    frame  can be rewound multiple times, and must eventually  be closed
    or discarded.

It is obligatory to call either of the two  closing functions to discard
a foreign frame.  Foreign frames may be nested.
________________________________________________________________________|                                                                        |
|int                                                                     |

|count_atoms()                                                           |
|{ fid_t fid = PL_open_foreign_frame();                                  |
|  term_t goal  = PL_new_term_ref();                                     |
|  term_t a1    = PL_new_term_ref();                                     |
|  term_t a2    = PL_new_term_ref();                                     |
|  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);          |
|  int atoms;                                                            |
|                                                                        |

|  PL_put_atom_chars(a1, "atoms");                                       |
|  PL_cons_functor(goal, s2, a1, a2);                                    |
|  PL_call(goal, NULL);         /* call it in current module */          |
|                                                                        |
|  PL_get_integer(a2, &atoms);                                           |
|  PL_discard_foreign_frame(fid);                                        |
|                                                                        |

|  return atoms;                                                         |
|}|_____________________________________________________________________ | |

                      Figure 12.3:  Calling Prolog


1122..44..1111 FFoorreeiiggnn CCooddee aanndd MMoodduulleess

Modules are  identified via a  unique handle.   The following  functions
are available to query and manipulate modules.


module_t PPLL__ccoonntteexxtt()
    Return the module  identifier of the context module of the currently
    active foreign predicate.


int PPLL__ssttrriipp__mmoodduullee(_t_e_r_m___t _+_r_a_w_, _m_o_d_u_l_e___t _*_m_, _t_e_r_m___t _-_p_l_a_i_n)
    Utility  function.  If  _r_a_w is a  term, possibly holding the  module
    construct <_m_o_d_u_l_e>:<_r_e_s_t>, this function will  make _p_l_a_i_n a reference
    to  <_r_e_s_t>  and fill  _m_o_d_u_l_e _*  with <_m_o_d_u_l_e>.    For further  nested
    module  constructs the  innermost module is  returned via _m_o_d_u_l_e  _*.
    If  _r_a_w is not a module construct, _r_a_w will simply be put  in _p_l_a_i_n.
    The  value  pointed  to by  _m  must  be initialized  before  calling
    PL_strip_module(), either to the  default module or to NULL.  A NULL
    value  is replaced by the current  context module if _r_a_w carries  no
    module.   The following example  shows how to obtain the plain  term
    and module if the default module is the user module:

    ____________________________________________________________________|                                                                    |
    | { module m = PL_new_module(PL_new_atom("user"));                   |
    |   term_t plain = PL_new_term_ref();                                |
    |                                                                    |

    |   PL_strip_module(term, &m, plain);                                |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


atom_t PPLL__mmoodduullee__nnaammee(_m_o_d_u_l_e___t _m_o_d_u_l_e)
    Return the name of _m_o_d_u_l_e as an atom.


module_t PPLL__nneeww__mmoodduullee(_a_t_o_m___t _n_a_m_e)
    Find an existing module or create a new module with the name _n_a_m_e.


1122..44..1122 PPrroolloogg eexxcceeppttiioonnss iinn ffoorreeiiggnn ccooddee

This     section    discusses     PL_exception(),     PL_throw()     and
PL_raise_exception(),  the  interface functions  to  detect and  generate
Prolog exceptions from C code.  PL_throw() and PL_raise_exception() from
the  C interface  raise  an exception  from foreign  code.    PL_throw()
exploits  the  C  function  longjmp()  to  return   immediately  to  the
innermost  PL_next_solution().      PL_raise_exception() registers   the
exception term and returns FALSE. If a foreign  predicate returns FALSE,
while  an exception  term  is registered,  a  Prolog exception  will  be
raised by the virtual machine.

Calling these functions  outside the context of a function  implementing
a foreign predicate results in undefined behaviour.

PL_exception() may  be used  after a  call to  PL_next_solution() fails,
and returns a  term reference to an  exception term if an exception  was
raised, and 0 otherwise.

If  a C  function  implementing a  predicate  calls Prolog  and  detects
an  exception using  PL_exception(), it  can  handle this  exception  or
return  with the  exception.    Some caution  is required  though.    It
is  nnoott allowed  to call  PL_close_query() or  PL_discard_foreign_frame()
afterwards,  as  this  will  invalidate  the  exception  term.     Below
is  the  code  that calls  a  Prolog-defined  arithmetic  function  (see
arithmetic_function/1).

If PL_next_solution() succeeds,  the result  is analysed and  translated
to  a number,  after  which the  query  is closed  and all  Prolog  data
created  after  PL_open_foreign_frame() is  destroyed.    On  the  other
hand,  if  PL_next_solution() fails  and  if an  exception  was  raised,
just  pass it.     Otherwise generate  an  exception  (PL_error() is  an
internal  call  for  building  the  standard  error  terms  and  calling
PL_raise_exception()).    After this,  the Prolog  environment should  be
discarded  using  PL_cut_query() and  PL_close_foreign_frame() to  avoid
invalidating the exception term.

________________________________________________________________________|                                                                        |
|static int                                                              |

|prologFunction(ArithFunction f, term_t av, Number r)                    |
|{ int arity = f->proc->definition->functor->arity;                      |
|  fid_t fid = PL_open_foreign_frame();                                  |
|  qid_t qid;                                                            |
|  int rval;                                                             |
|                                                                        |
|  qid = PL_open_query(NULL, PL_Q_NORMAL, f->proc, av);                  |
|                                                                        |

|  if ( PL_next_solution(qid) )                                          |
|  { rval = valueExpression(av+arity-1, r);                              |
|    PL_close_query(qid);                                                |
|    PL_discard_foreign_frame(fid);                                      |
|  } else                                                                |
|  { term_t except;                                                      |
|                                                                        |

|    if ( (except = PL_exception(qid)) )                                 |
|    { rval = PL_throw(except);          /* pass exception */            |
|    } else                                                              |
|    { char *name = stringAtom(f->proc->definition->functor->name);      |
|                                                                        |
|                                        /* generate exception */        |
|      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f->proc);        |
|    }                                                                   |

|                                                                        |
|    PL_cut_query(qid);                  /* donot destroy data */        |
|    PL_close_foreign_frame(fid);        /* same */                      |
|  }                                                                     |
|                                                                        |
|  return rval;                                                          |
|}|_____________________________________________________________________ | |


int PPLL__rraaiissee__eexxcceeppttiioonn(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Generate  an exception (as  throw/1) and return  FALSE. Below is  an
    example returning an exception from a foreign predicate:

    ____________________________________________________________________|                                                                    |
    | foreign_t                                                          |

    | pl_hello(term_t to)                                                |
    | { char *s;                                                         |
    |                                                                    |
    |   if ( PL_get_atom_chars(to, &s) )                                 |
    |   { Sprintf("Hello \"%s\"\n", s);                                  |
    |                                                                    |
    |     PL_succeed;                                                    |
    |   } else                                                           |

    |   { term_t except = PL_new_term_ref();                             |
    |                                                                    |
    |     PL_unify_term(except,                                          |
    |                   PL_FUNCTOR_CHARS, "type_error", 2,               |
    |                     PL_CHARS, "atom",                              |
    |                     PL_TERM, to);                                  |
    |                                                                    |

    |     return PL_raise_exception(except);                             |
    |   }                                                                |
    ||}_________________________________________________________________ ||


int PPLL__tthhrrooww(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Similar  to PL_raise_exception(),  but returns using the C  longjmp()
    function to the innermost PL_next_solution().


term_t PPLL__eexxcceeppttiioonn(_q_i_d___t _q_i_d)
    If  PL_next_solution() fails,  this  can be  due to  normal  failure
    of  the  Prolog  call, or  because  an  exception was  raised  using
    throw/1.   This function returns  a handle to the exception term  if
    an exception was raised,  or 0 if the Prolog goal simply failed.  If
    there is  an exception, PL_exception()allocates  a term-handle using
    PL_new_term_ref() that is used to return the exception term.

    Additionally,    \cfuncref{PL_exception}{0}  returns   the   pending
    exception  in the  current query or  0 if  no exception is  pending.
    This can be used  to check the error status after a failing call to,
    e.g., one of the unification functions.


void PPLL__cclleeaarr__eexxcceeppttiioonn(_v_o_i_d)
    Tells  Prolog that the encountered exception must be ignored.   This
    function  must be called  if control remains  in C after a  previous
    API call fails with an exception.


1122..44..1133 CCaattcchhiinngg SSiiggnnaallss ((SSooffttwwaarree IInntteerrrruuppttss))

SWI-Prolog offers both  a C and Prolog  interface to deal with  software
interrupts (signals).    The Prolog  mapping is defined  in section  ????.
This subsection deals with handling signals from C.

If a signal is not  used by Prolog and the handler does not  call Prolog
in any way, the native signal interface routines may be used.

Any handler that  wishes to call one  of the Prolog interface  functions
should  call  PL_sigaction()  to  install  the  handler.     PL_signal()
provides a deprecated interface that is notably not  capable of properly
restoring the old signal status if the signal was  previously handled by
Prolog.


int PPLL__ssiiggaaccttiioonn(_i_n_t _s_i_g_, _p_l___s_i_g_a_c_t_i_o_n___t _*_a_c_t_, _p_l___s_i_g_a_c_t_i_o_n___t _*_o_l_d_a_c_t)
    Install  or query  the status  for signal  _s_i_g.   The  signal is  an
    integer  between 1 and 64, where the where the signals up to  32 are
    mapped to OS  signals and signals above that are handled by Prolog's
    synchronous  signal handling.   The pl_sigaction_t is a struct  with
    the following definition:

    ____________________________________________________________________|                                                                    |
    | typedef struct pl_sigaction                                        |

    | { void        (*sa_cfunction)(int);     /* traditional C function */|
    |   predicate_t sa_predicate;             /* call a predicate */     |
    |   int         sa_flags;                 /* additional flags */     |
    ||}_pl_sigaction_t;_________________________________________________ ||

    The  sa_flags  is  a  bitwise  or  of  PLSIG_THROW,  PLSIG_SYNC  and
    PLSIG_NOFRAME.  Signal   handling  is  enabled  if   PLSIG_THROW   is
    provided, sa_cfunction or sa_predicate is provided.  sa_predicate is
    a  predicate handle for a predicate with  arity 1.  If no  action is
    provided  the signal  handling for  this signal is  restored to  the
    default before PL_initialise() was called.

    Finally,  0 (zero) may be passsed for _s_i_g.  In that  case the system
    allocates a free signal  in the _P_r_o_l_o_g _r_a_n_g_e (32...64).  Such signal
    handler are activated using PL_thread_raise().


void (*)() PPLL__ssiiggnnaall(_s_i_g_, _f_u_n_c)
    This  function  is equivalent  to  the BSD-Unix  signal()  function,
    regardless  of the  platform used.   The  signal handler is  blocked
    while  the signal routine  is active, and automatically  reactivated
    after the handler returns.

    After  a  signal handler  is  registered using  this  function,  the
    native  signal interface  redirects the signal  to a generic  signal
    handler  inside  SWI-Prolog.   This  generic  handler validates  the
    environment,   creates  a  suitable  environment  for   calling  the
    interface functions described  in this chapter and finally calls the
    registered user-handler.

    By  default, signals are handled  asynchronously (i.e., at the  time
    they  arrive).   It is inherently  dangerous to call extensive  code
    fragments,  and especially exception related code  from asynchronous
    handlers.     The  interface  allows  for  _s_y_n_c_h_r_o_n_o_u_s  handling  of
    signals.   In  this case  the native OS  handler just schedules  the
    signal  using PL_raise(),  which is checked by PL_handle_signals() at
    the  call- and redo-port.  This behaviour is realised by  _o_r-ing _s_i_g
    with the constant PL_SIGSYNC.

    Signal    handling    routines    may   raise    exceptions    using
    PL_raise_exception().      The  use  of  PL_throw()  is  not   safe.
    If  a  synchronous handler  raises an  exception,  the exception  is
    delayed to the next call to PL_handle_signals();


int PPLL__rraaiissee(_i_n_t _s_i_g)
    Register  _s_i_g  for  _s_y_n_c_h_r_o_n_o_u_s handling  by  Prolog.    Synchronous
    signals  are  handled at  the  call-port or  if foreign  code  calls
    PL_handle_signals().  See also thread_signal/2.


int PPLL__hhaannddllee__ssiiggnnaallss(_v_o_i_d)
    Handle  any signals  pending from  PL_raise().   PL_handle_signals()
    is  called at each  pass through the call-  and redo-port at a  safe
    point.   Exceptions raised by the handler using PL_raise_exception()
    are properly passed to the environment.

    The  user  may   call  this  function  inside  long-running  foreign
    functions to handle  scheduled interrupts.  This routine returns the
    number  of signals handled.   If a handler raises an exception,  the
    return value is  -1 and the calling routine should return with FALSE
    as soon as possible.


int PPLL__ggeett__ssiiggnnuumm__eexx(_t_e_r_m___t _t_, _i_n_t _*_s_i_g)
    Extract  a signal specification from a  Prolog term and store as  an
    integer  signal number in _s_i_g.   The specification is an integer,  a
    lowercase  signal name without SIG or  the full signal name.   These
    refer  to the same:  9, kill and SIGKILL. Leaves a typed,  domain or
    instantiation error if the conversion fails.


1122..44..1144 MMiisscceellllaanneeoouuss


1122..44..1144..11 TTeerrmm CCoommppaarriissoonn


int PPLL__ccoommppaarree(_t_e_r_m___t _t_1_, _t_e_r_m___t _t_2)
    Compares  two terms using  the standard order  of terms and  returns
    -1, 0 or 1.  See also compare/3.


int PPLL__ssaammee__ccoommppoouunndd(_t_e_r_m___t _t_1_, _t_e_r_m___t _t_2)
    Yields TRUE if _t_1  and _t_2 refer to physically the same compound term
    and FALSE otherwise.


1122..44..1144..22 RReeccoorrddeedd ddaattaabbaassee

In some  applications it is  useful to store  and retrieve Prolog  terms
from C code.  For example, the XPCE graphical  environment does this for
storing arbitrary Prolog data as slot-data of XPCE objects.

Please note  that the  returned handles  have no meaning  at the  Prolog
level  and  the recorded  terms  are  not  visible from  Prolog.     The
functions PL_recorded() and PL_erase() are  the only functions that  can
operate on the stored term.

Two groups of functions are provided.   The first group (PL_record() and
friends) store Prolog terms on the Prolog heap for  retrieval during the
same session.   These functions are also used by recorda/3  and friends.
The recorded  database may be used  to communicate Prolog terms  between
threads.


record_t PPLL__rreeccoorrdd(_t_e_r_m___t _+_t)
    Record  the term _t into the Prolog database as recorda/3  and return
    an  opaque handle to  the term.   The returned handle remains  valid
    until  PL_erase() is called on  it.   PL_recorded() is used to  copy
    recorded terms back to the Prolog stack.


record_t PPLL__dduupplliiccaattee__rreeccoorrdd(_r_e_c_o_r_d___t _r_e_c_o_r_d)
    Return  a duplicate  of _r_e_c_o_r_d.   As  records are read-only  objects
    this function merely increments the records reference count.


int PPLL__rreeccoorrddeedd(_r_e_c_o_r_d___t _r_e_c_o_r_d_, _t_e_r_m___t _-_t)
    Copy a recorded term  back to the Prolog stack.  The same record may
    be used to copy  multiple instances at any time to the Prolog stack.
    Returns  TRUE on  success, and FALSE  if there  is not enough  space
    on  the stack  to accommodate the  term.   See also  PL_record() and
    PL_erase().


void PPLL__eerraassee(_r_e_c_o_r_d___t _r_e_c_o_r_d)
    Remove  the recorded term from  the Prolog database, reclaiming  all
    associated memory resources.

The  second group  (headed  by PL_record_external()) provides  the  same
functionality, but the returned data has properties  that enable storing
the  data  on an  external  device.     It has  been  designed  to  make
it  possible to  store Prolog  terms  fast and  compact in  an  external
database.  Here are the main features:

  o _I_n_d_e_p_e_n_d_e_n_t _o_f _s_e_s_s_i_o_n
    Records  can  be communicated  to another  Prolog  session and  made
    visible using PL_recorded_external().

  o _B_i_n_a_r_y
    The representation is  binary for maximum performance.  The returned
    data may contain zero bytes.

  o _B_y_t_e_-_o_r_d_e_r _i_n_d_e_p_e_n_d_e_n_t
    The   representation  can  be  transferred  between   machines  with
    different byte order.

  o _N_o _a_l_i_g_n_m_e_n_t _r_e_s_t_r_i_c_t_i_o_n_s
    There are no  memory alignment restrictions and copies of the record
    can  thus be  moved freely.    For example,  it is  possible to  use
    this  representation to exchange  terms using shared memory  between
    different Prolog processes.

  o _C_o_m_p_a_c_t
    It  is  assumed  that a  smaller  memory footprint  will  eventually
    outperform slightly faster representations.

  o _S_t_a_b_l_e
    The  format is  designed  for future  enhancements without  breaking
    compatibility with older records.


char * PPLL__rreeccoorrdd__eexxtteerrnnaall(_t_e_r_m___t _+_t_, _s_i_z_e___t _*_l_e_n)
    Record  the term _t into the Prolog database as recorda/3  and return
    an  opaque handle to  the term.   The returned handle remains  valid
    until PL_erase_external() is called on it.

    It  is allowed  to copy the  data and use  PL_recorded_external() on
    the  copy.   The user  is responsible for  the memory management  of
    the  copy.    After copying,  the original  may  be discarded  using
    PL_erase_external().

    PL_recorded_external() is used to  copy such recorded terms back  to
    the Prolog stack.


int PPLL__rreeccoorrddeedd__eexxtteerrnnaall(_c_o_n_s_t _c_h_a_r _*_r_e_c_o_r_d_, _t_e_r_m___t _-_t)
    Copy a recorded term  back to the Prolog stack.  The same record may
    be used to copy  multiple instances at any time to the Prolog stack.
    See also PL_record_external() and PL_erase_external().


int PPLL__eerraassee__eexxtteerrnnaall(_c_h_a_r _*_r_e_c_o_r_d)
    Remove  the recorded term from  the Prolog database, reclaiming  all
    associated memory resources.


1122..44..1144..33 GGeettttiinngg ffiillee nnaammeess

The function PL_get_file_name() provides access to Prolog filenames  and
its  file-search mechanism  described  with absolute_file_name/3.    Its
existence is motivated to realise a uniform interface to  deal with file
properties, search, naming conventions, etc., from foreign code.


int PPLL__ggeett__ffiillee__nnaammee(_t_e_r_m___t _s_p_e_c_, _c_h_a_r _*_*_n_a_m_e_, _i_n_t _f_l_a_g_s)
    Translate  a Prolog  term into  a file  name.   The  name is  stored
    in  the static buffer  ring described with  th PL_get_chars() option
    BUF_RING.  Conversion from  the internal  UNICODE  encoding is  done
    using   standard  C  library  functions.     _f_l_a_g_s  is   a  bit-mask
    controlling the conversion process.  Options are:

    PL_FILE_ABSOLUTE
         Return an absolute path to the requested file.

    PL_FILE_OSPATH
         Return  the  name  using  the  hosting  OS  conventions.     On
         MS-Windows, \ is  used to separate directories rather than  the
         canonical /.

    PL_FILE_SEARCH
         Invoke  absolute_file_name/3.      This   implies  rules   from
         file_search_path/2are used.

    PL_FILE_EXIST
         Demand the path to refer to an existing entity.

    PL_FILE_READ
         Demand read-access on the result.

    PL_FILE_WRITE
         Demand write-access on the result.

    PL_FILE_EXECUTE
         Demand execute-access on the result.

    PL_FILE_NOERRORS
         Do not raise any exceptions.


int PPLL__ggeett__ffiillee__nnaammeeWW(_t_e_r_m___t _s_p_e_c_, _w_c_h_a_r___t _*_*_n_a_m_e_, _i_n_t _f_l_a_g_s)
    Same  as  PL_get_file_name(), but  returns the  filename  as a  wide-
    character  string.    This is  intended for  Windows  to access  the
    Unicode  version of the Win32 API. Note that the flag PL_FILE_OSPATH
    must  be provided to  fetch a filename in  OS native (e.g.,  C:\x\y)
    notation.


1122..44..1144..44 DDeeaalliinngg wwiitthh PPrroolloogg ffllaaggss ffrroomm CC

Foreign code can  set or create Prolog flags using  PL_set_prolog_flag().
See set_prolog_flag/2and create_prolog_flag/3.


int PPLL__sseett__pprroolloogg__ffllaagg(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _t_y_p_e_, _._._.)
    Set/create  a Prolog flag from C.  _n_a_m_e is the name of the  affected
    flag.    _t_y_p_e  is  one of  the  values below,  which  also  dictates
    the  type of  the  final argument.    The function  returns TRUE  on
    success  and FALSE on failure.   This function can be called  _b_e_f_o_r_e
    PL_initialise(),  making the  flag available to  the Prolog  startup
    code.

    PL_BOOL
         Create a boolean  (true or false) flag.   The argument must  be
         an int.

    PL_ATOM
         Create a flag with an  atom as value.  The argument must  be of
         type const char *.

    PL_INTEGER
         Create a flag with an  integer as value.  The argument  must be
         of type intptr_t *.


1122..44..1155 EErrrroorrss aanndd wwaarrnniinnggss

PL_warning() prints a  standard Prolog warning  message to the  standard
error (user_error) stream.   Please note  that new code should  consider
using  PL_raise_exception() to  raise a  Prolog  exception.    See  also
section ????.


int PPLL__wwaarrnniinngg(_f_o_r_m_a_t_, _a_1_, _._._.)
    Print  an  error message  starting  with `[WARNING: ',  followed  by
    the  output from  _f_o_r_m_a_t, followed  by a `]'  and a newline.    Then
    start  the tracer.   _f_o_r_m_a_t and  the arguments are  the same as  for
    printf(2).  Always returns FALSE.


1122..44..1166 EEnnvviirroonnmmeenntt CCoonnttrrooll ffrroomm FFoorreeiiggnn CCooddee


int PPLL__aaccttiioonn(_i_n_t_, _._._.)
    Perform  some  action on  the  Prolog system.    _i_n_t  describes  the
    action.   Remaining arguments depend  on the requested action.   The
    actions are listed below:

    PPLL__AACCTTIIOONN__TTRRAACCEE
         Start Prolog tracer (trace/0).  Requires no arguments.

    PPLL__AACCTTIIOONN__DDEEBBUUGG
         Switch on Prolog debug mode (debug/0).  Requires no arguments.

    PPLL__AACCTTIIOONN__BBAACCKKTTRRAACCEE
         Print backtrace  on current output  stream.   The argument  (an
         int) is the number of frames printed.

    PPLL__AACCTTIIOONN__HHAALLTT
         Halt Prolog  execution.   This action  should be called  rather
         than Unix exit()  to give Prolog  the opportunity to clean  up.
         This call does not return.   The argument (an int) is  the exit
         code.  See halt/1.

    PPLL__AACCTTIIOONN__AABBOORRTT
         Generate a Prolog abort (abort/0).  This call  does not return.
         Requires no arguments.

    PPLL__AACCTTIIOONN__BBRREEAAKK
         Create a standard Prolog break environment (break/0).   Returns
         after the user  types the end-of-file  character.  Requires  no
         arguments.

    PPLL__AACCTTIIOONN__GGUUIIAAPPPP
         Windows:  Used to  indicate to the kernel that  the application
         is a GUI  application if the argument is  not 0, and a  console
         application if  the argument is 0.   If  a fatal error  occurs,
         the system uses  a windows messagebox to  report this on a  GUI
         application, and otherwise simply prints the error and exits.

    PPLL__AACCTTIIOONN__TTRRAADDIITTIIOONNAALL
         Same effect  as using  --traditional.   Must  be called  _b_e_f_o_r_e
         PL_initialise().

    PPLL__AACCTTIIOONN__WWRRIITTEE
         Write the argument, a char * to the current output stream.

    PPLL__AACCTTIIOONN__FFLLUUSSHH
         Flush the current output stream.  Requires no arguments.

    PPLL__AACCTTIIOONN__AATTTTAACCHH__CCOONNSSOOLLEE
         Attach a  console to a  thread if it  does not have  one.   See
         attach_console/0.

    PPLL__GGMMPP__SSEETT__AALLLLOOCC__FFUUNNCCTTIIOONNSS
         Takes  an integer  argument.    If  TRUE, the  GMP  allocations
         are immediately  bound  to the  Prolog functions.    If  FALSE,
         SWI-Prolog  will never  rebind  the GMP  allocation  functions.
         See mp_set_memory_functions() in  the GMP  documentation.    The
         action returns  FALSE if  there  is no  GMP support  or GMP  is
         already initialised.


1122..44..1177 QQuueerryyiinngg PPrroolloogg


long PPLL__qquueerryy(_i_n_t)
    Obtain  status  information  on  the  Prolog system.     The  actual
    argument  type depends on the  information required.  _i_n_t  describes
    what information is wanted.  The options are given in table ????.
    __________________________________________________________
    | PL_QUERY_ARGC          |Return  an  integer holding  the|
    |                        |number  of  arguments  given  to|
    |                        |Prolog from Unix.               |
    | PL_QUERY_ARGV          |Return  a  char **  holding  the|
    |                        |argument vector  given to Prolog|

    |                        |from Unix.                      |
    | PL_QUERY_SYMBOLFILE    |Return  a   char *  holding  the|
    |                        |current   symbol  file   of  the|
    |                        |running process.                |
    | PL_MAX_INTEGER         |Return a  long, representing the|
    |                        |maximal  integer   value  repre-|
    |                        |sented by a Prolog integer.     |

    | PL_MIN_INTEGER         |Return a  long, representing the|
    |                        |minimal integer value.          |
    | PL_QUERY_VERSION       |Return a  long, representing the|
    |                        |version  as  10;000M* +100m* +p,|
    |                        |where  M is  the  major, m  the |
    |                        |minor version  number and  p the|
    |                        |patch level.  For example, 20717|
    |                        |means 2.7.17.                   |

    | PL_QUERY_ENCODING      |Return the default stream encod-|
    |                        |ing of Prolog (of type IOENC).  |
    | PL_QUERY_USER_CPU      |Get amount  of user CPU  time of|
    |________________________|the_process_in_milliseconds.____|

                    Table 12.1:  PL_query() options


1122..44..1188 RReeggiisstteerriinngg FFoorreeiiggnn PPrreeddiiccaatteess


int PPLL__rreeggiisstteerr__ffoorreeiiggnn__iinn__mmoodduullee(_c_h_a_r _*_m_o_d_, _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _f_o_r_e_i_g_n___t _(_*_f_)_(_)_, _i_n_t _f_l_a_g_s_, _._._.)
    Register  the C function _f to  implement a Prolog predicate.   After
    this  call returns successfully a  predicate with name _n_a_m_e (a  char
    *)  and arity _a_r_i_t_y  (a C  int) is created  in module _m_o_d.   If  _m_o_d
    is  NULL, the  predicate is  created in  the module  of the  calling
    context, or if no context is present in the module user.

    When  called in Prolog,  Prolog will  call _f_u_n_c_t_i_o_n.   _f_l_a_g_s form  a
    bitwise _o_r'ed list of options for the installation.  These are:
    _______________________________________________________________
    | PL_FA_META             |Provide   meta-predicate  info   (see|
    |                        |below)                               |
    | PL_FA_TRANSPARENT      |Predicate   is   module   transparent|
    |                        |(deprecated)                         |

    | PL_FA_NONDETERMINISTIC |Predicate is non-deterministic.   See|
    |                        |also PL_retry().                     |
    | PL_FA_NOTRACE          |Predicate  cannot  be  seen  in   the|
    |                        |tracer                               |
    |_PL_FA_VARARGS__________|Use_alternative_calling_convention.__|

    If  PL_FA_META is provided,  PL_register_foreign_in_module()takes one
    extra  argument.    This argument  is  of type  const char*.    This
    string  must  be exactly  as  long as  the  number of  arguments  of
    the  predicate and  filled with  characters from  the set  0-9:^-+?.
    See  meta_predicate/1 for  details.    PL_FA_TRANSPARENT  is  implied
    if  at  least one  meta-argument is  provided (0-9:^).    Note  that
    meta-arguments  are _n_o_t  _a_l_w_a_y_s passed  as <_m_o_d_u_l_e>:<_t_e_r_m>.    Always
    use  PL_strip_module()to  extract the module  and plain term from  a
    meta-argument.

    Predicates    may   be   registered    either   before   or    after
    PL_initialise().      When  registered  before  initialisation   the
    registration  is recorded and  executed after installing the  system
    predicates and before loading the saved state.

    Default  calling (i.e. without PL_FA_VARARGS) _f_u_n_c_t_i_o_n is  passed the
    same  number of term_t arguments as the arity of the  predicate and,
    if  the predicate is  non-deterministic, an  extra argument of  type
    control_t (see section ????).   If PL_FA_VARARGS is  provided, _f_u_n_c_t_i_o_n
    is  called with  three arguments.   The first  argument is  a term_t
    handle  to the  first argument.   Further  arguments can be  reached
    by  adding the  offset (see  also PL_new_term_refs()).   The  second
    argument  is  the arity,  which  defines the  number of  valid  term
    references  in the argument vector.   The last argument is used  for
    non-deterministic  calls.  It  is currently undocumented and  should
    be defined of type void*.  Here is an example:

    ____________________________________________________________________|                                                                    |

    | static foreign_t                                                   |
    | atom_checksum(term_t a0, int arity, void* context)                 |
    | { char *s;                                                         |
    |                                                                    |
    |   if ( PL_get_atom_chars(a0, &s) )                                 |
    |   { int sum;                                                       |

    |                                                                    |
    |     for(sum=0; *s; s++)                                            |
    |       sum += *s&0xff;                                              |
    |                                                                    |
    |     return PL_unify_integer(a0+1, sum&0xff);                       |
    |   }                                                                |
    |                                                                    |
    |   return FALSE;                                                    |

    | }                                                                  |
    |                                                                    |
    | install_t                                                          |
    | install()                                                          |
    | { PL_register_foreign("atom_checksum", 2,                          |
    |                       atom_checksum, PL_FA_VARARGS);               |
    ||}_________________________________________________________________ ||


int PPLL__rreeggiisstteerr__ffoorreeiiggnn(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _f_o_r_e_i_g_n___t _(_*_f_u_n_c_t_i_o_n_)_(_)_, _i_n_t _f_l_a_g_s_, _._._.)
    Same   as  PL_register_foreign_in_module(),  passing  NULL   for  the
    _m_o_d_u_l_e.


void PPLL__rreeggiisstteerr__eexxtteennssiioonnss__iinn__mmoodduullee(_c_o_n_s_t _c_h_a_r _*_m_o_d_u_l_e_, _P_L___e_x_t_e_n_s_i_o_n _*_e)
    Register a series  of predicates from an array of definitions of the
    type  PL_extension in  the given _m_o_d_u_l_e.    If _m_o_d_u_l_e  is NULL,  the
    predicate is created in  the module of the calling context, or if no
    context  is present in  the module user.   The PL_extension type  is
    defined as

    ____________________________________________________________________|                                                                    |
    | typedef struct PL_extension                                        |
    | { char          *predicate_name; /* Name of the predicate */       |
    |   short         arity;           /* Arity of the predicate */      |

    |   pl_function_t function;        /* Implementing functions */      |
    |   short         flags;           /* Or of PL_FA_... */             |
    ||}_PL_extension;___________________________________________________ ||

    For  details,  see  PL_register_foreign_in_module().     Here  is  an
    example of its usage:

    ____________________________________________________________________|                                                                    |
    | static PL_extension predicates[] = {                               |
    | { "foo",        1,      pl_foo, 0 },                               |
    | { "bar",        2,      pl_bar, PL_FA_NONDETERMINISTIC },          |

    | { NULL,         0,      NULL,   0 }                                |
    | };                                                                 |
    |                                                                    |
    | main(int argc, char **argv)                                        |
    | { PL_register_extensions_in_module("user", predicates);            |
    |                                                                    |
    |   if ( !PL_initialise(argc, argv) )                                |

    |     PL_halt(1);                                                    |
    |                                                                    |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


void PPLL__rreeggiisstteerr__eexxtteennssiioonnss( _P_L___e_x_t_e_n_s_i_o_n _*_e)
    Same as  PL_register_extensions_in_module()using  NULL for the _m_o_d_u_l_e
    argument.


1122..44..1199 FFoorreeiiggnn CCooddee HHooookkss

For various specific applications some hooks are provided.


PL_dispatch_hook_t PPLL__ddiissppaattcchh__hhooookk(_P_L___d_i_s_p_a_t_c_h___h_o_o_k___t)
    If this hook is  not NULL, this function is called when reading from
    the  terminal.   It is supposed  to dispatch events when  SWI-Prolog
    is  connected to a  window environment.   It can return two  values:
    PL_DISPATCH_INPUT  indicates  Prolog  input  is  available  on  file
    descriptor  0 or PL_DISPATCH_TIMEOUT to indicate a timeout.   The old
    hook is returned.  The type PL_dispatch_hook_t is defined as:

    ____________________________________________________________________|                                                                    |
    ||typedef_int__(*PL_dispatch_hook_t)(void);_________________________ ||


void PPLL__aabboorrtt__hhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Install  a hook  when abort/0 is  executed.   SWI-Prolog abort/0  is
    implemented  using C  setjmp()/longjmp() construct.   The hooks  are
    executed  in  the  reverse order  of  their registration  after  the
    longjmp()  took place and before the Prolog top level  is reinvoked.
    The type PL_abort_hook_t is defined as:

    ____________________________________________________________________|                                                                    |
    ||typedef_void_(*PL_abort_hook_t)(void);____________________________ ||


int PPLL__aabboorrtt__uunnhhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Remove  a hook installed with PL_abort_hook().  Returns FALSE  if no
    such hook is found, TRUE otherwise.


void PPLL__oonn__hhaalltt(_i_n_t _(_*_f_)_(_i_n_t_, _v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e)
    Register  the function _f to be called if SWI-Prolog is halted.   The
    function  is  called with  two  arguments:   the  exit code  of  the
    process  (0 if this cannot  be determined) and the _c_l_o_s_u_r_e  argument
    passed  to the PL_on_halt() call.   Handlers _m_u_s_t  return 0.   Other
    return  values are  reserved for future  use.   See  also at_halt/1.
    These  handlers are called _b_e_f_o_r_e  system cleanup and can  therefore
    access all normal Prolog resources.  See also PL_exit_hook().


void PPLL__eexxiitt__hhooookk(_i_n_t _(_*_f_)_(_i_n_t_, _v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e)
    Similar  to PL_on_halt(), but  the hooks  are executed  by PL_halt()
    instead of PL_cleanup() just before calling exit().


PL_agc_hook_t PPLL__aaggcc__hhooookk(_P_L___a_g_c___h_o_o_k___t _n_e_w)
    Register    a   hook   with   the   atom-garbage    collector   (see
    garbage_collect_atoms/0)  that  is  called  on  any  atom   that  is
    reclaimed.    The old hook  is returned.   If  no hook is  currently
    defined,  NULL is returned.  The argument of the called hook  is the
    atom  that is to be garbage collected.  The return value  is an int.
    If  the return value is zero, the  atom is nnoott reclaimed.   The hook
    may invoke any Prolog predicate.

    The  example  below  defines  a foreign  library  for  printing  the
    garbage collected atoms for debugging purposes.

    ____________________________________________________________________|                                                                    |
    | #include <SWI-Stream.h>                                            |

    | #include <SWI-Prolog.h>                                            |
    |                                                                    |
    | static int                                                         |
    | atom_hook(atom_t a)                                                |
    | { Sdprintf("AGC: deleting %s\n", PL_atom_chars(a));                |
    |                                                                    |
    |   return TRUE;                                                     |
    | }                                                                  |

    |                                                                    |
    | static PL_agc_hook_t old;                                          |
    |                                                                    |
    | install_t                                                          |
    | install()                                                          |
    | { old = PL_agc_hook(atom_hook);                                    |
    | }                                                                  |

    |                                                                    |
    | install_t                                                          |
    | uninstall()                                                        |
    | { PL_agc_hook(old);                                                |
    ||}_________________________________________________________________ ||


1122..44..2200 SSttoorriinngg ffoorreeiiggnn ddaattaa

When combining  foreign code with  Prolog, it can  be necessary to  make
data  represented in  the foreign  language available  to Prolog.    For
example, to  pass it to another  foreign function.   At the end of  this
section, there  is a partial  implementation of using foreign  functions
to manage  bit-vectors.   Another example is  the SGML/XML library  that
manages a `parser' object,  an object that represents the  current state
of  the parser  and that  can be  directed to  perform  actions such  as
parsing a document or make queries about the document content.

This section  provides some hints for  handling foreign data in  Prolog.
There are four options for storing such data:

  o _N_a_t_u_r_a_l _P_r_o_l_o_g _d_a_t_a
    Uses  the representation  one would choose  if no foreign  interface
    was  required.   For  example, a  bitvector representing  a list  of
    small integers can be represented as a Prolog list of integers.

  o _O_p_a_q_u_e _p_a_c_k_e_d _d_a_t_a _o_n _t_h_e _s_t_a_c_k_s
    It  is possible to  represent the raw  binary representation of  the
    foreign object as a  Prolog string (see section ????).  Strings may be
    created from foreign data using PL_put_string_nchars() and retrieved
    using PL_get_string_chars().  It is good practice to wrap the string
    in  a compound term with arity  1, so Prolog can identify  the type.
    The  hook portray/1 rules  may be used  to streamline printing  such
    terms during development.

  o _O_p_a_q_u_e _p_a_c_k_e_d _d_a_t_a _i_n _a _b_l_o_b
    Similar  to  the  above  solution,  binary data  can  be  stored  in
    an  atom.    The  blob interface  (section ????)  provides  additional
    facilities to assign  a type and hook-functions that act on creation
    and destruction of the underlying atom.

  o _N_a_t_u_r_a_l _f_o_r_e_i_g_n _d_a_t_a_, _p_a_s_s_e_d _a_s _a _p_o_i_n_t_e_r
    An  alternative is to pass  a pointer to the  foreign data.   Again,
    the pointer is often wrapped in a compound term.

The choice may be guided using the following distinctions

  o _I_s _t_h_e _d_a_t_a _o_p_a_q_u_e _t_o _P_r_o_l_o_g
    With  `opaque' data, we refer to data handled in  foreign functions,
    passed  around  in  Prolog,  but  where Prolog  never  examines  the
    contents  of the data itself.  If the data is opaque to  Prolog, the
    selection  will be driven solely by simplicity of the  interface and
    performance.

  o _W_h_a_t _i_s _t_h_e _l_i_f_e_t_i_m_e _o_f _t_h_e _d_a_t_a
    With  `lifetime' we refer  to how it is  decided that the object  is
    (or can be) destroyed.  We can distinguish three cases:

     1.  The object must be destroyed on backtracking  and normal Prolog
         garbage collection  (i.e., it  acts as a  normal Prolog  term).
         In  this case,  representing  the  object as  a  Prolog  string
         (second option above) is the only feasible solution.

     2.  The data  must survive Prolog  backtracking.   This leaves  two
         options.   One is to represent  the object using a pointer  and
         use explicit  creation and destruction,  making the  programmer
         responsible.   The  alternative is to  use the  blob-interface,
         leaving destruction to the (atom) garbage collector.

     3.  The  data   lives  as   during  the  lifetime   of  a   foreign
         function that  implements a  predicate.   If  the predicate  is
         deterministic, foreign  automatic variables are  suitable.   If
         the predicate is  non-deterministic, the data may be  allocated
         using malloc() and a pointer may be passed.  See section ????.


1122..44..2200..11 EExxaammpplleess ffoorr ssttoorriinngg ffoorreeiiggnn ddaattaa

In  this section,  we  outline some  examples, covering  typical  cases.
In  the  first  example,  we will  deal  with  extending  Prolog's  data
representation with integer sets, represented as bit-vectors.   Then, we
discuss the outline of the DDE interface.

IInntteeggeerr  sseettss with  not-too-far-apart upper-  and  lower-bounds  can  be
represented using  bit-vectors.  Common  set operations, such as  union,
intersection,  etc.,  are  reduced  to simple  _a_n_d'ing  and  _o_r'ing  the
bit-vectors.  This can be done using Prolog's unbounded integers.

For really demanding  applications, foreign representation will  perform
better,  especially  time-wise.    Bit-vectors are  naturally  expressed
using string  objects.   If the  string is wrapped  in bitvector/1,  the
lower-bound of the  vector is 0 and  the upper-bound is not defined;  an
implementation for  getting and putting  the sets as  well as the  union
predicate for it is below.

________________________________________________________________________|                                                                        |
|#include <SWI-Prolog.h>                                                 |

|                                                                        |
|#define max(a, b) ((a) > (b) ? (a) : (b))                               |
|#define min(a, b) ((a) < (b) ? (a) : (b))                               |
|                                                                        |
|static functor_t FUNCTOR_bitvector1;                                    |
|                                                                        |
|static int                                                              |
|get_bitvector(term_t in, int *len, unsigned char **data)                |

|{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )                          |
|  { term_t a = PL_new_term_ref();                                       |
|                                                                        |
|    PL_get_arg(1, in, a);                                               |
|    return PL_get_string(a, (char **)data, len);                        |
|  }                                                                     |
|                                                                        |

|  PL_fail;                                                              |
|}                                                                       |
|                                                                        |
|static int                                                              |
|unify_bitvector(term_t out, int len, const unsigned char *data)         |
|{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )                      |
|  { term_t a = PL_new_term_ref();                                       |
|                                                                        |

|    PL_get_arg(1, out, a);                                              |
|                                                                        |
|    return PL_unify_string_nchars(a, len, (const char *)data);          |
|  }                                                                     |
|                                                                        |
|  PL_fail;                                                              |
|}                                                                       |

|                                                                        |
|static foreign_t                                                        |
|pl_bitvector_union(term_t t1, term_t t2, term_t u)                      |
|{ unsigned char *s1, *s2;                                               |
|  int l1, l2;                                                           |
|                                                                        |
|  if ( get_bitvector(t1, &l1, &s1) &&                                   |
|       get_bitvector(t2, &l2, &s2) )                                    |

|  { int l = max(l1, l2);                                                |
|    unsigned char *s3 = alloca(l);                                      |
|                                                                        |
|    if ( s3 )                                                           |
|    { int n;                                                            |
|      int ml = min(l1, l2);                                             |
|                                                                        |

|      for(n=0; n<ml; n++)                                               |
|        s3[n] = s1[n] | s2[n];                                          |
|      for( ; n < l1; n++)                                               |
|        s3[n] = s1[n];                                                  |
|      for( ; n < l2; n++)                                               |
|        s3[n] = s2[n];                                                  |
|                                                                        |
|      return unify_bitvector(u, l, s3);                                 |

|    }                                                                   |
|                                                                        |
|    return PL_warning("Not enough memory");                             |
|  }                                                                     |
|                                                                        |
|  PL_fail;                                                              |
|}                                                                       |

|                                                                        |
|                                                                        |
|install_t                                                               |
|install()                                                               |
|{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);     |
|                                                                        |
|  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);     |
|}|_____________________________________________________________________ | |

TThhee DDDDEE  iinntteerrffaaccee (see section ????) represents  another common usage  of
the foreign interface:  providing communication to  new operating system
features.  The DDE interface requires knowledge about  active DDE server
and  client channels.    These channels  contains  various foreign  data
types.    Such an  interface is  normally achieved  using an  open/close
protocol that creates and destroys a _h_a_n_d_l_e.  The  handle is a reference
to a foreign data structure containing the relevant information.

There are a  couple of possibilities for  representing the handle.   The
choice  depends on  responsibilities  and  debugging facilities.     The
simplest  approach is  to  use PL_unify_pointer()  and PL_get_pointer().
This  approach is  fast and  easy, but  has the  drawbacks of  (untyped)
pointers:   there  is no  reliable way  to detect  the  validity of  the
pointer,  nor to  verify  that it  is  pointing to  a structure  of  the
desired type.   The  pointer may  be wrapped into  a compound term  with
arity  1 (i.e.,  dde_channel(<_P_o_i_n_t_e_r>)),  making the  type-problem  less
serious.

Alternatively  (used in  the  DDE  interface),  the interface  code  can
maintain a  (preferably variable  length) array of  pointers and  return
the index in this  array.  This provides better protection.   Especially
for debugging  purposes, wrapping  the handle  in a compound  is a  good
suggestion.


1122..44..2211 EEmmbbeeddddiinngg SSWWII--PPrroolloogg iinn ootthheerr aapppplliiccaattiioonnss

With embedded Prolog we refer to the situation where  the `main' program
is not the Prolog application.  Prolog is sometimes  embedded in C, C++,
Java or  other languages  to provide  logic based services  in a  larger
application.   Embedding  loads the Prolog  engine as  a library to  the
external language.   Prolog itself only provides for embedding in  the C
language (compatible  with C++).   Embedding in  Java is achieved  using
JPL using a C-glue between the Java and Prolog C interfaces.

The  most   simple  embedded   program  is   below.      The   interface
function  PL_initialise()  mmuusstt  be  called  before  any  of  the  other
SWI-Prolog  foreign  language  functions  described  in   this  chapter,
except  for  PL_initialise_hook(),   PL_new_atom(),  PL_new_functor()  and
PL_register_foreign().   PL_initialise() interprets all the command  line
arguments,  except  for the  -t toplevel  flag  that is  interpreted  by
PL_toplevel().

________________________________________________________________________|                                                                        |
|int                                                                     |

|main(int argc, char **argv)                                             |
|{ if ( !PL_initialise(argc, argv) )                                     |
|    PL_halt(1);                                                         |
|                                                                        |
|  PL_halt(PL_toplevel() ? 0 : 1);                                       |
|}|_____________________________________________________________________ | |


int PPLL__iinniittiiaalliissee(_i_n_t _a_r_g_c_, _c_h_a_r _*_*_a_r_g_v)
    Initialises  the SWI-Prolog  heap and  stacks,  restores the  Prolog
    state, loads the  system and personal initialisation files, runs the
    initialization/1 hooks and finally runs the -g goal hook.

    Special  consideration  is required  for argv[0].    On  UUnniixx,  this
    argument passes the part  of the command line that is used to locate
    the  executable.   Prolog  uses this to  find the  file holding  the
    running executable.   The WWiinnddoowwss version uses this to find a _m_o_d_u_l_e
    of  the  running executable.    If the  specified  module cannot  be
    found, it tries  the module libpl.dll, containing the Prolog runtime
    kernel.   In  all these cases,  the resulting file  is used for  two
    purposes:

      o  See whether a Prolog saved  state is appended to the file.   If
         this is  the case,  this state  will be loaded  instead of  the
         default boot.prc file from the SWI-Prolog home directory.   See
         also qsave_program/[1,2] and section ????.

      o  Find the Prolog home  directory.  This process is  described in
         detail in section ????.

    PL_initialise()  returns 1  if all  initialisation  succeeded and  0
    otherwise.

    In  most cases, _a_r_g_c and _a_r_g_v will be passed from the  main program.
    It  is allowed to create your own argument vector,  provided argv[0]
    is constructed according to the rules above.  For example:

    ____________________________________________________________________|                                                                    |

    | int                                                                |
    | main(int argc, char **argv)                                        |
    | { char *av[10];                                                    |
    |   int ac = 0;                                                      |
    |                                                                    |

    |   av[ac++] = argv[0];                                              |
    |   av[ac++] = "-x";                                                 |
    |   av[ac++] = "mystate";                                            |
    |   av[ac]   = NULL;                                                 |
    |                                                                    |
    |   if ( !PL_initialise(ac, av) )                                    |
    |     PL_halt(1);                                                    |
    |   ...                                                              |

    ||}_________________________________________________________________ ||

    Please  note that the  passed argument vector  may be referred  from
    Prolog  at any time  and should  therefore be valid  as long as  the
    Prolog engine is used.

    A  good setup  in Windows is  to add  SWI-Prolog's bin directory  to
    your  PATH  and either  pass  a module  holding  a saved  state,  or
    "libpl.dll"  as argv[0].  If the  Prolog state is attached to  a DLL
    (see the -dll option of swipl-ld), pass the name of this DLL.


int PPLL__iiss__iinniittiiaalliisseedd(_i_n_t _*_a_r_g_c_, _c_h_a_r _*_*_*_a_r_g_v)
    Test  whether the  Prolog engine  is already initialised.    Returns
    FALSE  if Prolog  is not  initialised and TRUE  otherwise.   If  the
    engine is initialised  and _a_r_g_c is not NULL, the argument count used
    with  PL_initialise() is  stored in  _a_r_g_c.   Same  for the  argument
    vector _a_r_g_v.


int PPLL__sseett__rreessoouurrccee__ddbb__mmeemm(_c_o_n_s_t _u_n_s_i_g_n_e_d _c_h_a_r _*_d_a_t_a_, _s_i_z_e___t _s_i_z_e)
    This  function  must  be called  at  most  once and  _b_e_f_o_r_e  calling
    PL_initialise().   The memory area designated by _d_a_t_a and  _s_i_z_e must
    contain  the  resource data  and be  in the  format  as produced  by
    qsave_program/2.  The memory  area is accessed by PL_initialise() as
    well as calls to open_resource/3.

    For  example, we  can include  the bootstrap data  into an  embedded
    executable  using the steps below.   The advantage of this  approach
    is  that it is  fully supported by  any OS and  you obtain a  single
    file executable.

     1.  Create a saved state using qsave_program/2 or

         _______________________________________________________________|                                                               |
         |%|swipl_-o_state_-c_file.pl_..._______________________________ | |

     2.  Create a  C source  file from the  state using  e.g., the  Unix
         utility xxd(1):

         _______________________________________________________________|                                                               |
         |%|xxd_-i_state_>_state.h______________________________________ | |

     3.  Embed Prolog as in the  example below.  Instead of  calling the
         toplevel you probably want to call your application code.

         _______________________________________________________________|                                                               |
         |#include <SWI-Prolog.h>                                        |
         |#include "state.h"                                             |
         |                                                               |

         |int                                                            |
         |main(int argc, char **argv)                                    |
         |{ if ( !PL_set_resource_db_mem(state, state_len) ||            |
         |       !PL_initialise(argc, argv) )                            |
         |    PL_halt(1);                                                |
         |                                                               |
         |  return PL_toplevel();                                        |
         |}|____________________________________________________________ | |

    Alternative  to xxd, it  is possible to  use inline assembler,  e.g.
    the  gcc incbin instruction.   Code for gcc was provided by  Roberto
    Bagnara  on the SWI-Prolog mailinglist.   Given the state in a  file
    state, create the following assembler program:

    ____________________________________________________________________|                                                                    |

    |         .globl _state                                              |
    |         .globl _state_end                                          |
    | _state:                                                            |
    |         .incbin "state"                                            |
    ||_state_end:_______________________________________________________ ||

    Now include this as follows:

    ____________________________________________________________________|                                                                    |

    | #include <SWI-Prolog.h>                                            |
    |                                                                    |
    | #if __linux                                                        |
    | #define STATE _state                                               |
    | #define STATE_END _state_end                                       |
    | #else                                                              |
    | #define STATE state                                                |

    | #define STATE_END state_end                                        |
    | #endif                                                             |
    |                                                                    |
    | extern unsigned char STATE[];                                      |
    | extern unsigned char STATE_END[];                                  |
    |                                                                    |
    | int                                                                |
    | main(int argc, char **argv)                                        |

    | { if ( !PL_set_resource_db_mem(STATE, STATE_END - STATE) ||        |
    |        !PL_initialise(argc, argv) )                                |
    |     PL_halt(1);                                                    |
    |   return PL_toplevel();                                            |
    ||}_________________________________________________________________ ||

    As   Jose  Morales  pointed  at   https://github.com/graphitemaster/
    incbin,  which  contains a  portability layer  on top  of the  above
    idea.


int PPLL__ttoopplleevveell()
    Runs  the  goal of  the -t toplevel  switch  (default prolog/0)  and
    returns 1 if successful, 0 otherwise.


int PPLL__cclleeaannuupp(_i_n_t _s_t_a_t_u_s)
    This function  performs the reverse of PL_initialise().   It runs the
    PL_on_halt() and at_halt/1 handlers, closes all streams  (except for
    the  `standard I/O'  streams which  are  flushed only),  deallocates
    all  memory if _s_t_a_t_u_s equals  `0' and restores all signal  handlers.
    The  _s_t_a_t_u_s argument is passed to the various termination  hooks and
    indicates the _e_x_i_t_-_s_t_a_t_u_s.

    The  function  returns  TRUE  if  successful  and  FALSE  otherwise.
    Currently,  FALSE  is  returned when  an  attempt  is made  to  call
    PL_cleanup() recursively or if one of the  exit handlers cancels the
    termination  using cancel_halt/1.    Exit handlers  may only  cancel
    termination if _s_t_a_t_u_s is 0.

    In  theory, this function allows deleting and restarting  the Prolog
    system  in the  same process.    In  practice, SWI-Prolog's  cleanup
    process is far  from complete, and trying to revive the system using
    PL_initialise()  will leak memory  in the best  case.   It can  also
    crash the appliction.

    In  this state,  there is  little practical use  for this  function.
    If  you want  to use Prolog  temporarily, consider  running it in  a
    separate  process.   If you want  to be able  to reset Prolog,  your
    options are (again) a separate process, modules or threads.


void PPLL__cclleeaannuupp__ffoorrkk()
    Stop intervaltimer that may  be running on behalf of profile/1.  The
    call is intended to be used in combination with fork():

    ____________________________________________________________________|                                                                    |
    |     if ( (pid=fork()) == 0 )                                       |
    |     { PL_cleanup_fork();                                           |
    |       <some exec variation>                                        |

    ||____}_____________________________________________________________ ||

    The  call behaves the same on  Windows, though there is probably  no
    meaningful application.


int PPLL__hhaalltt(_i_n_t _s_t_a_t_u_s)
    Clean  up the Prolog environment using PL_cleanup() and  if success-
    ful  call exit() with  the status argument.   Returns FALSE if  exit
    was cancelled by PL_cleanup().


1122..44..2211..11 TThhrreeaaddiinngg,, SSiiggnnaallss aanndd eemmbbeeddddeedd PPrroolloogg

This section  applies to  Unix-based environments that  have signals  or
multithreading.   The  Windows version is  compiled for  multithreading,
and Windows lacks proper signals.

We  can distinguish  two classes  of embedded  executables.   There  are
small C/C++  programs that act  as an  interfacing layer around  Prolog.
Most  of  these  programs  can  be  replaced  using  the  normal  Prolog
executable extended with  a dynamically loaded foreign extension and  in
most cases  this is  the preferred  route.   In other  cases, Prolog  is
embedded in a complex application that---like  Prolog---wants to control
the process  environment.   A good  example is Java.   Embedding  Prolog
is generally  the only  way to  get these environments  together in  one
process image.    Java VMs,  however,  are by  nature multithreaded  and
appear to do signal handling (software interrupts).

On  Unix  systems,  SWI-Prolog  installs   handlers  for  the  following
signals:

SSIIGGUUSSRR22  has an empty signal handler.   This signal is sent to  a thread
    after  sending a  thread-signal (see  thread_signal/2).   It  causes
    blocking  system calls to  return with EINTR,  which gives them  the
    opportunity to react to thread-signals.

    In  some  cases the  embedded  system and  SWI-Prolog may  both  use
    SIGUSR2 without conflict.   If the embedded system redefines SIGUSR2
    with  a  handler that  runs  quickly  and no  harm  is done  in  the
    embedded  system due to spurious wakeup when initiated  from Prolog,
    there  is  no problem.    If  SWI-Prolog  is initialised  _a_f_t_e_r  the
    embedded system it  will call the handler set by the embedded system
    and  the same conditions  as above apply.   SWI-Prolog's handler  is
    a  simple function  only chaining a  possibly previously  registered
    handler.  SWI-Prolog can handle spurious SIGUSR2 signals.

SSIIGGIINNTT  is used by the top level to activate the tracer (typically bound
    to control-C). The  first control-C posts a request for starting the
    tracer  in a safe, synchronous fashion.   If control-C is  hit again
    before  the safe route is executed,  it prompts the user whether  or
    not a forced interrupt is desired.

SSIIGGTTEERRMM,, SSIIGGAABBRRTT aanndd SSIIGGQQUUIITT  are caught to  cleanup before killing  the
    process again using the same signal.

SSIIGGSSEEGGVV,, SSIIGGIILLLL,, SSIIGGBBUUSS,, SSIIGGFFPPEE aanndd SSIIGGSSYYSS  are caught  by  to  print  a
    backtrace before killing the process again using the same signal.

SSIIGGHHUUPP  is caught and  causes the process  to exit  with status 2  after
    cleanup.

The --nosignals  option can  be used  to inhibit  all signal  processing
except for SIGUSR2.   The handling of SIGUSR2 is vital for  dealing with
blocking system call in  threads.  The used signal may be  changed using
the --sigalert=NUM option or disabled using --sigalert=0.


1122..55 LLiinnkkiinngg eemmbbeeddddeedd aapppplliiccaattiioonnss uussiinngg sswwiippll--lldd

The  utility program  swipl-ld (Win32:   swipl-ld.exe)  may  be used  to
link  a combination  of C  files  and Prolog  files into  a  stand-alone
executable.    swipl-ld  automates most  of  what  is described  in  the
previous sections.

In  normal usage,  a  copy is  made of  the default  embedding  template
.../swipl/include/stub.c.    The  main()  routine is  modified  to  suit
your  application.   PL_initialise()  mmuusstt be  passed the  program  name
(_a_r_g_v_[_0_])  (Win32:    the  executing  program  can   be  obtained  using
GetModuleFileName()).   The other  elements of the  command line may  be
modified.  Next, swipl-ld is typically invoked as:

________________________________________________________________________|                                                                        |
|swipl-ld|-o_output_stubfile.c_[other-c-or-o-files]_[plfiles]___________ |        |

swipl-ld will first split  the options into various groups for  both the
C compiler and the  Prolog compiler.  Next, it will add  various default
options to the  C compiler and call  it to create an executable  holding
the  user's C  code and  the Prolog  kernel.   Then,  it  will call  the
SWI-Prolog compiler  to create a  saved state  from the provided  Prolog
files  and finally,  it  will attach  this saved  state to  the  created
emulator to create the requested executable.

Below, it  is described how the options  are split and which  additional
options are passed.

-help
    Print brief synopsis.

-pl _p_r_o_l_o_g
    Select  the Prolog to use.   This Prolog  is used for two  purposes:
    get  the home directory as  well as the compiler/linker options  and
    create a saved state of the Prolog code.

-ld _l_i_n_k_e_r
    Linker  used to link the  raw executable.   Default is to use the  C
    compiler (Win32:  link.exe).

-cc _C _c_o_m_p_i_l_e_r
    Compiler  for .c files found  on the command line.   Default is  the
    compiler  used to  build  SWI-Prolog accessible  through the  Prolog
    flag c_cc (Win32:  cl.exe).

-c++ _C_+_+_-_c_o_m_p_i_l_e_r
    Compiler  for C++  source file (extensions  .cpp, .cxx,  .cc or  .C)
    found on the command  line.  Default is c++ or g++ if the C compiler
    is gcc (Win32:  cl.exe).

-nostate
    Just  relink  the  kernel,  do  not  add  any  Prolog  code  to  the
    new  kernel.     This  is  used  to  create  a  new  kernel  holding
    additional  foreign  predicates  on  machines that  do  not  support
    the  shared-library  (DLL)  interface,  or  if  building  the  state
    cannot  be  handled  by  the default  procedure  used  by  swipl-ld.
    In   the  latter   case  the   state  is   created  separately   and
    appended  to  the kernel  using  cat <_k_e_r_n_e_l> <_s_t_a_t_e> > <_o_u_t>(Win32:
    copy /b <_k_e_r_n_e_l>+<_s_t_a_t_e> <_o_u_t>).

-shared
    Link  C, C++ or object files into a shared object (DLL) that  can be
    loaded  by the  load_foreign_library/1predicate.    If used with  -c
    it  sets the proper  options to compile  a C or  C++ file ready  for
    linking into a shared object.

-dll
    _W_i_n_d_o_w_s  _o_n_l_y.     Embed  SWI-Prolog  into  a  DLL  rather  than  an
    executable.

-c
    Compile  C  or C++  source files  into  object files.    This  turns
    swipl-ld into a  replacement for the C or C++ compiler, where proper
    options  such as the  location of the  include directory are  passed
    automatically to the compiler.

-E
    Invoke the C preprocessor.   Used to make swipl-ld a replacement for
    the C or C++ compiler.

-pl-options _,_._._.
    Additional  options passed to Prolog when creating the  saved state.
    The  first character  immediately  following pl-options  is used  as
    separator  and  translated to  spaces when  the  argument is  built.
    Example:  -pl-options,-F,xpce  passes -F xpce as additional flags to
    Prolog.

-ld-options _,_._._.
    Passes options to the linker, similar to -pl-options.

-cc-options _,_._._.
    Passes options to the C/C++ compiler, similar to -pl-options.

-v
    Select  verbose operation,  showing the  various programs and  their
    options.

-o _o_u_t_f_i_l_e
    Reserved to specify the final output file.

-l_l_i_b_r_a_r_y
    Specifies  a  library for  the  C compiler.    By  default,  -lswipl
    (Win32:   libpl.lib) and the  libraries needed by the Prolog  kernel
    are given.

-L_l_i_b_r_a_r_y_-_d_i_r_e_c_t_o_r_y
    Specifies  a  library directory  for the  C compiler.    By  default
    the  directory  containing  the Prolog  C  library for  the  current
    architecture is passed.

-g | -I_i_n_c_l_u_d_e_-_d_i_r_e_c_t_o_r_y | -D_d_e_f_i_n_i_t_i_o_n
    These  options  are passed  to the  C  compiler.   By  default,  the
    include directory containing SWI-Prolog.h  is passed.  swipl-ld adds
    two additional * -Ddef flags:

    -D__SWI_PROLOG__
         Indicates the code is to be connected to SWI-Prolog.

    -D__SWI_EMBEDDED__
         Indicates the creation of an embedded program.

 _*_._o | _*_._c | _*_._C | _*_._c_x_x | _*_._c_p_p
    Passed as input files to the C compiler.

 _*_._p_l |_*_._q_l_f
    Passed  as input files  to the Prolog  compiler to create the  saved
    state.

 *
    All  other options.   These are  passed as linker  options to the  C
    compiler.


1122..55..11 AA ssiimmppllee eexxaammppllee

The  following is  a very  simple example  going through  all the  steps
outlined above.   It  provides an arithmetic expression  evaluator.   We
will call  the application calc  and define it in  the files calc.c  and
calc.pl.  The Prolog file is simple:

________________________________________________________________________|                                                                        |
|calc(Atom) :-                                                           |

|        term_to_atom(Expr, Atom),                                       |
|        A is Expr,                                                      |
|        write(A),                                                       |
||_______nl.____________________________________________________________ ||

The  C  part  of  the  application  parses  the  command  line  options,
initialises the  Prolog engine, locates  the calc/1 predicate and  calls
it.  The coder is in figure ????.

________________________________________________________________________|                                                                        |
|#include <stdio.h>                                                      |
|#include <SWI-Prolog.h>                                                 |
|                                                                        |
|#define MAXLINE 1024                                                    |

|                                                                        |
|int                                                                     |
|main(int argc, char **argv)                                             |
|{ char expression[MAXLINE];                                             |
|  char *e = expression;                                                 |
|  char *program = argv[0];                                              |
|  char *plav[2];                                                        |

|  int n;                                                                |
|                                                                        |
|  /* combine all the arguments in a single string */                    |
|                                                                        |
|  for(n=1; n<argc; n++)                                                 |
|  { if ( n != 1 )                                                       |
|      *e++ = ' ';                                                       |
|    strcpy(e, argv[n]);                                                 |

|    e += strlen(e);                                                     |
|  }                                                                     |
|                                                                        |
|  /* make the argument vector for Prolog */                             |
|                                                                        |
|  plav[0] = program;                                                    |
|  plav[1] = NULL;                                                       |

|                                                                        |
|  /* initialise Prolog */                                               |
|                                                                        |
|  if ( !PL_initialise(1, plav) )                                        |
|    PL_halt(1);                                                         |
|                                                                        |
|  /* Lookup calc/1 and make the arguments and call */                   |
|                                                                        |

|  { predicate_t pred = PL_predicate("calc", 1, "user");                 |
|    term_t h0 = PL_new_term_refs(1);                                    |
|    int rval;                                                           |
|                                                                        |
|    PL_put_atom_chars(h0, expression);                                  |
|    rval = PL_call_predicate(NULL, PL_Q_NORMAL, pred, h0);              |
|                                                                        |

|    PL_halt(rval ? 0 : 1);                                              |
|  }                                                                     |
|                                                                        |
|  return 0;                                                             |
|}|_____________________________________________________________________ | |

            Figure 12.4:  C source for the calc application

The application is now created using the following command line:

________________________________________________________________________|                                                                        |
|%|swipl-ld_-o_calc_calc.c_calc.pl______________________________________ | |

The following indicates the usage of the application:

________________________________________________________________________|                                                                        |

|% calc pi/2                                                             |
|1.5708|________________________________________________________________ |      |


1122..66 TThhee PPrroolloogg ``hhoommee'' ddiirreeccttoorryy

Executables  embedding SWI-Prolog  should  be able  to find  the  `home'
directory of the  development environment unless a self-contained  saved
state  has been  added to  the executable  (see qsave_program/[1,2]  and
section ????).

If Prolog starts up, it will try to  locate the development environment.
To do so, it will try the following steps until one succeeds:

 1. If the --home=DIR is provided, use this.

 2. If  the environment variable  SWI_HOME_DIRis  defined and points  to
    an existing directory, use this.

 3. If  the  environment variable  SWIPL  is defined  and points  to  an
    existing directory, use this.

 4. Locate  the  primary   executable  or  (Windows  only)  a  component
    (_m_o_d_u_l_e)  thereof  and check  whether the  parent  directory of  the
    directory  holding this file contains the  file swipl.  If so,  this
    file  contains the (relative) path to  the home directory.  If  this
    directory  exists, use this.   This is the normal mechanism  used by
    the binary distribution.

 5. If  the precompiled path exists, use it.  This is only  useful for a
    source installation.

If  all fails  and  there is  no state  attached  to the  executable  or
provided Windows module (see PL_initialise()), SWI-Prolog gives up.   If
a state is attached, the current working directory is used.

The file_search_path/2 alias swi is set  to point to the home  directory
located.


1122..77 EExxaammppllee ooff UUssiinngg tthhee FFoorreeiiggnn IInntteerrffaaccee

Below is an example  showing all stages of the declaration of  a foreign
predicate that transforms atoms possibly holding  uppercase letters into
an atom only  holding lowercase letters.   Figure ???? shows the C  source
file, figure ???? illustrates compiling and loading of foreign code.
________________________________________________________________________|                                                                        |
|/*  Include file depends on local installation */                       |
|#include <SWI-Prolog.h>                                                 |
|#include <stdlib.h>                                                     |

|#include <string.h>                                                     |
|#include <ctype.h>                                                      |
|                                                                        |
|foreign_t                                                               |
|pl_lowercase(term_t u, term_t l)                                        |
|{ char *copy;                                                           |
|  char *s, *q;                                                          |
|  int rval;                                                             |

|                                                                        |
|  if ( !PL_get_atom_chars(u, &s) )                                      |
|    return PL_warning("lowercase/2: instantiation fault");              |
|  copy = malloc(strlen(s)+1);                                           |
|                                                                        |
|  for( q=copy; *s; q++, s++)                                            |
|    *q = (isupper(*s) ? tolower(*s) : *s);                              |

|  *q = '\0';                                                            |
|                                                                        |
|  rval = PL_unify_atom_chars(l, copy);                                  |
|  free(copy);                                                           |
|                                                                        |
|  return rval;                                                          |
|}                                                                       |
|                                                                        |

|install_t                                                               |
|install()                                                               |
|{ PL_register_foreign("lowercase", 2, pl_lowercase, 0);                 |
|}|_____________________________________________________________________ | |

                  Figure 12.5:  Lowercase source file

________________________________________________________________________|                                                                        |
|% gcc -I/usr/local/lib/swipl-\plversion/include -fpic -c lowercase.c    |
|% gcc -shared -o lowercase.so lowercase.o                               |
|% swipl                                                                 |
|Welcome to SWI-Prolog (...)                                             |

|...                                                                     |
|                                                                        |
|1 ?- load_foreign_library(lowercase).                                   |
|true.                                                                   |
|                                                                        |
|2 ?- lowercase('Hello World!', L).                                      |
|L|=_'hello_world!'.____________________________________________________ | |

    Figure 12.6:  Compiling the C source and loading the object file


1122..88 NNootteess oonn UUssiinngg FFoorreeiiggnn CCooddee


1122..88..11 FFoorreeiiggnn ddeebbuuggggiinngg ffuunnccttiioonnss

The  functions in  this  section are  primarily intended  for  debugging
foreign extensions  or embedded Prolog.    Violating the constraints  of
the foreign  interface often leads  to crashes  in a subsequent  garbage
collection.   If this  happens, the system needs  to be recompiled  with
the cflags -DO_DEBUG. This is normally achieved by  editing src/Makefile
and  changing the  definition  of  COFLAGS to  the  value  below.    The
-gdwarf-2 -g3 provides detailed  debugging information for gcc.   If you
use another C compiler you may need other flags.

________________________________________________________________________|                                                                        |
|COFLAGS=-DO_DEBUG|-gdwarf-2_-g3________________________________________ |                 |

After  recompiling the  Prolog  kernel all  functions listed  above  are
available to  use from  the debugger (e.g.    gdb) or can  be placed  at
critical location in your code or the system code.


void PPLL__bbaacckkttrraaccee(_i_n_t _d_e_p_t_h_, _i_n_t _f_l_a_g_s)
    Dump  a Prolog  backtrace to the  user_error  stream.   _D_e_p_t_h is  the
    number  of frames to dump.   _F_l_a_g_s is a bitwise or of  the following
    constants:

    PPLL__BBTT__SSAAFFEE
         (0x1) Do  not try  to print  _g_o_a_l_s.   Instead,  just print  the
         predicate name  and  arity.   This  reduces  the likelyhood  to
         crash if PL_backtrace() is called in a damaged environment.

    PPLL__BBTT__UUSSEERR
         (0x2) Only show `user' frames.  Default is to  also show frames
         of hidden built-in predicates.


char * PPLL__bbaacckkttrraaccee__ssttrriinngg(_i_n_t _d_e_p_t_h_, _i_n_t _f_l_a_g_s)
    As  PL_backtrace(),  but returns the stack as  a string.  The  string
    uses  UTF-8  encoding.   The  returned string  must  be freed  using
    PL_free().   This  function is was  added to  get stack traces  from
    running servers where  I/O is redirected or discarded.  For example,
    using  gdb, a stack trace is  printed in the gdb console  regardless
    of Prolog I/O redirection using the following command:

    ____________________________________________________________________|                                                                    |
    ||(gdb)_printf_"%s",_PL_backtrace_string(25,0)______________________ ||

    The  source distribution provides  the script scripts/swipl-bt  that
    exploits  gdb  and PL_backtrace_string() to  print stack  traces  in
    various formats for a SWI-Prolog process, given its process id.


int PPLL__cchheecckk__ddaattaa(_t_e_r_m___t _d_a_t_a)
    Check  the consistency  of  the term  _d_a_t_a.   Returns  TRUE this  is
    actually  implemented in  the current version  and FALSE  otherwise.
    The  actual implementation  only exists  if the  system is  compiled
    with  the  cflag  -DO_DEBUG  or -DO_MAINTENANCE.  This  is  _n_o_t  the
    default.


int PPLL__cchheecckk__ssttaacckkss()
    Check  the consistency of the runtime stacks of the  calling thread.
    Returns  TRUE this  is actually implemented  in the current  version
    and  FALSE otherwise.    The  actual implementation  only exists  if
    the  system is compiled with the cflag -DO_DEBUG or -DO_MAINTENANCE.
    This is _n_o_t the default.

The  Prolog kernel  sources use  the macro  DEBUG(_T_o_p_i_c_, _C_o_d_e).    These
macros  are disabled  in  the production  version  and must  be  enabled
by  recompiling  the  system  as  described  above.     Specific  topics
can  be enabled  and disabled  using the  predicates prolog_debug/1  and
prolog_nodebug/1.     In  addition,  they  can  be  activated  from  the
commandline  using  commandline option  -d topics,  where  _t_o_p_i_c_s  is  a
comma-separated list of debug  topics to enable.  For example,  the code
below adds  many consistency checks  and prints  messages if the  Prolog
signal handler dispatches signals.

________________________________________________________________________|                                                                        |

|$|swipl_-d_chk_secure,msg_signal_______________________________________ | |


pprroolloogg__ddeebbuugg((_+_T_o_p_i_c))


pprroolloogg__nnooddeebbuugg((_+_T_o_p_i_c))
    Enable/disable a debug topic.   _T_o_p_i_c is an atom that identifies the
    desired topic.   The available topics are defined in src/pl-debug.h.
    Please  search the sources to find out what is actually  printed and
    when.  We highlight one topic here:

    cchhkk__sseeccuurree((_A))
         dd many  expensive  consistency checks  to the  system.    This
         should typically be  used when the  system crashes, notably  in
         the garbage collector.  Garbage collection crashes  are in most
         cases caused by invalid data on the Prolog stacks.   This debug
         topic may help locating how the invalid data was created.


1122..88..22 MMeemmoorryy AAllllooccaattiioonn

SWI-Prolog's heap  memory allocation is based  on the malloc(3)  library
routines.  SWI-Prolog  provides the functions below as a  wrapper around
malloc().    Allocation  errors  in these  functions  trap  SWI-Prolog's
fatal-error handler,  in which case  PL_malloc() or PL_realloc() do  not
return.

Portable applications must use PL_free() to release strings  returned by
PL_get_chars()using  the BUF_MALLOC argument.   Portable applications may
use both PL_malloc() and friends or malloc() and friends  but should not
mix these two sets of functions on the same memory.


void * PPLL__mmaalllloocc(_s_i_z_e___t _b_y_t_e_s)
    Allocate  _b_y_t_e_s  of memory.    On  failure SWI-Prolog's  fatal-error
    handler  is  called  and  PL_malloc()  does  not  return.     Memory
    allocated  using these functions must use PL_realloc() and PL_free()
    rather than realloc() and free().


void * PPLL__rreeaalllloocc(_v_o_i_d _*_m_e_m_, _s_i_z_e___t _s_i_z_e)
    Change  the size of the  allocated chunk, possibly  moving it.   The
    _m_e_m  argument  must  be  obtained  from a  previous  PL_malloc()  or
    PL_realloc() call.


void PPLL__ffrreeee(_v_o_i_d _*_m_e_m)
    Release  memory.  The _m_e_m argument must be obtained from  a previous
    PL_malloc() or PL_realloc() call.


1122..88..22..11 BBooeehhmm--GGCC ssuuppppoorrtt

    This  section is  obsolete.   Although the  Boehm-GC interfaces
    still  exist, it  turns out  that the  scalability is  not good
    enough  for SWI-Prolog.   It  is unlikely that  SWI-Prolog will
    ever switch to Boehm-GC.

To  accommodate future  use  of the  Boehm  garbage collector  for  heap
memory  allocation,  the  interface  provides  the  functions  described
below.  Foreign extensions that wish to use  the Boehm-GC facilities can
use these wrappers.   Please note that if SWI-Prolog is not  compiled to
use Boehm-GC  (default), the user  is responsible for  calling PL_free()
to reclaim memory.


void* PPLL__mmaalllloocc__aattoommiicc(_s_i_z_e___t _b_y_t_e_s)


void* PPLL__mmaalllloocc__uunnccoolllleeccttaabbllee(_s_i_z_e___t _b_y_t_e_s)


void* PPLL__mmaalllloocc__aattoommiicc__uunnccoolllleeccttaabbllee(_s_i_z_e___t _b_y_t_e_s)
    If  Boehm-GC is  not used,  these are all  the same  as PL_malloc().
    With  Boehm-GC, these map  to the corresponding Boehm-GC  functions.
    _A_t_o_m_i_c  means that the content  should not be scanned for  pointers,
    and  _u_n_c_o_l_l_e_c_t_a_b_l_e means  that the  object should  never be  garbage
    collected.


void* PPLL__mmaalllloocc__ssttuubbbboorrnn(_s_i_z_e___t _b_y_t_e_s)


void PPLL__eenndd__ssttuubbbboorrnn__cchhaannggee(_v_o_i_d _*_m_e_m_o_r_y)
    These  functions  allow  creating objects,  promising  GC  that  the
    content will not change after PL_end_stubborn_change().


1122..88..33 CCoommppaattiibbiilliittyy bbeettwweeeenn PPrroolloogg vveerrssiioonnss

Great  care  is   taken  to  ensure  binary  compatibility  of   foreign
extensions  between different  Prolog  versions.    Only the  much  less
frequently  used  stream  interface  has  been  responsible  for  binary
incompatibilities.

Source  code  that relies  on  new  features of  the  foreign  interface
can use  the macro  PLVERSION to  find the version  of SWI-Prolog.h  and
PL_query() using  the  option PL_QUERY_VERSION to  find the  version  of
the  attached Prolog  system.   Both  follow the  same numbering  schema
explained with PL_query().


1122..88..44 DDeebbuuggggiinngg aanndd pprrooffiilliinngg ffoorreeiiggnn ccooddee ((vvaallggrriinndd))

This section  is only  relevant for  Unix users  on platforms  supported
by  http://valgrind.org/valgrind.    Valgrind  is  an  excellent  binary
instrumentation platform.  Unlike many  other instrumentation platforms,
valgrind can deal with code loaded through dlopen().

The callgrind  tool can  be used  to profile foreign  code loaded  under
SWI-Prolog.    Compile  the foreign  library  adding  -g option  to  gcc
or  swipl-ld.   By  setting the  environment variable  VALGRIND to  yes,
SWI-Prolog  will _n_o_t  release  loaded  shared objects  using  dlclose().
This trick is required to get source information on  the loaded library.
Without,  valgrind  claims  that  the shared  object  has  no  debugging
information.  Here is the complete sequence using bash as login shell:

________________________________________________________________________|                                                                        |
|% VALGRIND=yes valgrind --tool=callgrind pl <args>                      |

|<prolog interaction>                                                    |
|%|kcachegrind_callgrind.out.<pid>______________________________________ | |


1122..88..55 NNaammee CCoonnfflliiccttss iinn CC mmoodduulleess

In  the  current  version  of the  system  all  public  C  functions  of
SWI-Prolog are in the symbol table.  This can lead  to name clashes with
foreign code.    Someday I  should write a  program to  strip all  these
symbols from the symbol table  (why does Unix not have that?).   For now
I can  only suggest you  give your function  another name.   You can  do
this using the C preprocessor.  If---for  example---your foreign package
uses  a function  warning(), which  happens to  exist  in SWI-Prolog  as
well, the following macro should fix the problem:

________________________________________________________________________|                                                                        |
|#define|warning_warning________________________________________________ |       |

Note  that shared  libraries do  not  have this  problem as  the  shared
library loader  will only look  for symbols in  the main executable  for
symbols that are not defined in the library itself.


1122..88..66 CCoommppaattiibbiilliittyy ooff tthhee FFoorreeiiggnn IInntteerrffaaccee

The  term  reference   mechanism  was  first  used  by  Quintus   Prolog
version 3.   SICStus Prolog version 3  is strongly based on the  Quintus
interface.  The  described SWI-Prolog interface is similar to  using the
Quintus or SICStus interfaces, defining all  foreign-predicate arguments
of  type  +term.    SWI-Prolog  explicitly uses  type  functor_t,  while
Quintus  and SICStus  use  <_n_a_m_e> and  <_a_r_i_t_y>.    As  the  names of  the
functions differ  from Prolog to  Prolog, a  simple macro layer  dealing
with the names can also deal with this detail.  For example:

________________________________________________________________________|                                                                        |
|#define QP_put_functor(t, n, a) \                                       |

||_______PL_put_functor(t,_PL_new_functor(n,_a))________________________ ||

The  PL_unify_*()  functions are  lacking from  the  Quintus and  SICStus
interface.    They can  easily be  emulated, or  the put/unify  approach
should be used to write compatible code.

The PL_open_foreign_frame()/PL_close_foreign_frame() combination is lack-
ing from both other  Prologs.  SICStus has PL_new_term_refs(_0),  followed
by PL_reset_term_refs(), that allows for discarding term references.

The  Prolog interface  for  the graphical  user interface  package  XPCE
shares about  90% of the code  using a simple  macro layer to deal  with
different naming and calling conventions of the interfaces.


CChhaapptteerr 1133..  DDEEPPLLOOYYIINNGG AAPPPPLLIICCAATTIIOONNSS

This  chapter  describes  the  features  of  SWI-Prolog  for  delivering
applications using _s_a_v_e_d _s_t_a_t_e_s.


1133..11 DDeeppllooyymmeenntt ooppttiioonnss

There are several  ways to make a  Prolog application available to  your
users.    By far  the easiest  way is  to require  the  user to  install
SWI-Prolog and  deliver the  application as a  directory holding  source
files,  other resources the  application may  need and  a _P_r_o_l_o_g  _S_c_r_i_p_t
file  that provides  the executable.    See section  ????.   The  two-step
installation  may be  slightly less  convenient for  the end  user,  but
enables the  end-user to conveniently  run your  program on a  different
operating  system or  architecture.   This  mechanism  is obviously  not
suitable if you want to keep the source of your program secret.

Another  solution  is to  use  _s_a_v_e_d  _s_t_a_t_e_s,  the main  topic  of  this
chapter,  together with  the installed  development  system and  disable
_a_u_t_o_l_o_a_d_i_n_g  requirements into  the  state  using --no-autoload  or  the
autoload(_f_a_l_s_e) option  of qsave_program/2.   This  allows creating  the
application  as  a  single file,  while  avoiding  the  need  to  ensure
that the  state is self-contained.   For  large programs this  technique
typically  reduces  startup  time  by an  order  of  magnitude.     This
mechanism is  particuarly suitable  for in-house  and cloud  deployment.
It  provides  some  protection against  inspecting  the  source.     See
section ???? for details.

The final solution  is to make sure  all required resources are  present
in  the saved  state.   In  this  case the  state may  be  added to  the
_e_m_u_l_a_t_o_r and  the application consists  of the  emulator with state  and
the shared  objects/DLLs required  to make the  emulator work.   If  the
emulator can be  statically linked for the target platform  this creates
a single file  executable that does not require SWI-Prolog  installed on
the target computer.


1133..22 UUnnddeerrssttaannddiinngg ssaavveedd ssttaatteess

A  SWI-Prolog  _s_a_v_e_d _s_t_a_t_e  is  a  _r_e_s_o_u_r_c_e _a_r_c_h_i_v_e  that  contains  the
compiled  program  in a  machine-independent  format,  startup  options,
optionally  shared  objects/DLLs  and  optionally   additional  _r_e_s_o_u_r_c_e
files.   As of  version 7.7.13,  the resource archive  format is ZIP.  A
resource file is normally ccrreeaatteedd using the commandline option -c:

________________________________________________________________________|                                                                        |
|swipl|-o_mystate_option_..._-c_file.pl_..._____________________________ |     |

The above  causes SWI-Prolog  to load  the given Prolog  files and  call
qsave_program/2 using  options  created from  the  _o_p_t_i_o_n _._._.    in  the
command above.

A saved state may be  eexxeeccuutteedd in several ways.  The basic  mechanism is
to use the -x:

________________________________________________________________________|                                                                        |

|swipl|-x_mystate_app-arg_...___________________________________________ |     |

Saved states may  have an arbitrary payload at  the _s_t_a_r_t.  This  allows
combining  a (shell)  script or  the  emulator with  the state  to  turn
the state  into a single  file executable.   By  default a state  starts
with a  shell script  (Unix) or  the emulator  (Windows).   The  options
emulator(_F_i_l_e) and stand_alone(_B_o_o_l) control what is added at  the start
of  the state.    Finally,  C/C++  programs that  embed Prolog  may  use
a  static C  string that  embeds the  state into  the executable.    See
PL_set_resource_db_mem().


1133..22..11 CCrreeaattiinngg aa ssaavveedd ssttaattee

The predicates  in this section  support creating a saved  state.   Note
that states are commonly created from the commandline using  the -c, for
example:

________________________________________________________________________|                                                                        |
|swipl|-o_mystate_--foreign=save_-c_load.pl_____________________________ |     |

Long  (--) options  are  translated  into options  for  qsave_program/2.
This   transformation   uses   the   same   conventions   as   used   by
argv_options/3, except that the  transformation is guided by the  option
type.     This  implies  that  integer  and  callable  options  need  to
have  valid syntax  and boolean  options may  be  abbreviated to  simply
--autoload  or  --no-autoload  as  shorthands  for  --autoload=true  and
--autoload=false.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e_, _+_O_p_t_i_o_n_s))
    Saves  the current  state of  the program  to the  file _F_i_l_e.    The
    result   is  a  resource  archive  _F_i_l_e  containing   expresses  all
    Prolog  data from  the running program,  all user-defined  resources
    (see  resource/2  and  open_resource/2) and  optionally  all  shared
    objects/DLLs  required by the program for the  current architecture.
    Depending  on the stand_alone option, the resource is headed  by the
    emulator,  a Unix shell  script or nothing.   _O_p_t_i_o_n_s  is a list  of
    additional options:

    llooccaall((_+_K_B_y_t_e_s))
         Limit for the local stack.  See section ????.

    gglloobbaall((_+_K_B_y_t_e_s))
         Limit for the global stack.  See section ????.

    ttrraaiill((_+_K_B_y_t_e_s))
         Limit for the trail stack.  See section ????.

    ggooaall((_:_C_a_l_l_a_b_l_e))
         Initialization goal for the new executable (see -g).

    ttoopplleevveell((_:_C_a_l_l_a_b_l_e))
         Top-level goal  for the new  executable (see -t).   Similar  to
         initialization/2 using main,  the default toplevel is to  enter
         the Prolog interactie  shell unless a  goal has been  specified
         using goal(_C_a_l_l_a_b_l_e).

    iinniitt__ffiillee((_+_A_t_o_m))
         Default initialization file for the new executable.  See -f.

    ccllaassss((_+_C_l_a_s_s))
         If  runtime  (default),  read  resources  from  the  state  and
         disconnect the  code loaded  into the state  from the  original
         source.     If  development,  save   the  predicates  in  their
         current state and keep reading resources from  their source (if
         present).  See also open_resource/3.

    aauuttoollooaadd((_+_B_o_o_l_e_a_n))
         If true (default), run autoload/0 first.

    mmaapp((_+_F_i_l_e))
         Dump a human-readable trace of what has been saved in _F_i_l_e.

    oopp((_+_A_c_t_i_o_n))
         One of  save (default) to  save the  current operator table  or
         standard to use the initial table of the emulator.

    ssttaanndd__aalloonnee((_+_B_o_o_l_e_a_n))
         If true, the emulator is  the first part of the state.   If the
         emulator is started it tests whether a saved  state is attached
         to itself and  load this state.   Provided the application  has
         all libraries  loaded, the  resulting executable is  completely
         independent from the  runtime environment or location where  it
         was built.  See also section ????.

    eemmuullaattoorr((_+_F_i_l_e))
         File to use  for the emulator.   Default is the running  Prolog
         image.

    ffoorreeiiggnn((_+_A_c_t_i_o_n))
         If save,  include shared objects (DLLs)  into the saved  state.
         See  current_foreign_library/2.     If   the  program  strip  is
         available,  this  is first  used  to  reduce the  size  of  the
         shared object.   If  a state is  started, use_foreign_library/1
         first tries  to locate  the  foreign resource  in the  resource
         database.   When found  it copies the  content of the  resource
         to a  temporary file and  loads it.   If  possible (Unix),  the
         temporary object is deleted immediately after opening.

    uunnddeeffiinneedd((_+_V_a_l_u_e))
         Defines what happens if an undefined predicate  is found during
         the code analysis.   Values are ignore (default) or error.   In
         the latter case  creating the state  is aborted with a  message
         that indicates  the undefines  predicates and  from where  they
         are called.

    oobbffuussccaattee((_+_B_o_o_l_e_a_n))
         If true  (default false), replace  predicate names with  gener-
         ated symbols  to make  the code  harder to  assess for  reverse
         engineering.  See section ????.

    vveerrbboossee((_+_B_o_o_l_e_a_n))
         If true  (default false), report  progress and status,  notably
         regarding auto loading.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e))
    Equivalent to qsave_program(File, []).


aauuttoollooaadd
    Check  the current Prolog program  for predicates that are  referred
    to,  are  undefined and  have a  definition in  the Prolog  library.
    Load the appropriate libraries.

    This  predicate is used  by qsave_program/[1,2] to ensure the  saved
    state  does  not depend  on  availability of  the  libraries.    The
    predicate  autoload/0 examines  all  clauses of  the loaded  program
    (obtained  with  clause/2)  and  analyzes the  body  for  referenced
    goals.  Such  an analysis cannot be complete in Prolog, which allows
    for  the creation of arbitrary terms at runtime and the use  of them
    as a goal.  The current analysis is limited to the following:

      o  Direct goals appearing in the body

      o  Arguments of declared  meta-predicates that are marked with  an
         integer (0..9).  See meta_predicate/1.

    The  analysis of meta-predicate arguments is limited to  cases where
    the  argument appears literally in  the clause or is assigned  using
    =/2  before  the meta-call.    That is,  the  following fragment  is
    processed correctly:

    ____________________________________________________________________|                                                                    |

    |         ...,                                                       |
    |         Goal = prove(Theory),                                      |
    |         forall(current_theory(Theory),                             |
    ||_______________Goal)),____________________________________________ ||

    But,  the calls to prove_simple/1 and prove_complex/1 in the example
    below  are _n_o_t discovered by the analysis and therefore  the modules
    that  define  these  predicates  must  be  loaded  explicitly  using
    use_module/1,2.

    ____________________________________________________________________|                                                                    |

    |         ...,                                                       |
    |         member(Goal, [ prove_simple(Theory),                       |
    |                        prove_complex(Theory)                       |
    |                      ]),                                           |
    |         forall(current_theory(Theory),                             |
    ||_______________Goal)),____________________________________________ ||

    It  is good practice  to use gxref/0 to  make sure that the  program
    has  sufficient  declarations  such  that the  analaysis  tools  can
    verify  that all required  predicates can be  resolved and that  all
    code  is  called.   See  meta_predicate/1, dynamic/1,  public/1  and
    prolog:called_by/2.


vvoollaattiillee _+_N_a_m_e_/_A_r_i_t_y_, _._._.
    Declare  that  the clauses  of specified  predicates  should nnoott  be
    saved to the program.   The volatile declaration is normally used to
    prevent  the clauses of dynamic  predicates that represent data  for
    the current session from being saved in the state file.


1133..22..22 LLiimmiittaattiioonnss ooff qqssaavvee__pprrooggrraamm

There  are  three  areas  that  require  special  attention  when  using
qsave_program/[1,2].

  o If  the  program  is an  embedded  Prolog  application or  uses  the
    foreign  language interface,  care has  to be taken  to restore  the
    appropriate foreign context.  See section ???? for details.

  o If  the program uses directives (:- goal. lines) that  perform other
    actions  than setting  predicate attributes (dynamic/1,  volatile/1,
    etc.)   or loading files  (use_module/1,  etc.).  Goals that need  to
    be  executed when  the state  is started  must use  initialization/1
    (ISO  standard)  or initialization/2  (SWI extension  that  provides
    more  control  over  when the  goal  is  executed).    For  example,
    initialization/2 can be used to start the application:

    ____________________________________________________________________|                                                                    |

    ||:-_initialization(go,_main).______________________________________ ||

  o _B_l_o_b_s   used  as   references   to  the   database  (see   clause/3,
    recorded/3),  streams,  threads,  etc.  can  not  be saved.     This
    implies  that (dynamic) clauses may  not contain such references  at
    the  moment the qsave_program/2 is called.   Note that the  required
    foreign  context (stream,  etc.)   cannot  be present  in the  state
    anyway, making it pointless  to save such references.  An attempt to
    save such objects results in a warning.

    The  volatile/1  directive   may  be  used  to  prevent  saving  the
    clauses  of  predicates  that  hold  such references.     The  saved
    program  must reinitialise such references using the  normal program
    initialization  techniques:     use  initialization/1,2  directives,
    explicitly  create  them by  the  entry point  or make  the  various
    components recreate the context lazily when required.


1133..22..33 RRuunnttiimmeess aanndd FFoorreeiiggnn CCooddee

Many applications use packages that include  foreign language components
compiled to shared objects or DLLs.  This code  is normally loaded using
use_foreign_library/1 and the  foreign file search  path.   Below is  an
example from the socket library.

________________________________________________________________________|                                                                        |
|:-|use_foreign_library(foreign(socket))._______________________________ |  |

There are two options to handle shared objects  in runtime applications.
The  first is  to use  the  foreign(_s_a_v_e) option  of qsave_program/2  or
the  --foreign=save commandline  option.    This  causes  the  dependent
shared  objects  to  be  included  into  the  resource  archive.     The
use_foreign_library/1 directive first attempts to find the  foreign file
in  the resource  archive.   Alternatively,  the shared  objects may  be
placed in  a directory  that is distributed  with the  application.   In
this cases the file  search path foreign must be setup to point  at this
directory.   For example, we  can place the  shared objects in the  same
directory as  the executable using  the definition below.   This may  be
refined further by  adding subdirectories depending on the  architecture
as available from the Prolog flag arch.

________________________________________________________________________|                                                                        |

|:- multifile user:file_search_path/2.                                   |
|                                                                        |
|user:file_search_path(foreign, Dir) :-                                  |
|    current_prolog_flag(executable, Exe),                               |
||___file_directory_name(Exe,_Dir)._____________________________________ ||


1133..33 SSttaattee iinniittiiaalliizzaattiioonn

The  initialization/1 and  initialization/2  directive  may be  used  to
register goals to be executed at various points in the  life cycle of an
executable.   Alternatively, one may consider _l_a_z_y  _i_n_i_t_i_a_l_i_z_a_t_i_o_n which
typically follows  the pattern below.   Single  threaded code can  avoid
using with_mutex/2.

________________________________________________________________________|                                                                        |
|:- dynamic x_done/0.                                                    |

|:- volatile x_done/0.                                                   |
|                                                                        |
|x(X) :-                                                                 |
|    x_done,                                                             |
|    !,                                                                  |
|    use_x(X).                                                           |
|x(X) :-                                                                 |
|    with_mutex(x, create_x),                                            |

|    use_x(X).                                                           |
|                                                                        |
|create_x :-                                                             |
|    x_done,                                                             |
|    !.                                                                  |
|create_x :-                                                             |
|    <create x>                                                          |

||___asserta(x_done).___________________________________________________ ||


1133..44 UUssiinngg pprrooggrraamm rreessoouurrcceess

A  _r_e_s_o_u_r_c_e  is  similar  to  a  file.    Resources,   however,  can  be
represented in  two different  formats:  on  files, as  well as part  of
the resource  _a_r_c_h_i_v_e of a saved  state (see qsave_program/2) that  acts
as a _v_i_r_t_u_a_l _f_i_l_e _s_y_s_t_e_m for the SWI-Prolog I/O  predicates (see open/4,
register_iri_scheme/3).

A  resource has  a _n_a_m_e.    The _s_o_u_r_c_e  data of  a resource  is a  file.
Resources are declared by adding clauses to the  predicate resource/2 or
resource/3.  Resources  can be accessed from Prolog as files  that start
with res:// or they can be opened using open_resource/3.


1133..44..11 RReessoouurrcceess aass ffiilleess

As of  SWI-Prolog 7.7.13, resources that  are compiled into the  program
can be accessed  using the normal file  handling predicates.   Currently
the  following predicates  transparently handle  resources as  read-only
files:

  o open/3, open/4

  o access_file/2

  o exists_file/1

  o exists_directory/2

  o time_file/2

  o size_file/2

In  addition,   open_shared_object/3,   underlying  use_foreign_library/1
handles _s_h_a_r_e_d _o_b_j_e_c_t_s or  DLLs by copying them to a temporary  file and
opening this file.  If the OS allows for it,  the copied file is deleted
immediately, otherwise it is deleted on program termination.

With the  ability to open  resources as  if they were  files we can  use
them for many  tasks without changing the  source code as required  when
using open_resource/2.  Below we describe a typical scenario.

  o Related  resources are placed in one or more directories.   Consider
    a  web application where we have several directories  holding icons.
    Add  clauses to file_search_path/2 that  makes all icons  accessible
    using the term icon(_f_i_l_e).

  o Add  a clause as below before creating  the state.  This  causes all
    icons to be become available as res://app/icon/_f_i_l_e.

    ____________________________________________________________________|                                                                    |
    ||resource(app/icon,_icon(.)).______________________________________ ||

  o Add  a clause  to file_search_path/2 that make  the icons  available
    from the resource data.  For example using the code below.

    ____________________________________________________________________|                                                                    |

    ||:-_asserta(user:file_search_path(icon,_'res://app/icon')._________ ||


1133..44..22 AAcccceessss rreessoouurrcceess uussiinngg ooppeenn__rreessoouurrccee

Before the system had the ability to open resources  as files, resources
were  opened using  the predicates  open_resource/2 or  open_resource/3.
These predicates provide somewhat better dynamic  control over resources
depending on  whether the  code is running  from files  or from a  saved
state.    The main  disadvantage is  that having  a  seperate open  call
requires  rewriting code  to make  it work  with  resources rather  than
files.


ooppeenn__rreessoouurrccee((_+_N_a_m_e_, _-_S_t_r_e_a_m))


ooppeenn__rreessoouurrccee((_+_N_a_m_e_, _-_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))
    Opens  the resource  specified by _N_a_m_e.   If  successful, _S_t_r_e_a_m  is
    unified  with an input stream that provides access to  the resource.
    The stream can be  tuned using the _O_p_t_i_o_n_s, which is a subset of the
    options provided by open/4.

    ttyyppee((_T_y_p_e))
    eennccooddiinngg((_E_n_c_o_d_i_n_g))
    bboomm((_B_o_o_l))
         Options that determine the binary/text type, encoding  for text
         streams and whether  or not the  content should be checked  for
         a  BOM marker.    The  options have  the  same meaning  as  the
         corresponding options for open/4.

    The  predicate  open_resource/3  first  checks  resource/2.     When
    successful   it  will  open  the  returned  resource   source  file.
    Otherwise  it will look  in the program's  resource database.   When
    creating  a  saved state,  the system  normally  saves the  resource
    contents  into the resource archive, but does not save  the resource
    clauses.

    This   way,  the  development   environment  uses  the  files   (and
    modifications)   to   the  resource/3   declarations  and/or   files
    containing  resource info,  thus immediately  affecting the  running
    environment,  while the runtime  system quickly accesses the  system
    resources.


1133..44..33 DDeeccllaarriinngg rreessoouurrcceess


rreessoouurrccee((_:_N_a_m_e_, _+_F_i_l_e_S_p_e_c))


rreessoouurrccee((_:_N_a_m_e_, _+_F_i_l_e_S_p_e_c_, _+_O_p_t_i_o_n_s))
    These  predicates are  defined as dynamic  predicates in the  module
    user.  Clauses  for them may be defined in any module, including the
    user  module.   _N_a_m_e  is the  name of  the resource  (an atom).    A
    resource  name may contain any character, except for $ and  :, which
    are  reserved for internal usage by the resource library.   _F_i_l_e_S_p_e_c
    is  a file  specification that  may exploit  file_search_path/2 (see
    absolute_file_name/2).

    Often,  resources  are  defined as  unit  clauses (facts),  but  the
    definition  of this  predicate also allows  for rules.   For  proper
    generation  of the  saved state,  it must be  possible to  enumerate
    the  available  resources by  calling this  predicate  with all  its
    arguments unbound.

    If  _F_i_l_e_S_p_e_c points  at a  directory, the content  of the  directory
    is  recursively  added below  _N_a_m_e.    If  _F_i_l_e_S_p_e_c  a term  of  the
    form Alias(_N_a_m_e),  all directories that match this specification are
    enumerated and their content  is added to the resource database.  If
    an  file appears in  multiple results of  this search path only  the
    first  file is added.  Note that this is consistent with  the normal
    behaviour  where absolute_file_name/3returns  the first match.   The
    _O_p_t_i_o_n_s can be used to control what is saved from a directory.

    iinncclluuddee((_+_P_a_t_t_e_r_n_s))
         Only include  a file from  a directory if  it matches at  least
         one of the members of _P_a_t_t_e_r_n_s.

    eexxcclluuddee((_+_P_a_t_t_e_r_n_s))
         Excludes a file from a directory if it matches at  least one of
         the members of _P_a_t_t_e_r_n_s.


1133..44..44 MMaannaaggiinngg rreessoouurrccee ffiilleess

As   of  version   7.7.13,   SWI-Prolog   resource  files   are   zip(1)
files.      Prolog  creates  and  accesses  its  resource   files  using
the  http://www.winimage.com/zLibDll/minizip.htmlminizip project.    The
resource files  may be  examined and  modified using any  tool that  can
process zip files.


1133..55 DDeebbuuggggiinngg aanndd uuppddaattiinngg ddeeppllooyyeedd ssyysstteemmss

SWI-Prolog  provides several  facilities  to  debug and  update  running
(server) applications.  The core to these facilities are:

  o Hot-swap  recompilation (section ???? and the library  hotswap) allow,
    with  some  limitation, making  modifications  to running  services.
    This includes adding debugging and logging statements.

  o To   make  this  useful  some  form  of  interaction   is  required.
    This  can  be implemented  using  signal handlers  (Unix),  specific
    HTTP  services,  generic  HTTP  services  (e.g.,  https://swish.swi-
    prolog.orgSWISH)   or  networked   interaction  using  the   library
    prolog_server that allow interaction using netcat (nc) or telnet.


1133..66 PPrrootteeccttiinngg yyoouurr ccooddee

Prolog  in general,  but  SWI-Prolog  in  particular is  an  transparent
environment.    Prolog's  ``code is  data''  point  of view  makes  this
natural  as  it  simplifies development  and  debugging.     Some  users
though want  or need to  protect their code  against copying or  reverse
engineering.

There are three  ways to distribute code:   as source, as .qlf file  and
in a saved state.   Both QLF files and saved states contain the  code as
_v_i_r_t_u_a_l _m_a_c_h_i_n_e _c_o_d_e.  QLF files capture the  predicates and directives,
while saved state  capture the current state of  the program.  From  the
viewpoint of protecting code there is no significant difference.

There are two aspects to  protection.  One is to make sure  the attacker
has no  access to the  code in any  format and the  other is to  provide
access  to  a non-human-readable  version  of  the  code.    The  second
approach  is known  as code  obfuscation.    Code obfuscation  typically
remove layout and comments  and rename all internal identifiers.   If an
attacker gets access to the SWI-Prolog virtual machine code  this can be
_d_e_c_o_m_p_i_l_e_d.   The decompiled  code does  not include layout  information
variable names and comments.   Other identifiers, notably  predicate and
module names  are maintained.    This provides  some protection  against
understanding  the source  as Prolog  code  without meaningful  variable
names and comments is generally hard to follow.

For further protecting the code, there are several scenarios.

  o If the user has  unrestricted access to the file system on which the
    application  is installed the  user can always  access the state  or
    QLF  file.  This data can  be loaded into a compatible  emulator and
    be _d_e_c_o_m_p_i_l_e_d.

  o If  the  user  can  run  arbitrary Prolog  code  or  shell  commands
    the  state  can  be  protected  by  embedding  it  as  a  string  in
    the   executable  deny  read  access  to  the  executable.      This
    requires   a  small   C  program  that   includes  the  string   and
    uses   PL_set_resource_db_mem() to  register   the  string  as   the
    resource  database.      See  PL_set_resource_db_mem() for  details.
    This  protection  should be  combined  with  the protect_static_code
    described below.

  o Some   extra   protection  can   be   provided  using   the   Prolog
    flag  protect_static_code,  which  disables decompilation  of  _s_t_a_t_i_c
    predicates.      Note   that  most  Prolog  implementations   cannot
    decompile  static  code.      Various  SWI-Prolog  tools  depend  on
    this  ability though.    Examples are list_undefined/0,  autoload/0,
    show_coverage/1, etc.


1133..66..11 OObbffuussccaattiinngg ccooddee iinn ssaavveedd ssttaatteess

If  the option  obfuscate(_t_r_u_e) is  used  with qsave_program/2,  certain
atoms in  the saved state  are renamed.   The  renaming is performed  by
library obfuscate.   The current implementation is rather  conservative,
renaming atoms  that are used  only to define the  functor that names  a
predicate.   This  is a safe  operation, provided  the application  does
not create  new references to renamed  predicates by reading  additional
source  code  or   constructing  the  atom  that  names  the   predicate
dynamically in some  other way such as using atom_concat/3.   Predicates
that are called this way must be declared using public/1.

Note that more aggressive  renaming is possible, but this  requires more
detailed analysis  of the various  roles played by some  atom.   Helpful
and descriptive predicate names  tend to be unique and are  thus subject
to this transformation.   More general names tend to collide  with other
roles of the same atom and thus prevent renaming.


1133..77 FFiinnddiinngg AApppplliiccaattiioonn ffiilleess

If your application  uses files that are  not part of the saved  program
such as database  files, configuration files, etc., the  runtime version
has to be able to  locate these files.  The file_search_path/2 mechanism
in  combination with  the  -p _a_l_i_a_s  command  line argument  provides  a
flexible mechanism for locating runtime files.


CChhaapptteerr 1144..  TTHHEE SSWWII--PPRROOLLOOGG LLIIBBRRAARRYY

This chapter documents  the SWI-Prolog library.  As  SWI-Prolog provides
auto-loading,  there is  little  difference between  library  predicates
and built-in predicates.   Part of  the library is therefore  documented
in the  rest of  the manual.   Library  predicates differ from  built-in
predicates in the following ways:

  o User  definition of a  built-in leads to  a permission error,  while
    using the name of a library predicate is allowed.

  o If  autoloading is disabled  explicitly or because trapping  unknown
    predicates  is disabled  (see unknown/2  and current_prolog_flag/2),
    library predicates must be loaded explicitly.

  o Using  libraries reduces  the footprint of  applications that  don't
    need them.

    _T_h_e  _d_o_c_u_m_e_n_t_a_t_i_o_n _o_f _t_h_e  _l_i_b_r_a_r_y _h_a_s _j_u_s_t _s_t_a_r_t_e_d_.   _M_a_t_e_r_i_a_l
    _f_r_o_m  _t_h_e _s_t_a_n_d_a_r_d _p_a_c_k_a_g_e_s _s_h_o_u_l_d _b_e _m_o_v_e_d _h_e_r_e_, _s_o_m_e _m_a_t_e_r_i_a_l
    _f_r_o_m  _o_t_h_e_r _p_a_r_t_s _o_f _t_h_e _m_a_n_u_a_l _s_h_o_u_l_d _b_e _m_o_v_e_d _t_o_o _a_n_d _v_a_r_i_o_u_s
    _l_i_b_r_a_r_i_e_s _a_r_e _n_o_t _d_o_c_u_m_e_n_t_e_d _a_t _a_l_l_.


1144..11 lliibbrraarryy((aaggggrreeggaattee))::     AAggggrreeggaattiioonn   ooppeerraattoorrss  oonn   bbaacckkttrraacckkaabbllee
     pprreeddiiccaatteess

    CCoommppaattiibbiilliittyy  Quintus,   SICStus  4.      The  forall/2  is  a
         SWI-Prolog built-in  and term_variables/3 is  a SWI-Prolog
         built-in with ddiiffffeerreenntt sseemmaannttiiccss.

    TToo bbee ddoonnee
         -  Analysing  the  aggregation  template and  compiling  a
         predicate for the list aggregation  can be done at compile
         time.
         -  aggregate_all/3 can  be rewritten  to  run  in constant
         space using non-backtrackable assignment on a term.

This  library provides  aggregating operators  over the  solutions of  a
predicate.  The operations are a generalisation of  the bagof/3, setof/3
and findall/3 built-in  predicates.  The defined aggregation  operations
are counting,  computing the sum, minimum,  maximum, a bag of  solutions
and a set of solutions.   We first give a simple example,  computing the
country with the smallest area:

________________________________________________________________________|                                                                        |

|smallest_country(Name, Area) :-                                         |
||_______aggregate(min(A,_N),_country(N,_A),_min(Area,_Name)).__________ ||

There  are  four   aggregation  predicates  (aggregate/3,   aggregate/4,
aggregate_all/3 and aggregate/4), distinguished on two properties.

aaggggrreeggaattee vvss..  aaggggrreeggaattee__aallll The   aggregate  predicates   use   setof/3
    (aggregate/4)  or bagof/3  (aggregate/3),  dealing with  existential
    qualified  variables  (Var^Goal)  and providing  multiple  solutions
    for  the  remaining free  variables in  Goal.   The  aggregate_all/3
    predicate  uses findall/3, implicitly qualifying all  free variables
    and  providing  exactly  one solution,  while  aggregate_all/4  uses
    sort/2  over  solutions  that Discriminator  (see  below)  generated
    using findall/3.

TThhee DDiissccrriimmiinnaattoorr aarrgguummeenntt  The versions  with 4  arguments  deduplicate
    redundant solutions of  Goal.  Solutions for which both the template
    variables  and Discriminator  are identical will  be treated as  one
    solution.   For example, if we wish to compute the  total population
    of  all countries,  and for  some reason  country(belgium, 11000000)
    may  succeed twice, we can use  the following to avoid counting  the
    population of Belgium twice:

    ____________________________________________________________________|                                                                    |
    ||____aggregate(sum(P),_Name,_country(Name,_P),_Total)______________ ||

All  aggregation predicates  support the  following  operators below  in
Template.    In addition,  they allow  for an  arbitrary named  compound
term,  where each  of  the arguments  is  a term  from the  list  below.
For example,  the term r(min(X), max(X))  computes both the minimum  and
maximum binding for X.

ccoouunntt
    Count number of solutions.  Same as sum(1).

ssuumm((_E_x_p_r))
    Sum of _E_x_p_r for all solutions.

mmiinn((_E_x_p_r))
    Minimum of _E_x_p_r for all solutions.

mmiinn((_E_x_p_r_, _W_i_t_n_e_s_s))
    A  term min(Min, Witness), where Min is the minimal version  of _E_x_p_r
    over  all solutions, and  _W_i_t_n_e_s_s is any  other template applied  to
    solutions  that produced  Min.   If multiple  solutions provide  the
    same minimum, _W_i_t_n_e_s_s corresponds to the first solution.

mmaaxx((_E_x_p_r))
    Maximum of _E_x_p_r for all solutions.

mmaaxx((_E_x_p_r_, _W_i_t_n_e_s_s))
    As min(Expr, Witness), but producing the maximum result.

sseett((_X))
    An ordered set with all solutions for _X.

bbaagg((_X))
    A list of all solutions for _X.

AAcckknnoowwlleeddggeemmeennttss

_T_h_e  _d_e_v_e_l_o_p_m_e_n_t   _o_f  _t_h_i_s  _l_i_b_r_a_r_y   _w_a_s  _s_p_o_n_s_o_r_e_d  _b_y   _S_e_c_u_r_i_t_E_a_s_e_,
http://www.securitease.com


aaggggrreeggaattee((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_R_e_s_u_l_t))                           _[_n_o_n_d_e_t_]
    Aggregate  bindings in _G_o_a_l according to _T_e_m_p_l_a_t_e.   The aggregate/3
    version performs bagof/3 on _G_o_a_l.


aaggggrreeggaattee((_+_T_e_m_p_l_a_t_e_, _+_D_i_s_c_r_i_m_i_n_a_t_o_r_, _:_G_o_a_l_, _-_R_e_s_u_l_t))           _[_n_o_n_d_e_t_]
    Aggregate  bindings in _G_o_a_l according to _T_e_m_p_l_a_t_e.   The aggregate/4
    version performs setof/3 on _G_o_a_l.


aaggggrreeggaattee__aallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_R_e_s_u_l_t))                       _[_s_e_m_i_d_e_t_]
    Aggregate   bindings  in   _G_o_a_l  according   to  _T_e_m_p_l_a_t_e.       The
    aggregate_all/3 version performs findall/3 on _G_o_a_l.   Note that this
    predicate fails if  _T_e_m_p_l_a_t_e contains one or more of min(X), max(X),
    min(X,Witness)  or max(X,Witness) and  _G_o_a_l has no solutions,  i.e.,
    the minumum and maximum of an empty set is undefined.


aaggggrreeggaattee__aallll((_+_T_e_m_p_l_a_t_e_, _+_D_i_s_c_r_i_m_i_n_a_t_o_r_, _:_G_o_a_l_, _-_R_e_s_u_l_t))       _[_s_e_m_i_d_e_t_]
    Aggregate   bindings  in   _G_o_a_l  according   to  _T_e_m_p_l_a_t_e.       The
    aggregate_all/4  version performs  findall/3 followed  by sort/2  on
    _G_o_a_l.    See aggregate_all/3 to  understand why  this predicate  can
    fail.


ffoorreeaacchh((_:_G_e_n_e_r_a_t_o_r_, _:_G_o_a_l))
    True  if conjunction  of results is  true.   Unlike forall/2,  which
    runs  a failure-driven loop  that proves _G_o_a_l  for each solution  of
    _G_e_n_e_r_a_t_o_r,  foreach/2 creates  a conjunction.   Each  member of  the
    conjunction  is  a  copy of  _G_o_a_l,  where  the variables  it  shares
    with  _G_e_n_e_r_a_t_o_r are  filled with the  values from the  corresponding
    solution.

    The  implementation executes forall/2 if  _G_o_a_l does not contain  any
    variables that are not shared with _G_e_n_e_r_a_t_o_r.

    Here is an example:

    ____________________________________________________________________|                                                                    |
    | ?- foreach(between(1,4,X), dif(X,Y)), Y = 5.                       |

    | Y = 5.                                                             |
    | ?- foreach(between(1,4,X), dif(X,Y)), Y = 3.                       |
    ||false.____________________________________________________________ ||

         bbuugg _G_o_a_l  is copied  repeatedly, which may  cause problems
             if attributed variables are involved.


ffrreeee__vvaarriiaabblleess((_:_G_e_n_e_r_a_t_o_r_, _+_T_e_m_p_l_a_t_e_, _+_V_a_r_L_i_s_t_0_, _-_V_a_r_L_i_s_t))         _[_d_e_t_]
    Find  free variables in  bagof/setof template.   In order to  handle
    variables  properly, we have to find all the  universally quantified
    variables  in  the _G_e_n_e_r_a_t_o_r.    All variables  as  yet unbound  are
    universally quantified, unless

     1.  they occur in the template

     2.  they are bound by X^P, setof/3, or bagof/3

    free_variables(Generator, Template, OldList, NewList)   finds   this
    set using OldList as an accumulator.

         aauutthhoorr
             - Richard O'Keefe
             - Jan Wielemaker (made some SWI-Prolog enhancements)

         lliicceennssee Public domain (from DEC10 library).

         TToo bbee ddoonnee
             -  Distinguish  between  control-structures  and  data
             terms.
             -   Exploit  our  built-in  term_variables/2  at  some
             places?


ssaannddbbooxx::ssaaffee__mmeettaa((_+_G_o_a_l_, _-_C_a_l_l_e_d))                    _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Declare  the aggregate meta-calls safe.   This cannot be proven  due
    to the manipulations of the argument _G_o_a_l.


1144..22 lliibbrraarryy((aappppllyy))::  AAppppllyy pprreeddiiccaatteess oonn aa lliisstt

    SSeeee aallssoo
         - apply_macros.pl provides compile-time expansion for part
         of this library.
         - http://www.cs.otago.ac.nz/staffpriv/ok/pllib.htm

    TToo bbee ddoonnee  Add include/4, include/5, exclude/4, exclude/5

This  module defines  meta-predicates  that  apply a  predicate  on  all
members of a list.


iinncclluuddee((_:_G_o_a_l_, _+_L_i_s_t_1_, _?_L_i_s_t_2))                                    _[_d_e_t_]
    Filter  elements for which  _G_o_a_l succeeds.   True if _L_i_s_t_2  contains
    those elements Xi of _L_i_s_t_1 for which call(Goal, Xi) succeeds.

         SSeeee aallssoo Older  versions of SWI-Prolog  had sublist/3 with
             the same arguments and semantics.


eexxcclluuddee((_:_G_o_a_l_, _+_L_i_s_t_1_, _?_L_i_s_t_2))                                    _[_d_e_t_]
    Filter elements for which  _G_o_a_l fails.  True if _L_i_s_t_2 contains those
    elements Xi of _L_i_s_t_1 for which call(Goal, Xi) fails.


ppaarrttiittiioonn((_:_P_r_e_d_, _+_L_i_s_t_, _?_I_n_c_l_u_d_e_d_, _?_E_x_c_l_u_d_e_d))                     _[_d_e_t_]
    Filter  elements  of _L_i_s_t  according  to _P_r_e_d.    True  if  _I_n_c_l_u_d_e_d
    contains all elements  for which call(Pred, X) succeeds and _E_x_c_l_u_d_e_d
    contains the remaining elements.


ppaarrttiittiioonn((_:_P_r_e_d_, _+_L_i_s_t_, _?_L_e_s_s_, _?_E_q_u_a_l_, _?_G_r_e_a_t_e_r))              _[_s_e_m_i_d_e_t_]
    Filter  _L_i_s_t according to _P_r_e_d in three  sets.  For each  element Xi
    of  _L_i_s_t, its  destination is  determined by  call(Pred, Xi, Place),
    where  Place must be  unified to one  of <, =  or >.   _P_r_e_d must  be
    deterministic.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t))
    True  if _G_o_a_l can successfully be  applied on all elements of  _L_i_s_t.
    Arguments  are reordered to gain performance as well as to  make the
    predicate deterministic under normal circumstances.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t_1_, _?_L_i_s_t_2))
    As maplist/2, operating on pairs of elements from two lists.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_3))
    As maplist/2, operating on triples of elements from three lists.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_3_, _?_L_i_s_t_4))
    As maplist/2, operating on quadruples of elements from four lists.


ccoonnvvlliisstt((_:_G_o_a_l_, _+_L_i_s_t_I_n_, _-_L_i_s_t_O_u_t))                                _[_d_e_t_]
    Similar  to maplist/3, but elements for  which call(Goal, ElemIn, _)
    fails are omitted from _L_i_s_t_O_u_t.  For example (using library(yall)):

    ____________________________________________________________________|                                                                    |
    | ?- convlist([X,Y]>>(integer(X), Y is X^2),                         |

    |             [3, 5, 4.4, 2], L).                                    |
    ||L_=_[9,_25,_4].___________________________________________________ ||

         CCoommppaattiibbiilliittyy Also  appears  in  YAP library(maplist)  and
             SICStus library(lists).


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_, _+_V_0_, _-_V))


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_V_0_, _-_V))


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_V_0_, _-_V))


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_L_i_s_t_4_, _+_V_0_, _-_V))
    Fold  a list, using  arguments of the  list as left  argument.   The
    foldl family of predicates is defined by:

    ____________________________________________________________________|                                                                    |
    | foldl(P, [X11,...,X1n], ..., [Xm1,...,Xmn], V0, Vn) :-             |

    |       P(X11, ..., Xm1, V0, V1),                                    |
    |       ...                                                          |
    ||______P(X1n,_...,_Xmn,_V',_Vn).___________________________________ ||


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_, _+_V_0_, _-_V_a_l_u_e_s))


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_V_0_, _-_V_a_l_u_e_s))


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_V_0_, _-_V_a_l_u_e_s))


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_L_i_s_t_4_, _+_V_0_, _-_V_a_l_u_e_s))
    Left  scan  of  list.     The scanl  family  of  higher  order  list
    operations is defined by:

    ____________________________________________________________________|                                                                    |
    | scanl(P, [X11,...,X1n], ..., [Xm1,...,Xmn], V0,                    |

    |       [V0,V1,...,Vn]) :-                                           |
    |       P(X11, ..., Xm1, V0, V1),                                    |
    |       ...                                                          |
    ||______P(X1n,_...,_Xmn,_V',_Vn).___________________________________ ||


        1144..33 lliibbrraarryy((aassssoocc))::  AAssssoocciiaattiioonn lliissttss

Authors: _R_i_c_h_a_r_d _A_. _O_'_K_e_e_f_e_, _L_._D_a_m_a_s_, _V_._S_._C_o_s_t_a _a_n_d _h_t_t_p_s_:_/_/_w_w_w_._m_e_t_a_l_e_v_e_l_._a_t_M_a_r_k_u_s _T_r_i_s_k_a


1144..33..11 IInnttrroodduuccttiioonn

An _a_s_s_o_c_i_a_t_i_o_n _l_i_s_t  as implemented by this  library is a collection  of
unique _k_e_y_s that are associated to _v_a_l_u_e_s.  Keys  must be ground, values
need not be.

An association list can be used to _f_e_t_c_h elements via  their keys and to
_e_n_u_m_e_r_a_t_e its elements in ascending order of their keys.

This library uses AAVVLL ttrreeeess to implement association lists.   This means
that

  o inserting a key

  o changing an association

  o fetching a single element

are all  _O_(log(N)_) _w_o_r_s_t_-_c_a_s_e  (and expected) time  operations, where  _N
denotes the number of elements in the association list.

The  logarithmic overhead  is often  acceptable in  practice.    Notable
advantages of association lists over several other methods are:

  o library(assoc) is written  entirely in Prolog, making it portable to
    other systems

  o the  interface  predicates fit  the  declarative nature  of  Prolog,
    avoiding destructive updates to terms

  o AVL  trees  scale very  predictably  and can  be used  to  represent
    sparse arrays efficiently.


1144..33..22 CCrreeaattiinngg aassssoocciiaattiioonn lliissttss

An assocation list is _c_r_e_a_t_e_d with one of the following predicates:


eemmppttyy__aassssoocc((_?_A_s_s_o_c))                                            _[_s_e_m_i_d_e_t_]
    Is true if _A_s_s_o_c is the empty association list.


lliisstt__ttoo__aassssoocc((_+_P_a_i_r_s_, _-_A_s_s_o_c))                                      _[_d_e_t_]
    Create  an association from a list  _P_a_i_r_s of Key-Value pairs.   List
    must not contain duplicate keys.

         EErrrroorrss domain_error(unique_key_pairs, List)  if  List con-
             tains duplicate keys


oorrdd__lliisstt__ttoo__aassssoocc((_+_P_a_i_r_s_, _-_A_s_s_o_c))                                   _[_d_e_t_]
    _A_s_s_o_c  is created  from an  ordered list _P_a_i_r_s  of Key-Value  pairs.
    The pairs must occur in strictly ascending order of their keys.

         EErrrroorrss domain_error(key_ordered_pairs, List)  if pairs are
             not ordered.


1144..33..33 QQuueerryyiinngg aassssoocciiaattiioonn lliissttss

An association list can be _q_u_e_r_i_e_d with:


ggeett__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_, _-_V_a_l_u_e))                                _[_s_e_m_i_d_e_t_]
    True if _K_e_y-_V_a_l_u_e is an association in _A_s_s_o_c.

         EErrrroorrss type_error(assoc, Assoc)   if   _A_s_s_o_c  is   not  an
             association list.


ggeett__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_0_, _?_V_a_l_0_, _?_A_s_s_o_c_, _?_V_a_l))                  _[_s_e_m_i_d_e_t_]
    True if _K_e_y-_V_a_l_0 is in _A_s_s_o_c_0 and _K_e_y-_V_a_l is in _A_s_s_o_c.


mmaaxx__aassssoocc((_+_A_s_s_o_c_, _-_K_e_y_, _-_V_a_l_u_e))                                _[_s_e_m_i_d_e_t_]
    True if _K_e_y-_V_a_l_u_e is in _A_s_s_o_c and _K_e_y is the largest key.


mmiinn__aassssoocc((_+_A_s_s_o_c_, _-_K_e_y_, _-_V_a_l_u_e))                                _[_s_e_m_i_d_e_t_]
    True if _K_e_y-_V_a_l_u_e is in assoc and _K_e_y is the smallest key.


ggeenn__aassssoocc((_?_K_e_y_, _+_A_s_s_o_c_, _?_V_a_l_u_e))                                 _[_n_o_n_d_e_t_]
    True  if _K_e_y-_V_a_l_u_e is an association  in _A_s_s_o_c.  Enumerates keys  in
    ascending order on backtracking.

         SSeeee aallssoo get_assoc/3.


1144..33..44 MMooddiiffyyiinngg aassssoocciiaattiioonn lliissttss

Elements of an association list can be changed and inserted with:


ppuutt__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_0_, _+_V_a_l_u_e_, _-_A_s_s_o_c))                           _[_d_e_t_]
    _A_s_s_o_c  is _A_s_s_o_c_0, except  that _K_e_y is associated  with _V_a_l_u_e.   This
    can be used to insert and change associations.


ddeell__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_0_, _?_V_a_l_u_e_, _-_A_s_s_o_c))                       _[_s_e_m_i_d_e_t_]
    True  if _K_e_y-_V_a_l_u_e is  in _A_s_s_o_c_0.   _A_s_s_o_c  is _A_s_s_o_c_0 with  _K_e_y-_V_a_l_u_e
    removed.


ddeell__mmiinn__aassssoocc((_+_A_s_s_o_c_0_, _?_K_e_y_, _?_V_a_l_, _-_A_s_s_o_c))                     _[_s_e_m_i_d_e_t_]
    True  if _K_e_y-Value is in _A_s_s_o_c_0 and _K_e_y is the smallest key.   _A_s_s_o_c
    is _A_s_s_o_c_0 with _K_e_y-Value  removed.  Warning:  This will succeed with
    _n_o bindings for _K_e_y or _V_a_l if _A_s_s_o_c_0 is empty.


ddeell__mmaaxx__aassssoocc((_+_A_s_s_o_c_0_, _?_K_e_y_, _?_V_a_l_, _-_A_s_s_o_c))                     _[_s_e_m_i_d_e_t_]
    True  if _K_e_y-Value is in _A_s_s_o_c_0 and _K_e_y is the greatest key.   _A_s_s_o_c
    is _A_s_s_o_c_0 with _K_e_y-Value  removed.  Warning:  This will succeed with
    _n_o bindings for _K_e_y or _V_a_l if _A_s_s_o_c_0 is empty.


1144..33..55 CCoonnvveerrssiioonn pprreeddiiccaatteess

Conversion of (parts of) an association list to _l_i_s_t_s is possible with:


aassssoocc__ttoo__lliisstt((_+_A_s_s_o_c_, _-_P_a_i_r_s))                                      _[_d_e_t_]
    Translate  _A_s_s_o_c to a list  _P_a_i_r_s of Key-Value pairs.   The keys  in
    _P_a_i_r_s are sorted in ascending order.


aassssoocc__ttoo__kkeeyyss((_+_A_s_s_o_c_, _-_K_e_y_s))                                       _[_d_e_t_]
    True  if _K_e_y_s is the list of keys in _A_s_s_o_c.  The keys  are sorted in
    ascending order.


aassssoocc__ttoo__vvaalluueess((_+_A_s_s_o_c_, _-_V_a_l_u_e_s))                                   _[_d_e_t_]
    True  if _V_a_l_u_e_s is the list of values in _A_s_s_o_c.   _V_a_l_u_e_s are ordered
    in  ascending  order  of the  key  to  which they  were  associated.
    _V_a_l_u_e_s may contain duplicates.


1144..33..66 RReeaassoonniinngg aabboouutt aassssoocciiaattiioonn lliissttss aanndd tthheeiirr eelleemmeennttss

Further inspection  predicates of an association  list and its  elements
are:


iiss__aassssoocc((_+_A_s_s_o_c))                                               _[_s_e_m_i_d_e_t_]
    True  if _A_s_s_o_c is an association  list.  This predicate checks  that
    the structure is valid,  elements are in order, and tree is balanced
    to  the extent  guaranteed by  AVL trees.   I.e.,  branches of  each
    subtree differ in depth by at most 1.


mmaapp__aassssoocc((_:_P_r_e_d_, _+_A_s_s_o_c))                                       _[_s_e_m_i_d_e_t_]
    True if _P_r_e_d(Value) is true for all values in _A_s_s_o_c.


mmaapp__aassssoocc((_:_P_r_e_d_, _+_A_s_s_o_c_0_, _?_A_s_s_o_c))                              _[_s_e_m_i_d_e_t_]
    Map  corresponding  values.    True if  _A_s_s_o_c  is _A_s_s_o_c_0  with  _P_r_e_d
    applied to all corresponding pairs of of values.


1144..44 lliibbrraarryy((bbrrooaaddccaasstt))::  BBrrooaaddccaasstt aanndd rreecceeiivvee eevveenntt nnoottiiffiiccaattiioonnss

The  broadcast  library   was  invented  to  realise  GUI   applications
consisting of  stand-alone components that use  the Prolog database  for
storing  the application  data.    Figure  ????  illustrates the  flow  of
information using this design

The  broadcasting service  provides two  services.    Using the  `shout'
service, an unknown number of agents may listen to  the message and act.
The broadcaster is not (directly) aware of the implications.   Using the
`request' service, listening  agents are asked for an  answer one-by-one
and the  broadcaster is allowed  to reject  answers using normal  Prolog
failure.

Shouting  is  often used  to  inform  about  changes made  to  a  common
database.  Other messages can be ``save yourself'' or ``show this''.

Requesting  is used  to get  information while  the  broadcaster is  not
aware who might  be able to answer the  question.  For example ``who  is
showing X?''.


bbrrooaaddccaasstt((_+_T_e_r_m))
    Broadcast  _T_e_r_m.   There are  no limitations to  _T_e_r_m, though  being
    a  global service,  it is  good practice  to use  a descriptive  and
    unique  principal  functor.     All  associated  goals  are  started
    and  regardless  of their  success  or failure,  broadcast/1  always
    succeeds.  Exceptions are passed.


bbrrooaaddccaasstt__rreeqquueesstt((_+_T_e_r_m))
    Unlike  broadcast/1,  this  predicate stops  if an  associated  goal
    succeeds.    Backtracking  causes it  to  try other  listeners.    A
    broadcast  request is used to fetch information without  knowing the
    identity  of the agent  providing it.   C.f. ``Is there someone  who
    knows the age of John?''  could be asked using

    ____________________________________________________________________|                                                                    |
    |         ...,                                                       |

    ||________broadcast_request(age_of('John',_Age)),___________________ ||

    If there is  an agent (_l_i_s_t_e_n_e_r) that registered an `age-of' service
    and knows about the age of `John' this question will be answered.


lliisstteenn((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Register  a  _l_i_s_t_e_n channel.    Whenever  a term  unifying  _T_e_m_p_l_a_t_e
    is  broadcasted,  call  _G_o_a_l.    The  following  example  traps  all
    broadcasted  messages as a variable unifies  to any message.  It  is
    commonly used to debug usage of the library.

    ____________________________________________________________________|                                                                    |
    | ?- listen(Term, (writeln(Term),fail)).                             |

    | ?- broadcast(hello(world)).                                        |
    | hello(world)                                                       |
    ||true._____________________________________________________________ ||


lliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Declare  _L_i_s_t_e_n_e_r as the  owner of  the channel.   Unlike a  channel
    opened  using listen/2,  channels that have  an owner can  terminate
    the  channel.  This  is commonly used if  an object is listening  to
    broadcast  messages.  In the  example below we define a  `name-item'
    displaying  the name of an  identifier represented by the  predicate
    name_of/2.

    ____________________________________________________________________|                                                                    |
    | :- pce_begin_class(name_item, text_item).                          |
    |                                                                    |
    | variable(id,    any,    get, "Id visualised").                     |

    |                                                                    |
    | initialise(NI, Id:any) :->                                         |
    |         name_of(Id, Name),                                         |
    |         send_super(NI, initialise, name, Name,                     |
    |                    message(NI, set_name, @arg1)),                  |
    |         send(NI, slot, id, Id),                                    |
    |         listen(NI, name_of(Id, Name),                              |

    |                send(NI, selection, Name)).                         |
    |                                                                    |
    | unlink(NI) :->                                                     |
    |         unlisten(NI),                                              |
    |         send_super(NI, unlink).                                    |
    |                                                                    |
    | set_name(NI, Name:name) :->                                        |
    |         get(NI, id, Id),                                           |

    |         retractall(name_of(Id, _)),                                |
    |         assert(name_of(Id, Name)),                                 |
    |         broadcast(name_of(Id, Name)).                              |
    |                                                                    |
    ||:-_pce_end_class._________________________________________________ ||


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r))
    Deregister all entries created with listen/3 whose _L_i_s_t_e_n_e_r unify.


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e))
    Deregister  all entries  created  with listen/3  whose _L_i_s_t_e_n_e_r  and
    _T_e_m_p_l_a_t_e unify.


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Deregister  all   entries  created  with  listen/3  whose  _L_i_s_t_e_n_e_r,
    _T_e_m_p_l_a_t_e and _G_o_a_l unify.


lliisstteenniinngg((_?_L_i_s_t_e_n_e_r_, _?_T_e_m_p_l_a_t_e_, _?_G_o_a_l))
    Examine  the  current  listeners.    This  predicate is  useful  for
    debugging purposes.


1144..55 lliibbrraarryy((cchhaarrssiioo))::  II//OO oonn LLiissttss ooff CChhaarraacctteerr CCooddeess

    CCoommppaattiibbiilliittyy  The  naming  of  this  library  is not  in  line
         with the  ISO standard.   We  believe that  the SWI-Prolog
         native predicates form a more elegant alternative for this
         library.

This module emulates the Quintus/SICStus library  charsio.pl for reading
and writing from/to lists of character codes.   Most of these predicates
are straight calls  into similar SWI-Prolog primitives.   Some can  even
be replaced by ISO standard predicates.


ffoorrmmaatt__ttoo__cchhaarrss((_+_F_o_r_m_a_t_, _+_A_r_g_s_, _-_C_o_d_e_s))                            _[_d_e_t_]
    Use format/2 to write to a list of character codes.


ffoorrmmaatt__ttoo__cchhaarrss((_+_F_o_r_m_a_t_, _+_A_r_g_s_, _-_C_o_d_e_s_, _?_T_a_i_l))                     _[_d_e_t_]
    Use format/2 to write to a difference list of character codes.


wwrriittee__ttoo__cchhaarrss((_+_T_e_r_m_, _-_C_o_d_e_s))
    Write  a  term to  a  code list.    True  when _C_o_d_e_s  is a  list  of
    character codes written by write/1 on _T_e_r_m.


wwrriittee__ttoo__cchhaarrss((_+_T_e_r_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Write  a term to a  code list.   _C_o_d_e_s\_T_a_i_l is a difference list  of
    character codes produced by write/1 on _T_e_r_m.


aattoomm__ttoo__cchhaarrss((_+_A_t_o_m_, _-_C_o_d_e_s))                                       _[_d_e_t_]
    Convert _A_t_o_m into a list of character codes.

         ddeepprreeccaatteedd Use ISO atom_codes/2.


aattoomm__ttoo__cchhaarrss((_+_A_t_o_m_, _-_C_o_d_e_s_, _?_T_a_i_l))                                _[_d_e_t_]
    Convert _A_t_o_m into a difference list of character codes.


nnuummbbeerr__ttoo__cchhaarrss((_+_N_u_m_b_e_r_, _-_C_o_d_e_s))                                   _[_d_e_t_]
    Convert Atom into a list of character codes.

         ddeepprreeccaatteedd Use ISO number_codes/2.


nnuummbbeerr__ttoo__cchhaarrss((_+_N_u_m_b_e_r_, _-_C_o_d_e_s_, _?_T_a_i_l))                            _[_d_e_t_]
    Convert _N_u_m_b_e_r into a difference list of character codes.


rreeaadd__ffrroomm__cchhaarrss((_+_C_o_d_e_s_, _-_T_e_r_m))                                     _[_d_e_t_]
    Read _C_o_d_e_s into _T_e_r_m.

         CCoommppaattiibbiilliittyy The  SWI-Prolog  version  does  not  require
             _C_o_d_e_s to end in a full-stop.


rreeaadd__tteerrmm__ffrroomm__cchhaarrss((_+_C_o_d_e_s_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))                       _[_d_e_t_]
    Read _C_o_d_e_s into _T_e_r_m.  _O_p_t_i_o_n_s are processed by read_term/3.

         CCoommppaattiibbiilliittyy sicstus


ooppeenn__cchhaarrss__ssttrreeaamm((_+_C_o_d_e_s_, _-_S_t_r_e_a_m))                                 _[_d_e_t_]
    Open _C_o_d_e_s as an input stream.

         SSeeee aallssoo open_string/2.


wwiitthh__oouuttppuutt__ttoo__cchhaarrss((_:_G_o_a_l_, _-_C_o_d_e_s))                                 _[_d_e_t_]
    Run  _G_o_a_l  as with  once/1.   Output  written  to current_output  is
    collected in _C_o_d_e_s.


wwiitthh__oouuttppuutt__ttoo__cchhaarrss((_:_G_o_a_l_, _-_C_o_d_e_s_, _?_T_a_i_l))                          _[_d_e_t_]
    Run  _G_o_a_l  as with  once/1.   Output  written  to current_output  is
    collected in _C_o_d_e_s\_T_a_i_l.


wwiitthh__oouuttppuutt__ttoo__cchhaarrss((_:_G_o_a_l_, _-_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))                 _[_d_e_t_]
    Same  as  with_output_to_chars/3 using  an  explicit stream.     The
    difference  list _C_o_d_e_s\_T_a_i_l contains  the character codes that  _G_o_a_l
    has written to _S_t_r_e_a_m.


1144..66 lliibbrraarryy((cchheecckk))::  CCoonnssiisstteennccyy cchheecckkiinngg

    SSeeee aallssoo
         - gxref/0 provides a graphical cross referencer
         - PceEmacs performs real time consistency checks while you
         edit
         -   library(prolog_xref)   implements   `offline'   cross-
         referencing
         - library(prolog_codewalk) implements `online' analysis

This  library provides  some consistency  checks for  the loaded  Prolog
program.   The predicate make/0 runs list_undefined/0 to find  undefined
predicates in `user' modules.


cchheecckk                                                             _[_d_e_t_]
    Run all consistency  checks defined by checker/2.  Checks enabled by
    default are:

      o  list_undefined/0 reports undefined predicates

      o  list_trivial_fails/0 reports  calls  for   which  there  is  no
         matching clause.

      o  list_redefined/0  reports   predicates   that  have   a   local
         definition and a  global definition.   Note that these are  nnoott
         errors.

      o  list_autoload/0  lists  predicates  that  will  be  defined  at
         runtime using the autoloader.


lliisstt__uunnddeeffiinneedd                                                     _[_d_e_t_]


lliisstt__uunnddeeffiinneedd((_+_O_p_t_i_o_n_s))                                           _[_d_e_t_]
    Report  undefined  predicates.     This  predicate  finds  undefined
    predciates  by decompiling  and analyzing the  body of all  clauses.
    _O_p_t_i_o_n_s:

    mmoodduullee__ccllaassss((_+_C_l_a_s_s_e_s))
         Process modules of the given _C_l_a_s_s_e_s.  The  default for classes
         is [user].    For example,  to include the  libraries into  the
         examination, use [user,library].

         SSeeee aallssoo
             - gxref/0 provides a graphical cross-referencer.
             - make/0 calls list_undefined/0


lliisstt__aauuttoollooaadd                                                      _[_d_e_t_]
    Report  predicates that may  be auto-loaded.   These are  predicates
    that are not defined, but will be loaded on demand if referenced.

         SSeeee aallssoo autoload/0

         TToo bbee ddoonnee This  predicate  uses  an  older mechanism  for
             finding undefined  predicates.  Should be synchronized
             with list undefined.


lliisstt__rreeddeeffiinneedd
    Lists predicates that  are defined in the global module user as well
    as  in a  normal module;  that is,  predicates for  which the  local
    definition overrules the global default definition.


lliisstt__vvooiidd__ddeeccllaarraattiioonnss                                             _[_d_e_t_]
    List predicates that have declared attributes, but no clauses.


lliisstt__ttrriivviiaall__ffaaiillss                                                 _[_d_e_t_]


lliisstt__ttrriivviiaall__ffaaiillss((_+_O_p_t_i_o_n_s))                                       _[_d_e_t_]
    List goals that  trivially fail because there is no matching clause.
    _O_p_t_i_o_n_s:

    mmoodduullee__ccllaassss((_+_C_l_a_s_s_e_s))
         Process modules of the given _C_l_a_s_s_e_s.  The  default for classes
         is [user].    For example,  to include the  libraries into  the
         examination, use [user,library].


ttrriivviiaall__ffaaiill__ggooaall((_:_G_o_a_l))                                     _[_m_u_l_t_i_f_i_l_e_]
    Multifile  hook that  tells list_trivial_fails/0 to  accept _G_o_a_l  as
    valid.


lliisstt__ssttrriinnggss                                                       _[_d_e_t_]


lliisstt__ssttrriinnggss((_+_O_p_t_i_o_n_s))                                             _[_d_e_t_]
    List  strings that appear  in clauses.   This  predicate is used  to
    find  portability issues for changing the Prolog  flag double_quotes
    from codes to  string, creating packed string objects.  Warnings may
    be suppressed using the following multifile hooks:

      o  string_predicate/1 to stop checking certain predicates

      o  valid_string_goal/1to tell the checker that a goal is safe.

         SSeeee aallssoo Prolog flag double_quotes.


ssttrriinngg__pprreeddiiccaattee((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                        _[_m_u_l_t_i_f_i_l_e_]
    Multifile  hook to  disable list_strings/0 on  the given  predicate.
    This is typically used for facts that store strings.


vvaalliidd__ssttrriinngg__ggooaall((_+_G_o_a_l))                             _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Multifile  hook  that qualifies  _G_o_a_l as  valid for  list_strings/0.
    For  example, format("Hello world~n")  is considered  proper use  of
    string constants.


cchheecckkeerr((_:_G_o_a_l_, _+_M_e_s_s_a_g_e_:_t_e_x_t))                               _[_m_u_l_t_i_f_i_l_e_]
    Register  code validation  routines.    Each clause  defines a  _G_o_a_l
    which  performs a consistency  check executed by  check/0.   _M_e_s_s_a_g_e
    is  a short description  of the  check.   For example, assuming  the
    my_checks module defines a predicate list_format_mistakes/0:

    ____________________________________________________________________|                                                                    |
    | :- multifile check:checker/2.                                      |

    | check:checker(my_checks:list_format_mistakes,                      |
    ||______________"errors_with_format/2_arguments").__________________ ||

    The predicate is  dynamic, so you can disable checks with retract/1.
    For example, to stop reporting redefined predicates:

    ____________________________________________________________________|                                                                    |
    ||retract(check:checker(list_redefined,_))._________________________ ||


1144..77 lliibbrraarryy((ccllppbb))::  CCLLPP((BB))::  CCoonnssttrraaiinntt LLooggiicc PPrrooggrraammmmiinngg oovveerr  BBoooolleeaann
     VVaarriiaabblleess

    aauutthhoorr  https://www.metalevel.atMarkus Triska


1144..77..11 IInnttrroodduuccttiioonn

This library provides CLP(B), Constraint Logic  Programming over Boolean
variables.   It can  be used to model  and solve combinatorial  problems
such as verification, allocation and covering tasks.

CLP(B)  is  an instance  of  the  general CLP(_X)  scheme  (section  ????),
extending logic programming with reasoning over specialised domains.

The  implementation is  based  on reduced  and ordered  Binary  Decision
Diagrams (BDDs).

Benchmarks  and usage  examples  of  this library  are  available  from:
https://www.metalevel.at/clpb/hhttttppss:://wwwwww..mmeettaalleevveell..aatt//ccllppbb//

We  recommend  the  following  reference  for  citing  this  library  in
scientific publications:

________________________________________________________________________|                                                                        |
|@inproceedings{Triska2016,                                              |

|  author    = "Markus Triska",                                          |
|  title     = "The {Boolean} Constraint Solver of {SWI-Prolog}:         |
|               System Description",                                     |
|  booktitle = "FLOPS",                                                  |
|  series    = "LNCS",                                                   |
|  volume    = 9613,                                                     |
|  year      = 2016,                                                     |
|  pages     = "45--61"                                                  |

|}|_____________________________________________________________________ | |

The            paper            is             available            from
https://www.metalevel.at/swiclpb.pdfhttps://www.metalevel.at/swiclpb.pdf


1144..77..22 BBoooolleeaann eexxpprreessssiioonnss

A _B_o_o_l_e_a_n _e_x_p_r_e_s_s_i_o_n is one of:

    _____________________________________________________
    | 0              |false                              |
    | 1              |true                               |
    | _v_a_r_i_a_b_l_e       _|unknown truth value                |

    | _a_t_o_m           _|universally quantified variable    |
    | ~ _E_x_p_r         _|logical NOT                        |
    | _E_x_p_r + _E_x_p_r    _|logical OR                         |
    | _E_x_p_r * _E_x_p_r    _|logical AND                        |
    | _E_x_p_r # _E_x_p_r    _|exclusive OR                       |
    | _V_a_r ^ _E_x_p_r     _|existential quantification         |
    | _E_x_p_r =:= _E_x_p_r  _|equality                           |

    | _E_x_p_r =\= _E_x_p_r  _|disequality (same as #)            |
    | _E_x_p_r =<  _E_x_p_r  _|less or equal (implication)        |
    | _E_x_p_r >= _E_x_p_r   _|greater or equal                   |
    | _E_x_p_r < _E_x_p_r    _|less than                          |
    | _E_x_p_r > _E_x_p_r    _|greater than                       |
    | card(Is,Exprs) |cardinality constraint (_s_e_e _b_e_l_o_w) |
    | +(Exprs)       |n-fold disjunction (_s_e_e _b_e_l_o_w)     |
    |_*(Exprs)_______|n-fold_conjunction_(_s_e_e__b_e_l_o_w)_____|

where _E_x_p_r again denotes a Boolean expression.

The Boolean  expression card(Is,Exprs) is  true iff  the number of  true
expressions in  the list _E_x_p_r_s is  a member of  the list _I_s of  integers
and integer  ranges of the  form From-To.   For  example, to state  that
precisely two of  the three variables _X, _Y  and _Z are true, you can  use
sat(card([2],[X,Y,Z])).

+(Exprs)  and  *(Exprs)  denote,   respectively,  the   disjunction  and
conjunction of all elements in the list _E_x_p_r_s of Boolean expressions.

Atoms denote  parametric values that  are universally  quantified.   All
universal  quantifiers  appear   implicitly  in  front  of  the   entire
expression.  In residual goals, universally  quantified variables always
appear on  the right-hand  side of equations.   Therefore,  they can  be
used to express functional dependencies on input variables.


1144..77..33 IInntteerrffaaccee pprreeddiiccaatteess

The most frequently used CLP(B) predicates are:

ssaatt((_+_E_x_p_r))
    True iff the Boolean expression _E_x_p_r is satisfiable.

ttaauutt((_+_E_x_p_r_, _-_T))
    If  _E_x_p_r is  a  tautology with  respect to  the posted  constraints,
    succeeds  with _T == 11.  If _E_x_p_r cannot be satisfied,  succeeds with _T
    == 00.  Otherwise, it fails.

llaabbeelliinngg((_+_V_s))
    Assigns  truth values to the variables _V_s such that  all constraints
    are satisfied.

The unification of  a CLP(B) variable _X with  a term _T is equivalent  to
posting the constraint sat(X=:=T).


1144..77..44 EExxaammpplleess

Here is an example session with a few queries and their answers:

________________________________________________________________________|                                                                        |
|?- use_module(library(clpb)).                                           |

|true.                                                                   |
|                                                                        |
|?- sat(X*Y).                                                            |
|X = Y, Y = 1.                                                           |
|                                                                        |
|?- sat(X * ~X).                                                         |
|false.                                                                  |
|                                                                        |

|?- taut(X * ~X, T).                                                     |
|T = 0,                                                                  |
|sat(X=:=X).                                                             |
|                                                                        |
|?- sat(X^Y^(X+Y)).                                                      |
|sat(X=:=X),                                                             |
|sat(Y=:=Y).                                                             |

|                                                                        |
|?- sat(X*Y + X*Z), labeling([X,Y,Z]).                                   |
|X = Z, Z = 1, Y = 0 ;                                                   |
|X = Y, Y = 1, Z = 0 ;                                                   |
|X = Y, Y = Z, Z = 1.                                                    |
|                                                                        |
|?- sat(X =< Y), sat(Y =< Z), taut(X =< Z, T).                           |
|T = 1,                                                                  |

|sat(X=:=X*Y),                                                           |
|sat(Y=:=Y*Z).                                                           |
|                                                                        |
|?- sat(1#X#a#b).                                                        |
|sat(X=:=a#b).|_________________________________________________________ |             |

The  pending residual  goals constrain  remaining  variables to  Boolean
expressions  and are  declaratively equivalent  to  the original  query.
The last example  illustrates that when applicable, remaining  variables
are expressed as functions of universally quantified variables.


1144..77..55 OObbttaaiinniinngg BBDDDDss

By default,  CLP(B) residual goals  appear in (approximately)  algebraic
normal form (ANF).  This projection is often computationally  expensive.
We  can set  the Prolog  flag clpb_residuals  to the  value  bdd to  see
the  BDD representation  of all  constraints.   This  results in  faster
projection  to residual  goals, and  is also  useful  for learning  more
about BDDs.  For example:

________________________________________________________________________|                                                                        |
|?- set_prolog_flag(clpb_residuals, bdd).                                |

|true.                                                                   |
|                                                                        |
|?- sat(X#Y).                                                            |
|node(3)- (v(X, 0)->node(2);node(1)),                                    |
|node(1)- (v(Y, 1)->true;false),                                         |
|node(2)-|(v(Y,_1)->false;true).________________________________________ |        |

Note that  this representation cannot  be pasted  back on the  toplevel,
and its details are  subject to change.  Use  copy_term/3to  obtain such
answers as Prolog terms.

The variable order  of the BDD is determined  by the order in which  the
variables first appear in  constraints.  To obtain different orders,  we
can for example use:

________________________________________________________________________|                                                                        |

|?- sat(+[1,Y,X]), sat(X#Y).                                             |
|node(3)- (v(Y, 0)->node(2);node(1)),                                    |
|node(1)- (v(X, 1)->true;false),                                         |
|node(2)-|(v(X,_1)->false;true).________________________________________ |        |


1144..77..66 EEnnaabblliinngg mmoonnoottoonniicc CCLLPP((BB))

In the  default execution  mode, CLP(B) constraints  are _n_o_t  monotonic.
This  means that  _a_d_d_i_n_g  constraints can  yield  new  solutions.    For
example:

________________________________________________________________________|                                                                        |
|?-          sat(X=:=1), X = 1+0.                                        |

|false.                                                                  |
|                                                                        |
|?- X = 1+0, sat(X=:=1), X = 1+0.                                        |
|X|=_1+0._______________________________________________________________ | |

This  behaviour is  highly problematic  from a  logical  point of  view,
and it  may render  https://www.metalevel.at/prolog/debuggingddeeccllaarraattiivvee
ddeebbuuggggiinngg techniques inapplicable.

Set the flag clpb_monotonic  to true to make CLP(B) mmoonnoottoonniicc.   If this
mode is enabled,  then you must wrap  CLP(B) variables with the  functor
v/1.  For example:

________________________________________________________________________|                                                                        |
|?- set_prolog_flag(clpb_monotonic, true).                               |
|true.                                                                   |

|                                                                        |
|?- sat(v(X)=:=1#1).                                                     |
|X|=_0._________________________________________________________________ | |


1144..77..77 EExxaammppllee::  PPiiggeeoonnss

In this  example,  we are attempting  to place  _I pigeons  into _J  holes
in  such a  way  that each  hole  contains  at most  one  pigeon.    One
interesting property  of this task  is that it  can be formulated  using
only _c_a_r_d_i_n_a_l_i_t_y  _c_o_n_s_t_r_a_i_n_t_s (card/2).   Another interesting aspect  is
that this task has no short resolution refutations in general.

In the  following, we use https://www.metalevel.at/prolog/dcgPPrroolloogg  DDCCGG
nnoottaattiioonn to describe  a list _C_s of  CLP(B) constraints that must all  be
satisfied.

________________________________________________________________________|                                                                        |
|:- use_module(library(clpb)).                                           |
|:- use_module(library(clpfd)).                                          |
|                                                                        |

|pigeon(I, J, Rows, Cs) :-                                               |
|        length(Rows, I), length(Row, J),                                |
|        maplist(same_length(Row), Rows),                                |
|        transpose(Rows, TRows),                                         |
|        phrase((all_cards(Rows,[1]),all_cards(TRows,[0,1])), Cs).       |
|                                                                        |
|all_cards([], _) --> [].                                                |
|all_cards([Ls|Lss],|Cs)_-->_[card(Cs,Ls)],_all_cards(Lss,_Cs)._________ |                   |

Example queries:

________________________________________________________________________|                                                                        |

|?- pigeon(9, 8, Rows, Cs), sat(*(Cs)).                                  |
|false.                                                                  |
|                                                                        |
|?- pigeon(2, 3, Rows, Cs), sat(*(Cs)),                                  |
|   append(Rows, Vs), labeling(Vs),                                      |

|   maplist(portray_clause, Rows).                                       |
|[0, 0, 1].                                                              |
|[0, 1, 0].                                                              |
|etc.|__________________________________________________________________ |    |


1144..77..88 EExxaammppllee::  BBoooolleeaann cciirrccuuiitt

Consider a  Boolean circuit that express  the Boolean function XOR  with
4 NAND gates.   We can model  such a circuit with CLP(B) constraints  as
follows:

________________________________________________________________________|                                                                        |
|:- use_module(library(clpb)).                                           |
|                                                                        |
|nand_gate(X, Y, Z) :- sat(Z =:= ~(X*Y)).                                |

|                                                                        |
|xor(X, Y, Z) :-                                                         |
|        nand_gate(X, Y, T1),                                            |
|        nand_gate(X, T1, T2),                                           |
|        nand_gate(Y, T1, T3),                                           |
||_______nand_gate(T2,_T3,_Z).__________________________________________ ||

Using universally  quantified variables,  we can show  that the  circuit
does compute XOR as intended:

________________________________________________________________________|                                                                        |

|?- xor(x, y, Z).                                                        |
|sat(Z=:=x#y).|_________________________________________________________ |             |


1144..77..99 AAcckknnoowwlleeddggmmeennttss

The  interface  predicates  of  this  library  follow   the  example  of
https://sicstus.sics.seSSIICCSSttuuss PPrroolloogg.

Use SICStus Prolog for higher performance in many cases.


1144..77..1100 CCLLPP((BB)) pprreeddiiccaattee iinnddeexx

In the following, each CLP(B) predicate is described in more detail.

We recommend the following link to refer to this manual:

http://eu.swi-prolog.org/man/clpb.html


ssaatt((_+_E_x_p_r))                                                    _[_s_e_m_i_d_e_t_]
    True iff _E_x_p_r is a satisfiable Boolean expression.


ttaauutt((_+_E_x_p_r_, _-_T))                                               _[_s_e_m_i_d_e_t_]
    Tautology  check.   Succeeds with  _T = 0  if the Boolean  expression
    _E_x_p_r  cannot be satisfied,  and with _T  = 1 if  _E_x_p_r is always  true
    with respect to the current constraints.  Fails otherwise.


llaabbeelliinngg((_+_V_s))                                                   _[_m_u_l_t_i_]
    Enumerate  concrete solutions.  Assigns truth values to  the Boolean
    variables _V_s such that all stated constraints are satisfied.


ssaatt__ccoouunntt((_+_E_x_p_r_, _-_C_o_u_n_t))                                           _[_d_e_t_]
    _C_o_u_n_t  the number of  admissible assignments.   _C_o_u_n_t is the  number
    of  different assignments of  truth values to  the variables in  the
    Boolean  expression _E_x_p_r,  such  that _E_x_p_r  is true  and all  posted
    constraints are satisfiable.

    A  common form  of  invocation is  sat_count(+[1|Vs], Count):   This
    counts  the number of admissible assignments to _V_s  without imposing
    any further constraints.

    Examples:

    ____________________________________________________________________|                                                                    |
    | ?- sat(A =< B), Vs = [A,B], sat_count(+[1|Vs], Count).             |

    | Vs = [A, B],                                                       |
    | Count = 3,                                                         |
    | sat(A=:=A*B).                                                      |
    |                                                                    |
    | ?- length(Vs, 120),                                                |
    |    sat_count(+Vs, CountOr),                                        |
    |    sat_count(*(Vs), CountAnd).                                     |
    | Vs = [...],                                                        |

    | CountOr = 1329227995784915872903807060280344575,                   |
    ||CountAnd_=_1._____________________________________________________ ||


wweeiigghhtteedd__mmaaxxiimmuumm((_+_W_e_i_g_h_t_s_, _+_V_s_, _-_M_a_x_i_m_u_m))                        _[_m_u_l_t_i_]
    Enumerate  weighted optima over admissible assignments.   Maximize a
    linear  objective function  over Boolean variables  _V_s with  integer
    coefficients  _W_e_i_g_h_t_s.    This  predicate assigns  0  and 1  to  the
    variables in _V_s  such that all stated constraints are satisfied, and
    _M_a_x_i_m_u_m  is the  maximum  of sum(Weight_i*V_i)  over all  admissible
    assignments.    On  backtracking,  all admissible  assignments  that
    attain the optimum are generated.

    This  predicate  can  also be  used  to  _m_i_n_i_m_i_z_e a  linear  Boolean
    program, since negative integers can appear in _W_e_i_g_h_t_s.

    Example:

    ____________________________________________________________________|                                                                    |
    | ?- sat(A#B), weighted_maximum([1,2,1], [A,B,C], Maximum).          |

    ||A_=_0,_B_=_1,_C_=_1,_Maximum_=_3._________________________________ ||


rraannddoomm__llaabbeelliinngg((_+_S_e_e_d_, _+_V_s))                                        _[_d_e_t_]
    Select a single  random solution.  An admissible assignment of truth
    values  to the Boolean variables in _V_s is chosen in such a  way that
    each  admissible assignment is equally likely.  _S_e_e_d is  an integer,
    used as the initial seed for the random number generator.


1144..88 lliibbrraarryy((ccllppffdd))::  CCLLPP((FFDD)):: CCoonnssttrraaiinntt LLooggiicc PPrrooggrraammmmiinngg  oovveerr FFiinniittee
     DDoommaaiinnss

    aauutthhoorr  https://www.metalevel.atMarkus Triska

DDeevveellooppmmeenntt ooff tthhiiss lliibbrraarryy hhaass mmoovveedd ttoo SSIICCSSttuuss PPrroolloogg..
Please see https://github.com/triska/clpzCCLLPP((ZZ)) for more information.


1144..88..11 IInnttrroodduuccttiioonn

This  library  provides  CLP(FD):  Constraint  Logic   Programming  over
Finite  Domains.      This  is  an   instance  of  the  general   CLP(_X)
scheme (section  ????), extending  logic programming  with reasoning  over
specialised domains.   CLP(FD)  lets us reason about  iinntteeggeerrss in a  way
that honors the relational nature of Prolog.

Read https://www.metalevel.at/prologTThhee  PPoowweerr ooff  PPrroolloogg to  understand
how this library is meant to be used in practice.

There are two major use cases of CLP(FD) constraints:

 1. ddeeccllaarraattiivvee iinntteeggeerr aarriitthhmmeettiicc (section ????)

 2. solving  ccoommbbiinnaattoorriiaall  pprroobblleemmss such  as planning,  scheduling  and
    allocation tasks.

The predicates of this library can be classified as:

  o _a_r_i_t_h_m_e_t_i_c constraints like #=/2, #>/2  and #\=/2 (section ????)

  o the _m_e_m_b_e_r_s_h_i_p constraints in/2 and ins/2 (section ????)

  o the  _e_n_u_m_e_r_a_t_i_o_n  predicates  indomain/1,   label/1  and  labeling/2
    (section ????)

  o _c_o_m_b_i_n_a_t_o_r_i_a_l      constraints      like     all_distinct/1      and
    global_cardinality/2 (section ????)

  o _r_e_i_f_i_c_a_t_i_o_n predicates such as #<==>/2  (section ????)

  o _r_e_f_l_e_c_t_i_o_n predicates such as fd_dom/2 (section ????)

In  most  cases,  _a_r_i_t_h_m_e_t_i_c  _c_o_n_s_t_r_a_i_n_t_s  (section  ????)  are  the  only
predicates  you will  ever  need from  this  library.    When  reasoning
over  integers,  simply  replace low-level  arithmetic  predicates  like
(is)/2 and (>)/2 by the corresponding CLP(FD) constraints  like #=/2 and
#>/2  to honor  and preserve  declarative properties  of your  programs.
For  satisfactory performance,  arithmetic  constraints  are  implicitly
rewritten at compilation time so that low-level  fallback predicates are
automatically used whenever possible.

Almost all Prolog  programs also reason about  integers.  Therefore,  it
is highly advisable  that you make CLP(FD) constraints available  in all
your programs.  One way to do this is to  put the following directive in
your ~/.swiplrc initialisation file:

________________________________________________________________________|                                                                        |
|:-|use_module(library(clpfd))._________________________________________ |  |

All example  programs that  appear in the  CLP(FD) documentation  assume
that you have done this.

Important concepts  and principles  of this library  are illustrated  by
means of usage examples  that are available in a public  git repository:
https://github.com/triska/clpfdggiitthhuubb..ccoomm//ttrriisskkaa//ccllppffdd

If  you are  used  to the  complicated operational  considerations  that
low-level  arithmetic primitives  necessitate,  then moving  to  CLP(FD)
constraints may,  due to their power and  convenience, at first feel  to
you excessive  and almost like  cheating.   It _i_s_n_'_t.   Constraints  are
an integral part  of all popular Prolog  systems, and they are  designed
to help you  eliminate and avoid the  use of low-level and less  general
primitives by  providing declarative alternatives that  are meant to  be
used instead.

When  teaching   Prolog,  CLP(FD)   constraints  should  be   introduced
_b_e_f_o_r_e explaining low-level  arithmetic predicates and their  procedural
idiosyncrasies.    This  is because  constraints  are easy  to  explain,
understand and use due to their purely relational nature.   In contrast,
the modedness and directionality of low-level  arithmetic primitives are
impure limitations that are better deferred to more advanced lectures.

We       recommend       the       following       reference       (PDF:
https://www.metalevel.at/swiclpfd.pdfmetalevel.at/swiclpfd.pdf)      for
citing this library in scientific publications:

________________________________________________________________________|                                                                        |

|@inproceedings{Triska12,                                                |
|  author    = {Markus Triska},                                          |
|  title     = {The Finite Domain Constraint Solver of {SWI-Prolog}},    |
|  booktitle = {FLOPS},                                                  |
|  series    = {LNCS},                                                   |
|  volume    = {7294},                                                   |

|  year      = {2012},                                                   |
|  pages     = {307-316}                                                 |
|}|_____________________________________________________________________ | |

More information about  CLP(FD) constraints and their implementation  is
contained in:  https://www.metalevel.at/drt.pdfmmeettaalleevveell..aatt//ddrrtt..ppddff

The   best   way  to   discuss   applying,   improving   and   extending
CLP(FD)   constraints  is   to   use   the  dedicated   clpfd   tag   on
http://stackoverflow.comstackoverflow.com.     Several  of  the  world's
foremost CLP(FD) experts regularly participate in  these discussions and
will help you for free on this platform.


1144..88..22 AArriitthhmmeettiicc ccoonnssttrraaiinnttss

In modern Prolog  systems, aarriitthhmmeettiicc ccoonnssttrraaiinnttss subsume and  supersede
low-level predicates  over integers.   The main advantage of  arithmetic
constraints is  that they  are true  _r_e_l_a_t_i_o_n_s and  can be  used in  all
directions.   For  most programs,  arithmetic constraints  are the  only
predicates you will ever need from this library.

The most  important arithmetic constraint is  #=/2, which subsumes  both
(is)/2 and (=:=)/2 over  integers.  Use #=/2 to make your  programs more
general.  See declarative integer arithmetic (section ????).

In total, the arithmetic constraints are:

    ___________________________________________________________
    | Expr1 #= Expr2  |Expr1 equals Expr2                      |
    | Expr1 #\= Expr2 |Expr1 is not equal to Expr2             |
    | Expr1 #>= Expr2 |Expr1 is greater than or equal to Expr2 |

    | Expr1 #=< Expr2 |Expr1 is less than or equal to Expr2    |
    | Expr1 #> Expr2  |Expr1 is greater than Expr2             |
    |_Expr1_#<_Expr2__|Expr1_is_less_than_Expr2________________|

_E_x_p_r_1 and _E_x_p_r_2 denote aarriitthhmmeettiicc eexxpprreessssiioonnss, which are:

    _______________________________________________________

    | _i_n_t_e_g_e_r        _|Given value                          |
    | _v_a_r_i_a_b_l_e       _|Unknown integer                      |
    | ?(_v_a_r_i_a_b_l_e)    |Unknown integer                      |
    | -Expr          |Unary minus                          |
    | Expr + Expr    |Addition                             |
    | Expr * Expr    |Multiplication                       |
    | Expr - Expr    |Subtraction                          |
    | Expr ^ Expr    |Exponentiation                       |

    | min(Expr,Expr) |Minimum of two expressions           |
    | max(Expr,Expr) |Maximum of two expressions           |
    | Expr mod Expr  |Modulo induced by floored division   |
    | Expr rem Expr  |Modulo induced by truncated division |
    | abs(Expr)      |Absolute value                       |
    | Expr // Expr   |Truncated integer division           |
    |_Expr_div_Expr__|Floored_integer_division_____________|

where _E_x_p_r again denotes an arithmetic expression.

The bitwise  operations (\)/1,  (/\)/2, (\/)/2,  (>>)/2, (<<)/2,  lsb/1,
msb/1, popcount/1 and (xor)/2 are also supported.


1144..88..33 DDeeccllaarraattiivvee iinntteeggeerr aarriitthhmmeettiicc

The _a_r_i_t_h_m_e_t_i_c _c_o_n_s_t_r_a_i_n_t_s  (section ????) #=/2, #>/2  etc.  are meant  to
be used  _i_n_s_t_e_a_d of the  primitives (is)/2,  (=:=)/2, (>)/2  etc.   over
integers.    Almost  all Prolog  programs  also reason  about  integers.
Therefore,  it  is recommended  that  you  put the  following  directive
in  your ~/.swiplrc  initialisation  file  to make  CLP(FD)  constraints
available in all your programs:

________________________________________________________________________|                                                                        |
|:-|use_module(library(clpfd))._________________________________________ |  |

Throughout the following, it is assumed that you have done this.

The most  basic use of CLP(FD)  constraints is _e_v_a_l_u_a_t_i_o_n of  arithmetic
expressions involving integers.  For example:

________________________________________________________________________|                                                                        |

|?- X #= 1+2.                                                            |
|X|=_3._________________________________________________________________ | |

This could in principle also be achieved with  the lower-level predicate
(is)/2.    However,  an important  advantage of  arithmetic  constraints
is  their purely  relational nature:   Constraints  can be  used in  _a_l_l
_d_i_r_e_c_t_i_o_n_s, also  if one or more of  their arguments are only  partially
instantiated.  For example:

________________________________________________________________________|                                                                        |
|?- 3 #= Y+2.                                                            |
|Y|=_1._________________________________________________________________ | |

This relational  nature makes  CLP(FD) constraints easy  to explain  and
use, and  well suited for  beginners and experienced Prolog  programmers
alike.  In contrast, when using low-level integer arithmetic, we get:

________________________________________________________________________|                                                                        |

|?- 3 is Y+2.                                                            |
|ERROR: is/2: Arguments are not sufficiently instantiated                |
|                                                                        |
|?- 3 =:= Y+2.                                                           |
|ERROR:|=:=/2:_Arguments_are_not_sufficiently_instantiated______________ |      |

Due  to the  necessary  operational  considerations,  the use  of  these
low-level  arithmetic predicates  is considerably  harder to  understand
and should therefore be deferred to more advanced lectures.

For supported expressions, CLP(FD) constraints are  drop-in replacements
of these  low-level arithmetic predicates,  often yielding more  general
programs.  See n_factorial/2 (section ????) for an example.

This library uses goal_expansion/2 to automatically  rewrite constraints
at  compilation  time  so  that  low-level   arithmetic  predicates  are
_a_u_t_o_m_a_t_i_c_a_l_l_y used whenever possible.  For example, the predicate:

________________________________________________________________________|                                                                        |

|positive_integer(N)|:-_N_#>=_1.________________________________________ |                   |

is executed as if it were written as:

________________________________________________________________________|                                                                        |
|positive_integer(N) :-                                                  |
|        (   integer(N)                                                  |
|        ->  N >= 1                                                      |
|        ;   N #>= 1                                                     |
||_______)._____________________________________________________________ ||

This illustrates  why the performance of  CLP(FD) constraints is  almost
always completely satisfactory when  they are used in modes that  can be
handled by  low-level arithmetic.   To disable the automatic  rewriting,
set the Prolog flag clpfd_goal_expansion to false.

If  you are  used  to the  complicated operational  considerations  that
low-level  arithmetic primitives  necessitate,  then moving  to  CLP(FD)
constraints may,  due to their power and  convenience, at first feel  to
you excessive  and almost like  cheating.   It _i_s_n_'_t.   Constraints  are
an integral part  of all popular Prolog  systems, and they are  designed
to help you  eliminate and avoid the  use of low-level and less  general
primitives by  providing declarative alternatives that  are meant to  be
used instead.


1144..88..44 EExxaammppllee::  FFaaccttoorriiaall rreellaattiioonn

We  illustrate the  benefit of  using #=/2  for more  generality with  a
simple example.

Consider  first  a  rather  conventional  definition  of  n_factorial/2,
relating each natural number _N to its factorial _F:

________________________________________________________________________|                                                                        |
|n_factorial(0, 1).                                                      |

|n_factorial(N, F) :-                                                    |
|        N #> 0,                                                         |
|        N1 #= N - 1,                                                    |
|        n_factorial(N1, F1),                                            |
||_______F_#=_N_*_F1.___________________________________________________ ||

This program  uses CLP(FD) constraints  _i_n_s_t_e_a_d of low-level  arithmetic
throughout,  and  everything  that  _w_o_u_l_d  _h_a_v_e  _w_o_r_k_e_d  with  low-level
arithmetic _a_l_s_o  works with CLP(FD)  constraints, retaining roughly  the
same performance.  For example:

________________________________________________________________________|                                                                        |
|?- n_factorial(47, F).                                                  |

|F = 258623241511168180642964355153611979969197632389120000000000 ;      |
|false.|________________________________________________________________ |      |

Now  the point:   Due  to the  increased flexibility  and generality  of
CLP(FD) constraints, we are free to _r_e_o_r_d_e_r the goals as follows:

________________________________________________________________________|                                                                        |
|n_factorial(0, 1).                                                      |
|n_factorial(N, F) :-                                                    |
|        N #> 0,                                                         |
|        N1 #= N - 1,                                                    |

|        F #= N * F1,                                                    |
||_______n_factorial(N1,_F1).___________________________________________ ||

In  this concrete  case,  _t_e_r_m_i_n_a_t_i_o_n properties  of the  predicate  are
improved.  For example, the following queries now both terminate:

________________________________________________________________________|                                                                        |
|?- n_factorial(N, 1).                                                   |
|N = 0 ;                                                                 |
|N = 1 ;                                                                 |

|false.                                                                  |
|                                                                        |
|?- n_factorial(N, 3).                                                   |
|false.|________________________________________________________________ |      |

To make  the predicate terminate  if _a_n_y  argument is instantiated,  add
the (implied) constraint F #\= 0 before the recursive call.   Otherwise,
the query  n_factorial(N, 0) is  the only non-terminating  case of  this
kind.

The  value   of  CLP(FD)   constraints  does  _n_o_t   lie  in   completely
freeing  us  from   _a_l_l  procedural  phenomena.      For  example,   the
two  programs  do   not  even  have  the  same  _t_e_r_m_i_n_a_t_i_o_n   _p_r_o_p_e_r_t_i_e_s
in   all  cases.        Instead,   the   primary  benefit   of   CLP(FD)
constraints  is  that   they  allow  you  to  try  different   execution
orders  and  apply  https://www.metalevel.at/prolog/debuggingddeeccllaarraattiivvee
ddeebbuuggggiinngg  techniques  _a_t _a_l_l!     Reordering goals  (and  clauses)  can
significantly impact  the performance  of Prolog programs,  and you  are
free  to try  different  variants  if you  use  declarative  approaches.
Moreover, since all  CLP(FD) constraints _a_l_w_a_y_s _t_e_r_m_i_n_a_t_e, placing  them
earlier can  at most _i_m_p_r_o_v_e, never  worsen, the termination  properties
of  your programs.    An additional  benefit of  CLP(FD) constraints  is
that they eliminate the complexity of introducing (is)/2  and (=:=)/2 to
beginners, since  _b_o_t_h predicates  are subsumed by  #=/2 when  reasoning
over integers.

In  the  case  above,   the  clauses  are  mutually  exclusive   _i_f  the
first argument  is sufficiently  instantiated.   To  make the  predicate
deterministic  in such  cases while  retaining its  generality, you  can
use  zcompare/3  to _r_e_i_f_y  a  comparison,  making  the  different  cases
distinguishable by  pattern matching.    For example,  in this  concrete
case and others like  it, you can use zcompare(Comp, 0, N) to  obtain as
_C_o_m_p the symbolic outcome (<, =, >) of 0 compared to N.


1144..88..55 CCoommbbiinnaattoorriiaall ccoonnssttrraaiinnttss

In addition to subsuming and replacing  low-level arithmetic predicates,
CLP(FD)  constraints are  often  used  to solve  combinatorial  problems
such  as  planning,  scheduling  and  allocation   tasks.     Among  the
most  frequently  used  ccoommbbiinnaattoorriiaall  ccoonnssttrraaiinnttss  are  all_distinct/1,
global_cardinality/2 and  cumulative/2.    This  library  also  provides
several other  constraints like disjoint2/1  and automaton/8, which  are
useful in more specialized applications.


1144..88..66 DDoommaaiinnss

Each  CLP(FD) variable  has an  associated set  of admissible  integers,
which we  call the  variable's ddoommaaiinn.   Initially,  the domain of  each
CLP(FD) variable is the  set of _a_l_l integers.  CLP(FD)  constraints like
#=/2, #>/2 and #\=/2  can at most reduce, and never extend,  the domains
of their arguments.   The constraints  in/2 and ins/2 let us  explicitly
state domains  of CLP(FD)  variables.   The process  of determining  and
adjusting domains  of variables  is called  constraint pprrooppaaggaattiioonn,  and
it is  performed automatically by this  library.   When the domain of  a
variable contains only  one element, then the variable  is automatically
unified to that element.

Domains are taken into account when further constraints  are stated, and
by enumeration predicates like labeling/2.


1144..88..77 EExxaammppllee::  SSuuddookkuu

As  another example,  consider  _S_u_d_o_k_u:   It is  a popular  puzzle  over
integers that can be easily solved with CLP(FD) constraints.

________________________________________________________________________|                                                                        |
|sudoku(Rows) :-                                                         |

|        length(Rows, 9), maplist(same_length(Rows), Rows),              |
|        append(Rows, Vs), Vs ins 1..9,                                  |
|        maplist(all_distinct, Rows),                                    |
|        transpose(Rows, Columns),                                       |
|        maplist(all_distinct, Columns),                                 |
|        Rows = [As,Bs,Cs,Ds,Es,Fs,Gs,Hs,Is],                            |
|        blocks(As, Bs, Cs),                                             |
|        blocks(Ds, Es, Fs),                                             |

|        blocks(Gs, Hs, Is).                                             |
|                                                                        |
|blocks([], [], []).                                                     |
|blocks([N1,N2,N3|Ns1], [N4,N5,N6|Ns2], [N7,N8,N9|Ns3]) :-               |
|        all_distinct([N1,N2,N3,N4,N5,N6,N7,N8,N9]),                     |
|        blocks(Ns1, Ns2, Ns3).                                          |
|                                                                        |

|problem(1, [[_,_,_,_,_,_,_,_,_],                                        |
|            [_,_,_,_,_,3,_,8,5],                                        |
|            [_,_,1,_,2,_,_,_,_],                                        |
|            [_,_,_,5,_,7,_,_,_],                                        |
|            [_,_,4,_,_,_,1,_,_],                                        |
|            [_,9,_,_,_,_,_,_,_],                                        |
|            [5,_,_,_,_,_,_,7,3],                                        |
|            [_,_,2,_,1,_,_,_,_],                                        |

||___________[_,_,_,_,4,_,_,_,9]])._____________________________________ ||

Sample query:

________________________________________________________________________|                                                                        |
|?- problem(1, Rows), sudoku(Rows), maplist(portray_clause, Rows).       |
|[9, 8, 7, 6, 5, 4, 3, 2, 1].                                            |
|[2, 4, 6, 1, 7, 3, 9, 8, 5].                                            |
|[3, 5, 1, 9, 2, 8, 7, 4, 6].                                            |
|[1, 2, 8, 5, 3, 7, 6, 9, 4].                                            |

|[6, 3, 4, 8, 9, 2, 1, 5, 7].                                            |
|[7, 9, 5, 4, 6, 1, 8, 3, 2].                                            |
|[5, 1, 9, 2, 8, 6, 4, 7, 3].                                            |
|[4, 7, 2, 3, 1, 9, 5, 6, 8].                                            |
|[8, 6, 3, 7, 4, 5, 2, 1, 9].                                            |
|Rows|=_[[9,_8,_7,_6,_5,_4,_3,_2|...],_..._,_[...|...]].________________ |    |

In this concrete  case, the constraint solver  is strong enough to  find
the unique  solution without  any search.    For the  general case,  see
search (section ????).


1144..88..88 RReessiidduuaall ggooaallss

Here is an example session with a few queries and their answers:

________________________________________________________________________|                                                                        |
|?- X #> 3.                                                              |

|X in 4..sup.                                                            |
|                                                                        |
|?- X #\= 20.                                                            |
|X in inf..19\/21..sup.                                                  |
|                                                                        |
|?- 2*X #= 10.                                                           |
|X = 5.                                                                  |
|                                                                        |

|?- X*X #= 144.                                                          |
|X in -12\/12.                                                           |
|                                                                        |
|?- 4*X + 2*Y #= 24, X + Y #= 9, [X,Y] ins 0..sup.                       |
|X = 3,                                                                  |
|Y = 6.                                                                  |
|                                                                        |

|?- X #= Y #<==> B, X in 0..3, Y in 4..5.                                |
|B = 0,                                                                  |
|X in 0..3,                                                              |
|Y|in_4..5._____________________________________________________________ | |

The answers  emitted by the toplevel  are called _r_e_s_i_d_u_a_l _p_r_o_g_r_a_m_s,  and
the goals  that comprise  each answer  are called  rreessiidduuaall ggooaallss.    In
each case  above, and  as for  all pure programs,  the residual  program
is declaratively equivalent  to the original query.   From the  residual
goals, it  is clear  that the constraint  solver has deduced  additional
domain restrictions in many cases.

To inspect residual goals,  it is best to let the toplevel  display them
for us.   Wrap  the call of  your predicate  into call_residue_vars/2 to
make sure  that all constrained  variables are displayed.   To make  the
constraints a  variable is involved  in available as  a Prolog term  for
further reasoning within your program, use copy_term/3.  For example:

________________________________________________________________________|                                                                        |
|?- X #= Y + Z, X in 0..5, copy_term([X,Y,Z], [X,Y,Z], Gs).              |
|Gs = [clpfd: (X in 0..5), clpfd: (Y+Z#=X)],                             |

|X in 0..5,                                                              |
|Y+Z#=X.|_______________________________________________________________ |       |

This  library  also  provides   _r_e_f_l_e_c_t_i_o_n  predicates  (like  fd_dom/2,
fd_size/2 etc.)  with which we can inspect a  variable's current domain.
These  predicates can  be  useful if  you  want  to implement  your  own
labeling strategies.


1144..88..99 CCoorree rreellaattiioonnss aanndd sseeaarrcchh

Using  CLP(FD)  constraints  to  solve  combinatorial   tasks  typically
consists of two phases:

 1. MMooddeelliinngg.  In this phase, all relevant constraints are stated.

 2. SSeeaarrcchh.   In this phase,  _e_n_u_m_e_r_a_t_i_o_n _p_r_e_d_i_c_a_t_e_s are used to  search
    for concrete solutions.

It  is  good  practice to  keep  the  modeling  part,  via  a  dedicated
predicate called the ccoorree rreellaattiioonn, separate from the  actual search for
solutions.  This lets us observe termination  and determinism properties
of the core relation  in isolation from the search, and more  easily try
different search strategies.

As  an  example of  a  constraint  satisfaction  problem,  consider  the
cryptoarithmetic puzzle  SEND +  MORE = MONEY,  where different  letters
denote distinct integers between 0 and 9.  It can  be modeled in CLP(FD)
as follows:

________________________________________________________________________|                                                                        |

|puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-                          |
|        Vars = [S,E,N,D,M,O,R,Y],                                       |
|        Vars ins 0..9,                                                  |
|        all_different(Vars),                                            |
|                  S*1000 + E*100 + N*10 + D +                           |
|                  M*1000 + O*100 + R*10 + E #=                          |
|        M*10000 + O*1000 + N*100 + E*10 + Y,                            |

||_______M_#\=_0,_S_#\=_0.______________________________________________ ||

Notice that we  are _n_o_t using labeling/2  in this predicate, so that  we
can first execute  and observe the modeling  part in isolation.   Sample
query and its result (actual variables replaced for readability):

________________________________________________________________________|                                                                        |
|?- puzzle(As+Bs=Cs).                                                    |
|As = [9, A2, A3, A4],                                                   |
|Bs = [1, 0, B3, A2],                                                    |
|Cs = [1, 0, A3, A2, C5],                                                |

|A2 in 4..7,                                                             |
|all_different([9, A2, A3, A4, 1, 0, B3, C5]),                           |
|91*A2+A4+10*B3#=90*A3+C5,                                               |
|A3 in 5..8,                                                             |
|A4 in 2..8,                                                             |
|B3 in 2..8,                                                             |
|C5|in_2..8.____________________________________________________________ |  |

From this answer,  we see that this  core relation _t_e_r_m_i_n_a_t_e_s and is  in
fact _d_e_t_e_r_m_i_n_i_s_t_i_c.   Moreover, we see from the residual goals  that the
constraint solver has  deduced more stringent bounds for all  variables.
Such observations  are only possible  if modeling  and search parts  are
cleanly separated.

Labeling  can  then be  used  to  search  for solutions  in  a  separate
predicate or goal:

________________________________________________________________________|                                                                        |

|?- puzzle(As+Bs=Cs), label(As).                                         |
|As = [9, 5, 6, 7],                                                      |
|Bs = [1, 0, 8, 5],                                                      |
|Cs = [1, 0, 6, 5, 2] ;                                                  |
|false.|________________________________________________________________ |      |

In this  case, it suffices to  label a subset  of variables to find  the
puzzle's unique solution,  since the constraint solver is  strong enough
to reduce  the domains  of remaining variables  to singleton  sets.   In
general though, it is necessary to label all  variables to obtain ground
solutions.


1144..88..1100 EExxaammppllee::  EEiigghhtt qquueeeennss ppuuzzzzllee

We illustrate  the concepts of  the preceding sections  by means of  the
so-called _e_i_g_h_t _q_u_e_e_n_s _p_u_z_z_l_e.  The task is to place  8 queens on an 8x8
chessboard such  that none of the  queens is under  attack.  This  means
that no two queens share the same row, column or diagonal.

To  express this  puzzle via  CLP(FD) constraints,  we  must first  pick
a  suitable representation.     Since CLP(FD)  constraints  reason  over
_i_n_t_e_g_e_r_s,  we  must  find a  way  to  map  the positions  of  queens  to
integers.    Several  such  mappings  are conceivable,  and  it  is  not
immediately obvious  which we  should use.   On top  of that,  different
constraints can  be used  to express the  desired relations.   For  such
reasons, _m_o_d_e_l_i_n_g  combinatorial problems via CLP(FD) constraints  often
necessitates some creativity  and has been described  as more of an  art
than a science.

In our concrete  case, we observe that  there must be exactly one  queen
per column.    The following representation  therefore suggests  itself:
We are looking for  8 integers, one for each column, where  each integer
denotes the _r_o_w  of the queen that  is placed in the respective  column,
and which are subject to certain constraints.

In  fact, let  us now  generalize the  task  to the  so-called _N  _q_u_e_e_n_s
_p_u_z_z_l_e,  which is  obtained by  replacing 8  by _N  everywhere it  occurs
in the  above description.    We implement the  above considerations  in
the ccoorree  rreellaattiioonn n_queens/2,  where the first  argument is the  number
of queens  (which is  identical to  the number  of rows  and columns  of
the generalized  chessboard), and  the second  argument is a  list of  _N
integers that represents a solution in the form described above.

________________________________________________________________________|                                                                        |
|n_queens(N, Qs) :-                                                      |

|        length(Qs, N),                                                  |
|        Qs ins 1..N,                                                    |
|        safe_queens(Qs).                                                |
|                                                                        |
|safe_queens([]).                                                        |
|safe_queens([Q|Qs]) :- safe_queens(Qs, Q, 1), safe_queens(Qs).          |
|                                                                        |
|safe_queens([], _, _).                                                  |

|safe_queens([Q|Qs], Q0, D0) :-                                          |
|        Q0 #\= Q,                                                       |
|        abs(Q0 - Q) #\= D0,                                             |
|        D1 #= D0 + 1,                                                   |
||_______safe_queens(Qs,_Q0,_D1)._______________________________________ ||

Note  that all  these predicates  can be  used in  _a_l_l  _d_i_r_e_c_t_i_o_n_s:   We
can use  them to _f_i_n_d solutions,  _t_e_s_t solutions and _c_o_m_p_l_e_t_e  partially
instantiated solutions.

The original task can be readily solved with the following query:

________________________________________________________________________|                                                                        |
|?- n_queens(8, Qs), label(Qs).                                          |

|Qs|=_[1,_5,_8,_6,_3,_7,_2,_4]_.________________________________________ |  |

Using suitable  labeling strategies, we  can easily find solutions  with
80 queens and more:

________________________________________________________________________|                                                                        |
|?- n_queens(80, Qs), labeling([ff], Qs).                                |
|Qs = [1, 3, 5, 44, 42, 4, 50, 7, 68|...] .                              |
|                                                                        |
|?- time((n_queens(90, Qs), labeling([ff], Qs))).                        |

|% 5,904,401 inferences, 0.722 CPU in 0.737 seconds (98% CPU)            |
|Qs|=_[1,_3,_5,_50,_42,_4,_49,_7,_59|...]_._____________________________ |  |

Experimenting with different  search strategies is easy because we  have
separated the core relation from the actual search.


1144..88..1111 OOppttiimmiissaattiioonn

We can  use labeling/2 to  minimize or maximize the  value of a  CLP(FD)
expression,  and generate solutions  in increasing  or decreasing  order
of  the value.    See  the  labeling  options min(Expr)  and  max(Expr),
respectively.

Again,  to easily  try  different labeling  options in  connection  with
optimisation,  we  recommend  to introduce  a  dedicated  predicate  for
posting constraints,  and to use  labeling/2 in a separate  goal.   This
way, we  can observe properties of the  core relation in isolation,  and
try different labeling options without recompiling our code.

If   necessary,   we   can  use   once/1   to   commit  to   the   first
optimal  solution.     However,  it  is   often  very  valuable  to  see
alternative  solutions   that  are  _a_l_s_o   optimal,   so  that  we   can
choose  among  optimal solutions  by  other  criteria.    For  the  sake
of  https://www.metalevel.at/prolog/purityppuurriittyy  and  completeness,  we
recommend to avoid  once/1 and other constructs that lead  to impurities
in CLP(FD) programs.

Related  to optimisation  with  CLP(FD) constraints  are  http://eu.swi-
prolog.org/man/simplex.htmllibrary(simplex)  and  CLP(Q)   which  reason
about _l_i_n_e_a_r constraints over rational numbers.


1144..88..1122 RReeiiffiiccaattiioonn

The constraints in/2, #=/2, #\=/2,  #</2, #>/2, #=</2, and #>=/2  can be
_r_e_i_f_i_e_d, which means  reflecting their truth values into  Boolean values
represented by  the integers  0 and 1.    Let P and  Q denote  reifiable
constraints or Boolean variables, then:

    __________________________________________________
    | #\ Q       |True iff Q is false                  |
    | P #\/ Q    |True iff either P or Q               |
    | P #/\ Q    |True iff both P and Q                |

    | P #\ Q     |True iff either P or Q, but not both |
    | P #<==>  Q |True iff P and Q are equivalent      |
    | P #==>  Q  |True iff P implies Q                 |
    |_P_#<==_Q___|True_iff_Q_implies_P________________ |

The constraints of this table are reifiable as well.

When   reasoning   over   Boolean    variables,   also    consider   us-
ing    CLP(B)     constraints    as    provided    by     http://eu.swi-
prolog.org/man/clpb.htmllibrary(clpb).


1144..88..1133 EEnnaabblliinngg mmoonnoottoonniicc CCLLPP((FFDD))

In the  default execution mode,  CLP(FD) constraints still exhibit  some
non-relational properties.   For example,  _a_d_d_i_n_g constraints can  yield
new solutions:

________________________________________________________________________|                                                                        |
|?-          X #= 2, X = 1+1.                                            |
|false.                                                                  |
|                                                                        |

|?- X = 1+1, X #= 2, X = 1+1.                                            |
|X|=_1+1._______________________________________________________________ | |

This behaviour is highly  problematic from a logical point of view,  and
it may render declarative debugging techniques inapplicable.

Set the Prolog  flag clpfd_monotonic to true to make  CLP(FD) mmoonnoottoonniicc:
This  means that  _a_d_d_i_n_g  new constraints  _c_a_n_n_o_t yield  new  solutions.
When this flag is true, we must wrap variables  that occur in arithmetic
expressions with the functor (?)/1 or (#)/1.  For example:

________________________________________________________________________|                                                                        |
|?- set_prolog_flag(clpfd_monotonic, true).                              |
|true.                                                                   |
|                                                                        |
|?- #(X) #= #(Y) + #(Z).                                                 |

|#(Y)+ #(Z)#= #(X).                                                      |
|                                                                        |
|?-          X #= 2, X = 1+1.                                            |
|ERROR:|Arguments_are_not_sufficiently_instantiated_____________________ |      |

The wrapper  can be omitted for  variables that are already  constrained
to integers.


1144..88..1144 CCuussttoomm ccoonnssttrraaiinnttss

We can  define custom  constraints.   The mechanism  to do  this is  not
yet finalised, and we welcome suggestions and descriptions  of use cases
that are important to you.

As an  example of  how it can  be done  currently, let us  define a  new
custom constraint oneground(X,Y,Z), where  Z shall be 1 if at  least one
of X and Y is instantiated:

________________________________________________________________________|                                                                        |
|:- multifile clpfd:run_propagator/2.                                    |
|                                                                        |
|oneground(X, Y, Z) :-                                                   |

|        clpfd:make_propagator(oneground(X, Y, Z), Prop),                |
|        clpfd:init_propagator(X, Prop),                                 |
|        clpfd:init_propagator(Y, Prop),                                 |
|        clpfd:trigger_once(Prop).                                       |
|                                                                        |
|clpfd:run_propagator(oneground(X, Y, Z), MState) :-                     |
|        (   integer(X) -> clpfd:kill(MState), Z = 1                     |
|        ;   integer(Y) -> clpfd:kill(MState), Z = 1                     |

|        ;   true                                                        |
||_______)._____________________________________________________________ ||

First,  clpfd:make_propagator/2  is used  to  transform  a  user-defined
representation  of  the new  constraint  to  an  internal form.     With
clpfd:init_propagator/2, this internal  form is then  attached to X  and
Y. From now on,  the propagator will be invoked whenever the  domains of
X or  Y are changed.    Then, clpfd:trigger_once/1 is  used to give  the
propagator its first  chance for propagation even though the  variables'
domains  have  not yet  changed.    Finally,  clpfd:run_propagator/2  is
extended to define the actual propagator.  As  explained, this predicate
is automatically called  by the constraint solver.   The first  argument
is  the  user-defined  representation  of  the  constraint  as  used  in
clpfd:make_propagator/2, and  the  second argument  is a  mutable  state
that can be used  to prevent further invocations of the  propagator when
the constraint has become  entailed, by using clpfd:kill/1.   An example
of using the new constraint:

________________________________________________________________________|                                                                        |
|?- oneground(X, Y, Z), Y = 5.                                           |
|Y = 5,                                                                  |
|Z = 1,                                                                  |

|X|in_inf..sup._________________________________________________________ | |


1144..88..1155 AApppplliiccaattiioonnss

CLP(FD)  applications that  we find  particularly  impressive and  worth
studying include:

  o Michael   Hendricks    uses   CLP(FD)   constraints   for   flexible
    reasoning   about   _d_a_t_e_s   and   _t_i_m_e_s   in   the   http://www.swi-
    prolog.org/pack/list?p=julianjulian package.

  o Julien  Cumin uses  CLP(FD)  constraints for  integer arithmetic  in
    https://github.com/JCumin/BrachylogBrachylog.


1144..88..1166 AAcckknnoowwlleeddggmmeennttss

This      library     gives      you     a      glimpse     of      what
https://sicstus.sics.se/SSIICCSSttuuss  PPrroolloogg  can  do.     The   API  is  in-
tentionally mostly compatible with  that of SICStus Prolog, so  that you
can easily switch  to a much more  feature-rich and much faster  CLP(FD)
system  when you  need  it.    I thank  https://www.sics.se/  matsc/Mats
Carlsson,  the   designer  and  main  implementor  of   SICStus  Prolog,
for  his  elegant  example.      I  first  encountered  his   system  as
part of the  excellent http://www.complang.tuwien.ac.at/ulrich/gupu/GGUUPPUU
teaching  environment by  http://www.complang.tuwien.ac.at/ulrich/Ulrich
Neumerkel.    Ulrich  was also  the  first  and most  determined  tester
of  the present  system,  filing hundreds  of comments  and  suggestions
for  improvement.     https://people.cs.kuleuven.be/  tom.schrijvers/Tom
Schrijvers has contributed  several constraint libraries to  SWI-Prolog,
and I learned a  lot from his coding style and  implementation examples.
https://people.cs.kuleuven.be/  bart.demoen/Bart Demoen  was  a  driving
force behind the  implementation of attributed variables in  SWI-Prolog,
and this library could not even have started without  his prior work and
contributions.  Thank you all!


1144..88..1177 CCLLPP((FFDD)) pprreeddiiccaattee iinnddeexx

In the following, each CLP(FD) predicate is described in more detail.

We recommend the following link to refer to this manual:

http://eu.swi-prolog.org/man/clpfd.html


1144..88..1177..11 AArriitthhmmeettiicc ccoonnssttrraaiinnttss

_A_r_i_t_h_m_e_t_i_c constraints  are the most  basic use  of CLP(FD). Every  time
you use  (is)/2 or one of  the low-level arithmetic comparisons  ((<)/2,
(>)/2 etc.)  over integers, consider using  CLP(FD) constraints _i_n_s_t_e_a_d.
This  can at  most  _i_n_c_r_e_a_s_e  the generality  of  your  programs.    See
declarative integer arithmetic (section ????).


_?_X #= _?_Y
    The  arithmetic expression _X  equals _Y. This  is the most  important
    arithmetic  constraint (section  ????), subsuming  and replacing  both
    (is)/2  _a_n_d  (=:=)/2   over  integers.     See  declarative  integer
    arithmetic (section ????).


_?_X #\= _?_Y
    The  arithmetic expressions _X and  _Y evaluate to distinct  integers.
    When  reasoning over integers,  replace (=\=)/2  by #\=/2 to  obtain
    more  general  relations.      See  declarative  integer  arithmetic
    (section ????).


_?_X #>= _?_Y
    Same  as _Y #=<  _X. When reasoning over  integers, replace (>=)/2  by
    #>=/2  to obtain more  general relations.   See declarative  integer
    arithmetic (section ????).


_?_X #=< _?_Y
    The  arithmetic  expression _X  is  less than  or  equal to  _Y.  When
    reasoning   over  integers,  replace  (=<)/2  by  #=</2   to  obtain
    more  general  relations.      See  declarative  integer  arithmetic
    (section ????).


_?_X #> _?_Y
    Same as _Y #<  _X. When reasoning over integers, replace (>)/2 by #>/2
    to obtain more  general relations See declarative integer arithmetic
    (section ????).


_?_X #< _?_Y
    The  arithmetic expression  _X is  less than _Y.  When reasoning  over
    integers,  replace (<)/2 by #</2  to obtain more general  relations.
    See declarative integer arithmetic (section ????).

    In  addition  to its  regular use  in tasks  that require  it,  this
    constraint can also  be useful to eliminate uninteresting symmetries
    from  a problem.   For example,  all possible matches between  pairs
    built from four players in total:

    ____________________________________________________________________|                                                                    |
    | ?- Vs = [A,B,C,D], Vs ins 1..4,                                    |

    |         all_different(Vs),                                         |
    |         A #< B, C #< D, A #< C,                                    |
    |    findall(pair(A,B)-pair(C,D), label(Vs), Ms).                    |
    | Ms = [ pair(1, 2)-pair(3, 4),                                      |
    |        pair(1, 3)-pair(2, 4),                                      |
    ||_______pair(1,_4)-pair(2,_3)].____________________________________ ||


1144..88..1177..22 MMeemmbbeerrsshhiipp ccoonnssttrraaiinnttss

If you are  using CLP(FD) to model  and solve combinatorial tasks,  then
you typically need to specify the admissible domains of  variables.  The
_m_e_m_b_e_r_s_h_i_p _c_o_n_s_t_r_a_i_n_t_s in/2 and ins/2 are useful in such cases.


_?_V_a_r iinn _+_D_o_m_a_i_n
    _V_a_r is an element of _D_o_m_a_i_n.  _D_o_m_a_i_n is one of:

    _I_n_t_e_g_e_r
         Singleton set consisting only of _I_n_t_e_g_e_r.

    _L_o_w_e_r ....  _U_p_p_e_r
         All integers _I such  that _L_o_w_e_r =< _I =<  _U_p_p_e_r.  _L_o_w_e_r must  be
         an integer or  the atom iinnff,  which denotes negative  infinity.
         _U_p_p_e_r  must be  an  integer  or the  atom  ssuupp,  which  denotes
         positive infinity.

    _D_o_m_a_i_n_1 \/ _D_o_m_a_i_n_2
         The union of _D_o_m_a_i_n_1 and _D_o_m_a_i_n_2.


_+_V_a_r_s iinnss _+_D_o_m_a_i_n
    The  variables in the list  _V_a_r_s are elements of  _D_o_m_a_i_n.  See  in/2
    for the syntax of _D_o_m_a_i_n.


1144..88..1177..33 EEnnuummeerraattiioonn pprreeddiiccaatteess

When modeling  combinatorial tasks, the  actual search for solutions  is
typically performed by _e_n_u_m_e_r_a_t_i_o_n _p_r_e_d_i_c_a_t_e_s like labeling/2.   See the
the section about _c_o_r_e _r_e_l_a_t_i_o_n_s and search for more information.


iinnddoommaaiinn((_?_V_a_r))
    Bind _V_a_r to all  feasible values of its domain on backtracking.  The
    domain of _V_a_r must be finite.


llaabbeell((_+_V_a_r_s))
    Equivalent to labeling([], Vars).  See labeling/2.


llaabbeelliinngg((_+_O_p_t_i_o_n_s_, _+_V_a_r_s))
    Assign  a  value   to  each  variable  in  _V_a_r_s.     Labeling  means
    systematically  trying out  values for the  finite domain  variables
    _V_a_r_s  until all of them are ground.  The domain of  each variable in
    _V_a_r_s  must be finite.   _O_p_t_i_o_n_s  is a list of  options that let  you
    exhibit  some control over the  search process.  Several  categories
    of options exist:

    The  variable selection strategy lets you specify which  variable of
    _V_a_r_s is labeled next and is one of:

    lleeffttmmoosstt
         Label the variables in the  order they occur in _V_a_r_s.   This is
         the default.

    ffff
         _F_i_r_s_t _f_a_i_l.   Label the leftmost variable with  smallest domain
         next, in order to detect infeasibility early.  This  is often a
         good strategy.

    ffffcc
         Of  the  variables with  smallest  domains,  the  leftmost  one
         participating in most constraints is labeled next.

    mmiinn
         Label the  leftmost variable  whose lower bound  is the  lowest
         next.

    mmaaxx
         Label the leftmost  variable whose upper  bound is the  highest
         next.

    The value order is one of:

    uupp
         Try the elements of  the chosen variable's domain in  ascending
         order.  This is the default.

    ddoowwnn
         Try the domain elements in descending order.

    The branching strategy is one of:

    sstteepp
         For each variable X, a  choice is made between X = V and  X #\=
         V, where V is determined  by the value ordering options.   This
         is the default.

    eennuumm
         For each variable X, a  choice is made between X = V_1, X = V_2
         etc.,  for all  values V_i  of  the domain  of X.  The order  is
         determined by the value ordering options.

    bbiisseecctt
         For each variable X, a choice is made between X #=< M  and X #>
         M, where M is the midpoint of the domain of X.

    At most one option  of each category can be specified, and an option
    must not occur repeatedly.

    The order of solutions can be influenced with:

      o  min(Expr)

      o  max(Expr)

    This generates  solutions in ascending/descending order with respect
    to the evaluation  of the arithmetic expression Expr.  Labeling _V_a_r_s
    must make Expr ground.   If several such options are specified, they
    are interpreted from left to right, e.g.:

    ____________________________________________________________________|                                                                    |
    ||?-_[X,Y]_ins_10..20,_labeling([max(X),min(Y)],[X,Y])._____________ ||

    This  generates solutions  in descending  order of X,  and for  each
    binding  of X, solutions are generated  in ascending order of Y.  To
    obtain  the incomplete  behaviour  that other  systems exhibit  with
    "maximize(Expr)" and "minimize(Expr)", use once/1, e.g.:

    ____________________________________________________________________|                                                                    |

    ||once(labeling([max(Expr)],_Vars))_________________________________ ||

    Labeling  is  always  complete,  always terminates,  and  yields  no
    redundant  solutions.   See core relations  and search (section  ????)
    for usage advice.


1144..88..1177..44 GGlloobbaall ccoonnssttrraaiinnttss

A _g_l_o_b_a_l  _c_o_n_s_t_r_a_i_n_t expresses a relation  that involves many  variables
at once.   The most frequently  used global constraints of this  library
are the  combinatorial constraints  all_distinct/1,  global_cardinality/2
and cumulative/2.


aallll__ddiissttiinncctt((_+_V_a_r_s))
    True  iff _V_a_r_s are pairwise  distinct.  For  example, all_distinct/1
    can  detect that not all variables can assume distinct  values given
    the following domains:

    ____________________________________________________________________|                                                                    |
    | ?- maplist(in, Vs,                                                 |

    |            [1\/3..4, 1..2\/4, 1..2\/4, 1..3, 1..3, 1..6]),         |
    |    all_distinct(Vs).                                               |
    ||false.____________________________________________________________ ||


aallll__ddiiffffeerreenntt((_+_V_a_r_s))
    Like  all_distinct/1,  but   with  weaker  propagation.     Consider
    using  all_distinct/1  instead,  since all_distinct/1  is  typically
    acceptably efficient and propagates much more strongly.


ssuumm((_+_V_a_r_s_, _+_R_e_l_, _?_E_x_p_r))
    The  sum of elements of  the list _V_a_r_s is  in relation _R_e_l to  _E_x_p_r.
    _R_e_l is one of #=, #\=, #<, #>, #=<  or #>=.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- [A,B,C] ins 0..sup, sum([A,B,C], #=, 100).                      |

    | A in 0..100,                                                       |
    | A+B+C#=100,                                                        |
    | B in 0..100,                                                       |
    ||C_in_0..100.______________________________________________________ ||


ssccaallaarr__pprroodduucctt((_+_C_s_, _+_V_s_, _+_R_e_l_, _?_E_x_p_r))
    True  iff the  scalar product of  _C_s and  _V_s is in  relation _R_e_l  to
    _E_x_p_r.   _C_s  is a list  of integers,  _V_s is a  list of variables  and
    integers.  _R_e_l is #=, #\=, #<, #>, #=<  or #>=.


lleexx__cchhaaiinn((_+_L_i_s_t_s))
    _L_i_s_t_s are lexicographically non-decreasing.


ttuupplleess__iinn((_+_T_u_p_l_e_s_, _+_R_e_l_a_t_i_o_n))
    True  iff all  _T_u_p_l_e_s are  elements of _R_e_l_a_t_i_o_n.    Each element  of
    the  list _T_u_p_l_e_s is a list  of integers or finite domain  variables.
    _R_e_l_a_t_i_o_n  is  a  list  of  lists of  integers.     Arbitrary  finite
    relations,  such as  compatibility tables,  can be  modeled in  this
    way.    For example,  if 1  is compatible  with 2  and 5,  and 4  is
    compatible with 0 and 3:

    ____________________________________________________________________|                                                                    |
    | ?- tuples_in([[X,Y]], [[1,2],[1,5],[4,0],[4,3]]), X = 4.           |

    | X = 4,                                                             |
    ||Y_in_0\/3.________________________________________________________ ||

    As another example,  consider a train schedule represented as a list
    of  quadruples, denoting departure and arrival places and  times for
    each  train.   In the  following program, Ps  is a feasible  journey
    of  length 3  from A  to D  via trains that  are part  of the  given
    schedule.

    ____________________________________________________________________|                                                                    |

    | trains([[1,2,0,1],                                                 |
    |         [2,3,4,5],                                                 |
    |         [2,3,0,1],                                                 |
    |         [3,4,5,6],                                                 |
    |         [3,4,2,3],                                                 |
    |         [3,4,8,9]]).                                               |

    |                                                                    |
    | threepath(A, D, Ps) :-                                             |
    |         Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],              |
    |         T2 #> T1,                                                  |
    |         T4 #> T3,                                                  |
    |         trains(Ts),                                                |
    ||________tuples_in(Ps,_Ts).________________________________________ ||

    In this example, the unique solution is found without labeling:

    ____________________________________________________________________|                                                                    |

    | ?- threepath(1, 4, Ps).                                            |
    ||Ps_=_[[1,_2,_0,_1],_[2,_3,_4,_5],_[3,_4,_8,_9]].__________________ ||


sseerriiaalliizzeedd((_+_S_t_a_r_t_s_, _+_D_u_r_a_t_i_o_n_s))
    Describes  a set of non-overlapping  tasks.  _S_t_a_r_t_s  = [S_1,...,S_n],
    is  a list of variables  or integers, _D_u_r_a_t_i_o_n_s =  [D_1,...,D_n] is  a
    list  of non-negative integers.  Constrains _S_t_a_r_t_s and  _D_u_r_a_t_i_o_n_s to
    denote a  set of non-overlapping tasks, i.e.:  S_i + D_i =< S_j or S_j
    + D_j =< S_i for all 1 =< i < j =< n.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- length(Vs, 3),                                                  |

    |    Vs ins 0..3,                                                    |
    |    serialized(Vs, [1,2,3]),                                        |
    |    label(Vs).                                                      |
    | Vs = [0, 1, 3] ;                                                   |
    | Vs = [2, 0, 3] ;                                                   |
    ||false.____________________________________________________________ ||

         SSeeee aallssoo Dorndorf  et al.   2000,  "Constraint Propagation
             Techniques for the Disjunctive Scheduling Problem"


eelleemmeenntt((_?_N_, _+_V_s_, _?_V))
    The  _N-th element of  the list of finite  domain variables _V_s is  _V.
    Analogous to nth1/3.


gglloobbaall__ccaarrddiinnaalliittyy((_+_V_s_, _+_P_a_i_r_s))
    Global     Cardinality     constraint.             Equivalent     to
    global_cardinality(Vs, Pairs, []).  See global_cardinality/3.

    Example:

    ____________________________________________________________________|                                                                    |
    | ?- Vs = [_,_,_], global_cardinality(Vs, [1-2,3-_]), label(Vs).     |

    | Vs = [1, 1, 3] ;                                                   |
    | Vs = [1, 3, 1] ;                                                   |
    ||Vs_=_[3,_1,_1].___________________________________________________ ||


gglloobbaall__ccaarrddiinnaalliittyy((_+_V_s_, _+_P_a_i_r_s_, _+_O_p_t_i_o_n_s))
    Global  Cardinality  constraint.   _V_s  is a  list  of finite  domain
    variables,  _P_a_i_r_s  is a  list  of Key-Num  pairs,  where Key  is  an
    integer  and Num is a finite domain variable.  The  constraint holds
    iff each V in _V_s  is equal to some key, and for each Key-Num pair in
    _P_a_i_r_s, the number of  occurrences of Key in _V_s is Num.  _O_p_t_i_o_n_s is a
    list of options.  Supported options are:

    ccoonnssiisstteennccyy((_v_a_l_u_e))
         A weaker form of consistency is used.

    ccoosstt((_C_o_s_t_, _M_a_t_r_i_x))
         _M_a_t_r_i_x is a list of  rows, one for each variable, in  the order
         they occur in _V_s.   Each of these  rows is a list of  integers,
         one for  each key,  in  the order  these keys  occur in  _P_a_i_r_s.
         When variable  v_i is  assigned the value  of key  k_j, then  the
         associated cost is _M_a_t_r_i_x__{ij}.  _C_o_s_t is the sum of all costs.


cciirrccuuiitt((_+_V_s))
    True  iff  the   list  _V_s  of  finite  domain  variables  induces  a
    Hamiltonian  circuit.  The k-th element of _V_s denotes  the successor
    of node k.  Node indexing starts with 1.  Examples:

    ____________________________________________________________________|                                                                    |
    | ?- length(Vs, _), circuit(Vs), label(Vs).                          |

    | Vs = [] ;                                                          |
    | Vs = [1] ;                                                         |
    | Vs = [2, 1] ;                                                      |
    | Vs = [2, 3, 1] ;                                                   |
    | Vs = [3, 1, 2] ;                                                   |
    ||Vs_=_[2,_3,_4,_1]_._______________________________________________ ||


ccuummuullaattiivvee((_+_T_a_s_k_s))
    Equivalent to cumulative(Tasks, [limit(1)]).  See cumulative/2.


ccuummuullaattiivvee((_+_T_a_s_k_s_, _+_O_p_t_i_o_n_s))
    Schedule  with  a limited  resource.    _T_a_s_k_s is  a list  of  tasks,
    each  of the  form task(S_i, D_i, E_i, C_i, T_i).   S_i denotes  the
    start  time, D_i the  positive duration,  E_i the  end time,  C_i  the
    non-negative  resource  consumption,  and T_i the  task  identifier.
    Each  of  these arguments  must  be a  finite domain  variable  with
    bounded  domain, or an  integer.  The  constraint holds iff at  each
    time slot during the  start and end of each task, the total resource
    consumption  of all tasks running at  that time does not exceed  the
    global  resource limit.  _O_p_t_i_o_n_s is  a list of options.   Currently,
    the only supported option is:

    lliimmiitt((_L))
         The integer _L is the global resource limit.  Default is 1.

    For example, given  the following predicate that relates three tasks
    of durations 2 and 3 to a list containing their starting times:

    ____________________________________________________________________|                                                                    |

    | tasks_starts(Tasks, [S1,S2,S3]) :-                                 |
    |         Tasks = [task(S1,3,_,1,_),                                 |
    |                  task(S2,2,_,1,_),                                 |
    ||_________________task(S3,2,_,1,_)]._______________________________ ||

    We can use cumulative/2 as follows, and obtain a schedule:

    ____________________________________________________________________|                                                                    |

    | ?- tasks_starts(Tasks, Starts), Starts ins 0..10,                  |
    |    cumulative(Tasks, [limit(2)]), label(Starts).                   |
    | Tasks = [task(0, 3, 3, 1, _G36), task(0, 2, 2, 1, _G45), ...],     |
    ||Starts_=_[0,_0,_2]_.______________________________________________ ||


ddiissjjooiinntt22((_+_R_e_c_t_a_n_g_l_e_s))
    True  iff _R_e_c_t_a_n_g_l_e_s are not overlapping.   _R_e_c_t_a_n_g_l_e_s is a list  of
    terms  of the form F(X_i, W_i, Y_i, H_i), where F is any  functor, and
    the  arguments are finite domain variables or integers  that denote,
    respectively,  the X coordinate, width,  Y coordinate and height  of
    each rectangle.


aauuttoommaattoonn((_+_V_s_, _+_N_o_d_e_s_, _+_A_r_c_s))
    Describes  a list of finite  domain variables with a finite  automa-
    ton.    Equivalent to  automaton(Vs, _, Vs, Nodes, Arcs, [], [], _),
    a  common use  case of  automaton/8.   In the  following example,  a
    list of binary  finite domain variables is constrained to contain at
    least two consecutive ones:

    ____________________________________________________________________|                                                                    |
    | two_consecutive_ones(Vs) :-                                        |
    |         automaton(Vs, [source(a),sink(c)],                         |
    |                   [arc(a,0,a), arc(a,1,b),                         |

    |                    arc(b,0,a), arc(b,1,c),                         |
    ||___________________arc(c,0,c),_arc(c,1,c)]).______________________ ||

    Example query:

    ____________________________________________________________________|                                                                    |
    | ?- length(Vs, 3), two_consecutive_ones(Vs), label(Vs).             |
    | Vs = [0, 1, 1] ;                                                   |
    | Vs = [1, 1, 0] ;                                                   |
    ||Vs_=_[1,_1,_1].___________________________________________________ ||


aauuttoommaattoonn((_+_S_e_q_u_e_n_c_e_, _?_T_e_m_p_l_a_t_e_, _+_S_i_g_n_a_t_u_r_e_, _+_N_o_d_e_s_, _+_A_r_c_s_, _+_C_o_u_n_t_e_r_s_, _+_I_n_i_t_i_a_l_s_, _?_F_i_n_a_l_s))
    Describes   a  list  of  finite  domain  variables  with   a  finite
    automaton.    True iff  the finite  automaton induced  by _N_o_d_e_s  and
    _A_r_c_s  (extended with  _C_o_u_n_t_e_r_s) accepts  _S_i_g_n_a_t_u_r_e.   _S_e_q_u_e_n_c_e is  a
    list  of  terms, all  of the  same shape.    Additional  constraints
    must  link  _S_e_q_u_e_n_c_e  to  _S_i_g_n_a_t_u_r_e,  if  necessary.    _N_o_d_e_s  is  a
    list  of source(Node)  and  sink(Node) terms.    _A_r_c_s is  a list  of
    arc(Node,Integer,Node)  and arc(Node,Integer,Node,Exprs) terms  that
    denote  the automaton's transitions.   Each  node is represented  by
    an  arbitrary term.   Transitions  that are not  mentioned go to  an
    implicit  failure node.  _E_x_p_r_s is a list of  arithmetic expressions,
    of  the same  length as  _C_o_u_n_t_e_r_s.   In  each expression,  variables
    occurring  in   _C_o_u_n_t_e_r_s  symbolically  refer  to  previous  counter
    values,  and variables  occurring in _T_e_m_p_l_a_t_e  refer to the  current
    element  of  _S_e_q_u_e_n_c_e.    When  a transition  containing  arithmetic
    expressions  is  taken, each  counter is  updated  according to  the
    result  of the corresponding expression.  When a  transition without
    arithmetic  expressions  is taken,  all  counters remain  unchanged.
    _C_o_u_n_t_e_r_s  is a  list of variables.    _I_n_i_t_i_a_l_s is a  list of  finite
    domain  variables  or integers  denoting,  in  the same  order,  the
    initial  value of each counter.  These values are related  to _F_i_n_a_l_s
    according to the arithmetic expressions of the taken transitions.

    The  following example is taken from Beldiceanu,  Carlsson, Debruyne
    and   Petit:    "Reformulation   of  Global  Constraints  Based   on
    Constraints  Checkers", Constraints  10(4), pp 339-362  (2005).   It
    relates  a sequence of integers  and finite domain variables to  its
    number of inflexions,  which are switches between strictly ascending
    and strictly descending subsequences:

    ____________________________________________________________________|                                                                    |
    | sequence_inflexions(Vs, N) :-                                      |

    |         variables_signature(Vs, Sigs),                             |
    |         automaton(Sigs, _, Sigs,                                   |
    |                   [source(s),sink(i),sink(j),sink(s)],             |
    |                   [arc(s,0,s), arc(s,1,j), arc(s,2,i),             |
    |                    arc(i,0,i), arc(i,1,j,[C+1]), arc(i,2,i),       |
    |                    arc(j,0,j), arc(j,1,j),                         |
    |                    arc(j,2,i,[C+1])],                              |
    |                   [C], [0], [N]).                                  |

    |                                                                    |
    | variables_signature([], []).                                       |
    | variables_signature([V|Vs], Sigs) :-                               |
    |         variables_signature_(Vs, V, Sigs).                         |
    |                                                                    |
    | variables_signature_([], _, []).                                   |
    | variables_signature_([V|Vs], Prev, [S|Sigs]) :-                    |

    |         V #= Prev #<==> S #= 0,                                    |
    |         Prev #< V #<==> S #= 1,                                    |
    |         Prev #> V #<==> S #= 2,                                    |
    ||________variables_signature_(Vs,_V,_Sigs).________________________ ||

    Example queries:

    ____________________________________________________________________|                                                                    |
    | ?- sequence_inflexions([1,2,3,3,2,1,3,0], N).                      |
    | N = 3.                                                             |

    |                                                                    |
    | ?- length(Ls, 5), Ls ins 0..1,                                     |
    |    sequence_inflexions(Ls, 3), label(Ls).                          |
    | Ls = [0, 1, 0, 1, 0] ;                                             |
    ||Ls_=_[1,_0,_1,_0,_1]._____________________________________________ ||


cchhaaiinn((_+_Z_s_, _+_R_e_l_a_t_i_o_n))
    _Z_s  form a chain with respect to _R_e_l_a_t_i_o_n.   _Z_s is a list  of finite
    domain variables that  are a chain with respect to the partial order
    _R_e_l_a_t_i_o_n,  in the order they appear in  the list.  _R_e_l_a_t_i_o_n  must be
    #=, #=<, #>=, #<  or #>.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- chain([X,Y,Z], #>=).                                            |

    | X#>=Y,                                                             |
    ||Y#>=Z.____________________________________________________________ ||


1144..88..1177..55 RReeiiffiiccaattiioonn pprreeddiiccaatteess

Many  CLP(FD)  constraints can  be  _r_e_i_f_i_e_d.    This  means  that  their
truth  value is  itself  turned into  a  CLP(FD) variable,  so  that  we
can explicitly  reason about  whether a constraint  holds or  not.   See
reification (section ????).


#\ _+_Q
    _Q does _n_o_t hold.  See reification (section ????).

    For example, to obtain the complement of a domain:

    ____________________________________________________________________|                                                                    |
    | ?- #\ X in -3..0\/10..80.                                          |

    ||X_in_inf.._-4\/1..9\/81..sup._____________________________________ ||


_?_P #<==> _?_Q
    _P and _Q are equivalent.  See reification (section ????).

    For example:

    ____________________________________________________________________|                                                                    |
    | ?- X #= 4 #<==> B, X #\= 4.                                        |

    | B = 0,                                                             |
    ||X_in_inf..3\/5..sup.______________________________________________ ||

    The  following example uses reified constraints to relate a  list of
    finite  domain variables  to the  number of occurrences  of a  given
    value:

    ____________________________________________________________________|                                                                    |

    | vs_n_num(Vs, N, Num) :-                                            |
    |         maplist(eq_b(N), Vs, Bs),                                  |
    |         sum(Bs, #=, Num).                                          |
    |                                                                    |
    ||eq_b(X,_Y,_B)_:-_X_#=_Y_#<==>_B.__________________________________ ||

    Sample queries and their results:

    ____________________________________________________________________|                                                                    |

    | ?- Vs = [X,Y,Z], Vs ins 0..1, vs_n_num(Vs, 4, Num).                |
    | Vs = [X, Y, Z],                                                    |
    | Num = 0,                                                           |
    | X in 0..1,                                                         |
    | Y in 0..1,                                                         |
    | Z in 0..1.                                                         |

    |                                                                    |
    | ?- vs_n_num([X,Y,Z], 2, 3).                                        |
    | X = 2,                                                             |
    | Y = 2,                                                             |
    ||Z_=_2.____________________________________________________________ ||


_?_P #==> _?_Q
    _P implies _Q. See reification (section ????).


_?_P #<== _?_Q
    _Q implies _P. See reification (section ????).


_?_P #/\ _?_Q
    _P and _Q hold.  See reification (section ????).


_?_P #\/ _?_Q
    _P or _Q holds.  See reification (section ????).

    For  example,  the  sum  of  natural numbers  below  1000  that  are
    multiples of 3 or 5:

    ____________________________________________________________________|                                                                    |
    | ?- findall(N, (N mod 3 #= 0 #\/ N mod 5 #= 0, N in 0..999,         |

    |                indomain(N)),                                       |
    |            Ns),                                                    |
    |    sum(Ns, #=, Sum).                                               |
    | Ns = [0, 3, 5, 6, 9, 10, 12, 15, 18|...],                          |
    ||Sum_=_233168._____________________________________________________ ||


_?_P #\ _?_Q
    Either  _P  holds  or  _Q  holds,  but not  both.     See  reification
    (section ????).


zzccoommppaarree((_?_O_r_d_e_r_, _?_A_, _?_B))
    Analogous to compare/3, with finite domain variables _A and _B.

    Think  of zcompare/3  as _r_e_i_f_y_i_n_g  an arithmetic  comparison of  two
    integers.    This  means that  we can  explicitly  reason about  the
    different cases _w_i_t_h_i_n our  programs.  As in compare/3, the atoms <,
    >  and = denote the different cases of the trichotomy.   In contrast
    to compare/3 though,  zcompare/3 works correctly for _a_l_l _m_o_d_e_s, also
    if  only a subset  of the  arguments is instantiated.   This  allows
    you  to make  several predicates over  integers deterministic  while
    preserving their generality and completeness.  For example:

    ____________________________________________________________________|                                                                    |
    | n_factorial(N, F) :-                                               |

    |         zcompare(C, N, 0),                                         |
    |         n_factorial_(C, N, F).                                     |
    |                                                                    |
    | n_factorial_(=, _, 1).                                             |
    | n_factorial_(>, N, F) :-                                           |
    |         F #= F0*N,                                                 |
    |         N1 #= N - 1,                                               |
    ||________n_factorial(N1,_F0).______________________________________ ||

    This  version   of  n_factorial/2 is  deterministic   if  the  first
    argument is  instantiated, because argument indexing can distinguish
    the  different  clauses that  reflect  the possible  and  admissible
    outcomes of a comparison of _N against 0.  Example:

    ____________________________________________________________________|                                                                    |

    | ?- n_factorial(30, F).                                             |
    ||F_=_265252859812191058636308480000000.____________________________ ||

    Since  there is no clause  for <, the predicate automatically  _f_a_i_l_s
    if  _N is  less than  0.   The  predicate can  still be  used in  all
    directions, including the most general query:

    ____________________________________________________________________|                                                                    |
    | ?- n_factorial(N, F).                                              |
    | N = 0,                                                             |

    | F = 1 ;                                                            |
    | N = F, F = 1 ;                                                     |
    ||N_=_F,_F_=_2_.____________________________________________________ ||

    In this case,  all clauses are tried on backtracking, and zcompare/3
    ensures  that the respective ordering between N and 0 holds  in each
    case.

    The  truth value of a comparison can also be reified with  (#<==>)/2
    in combination with  one of the _a_r_i_t_h_m_e_t_i_c _c_o_n_s_t_r_a_i_n_t_s (section ????).
    See  reification (section ????).   However,  zcompare/3 lets you  more
    conveniently distinguish the cases.


1144..88..1177..66 RReefflleeccttiioonn pprreeddiiccaatteess

Reflection predicates let us obtain, in a  well-defined way, information
that  is  normally internal  to  this  library.    In  addition  to  the
predicates explained below, also  take a look at call_residue_vars/2 and
copy_term/3 to reason about CLP(FD) constraints that arise  in programs.
This can be useful in program analyzers and declarative debuggers.


ffdd__vvaarr((_+_V_a_r))
    True iff _V_a_r is a CLP(FD) variable.


ffdd__iinnff((_+_V_a_r_, _-_I_n_f))
    _I_n_f is the infimum of the current domain of _V_a_r.


ffdd__ssuupp((_+_V_a_r_, _-_S_u_p))
    _S_u_p is the supremum of the current domain of _V_a_r.


ffdd__ssiizzee((_+_V_a_r_, _-_S_i_z_e))
    Reflect  the  current size  of a  domain.   _S_i_z_e  is  the number  of
    elements  of the  current domain  of _V_a_r,  or  the atom  ssuupp if  the
    domain is unbounded.


ffdd__ddoomm((_+_V_a_r_, _-_D_o_m))
    _D_o_m  is the current  domain (see in/2)  of _V_a_r.   This predicate  is
    useful  if you  want to  reason about  domains.   It  is _n_o_t  needed
    if  you only want  to display remaining  domains; instead,  separate
    your  model from the search part  and let the toplevel display  this
    information via residual goals.

    For  example, to implement a custom labeling strategy, you  may need
    to  inspect the current  domain of a finite  domain variable.   With
    the  following code, you  can convert a _f_i_n_i_t_e  domain to a list  of
    integers:

    ____________________________________________________________________|                                                                    |
    | dom_integers(D, Is) :- phrase(dom_integers_(D), Is).               |

    |                                                                    |
    | dom_integers_(I)      --> { integer(I) }, [I].                     |
    | dom_integers_(L..U)   --> { numlist(L, U, Is) }, Is.               |
    ||dom_integers_(D1\/D2)_-->_dom_integers_(D1),_dom_integers_(D2).___ ||

    Example:

    ____________________________________________________________________|                                                                    |
    | ?- X in 1..5, X #\= 4, fd_dom(X, D), dom_integers(D, Is).          |
    | D = 1..3\/5,                                                       |

    | Is = [1,2,3,5],                                                    |
    ||X_in_1..3\/5._____________________________________________________ ||


1144..88..1188 CClloossiinngg aanndd ooppeenniinngg wwoorrddss aabboouutt CCLLPP((FFDD))

CLP(FD) constraints  are one of the  main reasons why logic  programming
approaches  are picked  over  other  paradigms for  solving  many  tasks
of high  practical relevance.    The usefulness  of CLP(FD)  constraints
for  scheduling,  allocation  and combinatorial  optimization  tasks  is
well-known both in academia and industry.

With  this library,  we take  the applicability  of CLP(FD)  constraints
one  step  further,  following  the road  that  visionary  systems  like
SICStus Prolog have already clearly outlined:  This  library is designed
to completely  subsume and _r_e_p_l_a_c_e  low-level predicates over  integers,
which were in  the past repeatedly found  to be a major stumbling  block
when introducing logic programming to beginners.

Embrace  the change  and new  opportunities that  this paradigm  allows!
Use  CLP(FD)  constraints  in  your  programs.     The  use  of  CLP(FD)
constraints instead of low-level arithmetic is also a  good indicator to
judge the quality of any introductory Prolog text.


1144..99 lliibbrraarryy((ccllppqqrr))::   CCoonnssttrraaiinntt LLooggiicc  PPrrooggrraammmmiinngg oovveerr RRaattiioonnaallss  aanndd
     RReeaallss

    Author:   _C_h_r_i_s_t_i_a_n _H_o_l_z_b_a_u_r, ported to SWI-Prolog by _L_e_s_l_i_e _D_e
    _K_o_n_i_n_c_k, K.U. Leuven

This CLP(Q,R) system is a port of the CLP(Q,R)  system of Sicstus Prolog
by Christian  Holzbaur:   Holzbaur C.:   OFAI  clp(q,r) Manual,  Edition
1.3.3, Austrian Research Institute for Artificial  Intelligence, Vienna,
TR-95-09,  1995.   This manual  is roughly  based on the  manual of  the
above mentioned CLP(Q,R) implementation.

The CLP(Q,R) system consists of two components:  the  CLP(Q) library for
handling constraints  over the rational numbers  and the CLP(R)  library
for handling  constraints over  the real numbers  (using floating  point
numbers as  representation).  Both  libraries offer the same  predicates
(with exception  of bb_inf/4 in  CLP(Q) and bb_inf/5  in CLP(R)). It  is
allowed to use both libraries in one program, but  using both CLP(Q) and
CLP(R) constraints on the same variable will result in an exception.

Please  note that  the clpqr  library  is _n_o_t  an _a_u_t_o_l_o_a_d  library  and
therefore this library must be loaded explicitly before using it:

________________________________________________________________________|                                                                        |

|:-|use_module(library(clpq)).__________________________________________ |  |

or

________________________________________________________________________|                                                                        |

|:-|use_module(library(clpr)).__________________________________________ |  |


1144..99..11 SSoollvveerr pprreeddiiccaatteess

The following predicates are provided to work with constraints:


{}((_+_C_o_n_s_t_r_a_i_n_t_s))
    Adds the constraints given by _C_o_n_s_t_r_a_i_n_t_s to the constraint store.


eennttaaiilleedd((_+_C_o_n_s_t_r_a_i_n_t))
    Succeeds  if  _C_o_n_s_t_r_a_i_n_t  is  necessarily true  within  the  current
    constraint  store.    This means  that adding  the  negation of  the
    constraint to the store results in failure.


iinnff((_+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f))
    Computes  the infimum of _E_x_p_r_e_s_s_i_o_n within the current state  of the
    constraint  store and returns that infimum  in _I_n_f.  This  predicate
    does not change the constraint store.


ssuupp((_+_E_x_p_r_e_s_s_i_o_n_, _-_S_u_p))
    Computes the supremum  of _E_x_p_r_e_s_s_i_o_n within the current state of the
    constraint  store and returns that supremum in _S_u_p.   This predicate
    does not change the constraint store.


mmiinniimmiizzee((_+_E_x_p_r_e_s_s_i_o_n))
    Minimizes  _E_x_p_r_e_s_s_i_o_n within the current constraint store.   This is
    the  same as computing  the infimum and  equating the expression  to
    that infimum.


mmaaxxiimmiizzee((_+_E_x_p_r_e_s_s_i_o_n))
    Maximizes  _E_x_p_r_e_s_s_i_o_n within the current constraint store.   This is
    the  same as computing the  supremum and equating the expression  to
    that supremum.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f_, _-_V_e_r_t_e_x_, _+_E_p_s))
    This  predicate  is  offered  in  CLP(R) only.     It  computes  the
    infimum of _E_x_p_r_e_s_s_i_o_n  within the current constraint store, with the
    additional  constraint that in that  infimum, all variables in  _I_n_t_s
    have  integral values.   _V_e_r_t_e_x will contain  the values of _I_n_t_s  in
    the  infimum.   _E_p_s  denotes how  much a  value may  differ from  an
    integer to be considered  an integer.  E.g. when _E_p_s = 0.001, then X
    =  4.999 will be  considered as an  integer (5 in this  case).   _E_p_s
    should be between 0 and 0.5.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f_, _-_V_e_r_t_e_x))
    This  predicate is offered in CLP(Q) only.   It behaves the  same as
    bb_inf/5 but does not use an error margin.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f))
    The  same as bb_inf/5 or  bb_inf/4 but without returning the  values
    of the integers.  In CLP(R), an error margin of 0.001 is used.


dduummpp((_+_T_a_r_g_e_t_, _+_N_e_w_v_a_r_s_, _-_C_o_d_e_d_A_n_s_w_e_r))
    Returns the constraints  on _T_a_r_g_e_t in the list _C_o_d_e_d_A_n_s_w_e_r where all
    variables  of _T_a_r_g_e_t have been replaced by _N_e_w_V_a_r_s.   This operation
    does not change the constraint store.  E.g. in

    ____________________________________________________________________|                                                                    |
    ||dump([X,Y,Z],[x,y,z],Cons)________________________________________ ||

    Cons  will  contain the  constraints  on X,  Y  and Z,  where  these
    variables have been replaced by atoms x, y and z.


1144..99..22 SSyynnttaaxx ooff tthhee pprreeddiiccaattee aarrgguummeennttss

The arguments  of the  predicates defined  in the  subsection above  are
defined in table  ????.  Failing to  meet the syntax rules will result  in
an exception.
 _______________________________________________________________________
 | <_C_o_n_s_t_r_a_i_n_t_s>::=  <_C_o_n_s_t_r_a_i_n_t>                   |single constraint |
 |                 | <_C_o_n_s_t_r_a_i_n_t> , <_C_o_n_s_t_r_a_i_n_t_s>    |conjunction       |
 |                 | <_C_o_n_s_t_r_a_i_n_t> ; <_C_o_n_s_t_r_a_i_n_t_s>    |disjunction       |
 | <_C_o_n_s_t_r_a_i_n_t> ::=  <_E_x_p_r_e_s_s_i_o_n> < <_E_x_p_r_e_s_s_i_o_n>     |less than         |
 |                 | <_E_x_p_r_e_s_s_i_o_n> > <_E_x_p_r_e_s_s_i_o_n>     |greater than      |

 |                 | <_E_x_p_r_e_s_s_i_o_n> =< <_E_x_p_r_e_s_s_i_o_n>    |less or equal     |
 |                 | <=(<_E_x_p_r_e_s_s_i_o_n>, <_E_x_p_r_e_s_s_i_o_n>)  |less or equal     |
 |                 | <_E_x_p_r_e_s_s_i_o_n> >= <_E_x_p_r_e_s_s_i_o_n>    |greater or equal  |
 |                 | <_E_x_p_r_e_s_s_i_o_n> =\= <_E_x_p_r_e_s_s_i_o_n>   |not equal         |
 |                 | <_E_x_p_r_e_s_s_i_o_n> =:= <_E_x_p_r_e_s_s_i_o_n>   |equal             |
 |                 | <_E_x_p_r_e_s_s_i_o_n> = <_E_x_p_r_e_s_s_i_o_n>     |equal             |
 | <_E_x_p_r_e_s_s_i_o_n> ::=  <_V_a_r_i_a_b_l_e>                     |Prolog variable   |
 |                 | <_N_u_m_b_e_r>                       |Prolog number     |

 |                 | +<_E_x_p_r_e_s_s_i_o_n>                  |unary plus        |
 |                 | -<_E_x_p_r_e_s_s_i_o_n>                  |unary minus       |
 |                 | <_E_x_p_r_e_s_s_i_o_n> + <_E_x_p_r_e_s_s_i_o_n>     |addition          |
 |                 | <_E_x_p_r_e_s_s_i_o_n> - <_E_x_p_r_e_s_s_i_o_n>     |substraction      |
 |                 | <_E_x_p_r_e_s_s_i_o_n> * <_E_x_p_r_e_s_s_i_o_n>     |multiplication    |
 |                 | <_E_x_p_r_e_s_s_i_o_n> / <_E_x_p_r_e_s_s_i_o_n>     |division          |
 |                 | abs(<_E_x_p_r_e_s_s_i_o_n>)              |absolute value    |

 |                 | sin(<_E_x_p_r_e_s_s_i_o_n>)              |sine              |
 |                 | cos(<_E_x_p_r_e_s_s_i_o_n>)              |cosine            |
 |                 | tan(<_E_x_p_r_e_s_s_i_o_n>)              |tangent           |
 |                 | exp(<_E_x_p_r_e_s_s_i_o_n>)              |exponent          |
 |                 | pow(<_E_x_p_r_e_s_s_i_o_n>)              |exponent          |
 |                 | <_E_x_p_r_e_s_s_i_o_n> ^ <_E_x_p_r_e_s_s_i_o_n>     |exponent          |
 |                 | min(<_E_x_p_r_e_s_s_i_o_n>, <_E_x_p_r_e_s_s_i_o_n>) |minimum           |
 |_________________|_max(<_E_x_p_r_e_s_s_i_o_n>,_<_E_x_p_r_e_s_s_i_o_n>)_|maximum___________|

                  Table 14.1:  CLP(Q,R) constraint BNF


1144..99..33 UUssee ooff uunniiffiiccaattiioonn

Instead  of using  the {}/1  predicate, you  can also  use the  standard
unification mechanism to store constraints.  The  following code samples
are equivalent:

    ____________________________________________________________________|                                                                    |
  o _U_n_i_f_i_c_a_t_i_o_n_|_w_i_t_h{_aX_v_a_r_i_a_b_l_e=:= Y}                                                          |

    | {X = Y}                                                            |
    ||X_=_Y_____________________________________________________________ ||

    ____________________________________________________________________|                                                                    |
  o _U_n_i_f_i_c_a_t_i_o_n_|_w_i_t_h{_aX_n_u_m_b_e_r=:= 5.0}                                                        |

    | {X = 5.0}                                                          |
    ||X_=_5.0___________________________________________________________ ||


1144..99..44 NNoonn--lliinneeaarr ccoonnssttrraaiinnttss

The CLP(Q,R)  system deals only  passively with non-linear  constraints.
They remain in  a passive state until certain conditions  are satisfied.
These conditions,  which are called the  isolation axioms, are given  in
table ????.
     ______________________________________________________________
     | A =B *C     |B or C is ground       |A = 5 *  C or A = B * |
     |             |                       |4                     |
     |              |A  and  (B or  C)  are|20 = 5  * C or 20 = B |
     |______________|ground________________|*_4___________________|_
     | A =B=C      |C is ground            |A = B / 3             |
     |______________|A_and_B_are_ground____|4_=_12_/_C____________|_

     | X =min(Y; Z) |Y and Z are ground    |X = min(4,3)          |
     | X =max(Y; Z) |Y and Z are ground    |X = max(4,3)          |
     |_X_=abs(Y_)___|Y_is_ground___________|X_=_abs(-7)___________|_
     | X =pow(Y; Z) |X and Y are ground    |8 = 2 ^ Z             |
     | X =exp(Y; Z) |X and Z are ground    |8 = Y ^ 3             |
     |_X_=Y__^_Z___|Y_and_Z_are_ground_____|X_=_2_^_3_____________|_
     | X =sin(Y )   X|is ground            |1 = sin(Y)            |

     | X =cos(Y )   Y|is ground            |X = sin(1.5707)       |
     |_X_=tan(Y_)___|______________________|______________________|_
                 Table 14.2:  CLP(Q,R) isolating axioms


1144..99..55 SSttaattuuss aanndd kknnoowwnn pprroobblleemmss

The clpq  and clpr libraries are  `orphaned', i.e., they currently  have
no maintainer.

  o _T_o_p_-_l_e_v_e_l _o_u_t_p_u_t
    The  top-level  output  may contain  variables  not present  in  the
    original query:

    ____________________________________________________________________|                                                                    |

    | ?- {X+Y>=1}.                                                       |
    | {Y=1-X+_G2160, _G2160>=0}.                                         |
    |                                                                    |
    ||?-________________________________________________________________ ||

    Nonetheless,  for  linear  constraints  this kind  of  answer  means
    unconditional satisfiability.

  o _D_u_m_p_i_n_g _c_o_n_s_t_r_a_i_n_t_s
    The  first argument of dump/3 has to be a list of free  variables at
    call-time:

    ____________________________________________________________________|                                                                    |
    | ?- {X=1},dump([X],[Y],L).                                          |
    | ERROR: Unhandled exception: Unknown message:                       |
    |        instantiation_error(dump([1],[_G11],_G6),1)                 |

    ||?-________________________________________________________________ ||


1144..1100 lliibbrraarryy((ccssvv))::  PPrroocceessss CCSSVV ((CCoommmmaa--SSeeppaarraatteedd VVaalluueess)) ddaattaa

    SSeeee aallssoo  RFC 4180

    TToo bbee ddoonnee
         - Implement immediate assert of the data to avoid possible
         stack overflows.
         -  Writing  creates an  intermediate  code-list,  possibly
         overflowing resources.  This waits for pure output!

This library parses and generates CSV data.  CSV  data is represented in
Prolog as a list of  rows.  Each row is a compound term, where  all rows
have the same name and arity.


ccssvv__rreeaadd__ffiillee((_+_F_i_l_e_, _-_R_o_w_s))                                        _[_d_e_t_]


ccssvv__rreeaadd__ffiillee((_+_F_i_l_e_, _-_R_o_w_s_, _+_O_p_t_i_o_n_s))                              _[_d_e_t_]
    Read  a CSV file into  a list of  rows.  Each  row is a Prolog  term
    with  the same  arity.   _O_p_t_i_o_n_s  is handed  to csv//2.    Remaining
    options  are processed by phrase_from_file/3.   The default separator
    depends  on the file name extension and  is \t for .tsv files  and ,
    otherwise.

    Suppose  we want to create a predicate table/6 from a CSV  file that
    we  know contains 6 fields per record.   This can be done  using the
    code  below.   Without the  option arity(6),  this would generate  a
    predicate  table/N, where N  is the number  of fields per record  in
    the data.

    ____________________________________________________________________|                                                                    |
    | ?- csv_read_file(File, Rows, [functor(table), arity(6)]),          |
    ||___maplist(assert,_Rows)._________________________________________ ||


ccssvv((_?_R_o_w_s)) //                                                     _[_d_e_t_]


ccssvv((_?_R_o_w_s_, _+_O_p_t_i_o_n_s)) //                                           _[_d_e_t_]
    Prolog DCG to `read/write' CSV data.  _O_p_t_i_o_n_s:

    sseeppaarraattoorr((_+_C_o_d_e))
         The comma-separator.   Must be  a character code.   Default  is
         (of course) the comma.  Character codes can  be specified using
         the 0' notion.   E.g., using separator(0';) parses  a semicolon
         separated file.

    iiggnnoorree__qquuootteess((_+_B_o_o_l_e_a_n))
         If true  (default  false),  threat double  quotes as  a  normal
         character.

    ssttrriipp((_+_B_o_o_l_e_a_n))
         If  true (default  false),  strip  leading and  trailing  blank
         space.  RFC4180 says that blank space is part of the data.

    ccoonnvveerrtt((_+_B_o_o_l_e_a_n))
         If  true (default),  use  name/2  on  the  field data.     This
         translates the field into a number if possible.

    ccaassee((_+_A_c_t_i_o_n))
         If down,  downcase atomic values.   If up,  upcase them and  if
         preserve (default), do not change the case.

    ffuunnccttoorr((_+_A_t_o_m))
         Functor to use for creating row terms.  Default is row.

    aarriittyy((_?_A_r_i_t_y))
         Number  of fields  in  each  row.    This  predicate  raises  a
         domain_error(row_arity(Expected), Found)  if  a  row  is  found
         with different arity.

    mmaattcchh__aarriittyy((_+_B_o_o_l_e_a_n))
         If false (default  true), do not  reject CSV files where  lines
         provide a varying  number of fields (columns).   This can be  a
         work-around to use some incorrect CSV files.


ccssvv__rreeaadd__ffiillee__rrooww((_+_F_i_l_e_, _-_R_o_w_, _+_O_p_t_i_o_n_s))                         _[_n_o_n_d_e_t_]
    True  when _R_o_w is a row in _F_i_l_e.   First unifies _R_o_w with  the first
    row  in _F_i_l_e.   Backtracking  yields the  second, ...   row.    This
    interface  is an alternative to  csv_read_file/3that avoids  loading
    all  rows in memory.   Note that  this interface does not  guarantee
    that all rows in _F_i_l_e have the same arity.

    In  addition  to  the  options  of csv_read_file/3,  this  predicate
    processes the option:

    lliinnee((_-_L_i_n_e))
         _L_i_n_e is unified with the 1-based line-number from  which _R_o_w is
         read.  Note that _L_i_n_e is not the physical line,  but rather the
         _l_o_g_i_c_a_l record number.

         TToo bbee ddoonnee Input  is  read  line by  line.    If  a record
             separator  is embedded in a quoted  field, parsing the
             record  fails and another line is  added to the input.
             This  does  not  nicely deal  with  other  reasons why
             parsing the row may fail.


ccssvv__rreeaadd__rrooww((_+_S_t_r_e_a_m_, _-_R_o_w_, _+_C_o_m_p_i_l_e_d_O_p_t_i_o_n_s))                      _[_d_e_t_]
    Read the next CSV  record from _S_t_r_e_a_m and unify the result with _R_o_w.
    _C_o_m_p_i_l_e_d_O_p_t_i_o_n_s  is created  from options defined  for csv//2  using
    csv_options/2.   _R_o_w is unified  with end_of_file upon reaching  the
    end of the input.


ccssvv__ooppttiioonnss((_-_C_o_m_p_i_l_e_d_, _+_O_p_t_i_o_n_s))                                   _[_d_e_t_]
    _C_o_m_p_i_l_e_d  is  the  compiled  representation of  the  CSV  processing
    options  as they may  be passed  into csv//2, etc.   This  predicate
    is  used  in  combination  with  csv_read_row/3  to  avoid  repeated
    processing of the options.


ccssvv__wwrriittee__ffiillee((_+_F_i_l_e_, _+_D_a_t_a))                                       _[_d_e_t_]


ccssvv__wwrriittee__ffiillee((_+_F_i_l_e_, _+_D_a_t_a_, _+_O_p_t_i_o_n_s))                             _[_d_e_t_]
    Write  a list  of Prolog terms  to a CSV  file.   _O_p_t_i_o_n_s are  given
    to  csv//2.   Remaining options are  given to open/4.   The  default
    separator  depends on  the file name  extension and  is \t for  .tsv
    files and , otherwise.


ccssvv__wwrriittee__ssttrreeaamm((_+_S_t_r_e_a_m_, _+_D_a_t_a_, _+_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Write   the  rows  in  _D_a_t_a  to   _S_t_r_e_a_m.     This  is  similar   to
    csv_write_file/3,   but  can  deal  with   data  that  is   produced
    incrementally.     The example  below  saves  all answers  from  the
    predicate data/3 to File.

    ____________________________________________________________________|                                                                    |
    | save_data(File) :-                                                 |

    |    setup_call_cleanup(                                             |
    |        open(File, write, Out),                                     |
    |        forall(data(C1,C2,C3),                                      |
    |               csv_write_stream(Out, [row(C1,C2,C3)], [])),         |
    ||_______close(Out)),_______________________________________________ ||


1144..1111 lliibbrraarryy((ddeebbuugg))::  PPrriinntt ddeebbuugg mmeessssaaggeess aanndd tteesstt aasssseerrttiioonnss

    aauutthhoorr  Jan Wielemaker

This library is a replacement for format/3 for  printing debug messages.
Messages are  assigned a _t_o_p_i_c.   By  dynamically enabling or  disabling
topics  the user  can select  desired messages.    Debug statements  are
removed when the code is compiled for optimization.

See manual for details.  With XPCE, you can use  the call below to start
a graphical monitoring tool.

________________________________________________________________________|                                                                        |

|?-|prolog_ide(debug_monitor).__________________________________________ |  |

Using  the predicate  assertion/1 you  can make  assumptions about  your
program explicit, trapping the debugger if the condition does not hold.


ddeebbuuggggiinngg((_+_T_o_p_i_c))                                             _[_s_e_m_i_d_e_t_]


ddeebbuuggggiinngg((_-_T_o_p_i_c))                                              _[_n_o_n_d_e_t_]


ddeebbuuggggiinngg((_?_T_o_p_i_c_, _?_B_o_o_l))                                       _[_n_o_n_d_e_t_]
    Examine  debug topics.   The form  debugging(+Topic) may be used  to
    perform more complex debugging tasks.  A typical usage skeleton is:

    ____________________________________________________________________|                                                                    |
    |       (   debugging(mytopic)                                       |

    |       ->  <perform debugging actions>                              |
    |       ;   true                                                     |
    |       ),                                                           |
    ||______..._________________________________________________________ ||

    The  other two calls  are intended to  examine existing and  enabled
    debugging tokens and are typically not used in user programs.


ddeebbuugg((_+_T_o_p_i_c))                                                     _[_d_e_t_]


nnooddeebbuugg((_+_T_o_p_i_c))                                                   _[_d_e_t_]
    Add/remove  a topic  from  being printed.    nodebug(_) removes  all
    topics.   Gives a warning if  the topic is not defined unless  it is
    used  from a directive.   The latter allows placing debug topics  at
    the start of a (load-)file without warnings.

    For  debug/1, _T_o_p_i_c can be a term _T_o_p_i_c  > Out, where Out is either
    a  stream or  stream-alias or  a filename  (atom).   This  redirects
    debug information on this topic to the given output.


lliisstt__ddeebbuugg__ttooppiiccss                                                  _[_d_e_t_]
    List currently known debug topics and their setting.


ddeebbuugg__mmeessssaaggee__ccoonntteexxtt((_+_W_h_a_t))                                       _[_d_e_t_]
    Specify additional context for debug messages.

         ddeepprreeccaatteedd New   code   should   use   the   Prolog   flag
             message_context.    This  predicates  adds  or deletes
             topics from this list.


ddeebbuugg((_+_T_o_p_i_c_, _+_F_o_r_m_a_t_, _:_A_r_g_s))                                     _[_d_e_t_]
    _F_o_r_m_a_t a message if  debug topic is enabled.  Similar to format/3 to
    user_error,  but only prints if _T_o_p_i_c is activated  through debug/1.
    _A_r_g_s  is  a  meta-argument to  deal  with  goal for  the  @-command.
    Output  is first handed  to the hook prolog:debug_print_hook/3.   If
    this  fails, _F_o_r_m_a_t+_A_r_g_s  is translated to  text using the  message-
    translation  (see print_message/2) for the term  debug(Format, Args)
    and  then  printed  to  every matching  destination  (controlled  by
    debug/1) using print_message_lines/3.

    The message is preceded by '% ' and terminated with a newline.

         SSeeee aallssoo format/3.


pprroolloogg::ddeebbuugg__pprriinntt__hhooookk((_+_T_o_p_i_c_, _+_F_o_r_m_a_t_, _+_A_r_g_s))      _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook  called  by debug/3.     This hook  is  used by  the  graphical
    frontend that can be activated using prolog_ide/1:

    ____________________________________________________________________|                                                                    |
    ||?-_prolog_ide(debug_monitor)._____________________________________ ||


aasssseerrttiioonn((_:_G_o_a_l))                                                  _[_d_e_t_]
    Acts  similar  to C  assert()  macro.    It has  no effect  if  _G_o_a_l
    succeeds.    If _G_o_a_l  fails or  throws an  exception, the  following
    steps are taken:

      o  call prolog:assertion_failed/2.   If  prolog:assertion_failed/2
         fails, then:

           {{ If  this  is  an  interactive  toplevel  thread,   print  a
             message, the stack-trace, and finally trap the debugger.

           {{ Otherwise, throw  error(assertion_error(Reason, G),_) where
             Reason is one of fail or the exception raised.


pprroolloogg::aasssseerrttiioonn__ffaaiilleedd((_+_R_e_a_s_o_n_, _+_G_o_a_l))              _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    This  hook is called if  the _G_o_a_l of assertion/1  fails.  _R_e_a_s_o_n  is
    unified with either  fail if _G_o_a_l simply failed or an exception call
    otherwise.   If this hook fails, the default behaviour is activated.
    If  the hooks  throws an exception  it will  be propagated into  the
    caller of assertion/1.


1144..1122 lliibbrraarryy((eerrrroorr))


ccuurrrreenntt__ttyyppee((_?_T_y_p_e_, _@_V_a_r_, _-_B_o_d_y))                                _[_n_o_n_d_e_t_]
    True  when _T_y_p_e is a currently  defined type and _V_a_r satisfies  _T_y_p_e
    of the body term _B_o_d_y succeeds.


1144..1133 lliibbrraarryy((ggeennssyymm))::  GGeenneerraattee uunniiqquuee iiddeennttiiffiieerrss

Gensym  (GGeennerate SSyymmbols)  is  an  old library  for  generating  unique
symbols (atoms).    Such symbols are  generated from  a base atom  which
gets a sequence number  appended.  Of course there is no  guarantee that
`catch22'  is not  an already  defined atom  and therefore  one must  be
aware these atoms are only unique in an isolated context.

The SWI-Prolog gensym library is thread-safe.  The  sequence numbers are
global over  all threads and therefore  generated atoms are unique  over
all threads.


ggeennssyymm((_+_B_a_s_e_, _-_U_n_i_q_u_e))
    Generate  a unique  atom from base  _B_a_s_e and  unify it with  _U_n_i_q_u_e.
    _B_a_s_e  should be an  atom.  The  first call will  return <_b_a_s_e>1,  the
    next <_b_a_s_e>2, etc.  Note that this is no guarantee  that the atom is
    unique in the system.


rreesseett__ggeennssyymm((_+_B_a_s_e))
    Restart  generation of identifiers  from _B_a_s_e  at <_B_a_s_e>1.   Used to
    make  sure a program produces  the same results on subsequent  runs.
    Use with care.


rreesseett__ggeennssyymm
    Reset  gensym for all registered keys.  This predicate  is available
    for  compatibility only.  New code is strongly advised to  avoid the
    use  of reset_gensym or at least to reset only the keys  used by your
    program to avoid unexpected side effects on other components.


1144..1144 lliibbrraarryy((iioossttrreeaamm))::  UUttiilliittiieess ttoo ddeeaall wwiitthh ssttrreeaammss

    SSeeee aallssoo  library(archive),   library(process),  library(zlib),
         library(http/http_stream)

This  library  contains  utilities  that  deal  with  streams,   notably
originating from non-built-in  sources such as URLs, archives,  windows,
processes, etc.

The predicate open_any/5 acts as a _b_r_o_k_e_r between applications  that can
process data from  a stream and libraries  that can create streams  from
diverse sources.    Without this predicate,  processing data  inevitally
follows the pattern below.   As _c_a_l_l___s_o_m_e___o_p_e_n___v_a_r_i_a_t_i_o_n can  be anything,
this blocks us from writing predicates such  as load_xml(From, DOM) that
can operate on arbitrary input sources.

________________________________________________________________________|                                                                        |

|setup_call_cleanup(                                                     |
|    call_some_open_variation(Spec, In),                                 |
|    process(In),                                                        |
||___close(In)).________________________________________________________ ||

Libraries   that    can   open    streams   can    install   the    hook
iostream:open_hook/6  to  make  their  functionality  available  through
open_any/5.


ooppeenn__aannyy((_+_S_p_e_c_i_f_i_c_a_t_i_o_n_, _+_M_o_d_e_, _-_S_t_r_e_a_m_, _-_C_l_o_s_e_, _+_O_p_t_i_o_n_s))
    Establish  a stream from _S_p_e_c_i_f_i_c_a_t_i_o_n  that should be closed  using
    _C_l_o_s_e,   which  can either  be  called  or  passed  to  close_any/1.
    _O_p_t_i_o_n_s processed:

    eennccooddiinngg((_E_n_c))
         Set stream to encoding _E_n_c.

    Without  loaded  plugins,  the  open_any/5 processes  the  following
    values for  _S_p_e_c_i_f_i_c_a_t_i_o_n.  If no rule matches, open_any/5 processes
    _S_p_e_c_i_f_i_c_a_t_i_o_n as file(Specification).

    _S_t_r_e_a_m
         A plain  stream  handle.   Possisible  post-processing  options
         such  as encoding  are  applied.    _C_l_o_s_e  does _n_o_t  close  the
         stream, but resets other side-effects such as the encoding.

    ssttrreeaamm((_S_t_r_e_a_m))
         Same as a plain _S_t_r_e_a_m.

    _F_i_l_e_U_R_L
         If _S_p_e_c_i_f_i_c_a_t_i_o_n is  of the form  =file://...=, the pointed  to
         file is  opened  using open/4.    Requires  library(uri) to  be
         installed.

    ffiillee((_P_a_t_h))
         Explicitly open the file _P_a_t_h.  _P_a_t_h can be  an _P_a_t_h(File) term
         as accepted by absolute_file_name/3.

    ssttrriinngg((_S_t_r_i_n_g))
         Open a Prolog string,  atom, list of characters or codes  as an
         _i_n_p_u_t stream.

    The  typical  usage  scenario is  given  in the  code  below,  where
    <process> processes the input.

    ____________________________________________________________________|                                                                    |
    | setup_call_cleanup(                                                |

    |     open_any(Spec, read, In, Close, Options),                      |
    |     <process>(In),                                                 |
    ||____Close)._______________________________________________________ ||

    Currently, the following libraries extend this predicate:

    lliibbrraarryy((_h_t_t_p_/_h_t_t_p___o_p_e_n))
         Adds support for URLs using the http and https schemes.


cclloossee__aannyy((_+_G_o_a_l))
    Execute  the  _C_l_o_s_e closure  returned by  open_any/5.    The  closure
    can  also be called directly.   Using close_any/1 can be  considered
    better style and enhances tractability of the source code.


ooppeenn__hhooookk((_+_S_p_e_c_, _+_M_o_d_e_, _-_S_t_r_e_a_m_, _-_C_l_o_s_e_, _+_O_p_t_i_o_n_s_0_, _-_O_p_t_i_o_n_s))_[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Open _S_p_e_c in _M_o_d_e, producing _S_t_r_e_a_m.

    ___________________________________________________________Arguments_
     _C_l_o_s_e     is  unified to  a goal  that must  be called  to
               undo  the  side-effects  of  the action,   e.g.,
               typically the term close(Stream)
     _O_p_t_i_o_n_s_0  are the options passed to open_any/5
     _O_p_t_i_o_n_s   are  passed to the post processing filters  that
               may be installed by open_any/5.


1144..1155 lliibbrraarryy((lliissttss))::  LLiisstt MMaanniippuullaattiioonn

    CCoommppaattiibbiilliittyy  Virtually     every     Prolog    system     has
         library(lists),   but  the  set   of  provided  predicates
         is diverse.   There is  a fair agreement  on the semantics
         of most of  these predicates, although  error handling may
         vary.

This  library  provides  commonly accepted  basic  predicates  for  list
manipulation  in   the  Prolog   community.      Some  additional   list
manipulations are built-in.  See e.g., memberchk/2, length/2.

The implementation of  this library is copied  from many places.   These
include:  "The Craft  of Prolog", the DEC-10 Prolog  library (LISTRO.PL)
and the YAP lists  library.  Some predicates are reimplemented  based on
their specification by Quintus and SICStus.


mmeemmbbeerr((_?_E_l_e_m_, _?_L_i_s_t))
    True  if  _E_l_e_m is  a member  of  _L_i_s_t.   The  SWI-Prolog  definition
    differs  from the classical  one.   Our definition avoids  unpacking
    each  list  element  twice  and provides  determinism  on  the  last
    element.  E.g.  this is deterministic:

    ____________________________________________________________________|                                                                    |
    ||____member(X,_[One])._____________________________________________ ||

         aauutthhoorr Gertjan van Noord


aappppeenndd((_?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_1_A_n_d_L_i_s_t_2))
    _L_i_s_t_1_A_n_d_L_i_s_t_2 is the concatenation of _L_i_s_t_1 and _L_i_s_t_2


aappppeenndd((_+_L_i_s_t_O_f_L_i_s_t_s_, _?_L_i_s_t))
    Concatenate  a list of lists.   Is true if _L_i_s_t_O_f_L_i_s_t_s is a  list of
    lists, and _L_i_s_t is the concatenation of these lists.

    ___________________________________________________________Arguments_
     _L_i_s_t_O_f_L_i_s_t_s  must be a list of _p_o_s_s_i_b_l_y partial lists


pprreeffiixx((_?_P_a_r_t_, _?_W_h_o_l_e))
    True iff _P_a_r_t is  a leading substring of _W_h_o_l_e.  This is the same as
    append(Part, _, Whole).


sseelleecctt((_?_E_l_e_m_, _?_L_i_s_t_1_, _?_L_i_s_t_2))
    Is true when _L_i_s_t_1, with _E_l_e_m removed, results in _L_i_s_t_2.


sseelleeccttcchhkk((_+_E_l_e_m_, _+_L_i_s_t_, _-_R_e_s_t))                                _[_s_e_m_i_d_e_t_]
    Semi-deterministic  removal of  first element in  _L_i_s_t that  unifies
    with _E_l_e_m.


sseelleecctt((_?_X_, _?_X_L_i_s_t_, _?_Y_, _?_Y_L_i_s_t))                                 _[_n_o_n_d_e_t_]
    Select  from  two lists  at the  same positon.    True  if _X_L_i_s_t  is
    unifiable  with _Y_L_i_s_t apart  a single element  at the same  position
    that  is unified with  _X in _X_L_i_s_t and  with _Y in  _Y_L_i_s_t.  A  typical
    use  for  this predicate  is  to _r_e_p_l_a_c_e  an  element, as  shown  in
    the  example below.    All possible substitutions  are performed  on
    backtracking.

    ____________________________________________________________________|                                                                    |
    | ?- select(b, [a,b,c,b], 2, X).                                     |

    | X = [a, 2, c, b] ;                                                 |
    | X = [a, b, c, 2] ;                                                 |
    ||false.____________________________________________________________ ||

         SSeeee aallssoo selectchk/4 provides a semidet version.


sseelleeccttcchhkk((_?_X_, _?_X_L_i_s_t_, _?_Y_, _?_Y_L_i_s_t))                             _[_s_e_m_i_d_e_t_]
    Semi-deterministic version of select/4.


nneexxttttoo((_?_X_, _?_Y_, _?_L_i_s_t))
    True if _Y directly follows _X in _L_i_s_t.


ddeelleettee((_+_L_i_s_t_1_, _@_E_l_e_m_, _-_L_i_s_t_2))                                     _[_d_e_t_]
    Delete  matching elements from a  list.  True  when _L_i_s_t_2 is a  list
    with all elements  from _L_i_s_t_1 except for those that unify with _E_l_e_m.
    Matching  _E_l_e_m with  elements of _L_i_s_t_1  is uses \+ Elem \= H,  which
    implies that _E_l_e_m is not changed.

         SSeeee aallssoo select/3, subtract/3.

         ddeepprreeccaatteedd There  are  too many  ways in  which  one might
             want  to delete  elements from a  list to  justify the
             name.     Think  of  matching  (= vs.     ==),  delete
             first/all, be deterministic or not.


nntthh00((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    True when _E_l_e_m is  the _I_n_d_e_x'th element of _L_i_s_t.  Counting starts at
    0.

         EErrrroorrss type_error(integer, Index)   if  _I_n_d_e_x  is  not  an
             integer or unbound.

         SSeeee aallssoo nth1/3.


nntthh11((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    Is true when _E_l_e_m  is the _I_n_d_e_x'th element of _L_i_s_t.  Counting starts
    at 1.

         SSeeee aallssoo nth0/3.


nntthh00((_?_N_, _?_L_i_s_t_, _?_E_l_e_m_, _?_R_e_s_t))                                     _[_d_e_t_]
    Select/insert  element  at  index.    True  when _E_l_e_m  is  the  _N'th
    (0-based)  element  of _L_i_s_t  and _R_e_s_t  is the  remainder  (as in  by
    select/3) of _L_i_s_t.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- nth0(I, [a,b,c], E, R).                                         |

    | I = 0, E = a, R = [b, c] ;                                         |
    | I = 1, E = b, R = [a, c] ;                                         |
    | I = 2, E = c, R = [a, b] ;                                         |
    ||false.____________________________________________________________ ||

    ____________________________________________________________________|                                                                    |

    | ?- nth0(1, L, a1, [a,b]).                                          |
    ||L_=_[a,_a1,_b].___________________________________________________ ||


nntthh11((_?_N_, _?_L_i_s_t_, _?_E_l_e_m_, _?_R_e_s_t))                                     _[_d_e_t_]
    As nth0/4, but counting starts at 1.


llaasstt((_?_L_i_s_t_, _?_L_a_s_t))
    Succeeds  when _L_a_s_t is the last element of _L_i_s_t.  This  predicate is
    semidet if _L_i_s_t is a list and multi if _L_i_s_t is a partial list.

         CCoommppaattiibbiilliittyy There   is  no  de-facto  standard  for  the
             argument  order of  last/2.   Be careful  when porting
             code  or  use  append(_, [Last], List)  as a  portable
             alternative.


pprrooppeerr__lleennggtthh((_@_L_i_s_t_, _-_L_e_n_g_t_h))                                  _[_s_e_m_i_d_e_t_]
    True when _L_e_n_g_t_h is  the number of elements in the proper list _L_i_s_t.
    This is equivalent to

    ____________________________________________________________________|                                                                    |
    | proper_length(List, Length) :-                                     |

    |       is_list(List),                                               |
    ||______length(List,_Length)._______________________________________ ||


ssaammee__lleennggtthh((_?_L_i_s_t_1_, _?_L_i_s_t_2))
    Is  true when  _L_i_s_t_1 and  _L_i_s_t_2 are lists  with the  same number  of
    elements.   The  predicate is deterministic if  at least one of  the
    arguments  is  a proper  list.    It  is non-deterministic  if  both
    arguments are partial lists.

         SSeeee aallssoo length/2


rreevveerrssee((_?_L_i_s_t_1_, _?_L_i_s_t_2))
    Is true when the  elements of _L_i_s_t_2 are in reverse order compared to
    _L_i_s_t_1.


ppeerrmmuuttaattiioonn((_?_X_s_, _?_Y_s))                                          _[_n_o_n_d_e_t_]
    True  when  _X_s  is  a  permutation  of _Y_s.     This  can  solve  for
    _Y_s  given  _X_s  or  _X_s  given  _Y_s,   or  even  enumerate  _X_s  and  _Y_s
    together.     The  predicate  permutation/2  is  primarily  intended
    to  generate  permutations.    Note  that a  list  of length  N  has
    N!  permutations,   and  unbounded  permutation  generation  becomes
    prohibitively  expensive,  even  for rather  short  lists  (10!    =
    3,628,800).

    If both _X_s and  _Y_s are provided and both lists have equal length the
    order  is |_X_s|^2.  Simply testing whether _X_s is a permutation  of _Y_s
    can  be achieved  in order  log(|_X_s|) using  msort/2 as  illustrated
    below with the semidet predicate is_permutation/2:

    ____________________________________________________________________|                                                                    |
    | is_permutation(Xs, Ys) :-                                          |

    |   msort(Xs, Sorted),                                               |
    ||__msort(Ys,_Sorted).______________________________________________ ||

    The  example below illustrates that _X_s and _Y_s being proper  lists is
    not a sufficient condition to use the above replacement.

    ____________________________________________________________________|                                                                    |
    | ?- permutation([1,2], [X,Y]).                                      |
    | X = 1, Y = 2 ;                                                     |
    | X = 2, Y = 1 ;                                                     |
    ||false.____________________________________________________________ ||

         EErrrroorrss type_error(list, Arg)  if either argument  is not a
             proper or partial list.


ffllaatttteenn((_+_N_e_s_t_e_d_L_i_s_t_, _-_F_l_a_t_L_i_s_t))                                   _[_d_e_t_]
    Is  true if _F_l_a_t_L_i_s_t  is a non-nested version  of _N_e_s_t_e_d_L_i_s_t.   Note
    that  empty lists  are removed.   In standard  Prolog, this  implies
    that  the atom '[]' is  removed too.  In  SWI7, [] is distinct  from
    '[]'.

    Ending  up  needing flatten/2  often  indicates, like  append/3  for
    appending  two lists, a bad design.   Efficient code that  generates
    lists  from generated small lists  must use difference lists,  often
    possible through grammar rules for optimal readability.

         SSeeee aallssoo append/2


mmaaxx__mmeemmbbeerr((_-_M_a_x_, _+_L_i_s_t))                                        _[_s_e_m_i_d_e_t_]
    True when _M_a_x is  the largest member in the standard order of terms.
    Fails if _L_i_s_t is empty.

         SSeeee aallssoo
             - compare/3
             - max_list/2 for the maximum of a list of numbers.


mmiinn__mmeemmbbeerr((_-_M_i_n_, _+_L_i_s_t))                                        _[_s_e_m_i_d_e_t_]
    True  when  _M_i_n is  the smallest  member in  the  standard order  of
    terms.  Fails if _L_i_s_t is empty.

         SSeeee aallssoo
             - compare/3
             - min_list/2 for the minimum of a list of numbers.


ssuumm__lliisstt((_+_L_i_s_t_, _-_S_u_m))                                              _[_d_e_t_]
    _S_u_m is the result of adding all numbers in _L_i_s_t.


mmaaxx__lliisstt((_+_L_i_s_t_:_l_i_s_t_(_n_u_m_b_e_r_)_, _-_M_a_x_:_n_u_m_b_e_r))                      _[_s_e_m_i_d_e_t_]
    True if _M_a_x is the largest number in _L_i_s_t.  Fails if _L_i_s_t is empty.

         SSeeee aallssoo max_member/2.


mmiinn__lliisstt((_+_L_i_s_t_:_l_i_s_t_(_n_u_m_b_e_r_)_, _-_M_i_n_:_n_u_m_b_e_r))                      _[_s_e_m_i_d_e_t_]
    True  if _M_i_n  is the  smallest number  in _L_i_s_t.   Fails  if _L_i_s_t  is
    empty.

         SSeeee aallssoo min_member/2.


nnuummlliisstt((_+_L_o_w_, _+_H_i_g_h_, _-_L_i_s_t))                                   _[_s_e_m_i_d_e_t_]
    _L_i_s_t is a list [_L_o_w, _L_o_w+1, ...  _H_i_g_h].  Fails if _H_i_g_h < _L_o_w.

         EErrrroorrss
             - type_error(integer, Low)
             - type_error(integer, High)


iiss__sseett((_@_S_e_t))                                                   _[_s_e_m_i_d_e_t_]
    True  if _S_e_t is  a proper list without  duplicates.  Equivalence  is
    based  on  ==/2.   The  implementation  uses sort/2,  which  implies
    that  the  complexity is  N*log(N)  and the  predicate may  cause  a
    resource-error.  There are no other error conditions.


lliisstt__ttoo__sseett((_+_L_i_s_t_, _?_S_e_t))                                           _[_d_e_t_]
    True when _S_e_t has  the same elements as _L_i_s_t in the same order.  The
    left-most copy of  duplicate elements is retained.  _L_i_s_t may contain
    variables.   Elements _E_1 and _E_2 are considered duplicates iff  _E_1 ==
    _E_2 holds.  The complexity of the implementation is N*log(N).

         EErrrroorrss _L_i_s_t is type-checked.

         SSeeee aallssoo sort/2  can  be used  to create  an  ordered set.
             Many  set  operations  on  ordered  sets  are order  N
             rather  than order N**2.   The list_to_set/2 predicate
             is  more expensive  than  sort/2 because  it involves,
             two sorts and a linear scan.

         CCoommppaattiibbiilliittyy Up   to  version  6.3.11,  list_to_set/2 had
             complexity N**2 and equality was tested using =/2.


iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))                                 _[_d_e_t_]
    True  if _S_e_t_3 unifies with the intersection  of _S_e_t_1 and _S_e_t_2.   The
    complexity of this predicate  is |_S_e_t_1|*|_S_e_t_2|.  A _s_e_t is defined to
    be  an unordered list without  duplicates.  Elements are  considered
    duplicates if they can be unified.

         SSeeee aallssoo ord_intersection/3.


uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))                                        _[_d_e_t_]
    True  if _S_e_t_3 unifies  with the  union of the  lists _S_e_t_1 and  _S_e_t_2.
    The  complexity  of this  predicate  is |_S_e_t_1|*|_S_e_t_2|.    A  _s_e_t  is
    defined  to be an unordered list  without duplicates.  Elements  are
    considered duplicates if they can be unified.

         SSeeee aallssoo ord_union/3


ssuubbsseett((_+_S_u_b_S_e_t_, _+_S_e_t))                                         _[_s_e_m_i_d_e_t_]
    True  if all elements of _S_u_b_S_e_t belong  to _S_e_t as well.   Membership
    test  is based on  memberchk/2.   The complexity is  |_S_u_b_S_e_t|*|_S_e_t|.
    A  _s_e_t  is  defined to  be  an  unordered list  without  duplicates.
    Elements are considered duplicates if they can be unified.

         SSeeee aallssoo ord_subset/2.


ssuubbttrraacctt((_+_S_e_t_, _+_D_e_l_e_t_e_, _-_R_e_s_u_l_t))                                  _[_d_e_t_]
    _D_e_l_e_t_e  all elements  in  _D_e_l_e_t_e from  _S_e_t.   Deletion  is based  on
    unification  using memberchk/2.   The complexity is  |_D_e_l_e_t_e|*|_S_e_t|.
    A  _s_e_t  is  defined to  be  an  unordered list  without  duplicates.
    Elements are considered duplicates if they can be unified.

         SSeeee aallssoo ord_subtract/3.


1144..1166 lliibbrraarryy((mmaaiinn))::  PPrroovviiddee eennttrryy ppooiinntt ffoorr ssccrriippttss

    SSeeee aallssoo  XPCE users  should have a  look at library(pce_main),
         which  starts  the  GUI  and processes  events  until  all
         windows have gone.

This library is  intended for supporting PrologScript on Unix  using the
#! magic  sequence for  scripts using  commandline options.   The  entry
point main/0 calls the user-supplied predicate main/1 passing  a list of
commandline options.   Below is `echo' in Prolog  (adjust /usr/bin/swipl
to where SWI-Prolog is installed)

________________________________________________________________________|                                                                        |

|#!/usr/bin/env swipl                                                    |
|                                                                        |
|:- initialization(main, main).                                          |
|                                                                        |
|main(Argv) :-                                                           |
|        echo(Argv).                                                     |
|                                                                        |

|echo([]) :- nl.                                                         |
|echo([Last]) :- !,                                                      |
|        write(Last), nl.                                                |
|echo([H|T]) :-                                                          |
|        write(H), write(' '),                                           |
||_______echo(T)._______________________________________________________ ||


mmaaiinn
    Call  main/1  using  the  passed command-line  arguments.     Before
    calling  main/1 this predicate installs a signal handler  for SIGINT
    (Control-C) that terminates the process with status 1.


aarrggvv__ooppttiioonnss((_+_A_r_g_v_, _-_R_e_s_t_A_r_g_v_, _-_O_p_t_i_o_n_s))                           _[_d_e_t_]
    Generic  transformation of  long commandline  arguments to  options.
    Each  --Name=Value is  mapped to Name(Value).    Each plain name  is
    mapped  to Name(true), unless  Name starts with  no-, in which  case
    the  option is  mapped to Name(false).    Numeric option values  are
    mapped to Prolog numbers.

         SSeeee aallssoo library(optparse)   provides   a   more  involved
             option   library,   providing  both  short   and  long
             options,  help and error handling.   This predicate is
             more for quick-and-dirty scripts.


1144..1177 lliibbrraarryy((nnbb__sseett))::  NNoonn--bbaacckkttrraacckkaabbllee sseett

The  library  nb_set  defines  _n_o_n_-_b_a_c_k_t_r_a_c_k_a_b_l_e  _s_e_t_s,  implemented  as
binary  trees.     The  sets  are  represented  as  compound  terms  and
manipulated  using  nb_setarg/3.     Non-backtrackable  manipulation  of
datastructures  is   not  supported   by  a  large   number  of   Prolog
implementations, but it has several advantages over  using the database.
It  produces less  garbage,  is thread-safe,  reentrant and  deals  with
exceptions without leaking data.

Similar to  the assoc library, keys  can be any  Prolog term, but it  is
not allowed to instantiate or modify a term.

One of  the ways to  use this  library is to  generate unique values  on
backtracking  _w_i_t_h_o_u_t generating  _a_l_l solutions  first,  for example  to
act as  a filter between  a generator producing  many duplicates and  an
expensive test routine, as outlined below:

________________________________________________________________________|                                                                        |
|generate_and_test(Solution) :-                                          |

|        empty_nb_set(Set),                                              |
|        generate(Solution),                                             |
|        add_nb_set(Solution, Set, true),                                |
||_______test(Solution).________________________________________________ ||


eemmppttyy__nnbb__sseett((_?_S_e_t))
    True if _S_e_t is a non-backtrackable empty set.


aadddd__nnbb__sseett((_+_K_e_y_, _!_S_e_t))
    Add  _K_e_y to _S_e_t.   If _K_e_y  is already a member  of _S_e_t, add_nb_set/3
    succeeds without modifying _S_e_t.


aadddd__nnbb__sseett((_+_K_e_y_, _!_S_e_t_, _?_N_e_w))
    If  _K_e_y is not in _S_e_t  and _N_e_w is unified  to true, _K_e_y is added  to
    _S_e_t.   If _K_e_y is  in _S_e_t, _N_e_w is unified to  false.  It can  be used
    for many purposes:

             add_nb_set(+, +, false) Test membership
             add_nb_set(+, +, true)  Succeed only if new member
             add_nb_set(+, +, Var)   Succeed, binding _V_a_r


ggeenn__nnbb__sseett((_+_S_e_t_, _-_K_e_y))
    Generate  all members of _S_e_t  on backtracking in the standard  order
    of terms.  To test membership, use add_nb_set/3.


ssiizzee__nnbb__sseett((_+_S_e_t_, _-_S_i_z_e))
    Unify _S_i_z_e with the number of elements in _S_e_t.


nnbb__sseett__ttoo__lliisstt((_+_S_e_t_, _-_L_i_s_t))
    Unify _L_i_s_t with a  list of all elements in _S_e_t in the standard order
    of terms (i.e., an _o_r_d_e_r_e_d _l_i_s_t).


1144..1188 lliibbrraarryy((wwwwww__bbrroowwsseerr))::  AAccttiivvaattiinngg yyoouurr WWeebb--bbrroowwsseerr

This library deals with the very system-dependent task of  opening a web
page in a browser.  See also url and the HTTP package.


wwwwww__ooppeenn__uurrll((_+_U_R_L))
    Open  _U_R_L in  an external web  browser.   The reason  to place  this
    in  the library  is  to centralise  the maintenance  on this  highly
    platform-  and browser-specific task.  It distinguishes  between the
    following cases:

      o  _M_S_-_W_i_n_d_o_w_s
         If it detects MS-Windows  it uses win_shell/2 to open the  _U_R_L.
         The behaviour  and browser  started depends on  the version  of
         Windows  and Windows-shell  configuration,  but in  general  it
         should be the behaviour expected by the user.

      o  _O_t_h_e_r _p_l_a_t_f_o_r_m_s
         On  other platforms  it  tests  the environment  variable  (see
         getenv/2) named BROWSER  or uses netscape  if this variable  is
         not  set.    If the  browser  is  either mozilla  or  netscape,
         www_open_url/1 first tries to  open a new  window on a  running
         browser using the  -remote option of Netscape.   If this  fails
         or the  browser is not  mozilla or  netscape the system  simply
         passes the URL as first argument to the program.


1144..1199 lliibbrraarryy((ooppttiioonn))::  OOppttiioonn lliisstt pprroocceessssiinngg

    SSeeee aallssoo
         - library(record)
         - Option processing capabilities may be declared using the
         directive predicate_options/3.

    TToo bbee ddoonnee  We should consider putting many options in an assoc
         or record with appropriate preprocessing to achieve better
         performance.

The  library(option)  provides  some  utilities  for  processing  option
lists.     Option  lists  are  commonly  used  as   an  alternative  for
many  arguments.    Examples  of  built-in  predicates  are  open/4  and
write_term/3.  Naming the  arguments results in more readable code,  and
the list  nature makes it  easy to extend the  list of options  accepted
by a  predicate.   Option lists come  in two styles,  both of which  are
handled by this library.

NNaammee((VVaalluuee))  This is the preferred style.

NNaammee == VVaalluuee  This is often used, but deprecated.

Processing options inside  time-critical code (loops) can cause  serious
overhead.  One  possibility is to define a record  using library(record)
and initialise  this using  make_<record>/2.   In  addition to providing
good  performance,   this  also   provides  type-checking  and   central
declaration of defaults.

________________________________________________________________________|                                                                        |
|:- record atts(width:integer=100, shape:oneof([box,circle])=box).       |
|                                                                        |
|process(Data, Options) :-                                               |
|        make_atts(Options, Attributes),                                 |
|        action(Data, Attributes).                                       |

|                                                                        |
|action(Data, Attributes) :-                                             |
|        atts_shape(Attributes, Shape),                                  |
||_______...____________________________________________________________ ||

Options  typically  have  exactly  one  argument.     The  library  does
support options  with 0  or more  than one argument  with the  following
restrictions:

  o The  predicate   option/3  and  select_option/4,   involving  default
    are   meaningless.      They  perform  an   arg(1, Option, Default),
    causing  failure  without  arguments  and  filling  only  the  first
    option-argument otherwise.

  o meta_options/3 can only qualify options with exactly one argument.


ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_L_i_s_t_, _+_D_e_f_a_u_l_t))                        _[_s_e_m_i_d_e_t_]
    Get  an _O_p_t_i_o_n from _O_p_t_i_o_n_L_i_s_t.   _O_p_t_i_o_n_L_i_s_t can use the  Name=Value
    as well as the Name(Value) convention.

    ___________________________________________________________Arguments_
     _O_p_t_i_o_n  Term of the form Name(?Value).


ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_L_i_s_t))                                  _[_s_e_m_i_d_e_t_]
    Get  an _O_p_t_i_o_n from _O_p_t_i_o_n_L_i_s_t.   _O_p_t_i_o_n_L_i_s_t can use the  Name=Value
    as  well  as the  Name(Value) convention.    Fails  silently if  the
    option does not appear in _O_p_t_i_o_n_L_i_s_t.

    ___________________________________________________________Arguments_
     _O_p_t_i_o_n  Term of the form Name(?Value).


sseelleecctt__ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_s_, _-_R_e_s_t_O_p_t_i_o_n_s))                 _[_s_e_m_i_d_e_t_]
    Get  and remove _O_p_t_i_o_n from an  option list.  As option/2,  removing
    the matching option  from _O_p_t_i_o_n_s and unifying the remaining options
    with _R_e_s_t_O_p_t_i_o_n_s.


sseelleecctt__ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_s_, _-_R_e_s_t_O_p_t_i_o_n_s_, _+_D_e_f_a_u_l_t))           _[_d_e_t_]
    Get  and remove _O_p_t_i_o_n with default value.   As select_option/3, but
    if  _O_p_t_i_o_n is not in _O_p_t_i_o_n_s, its value is unified with  _D_e_f_a_u_l_t and
    _R_e_s_t_O_p_t_i_o_n_s with _O_p_t_i_o_n_s.


mmeerrggee__ooppttiioonnss((_+_N_e_w_, _+_O_l_d_, _-_M_e_r_g_e_d))                                 _[_d_e_t_]
    Merge  two option lists.  _M_e_r_g_e_d  is a sorted list of  options using
    the  canonical format Name(Value) holding  all options from _N_e_w  and
    _O_l_d, after removing conflicting options from _O_l_d.

    Multi-values  options (e.g.,  proxy(Host, Port)) are allowed,  where
    both option-name and arity define the identity of the option.


mmeettaa__ooppttiioonnss((_+_I_s_M_e_t_a_, _:_O_p_t_i_o_n_s_0_, _-_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Perform   meta-expansion  on  options  that  are   module-sensitive.
    Whether an option  name is module-sensitive is determined by calling
    call(IsMeta, Name).  Here is an example:

    ____________________________________________________________________|                                                                    |
    |         meta_options(is_meta, OptionsIn, Options),                 |

    |         ...                                                        |
    |                                                                    |
    ||is_meta(callback).________________________________________________ ||

    Meta-options must have  exactly one argument.  This argument will be
    qualified.

         TToo bbee ddoonnee Should  be  integrated  with declarations  from
             predicate_options/3.


ddiicctt__ooppttiioonnss((_?_D_i_c_t_, _?_O_p_t_i_o_n_s))                                      _[_d_e_t_]
    Convert  between  an option  list and  a  dictionary.   One  of  the
    arguments  must be instantiated.  If the option list is  created, it
    is  created in canonical  form, i.e.,  using Option(Value) with  the
    _O_p_t_i_o_n_s  sorted in  the  standard order  of terms.    Note that  the
    conversion  is not always possible due to different  constraints and
    convertion may thus lead to (type) errors.

      o  _D_i_c_t keys can  be integers.   This is not allowed in  canonical
         option lists.

      o  _O_p_t_i_o_n_s can hold multiple options  with the same key.   This is
         not allowed in dicts.

      o  _O_p_t_i_o_n_s can have  more than one value  (name(V1,V2)).  This  is
         not allowed in dicts.

    Also  note that  most system  predicates and  predicates using  this
    library  for  processing  the option  argument  can both  work  with
    classical Prolog options and dicts objects.


1144..2200 lliibbrraarryy((ooppttppaarrssee))::  ccoommmmaanndd lliinnee ppaarrssiinngg

    aauutthhoorr  Marcus Uneson

    vveerrssiioonn  0.20 (2011-04-27)

    TToo bbee ddoonnee  :  validation?   e.g, numbers; file path existence;
         one-out-of-a-set-of-atoms

This  module   helps  in  building  a   command-line  interface  to   an
application.  In  particular, it provides functions that take  an option
specification and  a list  of atoms,  probably given to  the program  on
the command  line, and  return a  parsed representation (a  list of  the
customary Key(Val) by default;  or optionally, a list of Func(Key,  Val)
terms in the style of  current_prolog_flag/2).  It can also  synthesize a
simple help text from the options specification.

The  terminology  in  the following  is  partly  borrowed  from  python,
see  http://docs.python.org/library/optparse.html#terminology .     Very
briefly,   _a_r_g_u_m_e_n_t_s  is   what  you   provide  on   the  command   line
and  for   many  prologs   show  up  as   a  list   of  atoms  Args   in
current_prolog_flag(argv, Args).    For  a typical  prolog  incantation,
they can be divided into

  o _r_u_n_t_i_m_e  _a_r_g_u_m_e_n_t_s, which controls  the prolog runtime;  convention-
    ally, they are ended by '--';

  o _o_p_t_i_o_n_s,  which are key-value pairs  (with a boolean value  possibly
    implicit)  intended to control your  program in one way or  another;
    and

  o _p_o_s_i_t_i_o_n_a_l  _a_r_g_u_m_e_n_t_s,  which  is  what remains  after  all  runtime
    arguments and options  have been removed (with implicit arguments --
    true/false for booleans -- filled in).

Positional  arguments are  in particular  used  for mandatory  arguments
without  which your  program  won't work  and  for  which there  are  no
sensible  defaults (e.g,,  input file  names).   Options,  by  contrast,
offer flexibility  by letting  you change  a default setting.    Options
are optional  not only  by etymology:   this  library has  no notion  of
mandatory or required options (see the python docs  for other rationales
than laziness).

The command-line arguments  enter your program as  a list of atoms,  but
the programs perhaps  expects booleans, integers, floats or  even prolog
terms.   You tell the parser  so by providing an _o_p_t_i_o_n_s  _s_p_e_c_i_f_i_c_a_t_i_o_n.
This is just a list of individual option specifications.   One of those,
in turn, is a  list of ground prolog terms in the  customary Name(Value)
format.  The following terms are recognized (any others raise error).

oopptt((_K_e_y))
    _K_e_y  is what the  option later  will be accessed  by, just like  for
    current_prolog_flag(Key, Value).   This term is mandatory  (an error
    is thrown if missing).

sshhoorrttffllaaggss((_L_i_s_t_O_f_F_l_a_g_s))
    _L_i_s_t_O_f_F_l_a_g_s  denotes any single-dashed, single letter  args specify-
    ing  the current  option  (-s , -K, etc).    Uppercase letters  must
    be  quoted.    Usually _L_i_s_t_O_f_F_l_a_g_s  will be  a singleton  list,  but
    sometimes aliased flags may be convenient.

lloonnggffllaaggss((_L_i_s_t_O_f_F_l_a_g_s))
    _L_i_s_t_O_f_F_l_a_g_s  denotes  any  double-dashed  arguments  specifying  the
    current  option (--verbose, --no-debug, etc).  They are  basically a
    more readable alternative to short flags, except

 1. long  flags can  be specified as  --flag value or --flag=value  (but
    not  as  --flagvalue);  short  flags as  -f val  or -fval  (but  not
    -f=val)

 2. boolean  long  flags  can be  specified  as --bool-flag  or  --bool-
    flag=true   or  --bool-flag true;   and  they  can  be  negated   as
    --no-bool-flag or --bool-flag=false or --bool-flag false.

    Except  that shortflags must  be single characters, the  distinction
    between long and  short is in calling convention, not in namespaces.
    Thus, if you have  shortflags([v]), you can use it as -v2 or -v 2 or
    --v=2 or --v 2 (but not -v=2 or --v2).

    Shortflags  and longflags both default to [].   It can be  useful to
    have flagless options -- see example below.

mmeettaa((_M_e_t_a))
    _M_e_t_a  is  optional  and  only relevant  for  the  synthesized  usage
    message  and is  the name  (an atom) of  the metasyntactic  variable
    (possibly)  appearing in  it together  with type  and default  value
    (e.g,  x:integer=3, interest:float=0.11).  It may be useful  to have
    named  variables (x,  interest)  in case  you wish  to mention  them
    again  in the help text.  If not given the Meta:  part is suppressed
    -- see example below.

ttyyppee((_T_y_p_e))
    _T_y_p_e  is one  of  boolean, atom, integer, float, term.   The  corre-
    sponding  argument  will be  parsed  appropriately.   This  term  is
    optional; if not given, defaults to term.

ddeeffaauulltt((_D_e_f_a_u_l_t))
    _D_e_f_a_u_l_t  value.  This  term is optional; if  not given, or if  given
    the  special value '_', an uninstantiated  variable is created  (and
    any type declaration is ignored).

hheellpp((_H_e_l_p))
    _H_e_l_p is (usually) an  atom of text describing the option in the help
    text.   This  term is optional  (but obviously strongly  recommended
    for all options which have flags).

    Long  lines are  subject to basic  word wrapping  -- split on  white
    space,  reindent,  rejoin.   However, you  can get  more control  by
    supplying  the line breaking  yourself:  rather  than a single  line
    of  text, you can provide  a list of lines (as  atoms).  If you  do,
    they  will be joined with the appropriate indent but  otherwise left
    untouched (see the option mode in the example below).

Absence of mandatory option  specs or the presence of more than  one for
a  particular option  throws an  error, as  do  unknown or  incompatible
types.

As a concrete  example from a fictive  application, suppose we want  the
following options to be read from the command line  (long flag(s), short
flag(s), meta:type=default, help)

________________________________________________________________________|                                                                        |
|--mode                  -m     atom=SCAN       data gathering mode,     |
|                                               one of                   |
|                                                SCAN: do this           |

|                                                READ: do that           |
|                                                MAKE: make numbers      |
|                                                WAIT: do nothing        |
|--rebuild-cache         -r     boolean=true    rebuild cache in         |
|                                               each iteration           |
|--heisenberg-threshold  -t,-h  float=0.1       heisenberg threshold     |
|--depths, --iters       -i,-d  K:integer=3     stop after K             |
|                                               iterations               |

|--distances                    term=[1,2,3,5]  initial prolog term      |
|--output-file           -o     FILE:atom=_     write output to FILE     |
|--label                 -l     atom=REPORT     report label             |
|--verbosity             -v     V:integer=2     verbosity level,         |
||______________________________________________1_<=_V_<=_3_____________ ||

We  may also  have  some  configuration parameters  which  we  currently
think  not  needs   to  be  controlled  from   the  command  line,   say
path('/some/file/path').

This  interface is  described  by  the following  options  specification
(order   between  the   specifications  of   a   particular  option   is
irrelevant).

________________________________________________________________________|                                                                        |
|ExampleOptsSpec =                                                       |

|    [ [opt(mode    ), type(atom), default('SCAN'),                      |
|        shortflags([m]),   longflags(['mode'] ),                        |
|        help([ 'data gathering mode, one of'                            |
|             , '  SCAN: do this'                                        |
|             , '  READ: do that'                                        |
|             , '  MAKE: fabricate some numbers'                         |
|             , '  WAIT: don''t do anything'])]                          |
|                                                                        |

|    , [opt(cache), type(boolean), default(true),                        |
|        shortflags([r]),   longflags(['rebuild-cache']),                |
|        help('rebuild cache in each iteration')]                        |
|                                                                        |
|    , [opt(threshold), type(float), default(0.1),                       |
|        shortflags([t,h]),  longflags(['heisenberg-threshold']),        |
|        help('heisenberg threshold')]                                   |

|                                                                        |
|    , [opt(depth), meta('K'), type(integer), default(3),                |
|        shortflags([i,d]),longflags([depths,iters]),                    |
|        help('stop after K iterations')]                                |
|                                                                        |
|    , [opt(distances), default([1,2,3,5]),                              |
|        longflags([distances]),                                         |
|        help('initial prolog term')]                                    |

|                                                                        |
|    , [opt(outfile), meta('FILE'), type(atom),                          |
|        shortflags([o]),  longflags(['output-file']),                   |
|        help('write output to FILE')]                                   |
|                                                                        |
|    , [opt(label), type(atom), default('REPORT'),                       |
|        shortflags([l]), longflags([label]),                            |

|        help('report label')]                                           |
|                                                                        |
|    , [opt(verbose),  meta('V'), type(integer), default(2),             |
|        shortflags([v]),  longflags([verbosity]),                       |
|        help('verbosity level, 1 <= V <= 3')]                           |
|                                                                        |
|    , [opt(path), default('/some/file/path/')]                          |
||___]._________________________________________________________________ ||

The       help       text       above       was        accessed       by
opt_help(ExamplesOptsSpec, HelpText).     The  options  appear   in  the
same order as in the OptsSpec.

Given   ExampleOptsSpec,   a   command  line   (somewhat   syntactically
inconsistent,  in order  to demonstrate  different calling  conventions)
may look as follows

________________________________________________________________________|                                                                        |

|ExampleArgs = [ '-d5'                                                   |
|              , '--heisenberg-threshold', '0.14'                        |
|              , '--distances=[1,1,2,3,5,8]'                             |
|              , '--iters', '7'                                          |
|              , '-ooutput.txt'                                          |
|              , '--rebuild-cache', 'true'                               |

|              , 'input.txt'                                             |
|              , '--verbosity=2'                                         |
||_____________]._______________________________________________________ ||

opt_parse(ExampleOptsSpec, ExampleArgs, Opts, PositionalArgs)      would
then succeed with

________________________________________________________________________|                                                                        |
|Opts =    [ mode('SCAN')                                                |
|          , label('REPORT')                                             |
|          , path('/some/file/path')                                     |
|          , threshold(0.14)                                             |

|          , distances([1,1,2,3,5,8])                                    |
|          , depth(7)                                                    |
|          , outfile('output.txt')                                       |
|          , cache(true)                                                 |
|          , verbose(2)                                                  |
|          ],                                                            |
|PositionalArgs|=_['input.txt'].________________________________________ |              |

Note  that path('/some/file/path')  showing  up in  Opts has  a  default
value  (of  the  implicit  type  'term'),  but  no  corresponding  flags
in  OptsSpec.      Thus  it  can't   be  set  from  the  command   line.
The  rest  of  your program  doesn't  need  to  know  that,  of  course.
This  provides  an  alternative to  the  common  practice  of  asserting
such  hard-coded  parameters  under a  single  predicate  (for  instance
setting(path, '/some/file/path')),  with  the  advantage  that  you  may
seamlessly  upgrade them  to command-line  options, should  you one  day
find this  a good  idea.   Just  add an appropriate  flag or  two and  a
line of  help text.   Similarly,  suppressing an  option in a  cluttered
interface amounts to commenting out the flags.

opt_parse/5 allows more control  through an additional argument list  as
shown in the example below.

________________________________________________________________________|                                                                        |

|?- opt_parse(ExampleOptsSpec, ExampleArgs,  Opts, PositionalArgs,       |
|             [ output_functor(appl_config)                              |
|             ]).                                                        |
|                                                                        |
|Opts =    [ appl_config(verbose, 2),                                    |
|          , appl_config(label, 'REPORT')                                |

|          ...                                                           |
||_________]____________________________________________________________ ||

This representation may be preferable with  the empty-flag configuration
parameter style above (perhaps with asserting appl_config/2).


1144..2200..11 NNootteess aanndd ttiippss

  o In  the example  we were  mostly explicit about  the types.    Since
    the  default is  term, which subsumes  integer, float, atom, it  may
    be  possible to get  away cheaper (e.g.,  by only giving  booleans).
    However,   it is  recommended  practice  to  always  specify  types:
    parsing  becomes more reliable and error messages will be  easier to
    interpret.

  o Note  that -sbar is taken to mean -s bar, not -s -b -a -r,  that is,
    there is no clustering of flags.

  o -s=foo  is  disallowed.     The  rationale  is  that  although  some
    command-line  parsers will silently interpret this as -s =foo,  this
    is  very seldom what  you want.   To have  an option argument  start
    with '=' (very un-recommended), say so explicitly.

  o The  example specifies  the option  depth twice:   once  as -d5  and
    once  as --iters 7.  The default when encountering  duplicated flags
    is  to keeplast (this  behaviour can  be controlled, by  ParseOption
    duplicated_flags).

  o The  order of the options returned  by the parsing functions is  the
    same  as given  on the  command line,  with non-overridden  defaults
    prepended  and duplicates removed as in  previous item.  You  should
    not rely on this, however.

  o Unknown  flags (not appearing in OptsSpec) will throw errors.   This
    is  usually a Good Thing.  Sometimes, however, you may wish  to pass
    along  flags to an  external program (say,  one called by  shell/2),
    and  it means duplicated effort  and a maintenance headache to  have
    to  specify all possible flags  for the external program  explicitly
    (if  it even can  be done).   On the other  hand, simply taking  all
    unknown  flags as  valid makes  error checking  much less  efficient
    and  identification of  positional arguments  uncertain.   A  better
    solution  is to collect all arguments intended for passing  along to
    an  indirectly called program as  a single argument, probably as  an
    atom  (if you don't need to inspect them first) or as a  prolog term
    (if you do).


oopptt__aarrgguummeennttss((_+_O_p_t_s_S_p_e_c_, _-_O_p_t_s_, _-_P_o_s_i_t_i_o_n_a_l_A_r_g_s))                   _[_d_e_t_]
    Extract  commandline options  according to  a specification.    Con-
    venience  predicate,  assuming that  command-line  arguments can  be
    accessed  by current_prolog_flag/2 (as  in swi-prolog).   For  other
    access  mechanisms and/or more control,  get the args and pass  them
    as a list of atoms to opt_parse/4 or opt_parse/5 instead.

    _O_p_t_s  is a list of  parsed options in the  form Key(Value).   Dashed
    args  not in _O_p_t_s_S_p_e_c  are not permitted  and will raise error  (see
    tip  on  how  to pass  unknown  flags  in the  module  description).
    _P_o_s_i_t_i_o_n_a_l_A_r_g_s  are the  remaining non-dashed args  after each  flag
    has  taken its  argument (filling  in true or  false for  booleans).
    There  are no restrictions on  non-dashed arguments and they may  go
    anywhere  (although it  is good  practice to put  them last).    Any
    leading  arguments for the  runtime (up to  and including '--')  are
    discarded.


oopptt__ppaarrssee((_+_O_p_t_s_S_p_e_c_, _+_A_p_p_l_A_r_g_s_, _-_O_p_t_s_, _-_P_o_s_i_t_i_o_n_a_l_A_r_g_s))            _[_d_e_t_]
    Equivalent to opt_parse(OptsSpec, ApplArgs, Opts, PositionalArgs, []).


oopptt__ppaarrssee((_+_O_p_t_s_S_p_e_c_, _+_A_p_p_l_A_r_g_s_, _-_O_p_t_s_, _-_P_o_s_i_t_i_o_n_a_l_A_r_g_s_, _+_P_a_r_s_e_O_p_t_i_o_n_s))_[_d_e_t_]
    Parse  the arguments Args (as list of atoms) according  to _O_p_t_s_S_p_e_c.
    Any runtime arguments  (typically terminated by '--') are assumed to
    be removed already.

    _O_p_t_s  is a list of parsed  options in the form Key(Value),  or (with
    the  option  functor(Func)  given) in  the  form  Func(Key,  Value).
    Dashed  args not in _O_p_t_s_S_p_e_c are not permitted and will  raise error
    (see  tip on how to pass  unknown flags in the module  description).
    _P_o_s_i_t_i_o_n_a_l_A_r_g_s  are the  remaining non-dashed args  after each  flag
    has  taken its  argument (filling  in true or  false for  booleans).
    There  are  no restrictions  on non-dashed  arguments  and they  may
    go  anywhere  (although  it is  good  practice  to put  them  last).
    _P_a_r_s_e_O_p_t_i_o_n_s are

    oouuttppuutt__ffuunnccttoorr((_F_u_n_c))
         Set the functor  _F_u_n_c of the returned options  _F_u_n_c(Key,Value).
         Default  is the  special  value  'OPTION'  (upper-case),  which
         makes the returned options have form Key(Value).

    dduupplliiccaatteedd__ffllaaggss((_K_e_e_p))
         Controls how  to handle  options given  more than  once on  the
         commad line.  _K_e_e_p is one  of keepfirst, keeplast, keepall with
         the obvious meaning.  Default is keeplast.

    aallllooww__eemmppttyy__ffllaagg__ssppeecc((_B_o_o_l))
         If true  (default), a  flag specification is  not required  (it
         is allowed  that both  shortflags  and longflags  be either  []
         or absent).   Flagless options  cannot be manipulated from  the
         command  line and  will  not show  up  in the  generated  help.
         This  is useful  when  you  have (also)  general  configuration
         parameters in your _O_p_t_s_S_p_e_c,  especially if you think they  one
         day might  need to be  controlled externally.   See example  in
         the module  overview.   allow_empty_flag_spec(false) gives  the
         more customary behaviour of raising error on empty flags.


oopptt__hheellpp((_+_O_p_t_s_S_p_e_c_, _-_H_e_l_p_:_a_t_o_m))                                    _[_d_e_t_]
    True when _H_e_l_p is a help string synthesized from _O_p_t_s_S_p_e_c.


ppaarrssee__ttyyppee((_+_T_y_p_e_, _+_C_o_d_e_s_:_l_i_s_t_(_c_o_d_e_)_, _-_R_e_s_u_l_t))        _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook to parse option text _C_o_d_e_s to an object of type _T_y_p_e.


1144..2211 lliibbrraarryy((oorrddsseettss))::  OOrrddeerreedd sseett mmaanniippuullaattiioonn

Ordered  sets are  lists with  unique elements  sorted  to the  standard
order of  terms (see  sort/2).   Exploiting  ordering, many  of the  set
operations can  be expressed  in order  N rather than  N^2 when  dealing
with unordered sets  that may contain duplicates.   The library(ordsets)
is available in a number of Prolog implementations.   Our predicates are
designed to be compatible with common practice in  the Prolog community.
The implementation  is incomplete  and relies  partly on  library(oset),
an  older  ordered  set  library  distributed  with  SWI-Prolog.     New
applications are advised to use library(ordsets).

Some  of   these  predicates  match   directly  to  corresponding   list
operations.    It  is advised  to use  the  versions from  this  library
to  make clear  you are  operating on  ordered sets.    An exception  is
member/2.  See ord_memberchk/2.

The ordsets  library is  based on  the standard order  of terms.    This
implies  it can  handle all  Prolog terms,  including variables.    Note
however, that  the ordering is not  stable if a  term inside the set  is
further  instantiated.   Also  note that  variable  ordering changes  if
variables in the  set are unified with each  other or a variable in  the
set is unified with a variable that is `older'  than the newest variable
in  the set.    In practice,  this implies  that  it is  allowed to  use
member(X, OrdSet) on an ordered set that holds variables only  if X is a
fresh variable.  In  other cases one should cease using it as  an ordset
because the order it relies on may have been changed.


iiss__oorrddsseett((_@_T_e_r_m))                                               _[_s_e_m_i_d_e_t_]
    True  if _T_e_r_m is  an ordered set.   All  predicates in this  library
    expect  ordered sets as  input arguments.   Failing to fullfil  this
    assumption results in  undefined behaviour.  Typically, ordered sets
    are created by predicates from this library, sort/2 or setof/3.


oorrdd__eemmppttyy((_?_L_i_s_t))                                               _[_s_e_m_i_d_e_t_]
    True  when _L_i_s_t is the empty ordered set.  Simply unifies  list with
    the empty list.  Not part of Quintus.


oorrdd__sseetteeqq((_+_S_e_t_1_, _+_S_e_t_2))                                        _[_s_e_m_i_d_e_t_]
    True  if  _S_e_t_1  and _S_e_t_2  have  the same  elements.    As  both  are
    canonical sorted lists, this is the same as ==/2.

         CCoommppaattiibbiilliittyy sicstus


lliisstt__ttoo__oorrdd__sseett((_+_L_i_s_t_, _-_O_r_d_S_e_t))                                     _[_d_e_t_]
    Transform  a list into an ordered set.  This is the  same as sorting
    the list.


oorrdd__iinntteerrsseecctt((_+_S_e_t_1_, _+_S_e_t_2))                                    _[_s_e_m_i_d_e_t_]
    True if both ordered sets have a non-empty intersection.


oorrdd__ddiissjjooiinntt((_+_S_e_t_1_, _+_S_e_t_2))                                     _[_s_e_m_i_d_e_t_]
    True  if  _S_e_t_1 and  _S_e_t_2  have no  common  elements.   This  is  the
    negation of ord_intersect/2.


oorrdd__iinntteerrsseecctt((_+_S_e_t_1_, _+_S_e_t_2_, _-_I_n_t_e_r_s_e_c_t_i_o_n))
    _I_n_t_e_r_s_e_c_t_i_o_n holds the common elements of _S_e_t_1 and _S_e_t_2.

         ddeepprreeccaatteedd Use ord_intersection/3


oorrdd__iinntteerrsseeccttiioonn((_+_P_o_w_e_r_S_e_t_, _-_I_n_t_e_r_s_e_c_t_i_o_n))
    _I_n_t_e_r_s_e_c_t_i_o_n  of a powerset.   True when _I_n_t_e_r_s_e_c_t_i_o_n is an  ordered
    set holding all elements common to all sets in _P_o_w_e_r_S_e_t.

         CCoommppaattiibbiilliittyy sicstus


oorrdd__iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_I_n_t_e_r_s_e_c_t_i_o_n))                      _[_d_e_t_]
    _I_n_t_e_r_s_e_c_t_i_o_n  holds the  common elements  of _S_e_t_1  and _S_e_t_2.    Uses
    ord_disjoint/2 if _I_n_t_e_r_s_e_c_t_i_o_n is bound to [] on entry.


oorrdd__iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _?_I_n_t_e_r_s_e_c_t_i_o_n_, _?_D_i_f_f_e_r_e_n_c_e))         _[_d_e_t_]
    _I_n_t_e_r_s_e_c_t_i_o_n and difference  between two ordered sets.  _I_n_t_e_r_s_e_c_t_i_o_n
    is  the  intersection between  _S_e_t_1 and  _S_e_t_2,  while _D_i_f_f_e_r_e_n_c_e  is
    defined by ord_subtract(Set2, Set1, Difference).

         SSeeee aallssoo ord_intersection/3 and ord_subtract/3.


oorrdd__aadddd__eelleemmeenntt((_+_S_e_t_1_, _+_E_l_e_m_e_n_t_, _?_S_e_t_2))                            _[_d_e_t_]
    Insert   an  element  into   the  set.      This  is  the  same   as
    ord_union(Set1, [Element], Set2).


oorrdd__ddeell__eelleemmeenntt((_+_S_e_t_, _+_E_l_e_m_e_n_t_, _-_N_e_w_S_e_t))                           _[_d_e_t_]
    Delete  an  element from  an  ordered set.    This  is the  same  as
    ord_subtract(Set, [Element], NewSet).


oorrdd__sseelleeccttcchhkk((_+_I_t_e_m_, _?_S_e_t_1_, _?_S_e_t_2))                             _[_s_e_m_i_d_e_t_]
    Selectchk/3,   specialised  for  ordered   sets.     Is  true   when
    select(Item, Set1, Set2)  and  _S_e_t_1,  _S_e_t_2  are  both  sorted  lists
    without  duplicates.  This  implementation is only expected to  work
    for  _I_t_e_m  ground  and  either _S_e_t_1  or  _S_e_t_2  ground.    The  "chk"
    suffix  is meant to  remind you of  memberchk/2, which also  expects
    its  first  argument  to  be  ground.    ord_selectchk(X, S, T)  =>
    ord_memberchk(X, S) & \+ ord_memberchk(X, T).

         aauutthhoorr Richard O'Keefe


oorrdd__mmeemmbbeerrcchhkk((_+_E_l_e_m_e_n_t_, _+_O_r_d_S_e_t))                               _[_s_e_m_i_d_e_t_]
    True  if _E_l_e_m_e_n_t is  a member of  _O_r_d_S_e_t, compared using  ==.   Note
    that  _e_n_u_m_e_r_a_t_i_n_g  elements of  an  ordered set  can be  done  using
    member/2.

    Some  Prolog  implementations also  provide  ord_member/2,  with  the
    same  semantics  as  ord_memberchk/2.     We believe  that  having  a
    semidet  ord_member/2 is  unacceptably  inconsistent with  the *_chk
    convention.  Portable code should use ord_memberchk/2 or member/2.

         aauutthhoorr Richard O'Keefe


oorrdd__ssuubbsseett((_+_S_u_b_, _+_S_u_p_e_r))                                       _[_s_e_m_i_d_e_t_]
    Is true if all elements of _S_u_b are in _S_u_p_e_r


oorrdd__ssuubbttrraacctt((_+_I_n_O_S_e_t_, _+_N_o_t_I_n_O_S_e_t_, _-_D_i_f_f))                           _[_d_e_t_]
    _D_i_f_f  is the  set holding  all elements of  _I_n_O_S_e_t that  are not  in
    _N_o_t_I_n_O_S_e_t.


oorrdd__uunniioonn((_+_S_e_t_O_f_S_e_t_s_, _-_U_n_i_o_n))                                      _[_d_e_t_]
    True  if  _U_n_i_o_n  is  the  union of  all  elements  in  the  superset
    _S_e_t_O_f_S_e_t_s.   Each member  of _S_e_t_O_f_S_e_t_s must  be an ordered set,  the
    sets need not be ordered in any way.

         aauutthhoorr Copied  from  YAP, probably  originally  by Richard
             O'Keefe.


oorrdd__uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _?_U_n_i_o_n))                                    _[_d_e_t_]
    _U_n_i_o_n is the union of _S_e_t_1 and _S_e_t_2


oorrdd__uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_U_n_i_o_n_, _-_N_e_w))                              _[_d_e_t_]
    True          iff          ord_union(Set1, Set2, Union)          and
    ord_subtract(Set2, Set1, New).


oorrdd__ssyymmddiiffff((_+_S_e_t_1_, _+_S_e_t_2_, _?_D_i_f_f_e_r_e_n_c_e))                             _[_d_e_t_]
    Is  true when  _D_i_f_f_e_r_e_n_c_e is  the symmetric difference  of _S_e_t_1  and
    _S_e_t_2.    I.e.,  _D_i_f_f_e_r_e_n_c_e contains  all elements  that  are not  in
    the  intersection of _S_e_t_1 and  _S_e_t_2.  The  semantics is the same  as
    the  sequence below (but the  actual implementation requires only  a
    single scan).

    ____________________________________________________________________|                                                                    |
    |       ord_union(Set1, Set2, Union),                                |

    |       ord_intersection(Set1, Set2, Intersection),                  |
    ||______ord_subtract(Union,_Intersection,_Difference).______________ ||

    For example:

    ____________________________________________________________________|                                                                    |
    | ?- ord_symdiff([1,2], [2,3], X).                                   |
    ||X_=_[1,3].________________________________________________________ ||


1144..2222 lliibbrraarryy((ppaaiirrss))::  OOppeerraattiioonnss oonn kkeeyy--vvaalluuee lliissttss

    aauutthhoorr  Jan Wielemaker

    SSeeee aallssoo  keysort/2, library(assoc)

This  module  implements common  operations  on  Key-Value  lists,  also
known as  _P_a_i_r_s.   Pairs have great practical  value, especially due  to
keysort/2 and the library assoc.pl.

This  library is  based  on  disussion in  the  SWI-Prolog  mailinglist,
including specifications from Quintus and a library  proposal by Richard
O'Keefe.


ppaaiirrss__kkeeyyss__vvaalluueess((_?_P_a_i_r_s_, _?_K_e_y_s_, _?_V_a_l_u_e_s))                          _[_d_e_t_]
    True if _K_e_y_s holds the keys of _P_a_i_r_s and _V_a_l_u_e_s the values.

    Deterministic  if any argument is instantiated to a finite  list and
    the others are either  free or finite lists.  All three lists are in
    the same order.

         SSeeee aallssoo pairs_values/2 and pairs_keys/2.


ppaaiirrss__vvaalluueess((_+_P_a_i_r_s_, _-_V_a_l_u_e_s))                                      _[_d_e_t_]
    Remove  the  keys  from  a  list  of  Key-Value  pairs.     Same  as
    pairs_keys_values(Pairs, _, Values)


ppaaiirrss__kkeeyyss((_+_P_a_i_r_s_, _-_K_e_y_s))                                          _[_d_e_t_]
    Remove  the  values  from  a list  of  Key-Value  pairs.    Same  as
    pairs_keys_values(Pairs, Keys, _)


ggrroouupp__ppaaiirrss__bbyy__kkeeyy((_+_P_a_i_r_s_, _-_J_o_i_n_e_d_:_l_i_s_t_(_K_e_y_-_V_a_l_u_e_s_)))                _[_d_e_t_]
    Group values with equivalent (==/2) consecutive keys.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- group_pairs_by_key([a-2, a-1, b-4, a-3], X).                    |

    |                                                                    |
    ||X_=_[a-[2,1],_b-[4],_a-[3]]_______________________________________ ||

    Sorting  the list of pairs before grouping can be used to  group _a_l_l
    values  associated with  a key.    For example,  finding all  values
    associated with the largest key:

    ____________________________________________________________________|                                                                    |
    | ?- sort(1, @>=, [a-1, b-2, c-3, a-4, a-5, c-6], Ps),               |
    |    group_pairs_by_key(Ps, [K-Vs|_]).                               |
    | K = c,                                                             |
    ||Vs_=_[3,_6].______________________________________________________ ||

    In  this example, sorting by key  only (first argument of sort/4  is
    1)  ensures that the  order of  the values in  the original list  of
    pairs is maintained.

    ___________________________________________________________Arguments_
     _P_a_i_r_s   _K_e_y-Value list
     _J_o_i_n_e_d  List  of _K_e_y-Group, where  Group is the list  of
             _V_a_l_u_e_s  associated with  equivalent  consecutive
             Keys in the same order as they appear in _P_a_i_r_s.


ttrraannssppoossee__ppaaiirrss((_+_P_a_i_r_s_, _-_T_r_a_n_s_p_o_s_e_d))                               _[_d_e_t_]
    Swap  Key-Value to Value-Key.   The  resulting list is sorted  using
    keysort/2 on the new key.


mmaapp__lliisstt__ttoo__ppaaiirrss((_:_F_u_n_c_t_i_o_n_, _+_L_i_s_t_, _-_K_e_y_e_d))
    Create  a Key-Value  list  by mapping  each element  of _L_i_s_t.    For
    example,  if  we have  a  list of  lists  we can  create a  list  of
    Length-_L_i_s_t using

    ____________________________________________________________________|                                                                    |
    ||________map_list_to_pairs(length,_ListOfLists,_Pairs),____________ ||


1144..2233 lliibbrraarryy((ppeerrssiisstteennccyy))::  PPrroovviiddee ppeerrssiisstteenntt ddyynnaammiicc pprreeddiiccaatteess

    TToo bbee ddoonnee
         - Provide type safety while loading
         - Thread  safety must now  be provided at  the user-level.
         Can we  provide generic  thread safety?    Basically, this
         means that  we must  wrap all exported  predicates.   That
         might better be done outside this library.
         - Transaction management?
         - Should  assert_<name>  only assert if  the database  does
         not contain a variant?

This module provides  simple persistent storage for one or  more dynamic
predicates.   A database is always associated  with a module.  A  module
that wishes to  maintain a database must  declare the terms that can  be
placed in the database using the directive persistent/1.

The persistent/1 expands each declaration into four predicates:

  o name(Arg, ...)

  o assert_name(Arg, ...)

  o retract_name(Arg, ...)

  o retractall_name(Arg, ...)

As  mentioned, a  database can  only be  accessed from  within a  single
module.   This limitation is on purpose,  forcing the user to provide  a
proper API for accessing the shared persistent data.

Below is a simple example:

________________________________________________________________________|                                                                        |
|:- module(user_db,                                                      |
|          [ attach_user_db/1,           % +File                         |
|            current_user_role/2,        % ?User, ?Role                  |

|            add_user/2,                 % +User, +Role                  |
|            set_user_role/2             % +User, +Role                  |
|          ]).                                                           |
|:- use_module(library(persistency)).                                    |
|                                                                        |
|:- persistent                                                           |
|        user_role(name:atom, role:oneof([user,administrator])).         |
|                                                                        |

|attach_user_db(File) :-                                                 |
|        db_attach(File, []).                                            |
|                                                                        |
|%%      current_user_role(+Name, -Role) is semidet.                     |
|                                                                        |
|current_user_role(Name, Role) :-                                        |
|        with_mutex(user_db, user_role(Name, Role)).                     |

|                                                                        |
|add_user(Name, Role) :-                                                 |
|        assert_user_role(Name, Role).                                   |
|                                                                        |
|set_user_role(Name, Role) :-                                            |
|        user_role(Name, Role), !.                                       |
|set_user_role(Name, Role) :-                                            |
|        with_mutex(user_db,                                             |

|                   (  retractall_user_role(Name, _),                    |
||_____________________assert_user_role(Name,_Role))).__________________ ||


ppeerrssiisstteenntt _+_S_p_e_c
    Declare dynamic database  terms.  Declarations appear in a directive
    and have the following format:

    ____________________________________________________________________|                                                                    |
    | :- persistent                                                      |

    |         <callable>,                                                |
    |         <callable>,                                                |
    ||________..._______________________________________________________ ||

    Each specification is  a callable term, following the conventions of
    library(record), where each argument is of the form

    ____________________________________________________________________|                                                                    |
    ||name:type_________________________________________________________ ||

    Types are defined by library(error).


ccuurrrreenntt__ppeerrssiisstteenntt__pprreeddiiccaattee((_:_P_I))                               _[_n_o_n_d_e_t_]
    True  if _P_I is  a predicate that  provides access to the  persistent
    database DB.


ddbb__aattttaacchh((_:_F_i_l_e_, _+_O_p_t_i_o_n_s))
    Use  _F_i_l_e  as persistent  database  for the  calling  module.    The
    calling  module must  defined persistent/1 to  declare the  database
    terms.  Defined options:

    ssyynncc((_+_S_y_n_c))
         One  of close  (close  journal after  write),  flush  (default,
         flush journal after  write) or none  (handle as fully  buffered
         stream).

    If  _F_i_l_e is  already  attached this  operation may  change the  sync
    behaviour.


ddbb__aattttaacchheedd((_:_F_i_l_e))                                             _[_s_e_m_i_d_e_t_]
    True  if  the context  module attached  to  the persistent  database
    _F_i_l_e.


ddbb__ddeettaacchh                                                          _[_d_e_t_]
    Detach  persistency from the calling  module and delete all  persis-
    tent  clauses from  the  Prolog database.    Note that  the file  is
    not  affected.  After this  operation another file may be  attached,
    providing it satisfies the same persistency declaration.


ddbb__ssyynncc((_:_W_h_a_t))
    Synchronise database with the associated file.  _W_h_a_t is one of:

    rreellooaadd
         Database is reloaded from  file if the file was  modified since
         loaded.

    uuppddaattee
         As reload,  but  use incremental  loading if  possible.    This
         allows for  two processes  to examine the  same database  file,
         where one writes the database and the  other periodycally calls
         db_sync(update) to follow the modified data.

    ggcc
         Database was  re-written, deleting  all retractall  statements.
         This is the same as gc(50).

    ggcc((_P_e_r_c_e_n_t_a_g_e))
         GC DB if  the number of deleted  terms is the given  percentage
         of the total number of terms.

    cclloossee
         Database stream was closed

    ddeettaacchh
         Remove all registered persistency for the calling module

    nnoopp
         No-operation performed

    With  unbound  _W_h_a_t,  db_sync/1  reloads  the  database  if  it  was
    modified  on disk,  gc  it if  it is  dirty and  close it  if it  is
    opened.


ddbb__ssyynncc__aallll((_+_W_h_a_t))
    Sync all registered databases.


1144..2244 lliibbrraarryy((ppiioo))::  PPuurree II//OO

This library provides  pure list-based I/O processing for Prolog,  where
the communication  to the actual I/O  device is performed  transparently
through coroutining.   This  module itself is just  an interface to  the
actual implementation modules.


1144..2244..11 lliibbrraarryy((ppuurree__iinnppuutt))::  PPuurree IInnppuutt ffrroomm ffiilleess aanndd ssttrreeaammss

    TToo bbee ddoonnee  Provide support for alternative input readers, e.g.
         reading terms, tokens, etc.

This module  is part  of pio.pl,  dealing with _p_u_r_e  _i_n_p_u_t:   processing
input  streams from  the outside  world using  pure predicates,  notably
grammar  rules  (DCG). Using  pure  predicates  makes  non-deterministic
processing of input much simpler.

Pure input  uses attributed variables  to read  input from the  external
source into  a list _o_n  _d_e_m_a_n_d.   The overhead of  lazy reading is  more
than compensated for by using block reads based on read_pending_codes/3.

Ulrich Neumerkel came up  with the idea to use coroutining  for creating
a  _l_a_z_y  _l_i_s_t.    His  implementation  repositioned  the  file  to  deal
with re-reading  that can  be necessary  on backtracking.   The  current
implementation uses destructive assignment together with  more low-level
attribute handling to realise pure input on any (buffered) stream.


pphhrraassee__ffrroomm__ffiillee((_:_G_r_a_m_m_a_r_, _+_F_i_l_e))                               _[_n_o_n_d_e_t_]
    Process  the content of _F_i_l_e using the DCG rule _G_r_a_m_m_a_r.   The space
    usage  of this mechanism depends on the length of the  not committed
    part  of  _G_r_a_m_m_a_r.    Committed  parts  of the  temporary  list  are
    reclaimed  by the garbage collector,  while the list is extended  on
    demand  due to unification of the  attributed tail variable.   Below
    is  an example that counts the  number of times a string appears  in
    a  file.    The library  dcg/basics provides  string//1 matching  an
    arbitrary  string and  remainder//1 which matches  the remainder  of
    the input without parsing.

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(dcg/basics)).                                |

    |                                                                    |
    | file_contains(File, Pattern) :-                                    |
    |         phrase_from_file(match(Pattern), File).                    |
    |                                                                    |
    | match(Pattern) -->                                                 |
    |         string(_),                                                 |
    |         string(Pattern),                                           |
    |         remainder(_).                                              |

    |                                                                    |
    | match_count(File, Pattern, Count) :-                               |
    ||________aggregate_all(count,_file_contains(File,_Pattern),_Count)._||

    This can be called  as (note that the pattern must be a string (code
    list)):

    ____________________________________________________________________|                                                                    |
    ||?-_match_count('pure_input.pl',_`file`,_Count).___________________ ||


pphhrraassee__ffrroomm__ffiillee((_:_G_r_a_m_m_a_r_, _+_F_i_l_e_, _+_O_p_t_i_o_n_s))                     _[_n_o_n_d_e_t_]
    As  phrase_from_file/2,  providing additional _O_p_t_i_o_n_s.   _O_p_t_i_o_n_s  are
    passed to open/4.


pphhrraassee__ffrroomm__ssttrreeaamm((_:_G_r_a_m_m_a_r_, _+_S_t_r_e_a_m))
    Run  Grammer against the character codes on _S_t_r_e_a_m.  _S_t_r_e_a_m  must be
    buffered.


ssyynnttaaxx__eerrrroorr((_+_E_r_r_o_r)) //
    Throw  the syntax error _E_r_r_o_r at the current location of  the input.
    This  predicate  is  designed  to  be called  from  the  handler  of
    phrase_from_file/3.

         tthhrroowwss error(syntax_error(Error), Location)


llaazzyy__lliisstt__llooccaattiioonn((_-_L_o_c_a_t_i_o_n)) //                                   _[_d_e_t_]
    Determine  current  (error) location  in a  lazy list.    True  when
    _L_o_c_a_t_i_o_n  is an  (error) location term  that represents the  current
    location in the DCG list.

    ___________________________________________________________Arguments_
     _L_o_c_a_t_i_o_n  is   a  term   file(Name, Line, LinePos, CharNo)
               or  stream(Stream, Line, LinePos, CharNo) if  no
               file  is associated to the stream  RestLazyList.
               Finally, if the Lazy list is fully  materialized
               (ends   in  []),   _L_o_c_a_t_i_o_n   is  unified   with
               end_of_file-CharCount.

         SSeeee aallssoo lazy_list_character_count//1  only  provides  the
             character count.


llaazzyy__lliisstt__cchhaarraacctteerr__ccoouunntt((_-_C_h_a_r_C_o_u_n_t)) //
    True  when _C_h_a_r_C_o_u_n_t  is  the current  character count  in the  Lazy
    list.   The character count  is computed by finding the distance  to
    the next frozen tail of the lazy list.  _C_h_a_r_C_o_u_n_t is one of:

      o  An integer

      o  A term end_of_file-Count

         SSeeee aallssoo lazy_list_location//1  provides  full details  of
             the location for error reporting.


ssttrreeaamm__ttoo__llaazzyy__lliisstt((_+_S_t_r_e_a_m_, _-_L_i_s_t))                                 _[_d_e_t_]
    Create  a  lazy list  representing the  character  codes in  _S_t_r_e_a_m.
    _L_i_s_t  is a partial list ending in an attributed variable.   Unifying
    this  variable reads the next  block of data.   The block is  stored
    with the attribute value such that there is no need to re-read it.

         CCoommppaattiibbiilliittyy Unlike  the previous version  of this predi-
             cate  this version  does not require  a repositionable
             stream.   It  does require a  buffer size  of at least
             the  maximum number of bytes  of a multi-byte sequence
             (6).


1144..2255 lliibbrraarryy((pprreeddiiccaattee__ooppttiioonnss))::   DDeeccllaarree  ooppttiioonn--pprroocceessssiinngg ooff  pprreeddii--
      ccaatteess

               _D_i_s_c_u_s_s_i_o_n_s _w_i_t_h _J_e_f_f _S_c_h_u_l_t_z _h_e_l_p_e_d _s_h_a_p_i_n_g _t_h_i_s _l_i_b_r_a_r_y


1144..2255..11 TThhee ssttrreennggtthh aanndd wweeaakknneessss ooff pprreeddiiccaattee ooppttiioonnss

Many  ISO  predicates  accept   options,  e.g.,   open/4,  write_term/3.
Options  offer an  attractive  alternative  to proliferation  into  many
predicates and using high-arity predicates.  Properly  defined and used,
they also  form a  mechanism for extending  the API  of both system  and
application predicates without  breaking portability.  I.e.,  previously
fixed behaviour  can be replaced by  dynamic behaviour controlled by  an
option  where the  default is  the previously  defined fixed  behaviour.
The  alternative to  using  options is  to  add an  additional  argument
and maintain  the previous  definition.   While a  series of  predicates
with  increasing arity  is adequate  for a  small  number of  additional
parameters, the untyped  positional argument handling of Prolog  quickly
makes this unmanageable.

The ISO standard  uses the extensibility offered by options  by allowing
implementations to extend  the set of accepted  options.  While  options
form a  perfect solution to  maintain backward  portability in a  linear
development  model, it  is not  well equipped  to  deal with  concurrent
branches because

 1. There is no API  to find which options are supported in a particular
    implementation.

 2. While  the  portability problem  caused by  a  missing predicate  in
    Prolog _A can  easily be solved by implementing this predicate, it is
    much harder to  add processing of an additional option to an already
    existing predicate.

Different Prolog implementations  can be seen as concurrent  development
branches of the  Prolog language.   Different sets of supported  options
pose a serious  portability issue.   Using an option _O that  establishes
the desired behaviour  on system _A leads  (on most systems) to an  error
or system _B. Porting may require several actions:

  o Drop  _O (if the option is not  vital, such as the layout  options to
    write_term/3)

  o Replace _O by _O_2 (i.e., a differently named option doing the same)

  o Something  else  (cannot be  ported;  requires a  totally  different
    approach, etc.)

Predicates that process options are particularly a  problem when writing
a compatibility layer to  run programs developed for System _A  on System
_B  because  complete  emulation is  often  hard,  may  cause  a  serious
slowdown and  is often not  needed because the  application-to-be-ported
only uses options that are shared by all  target Prolog implementations.
Unfortunately,  the  consequences  of  a  partial  emulation  cannot  be
assessed by tools.


1144..2255..22 OOppttiioonnss aass aarrgguummeennttss oorr eennvviirroonnmmeenntt??

We distinguish two views on  options.  One is to see them  as additional
parameters that require  strict existence, type and domain-checking  and
the other  is to consider them  `locally scoped environment  variables'.
Most systems  adopt the  first option.   SWI-Prolog  adopts the  second:
it silently  ignores options that  are not supported  but does type  and
domain checking  of option-values.   The `environment' view is  commonly
used in applications to create predicates supporting  more options using
the skeleton  below.   This way of programming  requires that _p_r_e_d_1  and
_p_r_e_d_2 do  not interpret  the same option  differently.   In cases  where
this is  not true,  the options  must be distributed  by _s_o_m_e___p_r_e_d.    We
have been using  this programming style for  many years and in  practice
it  turns out  that  the need  for  active  distribution of  options  is
rare.  I.e.,  options either have distinct names or  multiple predicates
implement the same option  but this has the desired effect.   An example
of  the latter  is the  encoding  option, which  typically needs  to  be
applied consistently.

________________________________________________________________________|                                                                        |
|some_pred(..., Options) :-                                              |

|      pred1(..., Options),                                              |
||_____pred2(...,_Options)._____________________________________________ ||

As stated before,  options provide a readable alternative  to high-arity
predicates and offer  a robust mechanism to  evolve the API, but at  the
cost  of some  runtime overhead  and weaker  consistency checking,  both
at compiletime  and runtime.    From our  experience, the  `environment'
approach is  productive, but  the consequence is  that mistyped  options
are  silently ignored.    The option  infrastructure  described in  this
section tries to remedy these problems.


1144..2255..33 IImmpprroovviinngg oonn tthhee ccuurrrreenntt ssiittuuaattiioonn

Whether  we see  options  as  arguments or  locally  scoped  environment
variables, the most obvious  way to improve on the current  situation is
to provide  reflective support for options:   discover that an  argument
is  an option-list  and find  what options  are supported.    Reflective
access  to  options  can  be  used  by  the   compiler  and  development
environment as well as by the runtime system to warn or throw errors.


1144..2255..33..11 OOppttiioonnss aass ttyyppeess

An obvious  approach to  deal with  options is to  define the  different
possible option values  as a type and  type the argument that  processes
the option  as list(<option_type>),  as illustrated below.   Considering
options as  types fully  covers the  case where we  consider options  as
additional parameters.

________________________________________________________________________|                                                                        |
|:- type open_option ---> type(stream_type) |                            |

|                         alias(atom) | ... .                            |
|:-|pred_open(source_sink,_open_mode,_stream,_list(open_option))._______ |  |

There are three reasons for considering a different approach:

  o There  is no  consensus about  types  in the  Prolog world,  neither
    about  what types  should look  like, nor  whether or  not they  are
    desirable.    It is  not likely that  this debate  will be  resolved
    shortly.

  o Considering  options as  types  does not  support the  `environment'
    view, which we consider the most productive.

  o Even  when using types,  we need reflective  access to what  options
    are  provided  in order  to  be able  to  write compile  or  runtime
    conditional code.


1144..2255..33..22 RReefflleeccttiivvee aacccceessss ttoo ooppttiioonnss

From  the above,  we  conclude  that  we require  reflective  access  to
find  out whether  an option  is supported  and valid  for a  particular
predicate.  Possible option  values must be described by types.   Due to
lack of a type system, we use library(error)  to describe allowed option
values.  Predicate options are declared using predicate_options/3:


pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _+_A_r_g_, _+_O_p_t_i_o_n_s))                             _[_d_e_t_]
    Declare that the predicate  _P_I processes options on _A_r_g.  _O_p_t_i_o_n_s is
    a list of options processed.  Each element is one of:

      o  Option(ModeAndType)  _P_I processes  Option.    The  option-value
         must comply to ModeAndType.  Mode is one of + or  - and Type is
         a type as accepted by must_be/2.

      o  pass_to(:_P_I,_A_r_g)  The  option-list is  passed to  the  indicated
         predicate.

    Below  is an example that  processes the option header(boolean)  and
    passes all options to open/4:

    ____________________________________________________________________|                                                                    |

    | :- predicate_options(write_xml_file/3, 3,                          |
    |                      [ header(boolean),                            |
    |                        pass_to(open/4, 4)                          |
    |                      ]).                                           |
    |                                                                    |

    | write_xml_file(File, XMLTerm, Options) :-                          |
    |     open(File, write, Out, Options),                               |
    |     (   option(header(true), Options, true)                        |
    |     ->  write_xml_header(Out)                                      |
    |     ;   true                                                       |
    |     ),                                                             |
    ||____...___________________________________________________________ ||

    This  predicate may only be used as a _d_i_r_e_c_t_i_v_e and is  processed by
    expand_term/2.  Option processing can be  specified at runtime using
    assert_predicate_options/3,  which is  intended to  support  program
    analysis.


aasssseerrtt__pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _+_A_r_g_, _+_O_p_t_i_o_n_s_, _?_N_e_w))            _[_s_e_m_i_d_e_t_]
    As  predicate_options(:_P_I, +_A_r_g,   +_O_p_t_i_o_n_s).    _N_e_w  is  a  boolean
    indicating  whether  the  declarations have  changed.    If  _N_e_w  is
    provided and false,  the predicate becomes semidet and fails without
    modifications if modifications are required.

The  predicates  below  realise the  support  for  compile  and  runtime
checking for supported options.


ccuurrrreenntt__pprreeddiiccaattee__ooppttiioonn((_:_P_I_, _?_A_r_g_, _?_O_p_t_i_o_n))                    _[_n_o_n_d_e_t_]
    True  when _A_r_g of _P_I processes  _O_p_t_i_o_n.  For example,  the following
    is true:

    ____________________________________________________________________|                                                                    |
    | ?- current_predicate_option(open/4, 4, type(text)).                |
    ||true._____________________________________________________________ ||

    This predicate is  intended to support conditional compilation using
    if/1  ...   endif/0.  The  predicate current_predicate_options/3 can
    be used to access the full capabilities of a predicate.


cchheecckk__pprreeddiiccaattee__ooppttiioonn((_:_P_I_, _+_A_r_g_, _+_O_p_t_i_o_n))                         _[_d_e_t_]
    Verify    predicate   options    at   runtime.         Similar    to
    current_predicate_option/3,   but   intended  to   support   runtime
    checking.

         EErrrroorrss
             -  existence_error(option, OptionName)  if  the option
             is not supported by _P_I.
             -  type_error(Type, Value) if the  option is supported
             but  the value does  not match the  option type.   See
             must_be/2.

The predicates below can be used in a development  environment to inform
the user  about supported  options.   PceEmacs uses  this for  colouring
option names and values.


ccuurrrreenntt__ooppttiioonn__aarrgg((_:_P_I_, _?_A_r_g))                                   _[_n_o_n_d_e_t_]
    True when _A_r_g of  _P_I processes predicate options.  Which options are
    processed can be accessed using current_predicate_option/3.


ccuurrrreenntt__pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _?_A_r_g_, _?_O_p_t_i_o_n_s))                  _[_n_o_n_d_e_t_]
    True  when _O_p_t_i_o_n_s is the  current active option declaration for  _P_I
    on _A_r_g.   See predicate_options/3for the  argument descriptions.  If
    _P_I  is ground and refers  to an undefined predicate, the  autoloader
    is used to obtain a definition of the predicate.

The  library  can  execute  a  complete  check  of  your  program  using
check_predicate_options/0:


cchheecckk__pprreeddiiccaattee__ooppttiioonnss                                            _[_d_e_t_]
    Analyse  loaded  program  for erroneous  options.    This  predicate
    decompiles the current  program and searches for calls to predicates
    that  process options.  For  each option list, it validates  whether
    the  provided  options  are  supported and  validates  the  argument
    type.   This predicate  performs partial dataflow analysis to  track
    option-lists inside a clause.

         SSeeee aallssoo derive_predicate_options/0 can be  used to derive
             declarations   for  predicates   that   pass  options.
             This  predicate   should  normally  be  called  before
             check_predicate_options/0.

The library  offers predicates that may  be used to create  declarations
for your application.   These predicates are designed to  cooperate with
the module system.


ddeerriivvee__pprreeddiiccaattee__ooppttiioonnss                                           _[_d_e_t_]
    Derive  new predicate option declarations.  This  predicate analyses
    the  loaded program to find  clauses that process options using  one
    of  the predicates from library(option)  or passes options to  other
    predicates  that  are known  to process  options.    The process  is
    repeated until no new declarations are retrieved.

         SSeeee aallssoo autoload/0  may  be used  to complete  the loaded
             program.


rreettrraaccttaallll__pprreeddiiccaattee__ooppttiioonnss                                       _[_d_e_t_]
    Remove all dynamically (derived) predicate options.


ddeerriivveedd__pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _?_A_r_g_, _?_O_p_t_i_o_n_s))                  _[_n_o_n_d_e_t_]
    Derive  option arguments using static  analysis.  True when  _O_p_t_i_o_n_s
    is the current _d_e_r_i_v_e_d active option declaration for _P_I on _A_r_g.


ddeerriivveedd__pprreeddiiccaattee__ooppttiioonnss((_+_M_o_d_u_l_e))                                 _[_d_e_t_]
    Derive  predicate option  declarations for  a module.   The  derived
    options are printed to the current_output stream.


1144..2266 lliibbrraarryy((pprroolloogg__ppaacckk))::  AA ppaacckkaaggee mmaannaaggeerr ffoorr PPrroolloogg

    SSeeee aallssoo  Installed   packages  can   be  inspected   using  ?-
         doc_browser.

    TToo bbee ddoonnee
         - Version logic
         - Find and resolve conflicts
         - Upgrade git packages
         - Validate git packages
         - Test packages:  run tests from directory `test'.

The library(prolog_pack) provides the SWI-Prolog package manager.   This
library lets  you inspect installed  packages, install packages,  remove
packages, etc.   It is complemented by the  built-in attach_packs/0 that
makes installed packages available as libaries.


ppaacckk__lliisstt__iinnssttaalllleedd                                                _[_d_e_t_]
    List  currently  installed  packages.     Unlike  pack_list/1,  only
    locally  installed packages are displayed and no connection  is made
    to the internet.

         SSeeee aallssoo Use pack_list/1 to find packages.


ppaacckk__iinnffoo((_+_P_a_c_k))
    Print more detailed information about _P_a_c_k.


ppaacckk__sseeaarrcchh((_+_Q_u_e_r_y))                                                _[_d_e_t_]


ppaacckk__lliisstt((_+_Q_u_e_r_y))                                                  _[_d_e_t_]
    _Q_u_e_r_y  package server  and installed packages  and display  results.
    _Q_u_e_r_y  is matches case-insensitively against  the name and title  of
    known  and installed packages.  For each matching package,  a single
    line is displayed that provides:

      o  Installation status

           {{ pp:  package, not installed

           {{ ii:  installed package; up-to-date with public version

           {{ UU: installed package; can be upgraded

           {{ AA: installed package; newer than publically available

           {{ ll:  installed package; not on server

      o  Name@Version

      o  Name@Version(ServerVersion)

      o  Title

    Hint:  ?- pack_list(''). lists all packages.

    The  predicates pack_list/1 and  pack_search/1 are synonyms.    Both
    contact  the  package server  at http://www.swi-prolog.org  to  find
    available packages.

         SSeeee aallssoo pack_list_installed/0 to  list installed packages
             without contacting the server.


ppaacckk__iinnssttaallll((_+_S_p_e_c_:_a_t_o_m))                                           _[_d_e_t_]
    Install a package.  _S_p_e_c is one of

      o  Archive file name

      o  HTTP URL of an archive file name.  This URL  may contain a star
         (*) for the  version.   In this case pack_install asks for  the
         directory content and selects the latest version.

      o  GIT URL (not well supported yet)

      o  A local directory name given as file:// URL.

      o  A  package name.     This  queries the  package  repository  at
         http://www.swi-prolog.org

    After  resolving the type of  package, pack_install/2 is used to  do
    the actual installation.


ppaacckk__iinnssttaallll((_+_N_a_m_e_, _+_O_p_t_i_o_n_s))                                      _[_d_e_t_]
    Install  package  _N_a_m_e.    Processes the  options  below.    Default
    options as  would be used by pack_install/1are  used to complete the
    provided _O_p_t_i_o_n_s.

    uurrll((_+_U_R_L))
         Source for downloading the package

    ppaacckkaaggee__ddiirreeccttoorryy((_+_D_i_r))
         Directory into which to install the package

    iinntteerraaccttiivvee((_+_B_o_o_l_e_a_n))
         Use  default answer  without  asking the  user  if there  is  a
         default action.

    ssiilleenntt((_+_B_o_o_l_e_a_n))
         If  true  (default  false),   suppress  informational  progress
         messages.

    uuppggrraaddee((_+_B_o_o_l_e_a_n))
         If true  (default  false),  upgrade package  if it  is  already
         installed.

    ggiitt((_+_B_o_o_l_e_a_n))
         If true  (default false  unless _U_R_L ends  with =.git=),  assume
         the URL is a GIT repository.

    Non-interactive  installation can  be established  using the  option
    interactive(false).    It is  adviced to install  from a  particular
    _t_r_u_s_t_e_d   URL  instead  of  the  plain  pack  name   for  unattented
    operation.


ppaacckk__uurrll__ffiillee((_+_U_R_L_, _-_F_i_l_e))                                         _[_d_e_t_]
    True  if _F_i_l_e is  a unique id for  the referenced pack and  version.
    Normally, that is  simply the base name, but GitHub archives destroy
    this picture.  Needed by the pack manager.


ppaacckk__rreebbuuiilldd((_+_P_a_c_k))                                                _[_d_e_t_]
    Rebuilt possible foreign components of _P_a_c_k.


ppaacckk__rreebbuuiilldd                                                       _[_d_e_t_]
    Rebuild foreign components of all packages.


eennvviirroonnmmeenntt((_-_N_a_m_e_, _-_V_a_l_u_e))                           _[_n_o_n_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook   to  define  the  environment  for  building  packs.      This
    Multifile hook extends  the process environment for building foreign
    extensions.    A  value  provided by  this hook  overrules  defaults
    provided  by  def_environment/2.     In  addition  to  changing  the
    environment,  this  may be  used to  pass additional  values to  the
    environment, as in:

    ____________________________________________________________________|                                                                    |
    | prolog_pack:environment('USER', User) :-                           |
    ||____getenv('USER',_User)._________________________________________ ||

    ___________________________________________________________Arguments_
     _N_a_m_e   is an atom denoting a valid variable name
     _V_a_l_u_e  is  either an  atom or  number representing  the
            value of the variable.


ppaacckk__uuppggrraaddee((_+_P_a_c_k))                                            _[_s_e_m_i_d_e_t_]
    Try to upgrade the package _P_a_c_k.

         TToo bbee ddoonnee Update  dependencies when updating  a pack from
             git?


ppaacckk__rreemmoovvee((_+_N_a_m_e))                                                 _[_d_e_t_]
    Remove the indicated package.


ppaacckk__pprrooppeerrttyy((_?_P_a_c_k_, _?_P_r_o_p_e_r_t_y))                                 _[_n_o_n_d_e_t_]
    True  when  _P_r_o_p_e_r_t_y is  a property  of  an installed  _P_a_c_k.    This
    interface  is intended for programs  that wish to interact with  the
    package manager.  Defined properties are:

    ddiirreeccttoorryy((_D_i_r_e_c_t_o_r_y))
         _D_i_r_e_c_t_o_r_y into which the package is installed

    vveerrssiioonn((_V_e_r_s_i_o_n))
         Installed version

    ttiittllee((_T_i_t_l_e))
         Full title of the package

    aauutthhoorr((_A_u_t_h_o_r))
         Registered author

    ddoowwnnllooaadd((_U_R_L))
         Official download _U_R_L

    rreeaaddmmee((_F_i_l_e))
         Package README file (if present)

    ttooddoo((_F_i_l_e))
         Package TODO file (if present)


1144..2277 lliibbrraarryy((pprroolloogg__xxrreeff))::  CCrroossss--rreeffeerreennccee ddaattaa ccoolllleeccttiioonn lliibbrraarryy

This library collects information on defined and used  objects in Prolog
source  files.    Typically these  are  predicates,  but we  expect  the
library  to deal  with  other types  of  objects in  the  future.    The
library  is a  building block  for tools  doing  dependency tracking  in
applications.  Dependency tracking is useful to reveal  the structure of
an unknown  program or detect  missing components  at compile time,  but
also for program  transformation or minimising a program saved  state by
only saving the reachable objects.

This section gives  a partial description of the library  API, providing
some insight  in how you  can use it  for analysing your  program.   The
library should be  further modularized, moving its knowledge about,  for
example, XPCE  into a different file  and allowing for adding  knowledge
about other  libraries such  as Logtalk.   PPlleeaassee  ddoo nnoott ccoonnssiiddeerr  tthhiiss
iinntteerrffaaccee rroocckk--ssoolliidd..

The  library is  exploited  by two  graphical  tools in  the  SWI-Prolog
environment:   the XPCE front-end  started by  gxref/0 and described  in
section ????, and  PceEmacs (section ????), which exploits this  library for
its syntax colouring.

For  all predicates  described  below,  _S_o_u_r_c_e  is the  source  that  is
processed.    This is  normally a  filename in  any notation  acceptable
to the  file loading  predicates (see  load_files/2).    Using the  hooks
defined in  section ???? it  can be anything else  that can be  translated
into  a Prolog  stream  holding  Prolog source  text.    _C_a_l_l_a_b_l_e  is  a
callable  term (see  callable/1).    Callables  do  not carry  a  module
qualifier unless  the referred predicate  is not  in the module  defined
_S_o_u_r_c_e.


xxrreeff__ssoouurrccee((_+_S_o_u_r_c_e))
    Gather information on  _S_o_u_r_c_e.  If _S_o_u_r_c_e has already been processed
    and  is still up-to-date according to the file timestamp,  no action
    is  taken.     This  predicate  must be  called  on  a  file  before
    information can be gathered.


xxrreeff__ccuurrrreenntt__ssoouurrccee((_?_S_o_u_r_c_e))
    _S_o_u_r_c_e has been processed.


xxrreeff__cclleeaann((_+_S_o_u_r_c_e))
    Remove the information gathered for _S_o_u_r_c_e


xxrreeff__ddeeffiinneedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e_, _-_H_o_w))
    _C_a_l_l_a_b_l_e is defined in _S_o_u_r_c_e.  _H_o_w is one of

             dynamic(_L_i_n_e)       Declared dynamic at _L_i_n_e

             thread_local(_L_i_n_e)  Declared thread local at _L_i_n_e
             multifile(_L_i_n_e)     Declared multifile at _L_i_n_e
             local(_L_i_n_e)         First clause at _L_i_n_e
             foreign(_L_i_n_e)       Foreign library loaded at _L_i_n_e
             constraint(_L_i_n_e)    CHR Constraint at _L_i_n_e
             imported(_F_i_l_e)      Imported from _F_i_l_e


xxrreeff__ccaalllleedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e_, _?_B_y))
    _C_a_l_l_a_b_l_e is called in _S_o_u_r_c_e by _B_y.


xxrreeff__eexxppoorrtteedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e))
    _C_a_l_l_a_b_l_e is public (exported from the module).


xxrreeff__mmoodduullee((_?_S_o_u_r_c_e_, _?_M_o_d_u_l_e))
    _S_o_u_r_c_e is a module file defining the given module.


xxrreeff__bbuuiilltt__iinn((_?_C_a_l_l_a_b_l_e))
    True  if  _C_a_l_l_a_b_l_e is  a  built-in predicate.    Currently  this  is
    assumed  for all predicates defined in the system module  and having
    the  property built_in.  Built-in  predicates are not registered  as
    `called'.


1144..2277..11 EExxtteennddiinngg tthhee lliibbrraarryy

The library provides hooks  for extending the rules it uses  for finding
predicates called by some programming construct.


pprroolloogg::ccaalllleedd__bbyy((_+_G_o_a_l_, _-_C_a_l_l_e_d))
    _G_o_a_l is a  non-var subgoal appearing in the called object (typically
    a  clause body).   If  it succeeds it  must return  a list of  goals
    called  by _G_o_a_l.    As a  special construct,  if a  term Callable +N
    is  returned,  N variable  arguments are  added to  _C_a_l_l_a_b_l_e before
    further  processing.  For simple meta-calls a single  fact suffices.
    Complex  rules as  used in  the html_write library  provided by  the
    HTTP  package examine  the  arguments and  create a  list of  called
    objects.

    The  current  system   cannot  deal  with  the  same  name/arity  in
    different  modules that  behave differently with  respect to  called
    arguments.


1144..2288 lliibbrraarryy((qquuaassii__qquuoottaattiioonnss))::  DDeeffiinnee QQuuaassii QQuuoottaattiioonn ssyynnttaaxx

    aauutthhoorr  Jan Wielemaker.    Introduction of Quasi  Quotation was
         suggested by Michael Hendricks.

    SSeeee aallssoo  http://www.cs.tufts.edu/comp/150FP/archive/geoff-
         mainland/quasiquoting.pdfWhy  it's  nice   to  be  quoted:
         quasiquoting for haskell

Inspired  by   http://www.haskell.org/haskellwiki/QuasiquotationHaskell,
SWI-Prolog  support  _q_u_a_s_i  _q_u_o_t_a_t_i_o_n.     Quasi  quotation  allows  for
embedding  (long) strings  using  the  syntax of  an  external  language
(e.g., HTML,  SQL) in Prolog text  and syntax-aware embedding of  Prolog
variables in this  syntax.  At  the same time, quasi quotation  provides
an alternative to represent long strings and atoms in Prolog.

The basic  form of a  quasi quotation is  defined below.   Here,  _S_y_n_t_a_x
is an  arbitrary Prolog term  that must parse into  a _c_a_l_l_a_b_l_e (atom  or
compound) term  and Quotation  is an arbitrary  sequence of  characters,
not including the sequence  |}.  If this sequence needs to  be embedded,
it must be escaped according to the rules of the  target language or the
`quoter' must provide an escaping mechanism.

________________________________________________________________________|                                                                        |

|{|Syntax||Quotation|}|_________________________________________________ |                     |

While reading  a Prolog  term, and  if the Prolog  flag quasi_quotes  is
set to true  (which is the case if  this library is loaded), the  parser
collects  quasi quotations.    After reading  the final  full stop,  the
parser makes  the call  below.   Here,  _S_y_n_t_a_x_N_a_m_e is  the functor  name
of _S_y_n_t_a_x above  and _S_y_n_t_a_x_A_r_g_s is a  list holding the arguments,  i.e.,
Syntax =.. [SyntaxName|SyntaxArgs].  Splitting the syntax  into its name
and arguments  is done to  make the quasi  quotation parser a  predicate
with  a consistent  arity  4, regardless  of  the number  of  additional
arguments.

________________________________________________________________________|                                                                        |
|call(+SyntaxName,|+Content,_+SyntaxArgs,_+VariableNames,_-Result)______ |                 |

The arguments are defined as

  o _S_y_n_t_a_x_N_a_m_e  is the principal functor of the quasi  quotation syntax.
    This  must be declared using quasi_quotation_syntax/1and  there must
    be a predicate SyntaxName/4.

  o _C_o_n_t_e_n_t  is an  opaque term that  carries the  content of the  quasi
    quoted material and  position information about the source code.  It
    is passed to with_quasi_quote_input/3.

  o _S_y_n_t_a_x_A_r_g_s  carries the additional arguments  of the _S_y_n_t_a_x.   These
    are  commonly used to make the parameter passing between  the clause
    and the quasi quotation explicit.  For example:

    ____________________________________________________________________|                                                                    |

    |     ...,                                                           |
    |     {|html(Name, Address)||                                        |
    |      <tr><td>Name<td>Address</tr>                                  |
    ||_____|}___________________________________________________________ ||

  o _V_a_r_i_a_b_l_e_N_a_m_e_s  is the  complete  variable dictionary  of the  clause
    as  it   is  made  available  throug  read_term/3  with  the  option
    variable_names.  It is a list of terms Name = Var.

  o _R_e_s_u_l_t  is  a  variable that  must  be  unified to  resulting  term.
    Typically,  this  term  is structured  Prolog  tree that  carries  a
    (partial)  representation of the abstract syntax tree  with embedded
    variables  that pass the Prolog parameters.   This term is  normally
    either  passed to  a predicate that  serializes the abstract  syntax
    tree,  or a  predicate that  processes the  result in Prolog.    For
    example,  HTML  is  commonly  embedded for  writing  HTML  documents
    (see  library(http/html_write)).  Examples of languages that  may be
    embedded  for processing  in Prolog  are SPARQL,  RuleML or  regular
    expressions.

The  file library(http/html_quasiquotations)  provides the,  suprisingly
simple, quasi quotation parser for HTML.


wwiitthh__qquuaassii__qquuoottaattiioonn__iinnppuutt((_+_C_o_n_t_e_n_t_, _-_S_t_r_e_a_m_, _:_G_o_a_l))                _[_d_e_t_]
    Process  the  quasi-quoted  _C_o_n_t_e_n_t  using _S_t_r_e_a_m  parsed  by  _G_o_a_l.
    _S_t_r_e_a_m is a temporary stream with the following properties:

      o  Its initial _p_o_s_i_t_i_o_n  represents the position  of the start  of
         the quoted material.

      o  It is a text stream, using utf8 _e_n_c_o_d_i_n_g.

      o  It allows for repositioning

      o  It will be closed after _G_o_a_l completes.

    ___________________________________________________________Arguments_
     _G_o_a_l  is  executed as once(Goal).  _G_o_a_l must  succeed.
           Failure or exceptions from _G_o_a_l are  interpreted
           as syntax errors.

         SSeeee aallssoo phrase_from_quasi_quotation/2  can  be   used  to
             process a quotation using a grammar.


pphhrraassee__ffrroomm__qquuaassii__qquuoottaattiioonn((_:_G_r_a_m_m_a_r_, _+_C_o_n_t_e_n_t))                     _[_d_e_t_]
    Process  the quasi quotation using the DCG _G_r_a_m_m_a_r.  Failure  of the
    grammar is interpreted as a syntax error.

         SSeeee aallssoo with_quasi_quotation_input/3 for  processing quo-
             tations from stream.


qquuaassii__qquuoottaattiioonn__ssyynnttaaxx((_:_S_y_n_t_a_x_N_a_m_e))                                _[_d_e_t_]
    Declare the predicate  _S_y_n_t_a_x_N_a_m_e/4 to implement the the quasi quote
    syntax _S_y_n_t_a_x_N_a_m_e.  Normally used as a directive.


qquuaassii__qquuoottaattiioonn__ssyynnttaaxx__eerrrroorr((_+_E_r_r_o_r))
    Report  syntax_error(Error) using the current location in  the quasi
    quoted input parser.

         tthhrroowwss error(syntax_error(Error), Position)


1144..2299 lliibbrraarryy((rraannddoomm))::  RRaannddoomm nnuummbbeerrss

    aauutthhoorr  R.A. O'Keefe, V.S. Costa, L. Damas, Jan Wielemaker

    SSeeee aallssoo  Built-in function random/1:  A is random(10)

This  library  is  derived  from the  DEC10  library  random.     Later,
the  core random  generator was  moved to  C. The  current version  uses
the SWI-Prolog  arithmetic functions  to realise  this library.    These
functions are based on the GMP library.


rraannddoomm((_-_R_:_f_l_o_a_t))                                                  _[_d_e_t_]
    Binds _R to a new random float in the _o_p_e_n interval (0.0,1.0).

         SSeeee aallssoo
             -  setrand/1, getrand/1 may  be used  to fetch/set the
             state.
             -  In  SWI-Prolog,  random/1  is  implemented  by  the
             function random_float/0.


rraannddoomm__bbeettwweeeenn((_+_L_:_i_n_t_, _+_U_:_i_n_t_, _-_R_:_i_n_t))                         _[_s_e_m_i_d_e_t_]
    Binds  _R to a random  integer in [_L,_U]  (i.e., including both _L  and
    _U). Fails silently if _U<_L.


rraannddoomm((_+_L_:_i_n_t_, _+_U_:_i_n_t_, _-_R_:_i_n_t))                                    _[_d_e_t_]


rraannddoomm((_+_L_:_f_l_o_a_t_, _+_U_:_f_l_o_a_t_, _-_R_:_f_l_o_a_t))                              _[_d_e_t_]
    Generate a random integer or  float in a range.  If _L and _U are both
    integers, _R is a  random integer in the half open interval [_L,_U). If
    _L and _U are both floats, _R is a float in the open interval (_L,_U).

         ddeepprreeccaatteedd Please  use  random/1 for  generating  a random
             float  and  random_between/3 for  generating  a random
             integer.     Note that  random_between/3  includes the
             upper bound, while this predicate excludes it.


sseettrraanndd((_+_S_t_a_t_e))                                                   _[_d_e_t_]


ggeettrraanndd((_-_S_t_a_t_e))                                                   _[_d_e_t_]
    Query/set  the state of the random generator.  This is  intended for
    restarting  the generator  at a  known state  only.   The  predicate
    setrand/1  accepts an opaque term returned by getrand/1.   This term
    may  be asserted, written  and read.   The application may not  make
    other assumptions about this term.

    For  compatibility  reasons with  older  versions of  this  library,
    setrand/1  also accepts  a term rand(A,B,C),  where A,  B and C  are
    integers in the range  1..30,000.  This argument is used to seed the
    random generator.  Deprecated.

         EErrrroorrss existence_error(random_state, _)  is raised  if the
             underlying  infrastructure  cannot  fetch  the  random
             state.   This is  currently the case  if SWI-Prolog is
             not compiled with the GMP library.

         SSeeee aallssoo set_random/1  and  random_property/1 provide  the
             SWI-Prolog native implementation.


mmaayybbee                                                         _[_s_e_m_i_d_e_t_]
    Succeed/fail with equal probability (variant of maybe/1).


mmaayybbee((_+_P))                                                     _[_s_e_m_i_d_e_t_]
    Succeed with probability _P, fail with probability 1-_P


mmaayybbee((_+_K_, _+_N))                                                 _[_s_e_m_i_d_e_t_]
    Succeed with probability _K/_N (variant of maybe/1)


rraannddoomm__ppeerrmm22((_?_A_, _?_B_, _?_X_, _?_Y))                                   _[_s_e_m_i_d_e_t_]
    Does _X=_A,_Y=_B or _X=_B,_Y=_A with equal probability.


rraannddoomm__mmeemmbbeerr((_-_X_, _+_L_i_s_t_:_l_i_s_t))                                  _[_s_e_m_i_d_e_t_]
    _X  is  a random  member of  _L_i_s_t.   Equivalent  to random_between(1,
    |_L_i_s_t|), followed by nth1/3.  Fails of _L_i_s_t is the empty list.

         CCoommppaattiibbiilliittyy Quintus and SICStus libraries.


rraannddoomm__sseelleecctt((_-_X_, _+_L_i_s_t_, _-_R_e_s_t))                                _[_s_e_m_i_d_e_t_]


rraannddoomm__sseelleecctt((_+_X_, _-_L_i_s_t_, _+_R_e_s_t))                                    _[_d_e_t_]
    Randomly  select or insert an element.  Either _L_i_s_t or _R_e_s_t  must be
    a list.  Fails if _L_i_s_t is the empty list.

         CCoommppaattiibbiilliittyy Quintus and SICStus libraries.


rraannddsseett((_+_K_:_i_n_t_, _+_N_:_i_n_t_, _-_S_:_l_i_s_t_(_i_n_t_)))                             _[_d_e_t_]
    _S  is a sorted list of _K  unique random integers in the  range 1.._N.
    Implemented  by enumerating  1.._N and  deciding whether  or not  the
    number should be part of the set.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- randset(5, 5, S).                                               |

    | S = [1, 2, 3, 4, 5].          (always)                             |
    | ?- randset(5, 20, S).                                              |
    ||S_=_[2,_7,_10,_19,_20].___________________________________________ ||

         SSeeee aallssoo randseq/3.

         bbuugg Slow if _N is large and _K is small.


rraannddsseeqq((_+_K_:_i_n_t_, _+_N_:_i_n_t_, _-_L_i_s_t_:_l_i_s_t_(_i_n_t_)))                          _[_d_e_t_]
    S  is a  list of _K  unique random  integers in the  range 1.._N.  The
    order is random.  Works as if defined by the following code.

    ____________________________________________________________________|                                                                    |
    | randseq(K, N, List) :-                                             |

    |       randset(K, N, Set),                                          |
    ||______random_permutation(Set,_List).______________________________ ||

         SSeeee aallssoo randset/3.


rraannddoomm__ppeerrmmuuttaattiioonn((_+_L_i_s_t_, _-_P_e_r_m_u_t_a_t_i_o_n))                            _[_d_e_t_]


rraannddoomm__ppeerrmmuuttaattiioonn((_-_L_i_s_t_, _+_P_e_r_m_u_t_a_t_i_o_n))                            _[_d_e_t_]
    _P_e_r_m_u_t_a_t_i_o_n  is a random permutation of  _L_i_s_t.  This is intended  to
    process  the elements of  _L_i_s_t in  random order.   The predicate  is
    symmetric.

         EErrrroorrss instantiation_error, type_error(list, _).


1144..3300 lliibbrraarryy((rreeaadduuttiill))::  RReeaaddiinngg lliinneess,, ssttrreeaammss aanndd ffiilleess

This library contains  primitives to read lines, files,  multiple terms,
etc.   The package clib provides  a shared object (DLL) named  readutil.
If the  library can locate  this shared object it  will use the  foreign
implementation for  reading character codes.   Otherwise  it will use  a
Prolog implementation.    Distributed applications should  make sure  to
deliver the  readutil shared object if  performance of these  predicates
is critical.


rreeaadd__lliinnee__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s))
    Read  the  next line  of  input from  _S_t_r_e_a_m  and unify  the  result
    with  _C_o_d_e_s _a_f_t_e_r the  line has  been read.   A line  is ended by  a
    newline character or end-of-file.  Unlike  read_line_to_codes/3, this
    predicate removes a trailing newline character.

    On  end-of-file  the  atom  end_of_file  is  returned.     See  also
    at_end_of_stream/[0,1].


rreeaadd__lliinnee__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Difference-list  version  to  read  an  input  line  to  a  list  of
    character  codes.    Reading  stops at  the newline  or  end-of-file
    character,  but unlike read_line_to_codes/2, the newline  is retained
    in  the output.  This  predicate is especially useful for reading  a
    block  of lines up to some  delimiter.  The following example  reads
    an HTTP header ended by a blank line:

    ____________________________________________________________________|                                                                    |
    | read_header_data(Stream, Header) :-                                |

    |         read_line_to_codes(Stream, Header, Tail),                  |
    |         read_header_data(Header, Stream, Tail).                    |
    |                                                                    |
    | read_header_data("\r\n", _, _) :- !.                               |
    | read_header_data("\n", _, _) :- !.                                 |
    | read_header_data("", _, _) :- !.                                   |
    | read_header_data(_, Stream, Tail) :-                               |
    |         read_line_to_codes(Stream, Tail, NewTail),                 |

    ||________read_header_data(Tail,_Stream,_NewTail).__________________ ||


rreeaadd__ssttrreeaamm__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s))
    Read all input until end-of-file and unify the result to _C_o_d_e_s.


rreeaadd__ssttrreeaamm__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Difference-list version of read_stream_to_codes/2.


rreeaadd__ffiillee__ttoo__ccooddeess((_+_S_p_e_c_, _-_C_o_d_e_s_, _+_O_p_t_i_o_n_s))
    Read  a  file  to a  list  of  character codes.    _S_p_e_c  is  a  file
    specification  for  absolute_file_name/3.    _C_o_d_e_s is  the  resulting
    code  list.  _O_p_t_i_o_n_s  is a list of  options for absolute_file_name/3
    and open/4.   In addition, the option tail(_T_a_i_l) is defined, forming
    a difference-list.


rreeaadd__ffiillee__ttoo__tteerrmmss((_+_S_p_e_c_, _-_T_e_r_m_s_, _+_O_p_t_i_o_n_s))
    Read  a  file  to  a list  of  Prolog  terms  (see read/1).     _S_p_e_c
    is  a file  specification for  absolute_file_name/3.    _T_e_r_m_s is  the
    resulting  list of  Prolog  terms.   _O_p_t_i_o_n_s  is a  list of  options
    for  absolute_file_name/3 and  open/4.    In  addition,  the  option
    tail(_T_a_i_l) is defined, forming a difference-list.


1144..3311 lliibbrraarryy((rreeccoorrdd))::  AAcccceessss nnaammeedd ffiieellddss iinn aa tteerrmm

The  library  record  provides  named  access  to  fields  in  a  record
represented as a  compound term such as  point(X, Y).  The Prolog  world
knows various  approaches to solve this  problem, unfortunately with  no
consensus.   The approach taken by  this library is proposed by  Richard
O'Keefe on the SWI-Prolog mailinglist.

The  approach  automates  a  technique  commonly   described  in  Prolog
text-books,  where access and  modification predicates  are defined  for
the record type.   Such predicates  are subject to normal  import/export
as well as  analysis by cross-referencers.   Given the simple nature  of
the access  predicates, an  optimizing compiler can  easily inline  them
for optimal preformance.

A record  is defined  using the directive  record/1.   We introduce  the
library with a short example:

________________________________________________________________________|                                                                        |
|:- record point(x:integer=0, y:integer=0).                              |

|                                                                        |
|        ...,                                                            |
|        default_point(Point),                                           |
|        point_x(Point, X),                                              |
|        set_x_of_point(10, Point, Point1),                              |
|                                                                        |
||_______make_point([y(20)],_YPoint),___________________________________ ||

The principal functor  and arity of the  term used defines the name  and
arity of  the compound  used as  records.   Each  argument is  described
using a term of the format below.

    <_n_a_m_e>[:<_t_y_p_e>][=<_d_e_f_a_u_l_t>]

In this definition, <_n_a_m_e> is an atom defining the name of the argument,
<_t_y_p_e> is  an optional type  specification as  defined by must_be/2 from
library error,  and <_d_e_f_a_u_l_t> is the default  initial value.   The <_t_y_p_e>
defaults to  any.  If  no default value is  specified the default is  an
unbound variable.

A  record  declaration  creates  a  set  of   predicates  through  _t_e_r_m_-
_e_x_p_a_n_s_i_o_n.   We describe these predicates  below.  In this  description,
<_c_o_n_s_t_r_u_c_t_o_r> refers to  the name of the record  (`point' in the example
above) and <_n_a_m_e> to the name of an argument (field).

  o _d_e_f_a_u_l_t__<_c_o_n_s_t_r_u_c_t_o_r>_(_-_R_e_c_o_r_d_)
    Create  a new  record where  all fields have  their default  values.
    This is the same as make_<_c_o_n_s_t_r_u_c_t_o_r>([], Record).

  o _m_a_k_e__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_F_i_e_l_d_s_, _-_R_e_c_o_r_d_)
    Create  a  new  record where  specified  fields have  the  specified
    values  and  remaining  fields  have  their default  value.     Each
    field  is specified as  a term <_n_a_m_e>(<_v_a_l_u_e>).   See example  in the
    introduction.

  o _m_a_k_e__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_F_i_e_l_d_s_, _-_R_e_c_o_r_d_, _-_R_e_s_t_F_i_e_l_d_s_)
    Same as  make_<_c_o_n_s_t_r_u_c_t_o_r>/2, but named fields that do not appear in
    _R_e_c_o_r_d  are returned in _R_e_s_t_F_i_e_l_d_s.  This predicate is  motivated by
    option-list processing.  See library option.

  o <_c_o_n_s_t_r_u_c_t_o_r>_<_n_a_m_e>_(_R_e_c_o_r_d_, _V_a_l_u_e_)
    Unify _V_a_l_u_e with argument in _R_e_c_o_r_d named <_n_a_m_e>.

  o <_c_o_n_s_t_r_u_c_t_o_r>__d_a_t_a_(_?_N_a_m_e_, _+_R_e_c_o_r_d_, _?_V_a_l_u_e_)
    True  when _V_a_l_u_e is  the value for the  field named _N_a_m_e in  _R_e_c_o_r_d.
    This predicate does not perform type-checking.

  o _s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _+_O_l_d_R_e_c_o_r_d_, _-_N_e_w_R_e_c_o_r_d_)
    Replace  the value for  <_n_a_m_e> in  _O_l_d_R_e_c_o_r_d by _V_a_l_u_e  and unify the
    result with _N_e_w_R_e_c_o_r_d.

  o _s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _!_R_e_c_o_r_d_)
    Destructively  replace the argument <_n_a_m_e> in  _R_e_c_o_r_d by _V_a_l_u_e based
    on setarg/3.  Use with care.

  o _n_b___s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _!_R_e_c_o_r_d_)
    As   above,   but  using  non-backtrackable   assignment  based   on
    nb_setarg/3.  Use with _e_x_t_r_e_m_e care.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_s_(_+_F_i_e_l_d_s_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_)
    Set  multiple fields using  the same syntax  as make_<_c_o_n_s_t_r_u_c_t_o_r>/2,
    but starting with _R_e_c_o_r_d_0 rather than the default record.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_s_(_+_F_i_e_l_d_s_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_, _-_R_e_s_t_F_i_e_l_d_s_)
    Similar  to  set_<_c_o_n_s_t_r_u_c_t_o_r>_fields/4, but  fields  not  defined by
    <_c_o_n_s_t_r_u_c_t_o_r> are returned in _R_e_s_t_F_i_e_l_d_s.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_(_+_F_i_e_l_d_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_)
    Set a single field specified as a term <_n_a_m_e>(<_v_a_l_u_e>).


rreeccoorrdd((_+_S_p_e_c))
    The  construct  :- record Spec, ...  is  used to  define  access  to
    named  fields in a compound.   It is subject to term-expansion  (see
    expand_term/2) and cannot be called as a predicate.   See section ????
    for details.


1144..3322 lliibbrraarryy((rreeggiissttrryy))::  MMaanniippuullaattiinngg tthhee WWiinnddoowwss rreeggiissttrryy

The registry is only available on the MS-Windows  version of SWI-Prolog.
It loads  the foreign extension  plregtry.dll, providing the  predicates
described below.   This  library only makes  the most common  operations
on the registry available  through the Prolog user.  The  underlying DLL
provides a  more complete coverage of  the Windows registry API.  Please
consult  the  sources  in  pl/src/win32/foreign/plregtry.c  for  further
details.

In  all these  predicates,  _P_a_t_h refers  to a  `/' separated  path  into
the registry.   This  is _n_o_t an atom  containing `/'-characters as  used
for  filenames, but  a term  using the  functor  //2.   Windows  defines
the  following  roots for  the  registry:   classes_root,  current_user,
local_machine and users.


rreeggiissttrryy__ggeett__kkeeyy((_+_P_a_t_h_, _-_V_a_l_u_e))
    Get  the principal (default)  value associated to  this key.   Fails
    silently if the key does not exist.


rreeggiissttrryy__ggeett__kkeeyy((_+_P_a_t_h_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Get a named value associated to this key.


rreeggiissttrryy__sseett__kkeeyy((_+_P_a_t_h_, _+_V_a_l_u_e))
    Set the principal (default)  value of this key.  Creates (a path to)
    the key if it does not already exist.


rreeggiissttrryy__sseett__kkeeyy((_+_P_a_t_h_, _+_N_a_m_e_, _+_V_a_l_u_e))
    Associate  a named value to this key.   Creates (a path to)  the key
    if it does not already exist.


rreeggiissttrryy__ddeelleettee__kkeeyy((_+_P_a_t_h))
    Delete the indicated key.


sshheellll__rreeggiisstteerr__ffiillee__ttyyppee((_+_E_x_t_, _+_T_y_p_e_, _+_N_a_m_e_, _+_O_p_e_n_A_c_t_i_o_n))
    Register  a file-type.   _E_x_t is  the extension to  associate.   _T_y_p_e
    is  the type name,  often something like prolog.type.   _N_a_m_e is  the
    name visible in  the Windows file-type browser.  Finally, _O_p_e_n_A_c_t_i_o_n
    defines  the action to  execute when a  file with this extension  is
    opened in the Windows explorer.


sshheellll__rreeggiisstteerr__ddddee((_+_T_y_p_e_, _+_A_c_t_i_o_n_, _+_S_e_r_v_i_c_e_, _+_T_o_p_i_c_, _+_C_o_m_m_a_n_d_, _+_I_f_N_o_t_R_u_n_n_i_n_g))
    Associate DDE actions to  a type.  _T_y_p_e is the same type as used for
    the 2nd argument of shell_register_file_type/4, _A_c_t_i_o_n is the action
    to  perform, _S_e_r_v_i_c_e  and _T_o_p_i_c  specify the DDE  topic to  address,
    and  _C_o_m_m_a_n_d is  the command  to execute on  this topic.    Finally,
    _I_f_N_o_t_R_u_n_n_i_n_g  defines the  command to  execute if  the required  DDE
    server is not present.


sshheellll__rreeggiisstteerr__pprroolloogg((_+_E_x_t))
    Default registration of  SWI-Prolog, which is invoked as part of the
    initialisation  process on  Windows  systems.   As  the source  also
    includes the above predicates, it is given as an example:

    ____________________________________________________________________|                                                                    |
    | shell_register_prolog(Ext) :-                                      |

    |         current_prolog_flag(argv, [Me|_]),                         |
    |         atomic_list_concat(['"', Me, '" "%1"'], OpenCommand),      |
    |         shell_register_file_type(                                  |
    |             Ext, 'prolog.type', 'Prolog Source', OpenCommand),     |
    |         shell_register_dde(                                        |
    |             'prolog.type', consult,                                |
    |             prolog, control, 'consult(''%1'')', Me),               |
    |         shell_register_dde(                                        |

    |             'prolog.type', edit,                                   |
    ||____________prolog,_control,_'edit(''%1'')',_Me)._________________ ||


1144..3333 lliibbrraarryy((ssiimmpplleexx))::  SSoollvvee lliinneeaarr pprrooggrraammmmiinngg pprroobblleemmss

    aauutthhoorr  https://www.metalevel.atMarkus Triska


1144..3333..11 IInnttrroodduuccttiioonn

A lliinneeaarr pprrooggrraammmmiinngg pprroobblleemm or simply lliinneeaarr pprrooggrraamm (LP) consists of:

  o a set of _l_i_n_e_a_r ccoonnssttrraaiinnttss

  o a set of vvaarriiaabblleess

  o a _l_i_n_e_a_r oobbjjeeccttiivvee ffuunnccttiioonn.

The goal  is to assign  values to  the variables so  as to _m_a_x_i_m_i_z_e  (or
minimize)  the value  of  the objective  function while  satisfying  all
constraints.

Many optimization  problems can be modeled  in this way.   As one  basic
example,  consider a knapsack  with fixed  capacity C, and  a number  of
items with  sizes s(i)  and values v(i).   The  goal is  to put as  many
items as  possible in the  knapsack (not  exceeding its capacity)  while
maximizing the sum of their values.

As another example,  suppose you are given  a set of _c_o_i_n_s with  certain
values, and you are to find the minimum number of  coins such that their
values  sum up  to a  fixed amount.    Instances of  these problems  are
solved below.

Solving  an  LP  or integer  linear  program  (ILP)  with  this  library
typically comprises 4 stages:

 1. an initial state is generated with gen_state/1

 2. all relevant constraints are added with constraint/3

 3. maximize/3  or minimize/3  are used  to obtain a  _s_o_l_v_e_d _s_t_a_t_e  that
    represents an optimum solution

 4. variable_value/3  and objective/2 are  used on  the solved state  to
    obtain variable values and the objective function at the optimum.

The most frequently used predicates are thus:


ggeenn__ssttaattee((_-_S_t_a_t_e))
    Generates  an  initial   state  corresponding  to  an  empty  linear
    program.


ccoonnssttrraaiinntt((_+_C_o_n_s_t_r_a_i_n_t_, _+_S_0_, _-_S))
    Adds  a  linear  or integrality  constraint  to the  linear  program
    corresponding  to state  _S_0.   A linear  constraint is  of the  form
    Left Op C,  where  _L_e_f_t  is  a list  of  Coefficient*Variable  terms
    (variables  in  the  context of  linear  programs  can be  atoms  or
    compound terms) and _C  is a non-negative numeric constant.  The list
    represents  the sum of its elements.   _O_p can be  =, =< or >=.   The
    coefficient  1 can  be omitted.    An integrality  constraint is  of
    the  form integral(Variable) and constrains Variable to  an integral
    value.


mmaaxxiimmiizzee((_+_O_b_j_e_c_t_i_v_e_, _+_S_0_, _-_S))
    Maximizes   the   objective   function,   stated   as  a   list   of
    Coefficient*Variable terms that  represents the sum of its elements,
    with  respect  to  the linear  program  corresponding to  state  _S_0.
    \arg{_S}  is unified  with an internal  representation of  the solved
    instance.


mmiinniimmiizzee((_+_O_b_j_e_c_t_i_v_e_, _+_S_0_, _-_S))
    Analogous to maximize/3.


vvaarriiaabbllee__vvaalluuee((_+_S_t_a_t_e_, _+_V_a_r_i_a_b_l_e_, _-_V_a_l_u_e))
    _V_a_l_u_e  is unified with the value obtained for _V_a_r_i_a_b_l_e.   _S_t_a_t_e must
    correspond to a solved instance.


oobbjjeeccttiivvee((_+_S_t_a_t_e_, _-_O_b_j_e_c_t_i_v_e))
    Unifies  _O_b_j_e_c_t_i_v_e with the result of the objective function  at the
    obtained extremum.  _S_t_a_t_e must correspond to a solved instance.

All numeric  quantities are  converted to  rationals via  rationalize/1,
and rational arithmetic is used throughout solving linear programs.   In
the  current implementation,  all variables  are implicitly  constrained
to  be  _n_o_n_-_n_e_g_a_t_i_v_e.     This  may  change  in  future  versions,   and
non-negativity constraints should therefore be stated explicitly.


1144..3333..22 DDeellaayyeedd ccoolluummnn ggeenneerraattiioonn

_D_e_l_a_y_e_d _c_o_l_u_m_n _g_e_n_e_r_a_t_i_o_n  means that more constraint columns are  added
to an  existing LP. The  following predicates  are frequently used  when
this method is applied:


ccoonnssttrraaiinntt((_+_N_a_m_e_, _+_C_o_n_s_t_r_a_i_n_t_, _+_S_0_, _-_S))
    Like  constraint/3, and attaches the name _N_a_m_e (an atom  or compound
    term) to the new constraint.


sshhaaddooww__pprriiccee((_+_S_t_a_t_e_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Unifies  _V_a_l_u_e with  the shadow  price corresponding  to the  linear
    constraint  whose name is _N_a_m_e.   _S_t_a_t_e must correspond to a  solved
    instance.


ccoonnssttrraaiinntt__aadddd((_+_N_a_m_e_, _+_L_e_f_t_, _+_S_0_, _-_S))
    _L_e_f_t  is a list of Coefficient*Variable terms.  The terms  are added
    to  the left-hand side of the constraint  named _N_a_m_e.  _S  is unified
    with the resulting state.

An    example     application    of     _d_e_l_a_y_e_d    _c_o_l_u_m_n     _g_e_n_e_r_a_t_i_o_n
to    solve    a     _b_i_n    _p_a_c_k_i_n_g    task    is    available     from:
https://www.metalevel.at/various/colgen/mmeettaalleevveell..aatt//vvaarriioouuss//ccoollggeenn//


1144..3333..33 SSoollvviinngg LLPPss wwiitthh ssppeecciiaall ssttrruuccttuurree

The following predicates allow  you to solve specific kinds of  LPs more
efficiently:


ttrraannssppoorrttaattiioonn((_+_S_u_p_p_l_i_e_s_, _+_D_e_m_a_n_d_s_, _+_C_o_s_t_s_, _-_T_r_a_n_s_p_o_r_t))
    Solves  a transportation  problem.    _S_u_p_p_l_i_e_s and  _D_e_m_a_n_d_s must  be
    lists  of non-negative  integers.    Their respective  sums must  be
    equal.    _C_o_s_t_s is  a list of  lists representing  the cost  matrix,
    where  an entry (_i,_j) denotes  the integer cost of transporting  one
    unit  from _i to  _j.   A transportation plan  having minimum cost  is
    computed  and unified with _T_r_a_n_s_p_o_r_t in the form of a list  of lists
    that  represents  the  transportation matrix,  where  element  (_i,_j)
    denotes how many units to ship from _i to _j.


aassssiiggnnmmeenntt((_+_C_o_s_t_, _-_A_s_s_i_g_n_m_e_n_t))
    Solves  a  linear assignment  problem.    _C_o_s_t is  a list  of  lists
    representing   the  quadratic  cost  matrix,  where   element  (i,j)
    denotes  the integer  cost of  assigning entity $i$  to entity  $j$.
    An  assignment  with  minimal  cost is  computed  and  unified  with
    _A_s_s_i_g_n_m_e_n_t as a list of lists, representing an adjacency matrix.


1144..3333..44 EExxaammpplleess

We include a few examples for solving LPs with this library.


1144..3333..44..11 EExxaammppllee 11

This  is the  "radiation therapy"  example, taken  from _I_n_t_r_o_d_u_c_t_i_o_n  _t_o
_O_p_e_r_a_t_i_o_n_s _R_e_s_e_a_r_c_h by Hillier and Lieberman.

https://www.metalevel.at/prolog/dcgPPrroolloogg  DDCCGG   nnoottaattiioonn  is  used   to
_i_m_p_l_i_c_i_t_l_y thread the state through posting the constraints:

________________________________________________________________________|                                                                        |
|:- use_module(library(simplex)).                                        |

|                                                                        |
|radiation(S) :-                                                         |
|        gen_state(S0),                                                  |
|        post_constraints(S0, S1),                                       |
|        minimize([0.4*x1, 0.5*x2], S1, S).                              |
|                                                                        |
|post_constraints -->                                                    |
|        constraint([0.3*x1, 0.1*x2] =< 2.7),                            |

|        constraint([0.5*x1, 0.5*x2] = 6),                               |
|        constraint([0.6*x1, 0.4*x2] >= 6),                              |
|        constraint([x1] >= 0),                                          |
||_______constraint([x2]_>=_0)._________________________________________ ||

An example query:

________________________________________________________________________|                                                                        |
|?- radiation(S), variable_value(S, x1, Val1),                           |
|                 variable_value(S, x2, Val2).                           |

|Val1 = 15 rdiv 2,                                                       |
|Val2|=_9_rdiv_2._______________________________________________________ |    |


1144..3333..44..22 EExxaammppllee 22

Here  is an  instance of  the knapsack  problem described  above,  where
C = 8,  and we  have two types  of items:   One  item with  value 7  and
size 6, and  2 items each having size 4  and value 4.  We  introduce two
variables, x(1)  and x(2)  that denote how  many items  to take of  each
type.

________________________________________________________________________|                                                                        |
|:- use_module(library(simplex)).                                        |

|                                                                        |
|knapsack(S) :-                                                          |
|        knapsack_constraints(S0),                                       |
|        maximize([7*x(1), 4*x(2)], S0, S).                              |
|                                                                        |
|knapsack_constraints(S) :-                                              |
|        gen_state(S0),                                                  |
|        constraint([6*x(1), 4*x(2)] =< 8, S0, S1),                      |

|        constraint([x(1)] =< 1, S1, S2),                                |
||_______constraint([x(2)]_=<_2,_S2,_S).________________________________ ||

An example query yields:

________________________________________________________________________|                                                                        |
|?- knapsack(S), variable_value(S, x(1), X1),                            |
|                variable_value(S, x(2), X2).                            |
|X1 = 1                                                                  |
|X2|=_1_rdiv_2._________________________________________________________ |  |

That is, we are to take the one item of the first  type, and half of one
of the items of the  other type to maximize the total value of  items in
the knapsack.

If items can not be split, integrality constraints have to be imposed:

________________________________________________________________________|                                                                        |

|knapsack_integral(S) :-                                                 |
|        knapsack_constraints(S0),                                       |
|        constraint(integral(x(1)), S0, S1),                             |
|        constraint(integral(x(2)), S1, S2),                             |
||_______maximize([7*x(1),_4*x(2)],_S2,_S)._____________________________ ||

Now the result is different:

________________________________________________________________________|                                                                        |

|?- knapsack_integral(S), variable_value(S, x(1), X1),                   |
|                         variable_value(S, x(2), X2).                   |
|                                                                        |
|X1 = 0                                                                  |
|X2|=_2_________________________________________________________________ |  |

That  is,  we are  to  take  only the  _t_w_o  items of  the  second  type.
Notice in particular  that always choosing the remaining item  with best
performance (ratio  of value to  size) that still  fits in the  knapsack
does  not necessarily  yield  an optimal  solution  in the  presence  of
integrality constraints.


1144..3333..44..33 EExxaammppllee 33

We are given:

  o 3 coins each worth 1 unit

  o 20 coins each worth 5 units and

  o 10 coins each worth 20 units.

The task is to find  a _m_i_n_i_m_a_l number of these coins that amount  to 111
units in total.   We introduce  variables c(1), c(5) and c(20)  denoting
how many coins to take of the respective type:

________________________________________________________________________|                                                                        |

|:- use_module(library(simplex)).                                        |
|                                                                        |
|coins(S) :-                                                             |
|        gen_state(S0),                                                  |
|        coins(S0, S).                                                   |

|                                                                        |
|coins -->                                                               |
|        constraint([c(1), 5*c(5), 20*c(20)] = 111),                     |
|        constraint([c(1)] =< 3),                                        |
|        constraint([c(5)] =< 20),                                       |
|        constraint([c(20)] =< 10),                                      |
|        constraint([c(1)] >= 0),                                        |
|        constraint([c(5)] >= 0),                                        |

|        constraint([c(20)] >= 0),                                       |
|        constraint(integral(c(1))),                                     |
|        constraint(integral(c(5))),                                     |
|        constraint(integral(c(20))),                                    |
||_______minimize([c(1),_c(5),_c(20)])._________________________________ ||

An example query:

________________________________________________________________________|                                                                        |

|?- coins(S), variable_value(S, c(1), C1),                               |
|             variable_value(S, c(5), C5),                               |
|             variable_value(S, c(20), C20).                             |
|                                                                        |
|C1 = 1,                                                                 |
|C5 = 2,                                                                 |
|C20|=_5._______________________________________________________________ |   |


1144..3344 lliibbrraarryy((ssoolluuttiioonn__sseeqquueenncceess))::  MMooddiiffyy ssoolluuttiioonn sseeqquueenncceess

    SSeeee aallssoo
         - all solution predicates findall/3, bagof/3 and setof/3.
         - library(aggregate)

The meta  predicates of this  library modify  the sequence of  solutions
of a  goal.   The  modifications and the  predicate names  are based  on
the classical database operations DISTINCT, LIMIT, OFFSET,  ORDER BY and
GROUP BY.

These   predicates   were    introduced   in   the   context   of    the
http://swish.swi-prolog.orgSWISH  Prolog   browser-based  shell,   which
can  represent the  solutions  to  a predicate  as  a  table.    Notably
wrapping a goal in distinct/1 avoids duplicates in the  result table and
using order_by/2 produces a nicely ordered table.

However,  the predicates  from this  library can  also be  used to  stay
longer  within the  clean  paradigm where  non-deterministic  predicates
are  composed from  simpler  non-deterministic  predicates by  means  of
conjunction and disjunction.   While evaluating a conjunction,  we might
want  to eliminate  duplicates of  the first  part  of the  conjunction.
Below we  give both  the classical  solution for  solving variations  of
(a(X), b(X)) and the ones using this library side-by-side.

    ____________________________________________________________________|                                                                    |
AAvvooiidd||dduupplliiccaatteesssooffeeeaarrlliieerrtsstteeppssof(X, a(X), Xs),               distinct(a(X)),                |

    |   member(X, Xs),                    b(X)                           |
    ||__b(X).___________________________________________________________ ||

    Note that the  distinct/1 based solution returns the first result of
    distinct(a(X))  immediately after a/1  produces a result, while  the
    setof/3 based solution will first compute all results of a/1.

    ____________________________________________________________________|                                                                    |
OOnnllyy|ttrryysb(X)eoonnllyytffoorrotthheefttoopp--1100(a(X)X, a(X), Xs),               limit(10, order_by([desc(X)], a(X))),|
    |   reverse(Xs, Desc),                b(X)                           |
    |   first_max_n(10, Desc, Limit),                                    |
    |   member(X, Limit),                                                |

    ||__b(X)____________________________________________________________ ||

    Here  we see  power of  composing primitives from  this library  and
    staying  within the  paradigm of  pure non-deterministic  relational
    predicates.


ddiissttiinncctt((_:_G_o_a_l))


ddiissttiinncctt((_?_W_i_t_n_e_s_s_, _:_G_o_a_l))
    True  if  _G_o_a_l  is true  and  no  previous solution  of  _G_o_a_l  bound
    _W_i_t_n_e_s_s  to the same value.  As previous answers need to  be copied,
    equivalence testing is  based on _t_e_r_m _v_a_r_i_a_n_c_e (=@=/2).  The variant
    distinct/1 is equivalent to distinct(Goal,Goal).

    If  the answers are ground terms, the predicate behaves as  the code
    below,  but answers are  returned as soon  as they become  available
    rather than first computing the complete answer set.

    ____________________________________________________________________|                                                                    |
    | distinct(Goal) :-                                                  |

    |     findall(Goal, Goal, List),                                     |
    |     list_to_set(List, Set),                                        |
    ||____member(Goal,_Set).____________________________________________ ||


rreedduucceedd((_:_G_o_a_l))


rreedduucceedd((_?_W_i_t_n_e_s_s_, _:_G_o_a_l_, _+_O_p_t_i_o_n_s))
    Similar  to distinct/1,  but does  not guarantee  unique results  in
    return  for  using a  limited amount  of memory.    Both  distinct/1
    and  reduced/1 create  a table that  block duplicate  results.   For
    distinct/1,  this  table may  get  arbitrary large.    In  contrast,
    reduced/1 discards the table  and starts a new one of the table size
    exceeds  a specified  limit.   This  filter is  useful for  reducing
    the  number of answers when  processing large or infinite long  tail
    distributions.  _O_p_t_i_o_n_s:

    ssiizzee__lliimmiitt((_+_I_n_t_e_g_e_r))
         Max number of elements kept in the table.  Default is 10,000.


lliimmiitt((_+_C_o_u_n_t_, _:_G_o_a_l))
    Limit  the number of  solutions.   True if  _G_o_a_l is true,  returning
    at  most _C_o_u_n_t solutions.   Solutions are  returned as soon as  they
    become available.


ooffffsseett((_+_C_o_u_n_t_, _:_G_o_a_l))
    Ignore  the  first _C_o_u_n_t  solutions.    True  if  _G_o_a_l is  true  and
    produces  more than _C_o_u_n_t  solutions.   This predicate computes  and
    ignores the first _C_o_u_n_t solutions.


ccaallll__nntthh((_:_G_o_a_l_, _?_N_t_h))
    True  when _G_o_a_l  succeeded for the  _N_t_h time.   If  _N_t_h is bound  on
    entry,  the  predicate succeeds  deterministically if  there are  at
    least _N_t_h solutions for _G_o_a_l.


oorrddeerr__bbyy((_+_S_p_e_c_, _:_G_o_a_l))
    Order  solutions according to _S_p_e_c.  _S_p_e_c is a list of  terms, where
    each  element is one  of.   The ordering of  solutions of _G_o_a_l  that
    only  differ  in variables  that are  _n_o_t shared  with  _S_p_e_c is  not
    changed.

    aasscc((_T_e_r_m))
         Order solution according to ascending _T_e_r_m

    ddeesscc((_T_e_r_m))
         Order solution according to descending _T_e_r_m


ggrroouupp__bbyy((_+_B_y_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                           _[_n_o_n_d_e_t_]
    Group  bindings of _T_e_m_p_l_a_t_e that have the  same value for _B_y.   This
    predicate  is almost the same as bagof/3, but instead  of specifying
    the  existential  variables  we specify  the  free  variables.    It
    is  provided for  consistency and  complete coverage  of the  common
    database vocabulary.


1144..3355 lliibbrraarryy((tthhrreeaadd__ppooooll))::  RReessoouurrccee bboouunnddeedd tthhrreeaadd mmaannaaggeemmeenntt

    SSeeee aallssoo  http_handler/3 and http_spawn/2.

The  module library(thread_pool)  manages  threads in  pools.    A  pool
defines  properties of  its member  threads and  the  maximum number  of
threads that can coexist  in the pool.  The call  thread_create_in_pool/4
allocates a thread in the pool, just  like thread_create/3.   If the pool
is fully allocated it can be asked to wait or raise an error.

The library  has been  designed to  deal with  server applications  that
receive a variety of requests, such as HTTP servers.   Simply starting a
thread for each request is a bit too simple minded for such servers:

  o Creating  many  CPU intensive  threads often  leads  to a  slow-down
    rather than a speedup.

  o Creating many memory intensive threads may exhaust resources

  o Tasks  that require little CPU and memory but take long  waiting for
    external resources can run many threads.

Using this  library, one can define  a pool for  each set of tasks  with
comparable characteristics and create threads in this pool.   Unlike the
worker-pool model,  threads are not started  immediately.  Depending  on
the design, both approaches can be attractive.

The  library is  implemented  by means  of  a  manager thread  with  the
fixed  thread id  __thread_pool_manager.   All  state  is maintained  in
this manager  thread, which  receives and processes  requests to  create
and destroy  pools, create threads  in a pool  and handle messages  from
terminated threads.   Thread pools  are _n_o_t saved  in a saved state  and
must  therefore be  recreated using  the  initialization/1 directive  or
otherwise during startup of the application.


tthhrreeaadd__ppooooll__ccrreeaattee((_+_P_o_o_l_, _+_S_i_z_e_, _+_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Create  a pool  of threads.    A pool  of threads  is a  declaration
    for  creating  threads  with  shared properties  (stack  sizes)  and
    a   limited  number  of  threads.      Threads  are  created   using
    thread_create_in_pool/4.   If all threads  in the  pool are in  use,
    the  behaviour depends on the wait option of  thread_create_in_pool/4
    and  the backlog  option described  below.   _O_p_t_i_o_n_s  are passed  to
    thread_create/3, except for

    bbaacckklloogg((_+_M_a_x_B_a_c_k_L_o_g))
         Maximum number of requests  that can be suspended.   Default is
         infinite.  Otherwise it must be a non-negative integer.   Using
         backlog(0) will never delay thread creation for this pool.

    The  pooling mechanism does _n_o_t interact with the detached  state of
    a thread.   Threads can be created both detached and normal and must
    be joined using thread_join/2 if they are not detached.


tthhrreeaadd__ppooooll__ddeessttrrooyy((_+_N_a_m_e))                                         _[_d_e_t_]
    Destroy the thread pool named _N_a_m_e.

         EErrrroorrss existence_error(thread_pool, Name).


ccuurrrreenntt__tthhrreeaadd__ppooooll((_?_N_a_m_e))                                      _[_n_o_n_d_e_t_]
    True if _N_a_m_e refers to a defined thread pool.


tthhrreeaadd__ppooooll__pprrooppeerrttyy((_?_N_a_m_e_, _?_P_r_o_p_e_r_t_y))                          _[_n_o_n_d_e_t_]
    True  if  _P_r_o_p_e_r_t_y is  a property  of  thread pool  _N_a_m_e.    Defined
    properties are:

    ooppttiioonnss((_O_p_t_i_o_n_s))
         Thread creation options for this pool

    ffrreeee((_S_i_z_e))
         Number of free slots on this pool

    ssiizzee((_S_i_z_e))
         Total number of slots on this pool

    mmeemmbbeerrss((_L_i_s_t_O_f_I_D_s))
         _L_i_s_t_O_f_I_D_s is the list or threads running in this pool

    rruunnnniinngg((_R_u_n_n_i_n_g))
         Number of running threads in this pool

    bbaacckklloogg((_S_i_z_e))
         Number of delayed thread creations on this pool


tthhrreeaadd__ccrreeaattee__iinn__ppooooll((_+_P_o_o_l_, _:_G_o_a_l_, _-_I_d_, _+_O_p_t_i_o_n_s))                  _[_d_e_t_]
    Create  a thread in _P_o_o_l.  _O_p_t_i_o_n_s overrule default  thread creation
    options  associated to the pool.  In addition, the  following option
    is defined:

    wwaaiitt((_+_B_o_o_l_e_a_n))
         If true (default) and the pool is full, wait until  a member of
         the pool completes.  If false, throw a resource_error.

         EErrrroorrss
             -  resource_error(threads_in_pool(Pool)) is  raised if
             wait is false or the backlog limit has been reached.
             - existence_error(thread_pool, Pool)  if _P_o_o_l does not
             exist.


ccrreeaattee__ppooooll((_+_P_o_o_l_N_a_m_e))                               _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook  to  create a  thread  pool lazily.    The  hook is  called  if
    thread_create_in_pool/4 discovers  that  the  thread pool  does  not
    exist.     If  the  hook  succeeds,  thread_create_in_pool/4 retries
    creating  the  thread.    For  example,  we can  use  the  following
    declaration  to create  threads in  the  pool media,  which holds  a
    maximum of 20 threads.

    ____________________________________________________________________|                                                                    |
    | :- multifile thread_pool:create_pool/1.                            |
    |                                                                    |
    | thread_pool:create_pool(media) :-                                  |

    ||____thread_pool_create(media,_20,_[]).____________________________ ||


1144..3366 lliibbrraarryy((uuggrraapphhss))::  UUnnwweeiigghhtteedd GGrraapphhss

                          Authors:  _R_i_c_h_a_r_d _O_'_K_e_e_f_e _& _V_i_t_o_r _S_a_n_t_o_s _C_o_s_t_a

    _I_m_p_l_e_m_e_n_t_a_t_i_o_n  _a_n_d  _d_o_c_u_m_e_n_t_a_t_i_o_n _a_r_e  _c_o_p_i_e_d _f_r_o_m  _Y_A_P _5_._0_._1_.
    _T_h_e   ugraph  _l_i_b_r_a_r_y  _i_s  _b_a_s_e_d  _o_n  _c_o_d_e  _o_r_i_g_i_n_a_l_l_y  _w_r_i_t_t_e_n
    _b_y  _R_i_c_h_a_r_d  _O_'_K_e_e_f_e_.     _T_h_e  _c_o_d_e  _w_a_s  _t_h_e_n _e_x_t_e_n_d_e_d  _t_o  _b_e
    _c_o_m_p_a_t_i_b_l_e  _w_i_t_h _t_h_e _S_I_C_S_t_u_s _P_r_o_l_o_g _u_g_r_a_p_h_s  _l_i_b_r_a_r_y_.  _C_o_d_e _a_n_d
    _d_o_c_u_m_e_n_t_a_t_i_o_n  _h_a_v_e _b_e_e_n _c_l_e_a_n_e_d _a_n_d _s_t_y_l_e  _h_a_s _b_e_e_n _c_h_a_n_g_e_d _t_o
    _b_e _m_o_r_e _i_n _l_i_n_e _w_i_t_h _t_h_e _r_e_s_t _o_f _S_W_I_-_P_r_o_l_o_g_.

    _T_h_e  _u_g_r_a_p_h_s  _l_i_b_r_a_r_y  _w_a_s _o_r_i_g_i_n_a_l_l_y  _r_e_l_e_a_s_e_d  _i_n  _t_h_e _p_u_b_l_i_c
    _d_o_m_a_i_n_.    _T_h_e  _Y_A_P  _v_e_r_s_i_o_n _i_s  _c_o_v_e_r_e_d _b_y  _t_h_e  _P_e_r_l _A_r_t_i_s_t_i_c
    _l_i_c_e_n_s_e_,  _v_e_r_s_i_o_n _2_._0_.   _T_h_i_s  _c_o_d_e _i_s  _d_u_a_l_-_l_i_c_e_n_s_e_d _u_n_d_e_r _t_h_e
    _m_o_d_i_f_i_e_d  _G_P_L _a_s _u_s_e_d _f_o_r _a_l_l  _S_W_I_-_P_r_o_l_o_g _l_i_b_r_a_r_i_e_s _o_r _t_h_e _P_e_r_l
    _A_r_t_i_s_t_i_c _l_i_c_e_n_s_e_, _v_e_r_s_i_o_n _2_._0_.

The  routines   assume  directed  graphs;   undirected  graphs  may   be
implemented by using two edges.

Originally graphs were represented in two formats.   The SICStus library
and  this version  of ugraphs.pl  only use  the _S_-_r_e_p_r_e_s_e_n_t_a_t_i_o_n.    The
S-representation  of a  graph  is a  list of  (vertex-neighbors)  pairs,
where the pairs are  in standard order (as produced by keysort)  and the
neighbors of  each vertex  are also  in standard order  (as produced  by
sort).   This form  is convenient  for many calculations.   Each  vertex
appears in the S-representation, even if it has no neighbors.


vveerrttiicceess__eeddggeess__ttoo__uuggrraapphh((_+_V_e_r_t_i_c_e_s_, _+_E_d_g_e_s_, _-_G_r_a_p_h))
    Given a graph with  a set of _V_e_r_t_i_c_e_s and a set of _E_d_g_e_s, _G_r_a_p_h must
    unify  with the corresponding S-representation.  Note  that vertices
    without  edges will appear in _V_e_r_t_i_c_e_s but not in _E_d_g_e_s.   Moreover,
    it is sufficient for a vertex to appear in _E_d_g_e_s.

    ____________________________________________________________________|                                                                    |
    | ?- vertices_edges_to_ugraph([],[1-3,2-4,4-5,1-5], L).              |

    ||L_=_[1-[3,5],_2-[4],_3-[],_4-[5],_5-[]]___________________________ ||

    In this case all  vertices are defined implicitly.  The next example
    shows three unconnected vertices:

    ____________________________________________________________________|                                                                    |

    | ?- vertices_edges_to_ugraph([6,7,8],[1-3,2-4,4-5,1-5], L).         |
    ||L_=_[1-[3,5],_2-[4],_3-[],_4-[5],_5-[],_6-[],_7-[],_8-[]]_?_______ ||


vveerrttiicceess((_+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify _V_e_r_t_i_c_e_s with all vertices appearing in _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- vertices([1-[3,5],2-[4],3-[],4-[5],5-[]], L).                   |
    ||L_=_[1,_2,_3,_4,_5]_______________________________________________ ||


eeddggeess((_+_G_r_a_p_h_, _-_E_d_g_e_s))
    Unify _E_d_g_e_s with all edges appearing in _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- edges([1-[3,5],2-[4],3-[],4-[5],5-[]], L).                      |

    ||L_=_[1-3,_1-5,_2-4,_4-5]__________________________________________ ||


aadddd__vveerrttiicceess((_+_G_r_a_p_h_, _+_V_e_r_t_i_c_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with  a new  graph obtained  by adding  the list  of
    _V_e_r_t_i_c_e_s to _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- add_vertices([1-[3,5],2-[]], [0,1,2,9], NG).                    |

    ||NG_=_[0-[],_1-[3,5],_2-[],_9-[]]__________________________________ ||


ddeell__vveerrttiicceess((_+_G_r_a_p_h_, _+_V_e_r_t_i_c_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h  with a  new  graph obtained  by deleting  the  list
    of  _V_e_r_t_i_c_e_s and  all edges that  start from  or go to  a vertex  in
    _V_e_r_t_i_c_e_s from _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- del_vertices([2,1],                                             |

    |                 [1-[3,5],2-[4],3-[],4-[5],                         |
    |                  5-[],6-[],7-[2,6],8-[]],                          |
    |                 NL).                                               |
    ||NL_=_[3-[],4-[5],5-[],6-[],7-[6],8-[]]____________________________ ||


aadddd__eeddggeess((_+_G_r_a_p_h_, _+_E_d_g_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with  a new  graph obtained  by adding  the list  of
    _E_d_g_e_s to _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- add_edges([1-[3,5],2-[4],3-[],4-[5],                            |

    |               5-[],6-[],7-[],8-[]],                                |
    |              [1-6,2-3,3-2,5-7,3-2,4-5],                            |
    |              NL).                                                  |
    | NL = [1-[3,5,6], 2-[3,4], 3-[2], 4-[5],                            |
    ||______5-[7],_6-[],_7-[],_8-[]]____________________________________ ||


ddeell__eeddggeess((_+_G_r_a_p_h_, _+_E_d_g_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with a  new graph obtained  by removing the list  of
    _E_d_g_e_s from _G_r_a_p_h.  Notice that no vertices are deleted.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- del_edges([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[],8-[]],       |

    |              [1-6,2-3,3-2,5-7,3-2,4-5,1-3],                        |
    |              NL).                                                  |
    ||NL_=_[1-[5],2-[4],3-[],4-[],5-[],6-[],7-[],8-[]]__________________ ||


ttrraannssppoossee__uuggrraapphh((_+_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with a  new graph obtained  from _G_r_a_p_h by  replacing
    all  edges of the form V1-V2 by edges  of the form V2-V1.   The cost
    is  O(|V|2).  Notice  that an undirected graph is  its own transpose.
    Example:

    ____________________________________________________________________|                                                                    |
    | ?- transpose_ugraph([1-[3,5],2-[4],3-[],4-[5],                     |

    |               5-[],6-[],7-[],8-[]], NL).                           |
    ||NL_=_[1-[],2-[],3-[1],4-[2],5-[1,4],6-[],7-[],8-[]]_______________ ||


nneeiigghhbboouurrss((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify  _V_e_r_t_i_c_e_s with  the  list of  neighbours of  vertex _V_e_r_t_e_x  in
    _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- neighbours(4,[1-[3,5],2-[4],3-[],                               |

    |                  4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).            |
    ||NL_=_[1,2,7,5]____________________________________________________ ||


nneeiigghhbboorrss((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    American version of neighbours/3.


ccoommpplleemmeenntt((_+_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Unify _N_e_w_G_r_a_p_h with the graph complementary to _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- complement([1-[3,5],2-[4],3-[],                                 |

    |                4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).              |
    | NL = [1-[2,4,6,7,8],2-[1,3,5,6,7,8],3-[1,2,4,5,6,7,8],             |
    |       4-[3,5,6,8],5-[1,2,3,4,6,7,8],6-[1,2,3,4,5,7,8],             |
    ||______7-[1,2,3,4,5,6,8],8-[1,2,3,4,5,6,7]]________________________ ||


ccoommppoossee((_+_L_e_f_t_G_r_a_p_h_, _+_R_i_g_h_t_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Compose  _N_e_w_G_r_a_p_h  by  connecting the  _d_r_a_i_n_s  of _L_e_f_t_G_r_a_p_h  to  the
    _s_o_u_r_c_e_s of _R_i_g_h_t_G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- compose([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).                     |

    ||L_=_[1-[4],_2-[1,2,4],_3-[]]______________________________________ ||


uuggrraapphh__uunniioonn((_+_G_r_a_p_h_1_, _+_G_r_a_p_h_2_, _-_N_e_w_G_r_a_p_h))
    _N_e_w_G_r_a_p_h is the union of _G_r_a_p_h_1 and _G_r_a_p_h_2.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- ugraph_union([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).                |

    ||L_=_[1-[2],_2-[3,4],_3-[1,2,4]]___________________________________ ||


ttoopp__ssoorrtt((_+_G_r_a_p_h_, _-_S_o_r_t))
    Generate  the set of nodes _S_o_r_t  as a topological sorting of  _G_r_a_p_h,
    if  one is possible.   A  toplogical sort is  possible if the  graph
    is  connected and acyclic.   In the example we show how  topological
    sorting works for a linear graph:

    ____________________________________________________________________|                                                                    |
    | ?- top_sort([1-[2], 2-[3], 3-[]], L).                              |

    ||L_=_[1,_2,_3]_____________________________________________________ ||


ttoopp__ssoorrtt((_+_G_r_a_p_h_, _-_S_o_r_t_0_, _-_S_o_r_t))
    Generate the difference  list Sort-Sort0 as a topological sorting of
    _G_r_a_p_h, if one is possible.


ttrraannssiittiivvee__cclloossuurree((_+_G_r_a_p_h_, _-_C_l_o_s_u_r_e))
    Generate  the  graph Closure  as the  transitive  closure of  _G_r_a_p_h.
    Example:

    ____________________________________________________________________|                                                                    |
    |  ?- transitive_closure([1-[2,3],2-[4,5],4-[6]],L).                 |

    ||L_=_[1-[2,3,4,5,6],_2-[4,5,6],_4-[6]]_____________________________ ||


rreeaacchhaabbllee((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify  _V_e_r_t_i_c_e_s  with the  set of  all vertices  in  _G_r_a_p_h that  are
    reachable from _V_e_r_t_e_x.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- reachable(1,[1-[3,5],2-[4],3-[],4-[5],5-[]],V).                 |

    ||V_=_[1,_3,_5]_____________________________________________________ ||


1144..3377 lliibbrraarryy((uurrll))::  AAnnaallyyssiinngg aanndd ccoonnssttrruuccttiinngg UURRLL

    aauutthhoorr
         - Jan Wielemaker
         - Lukas Faulstich

    ddeepprreeccaatteedd  New code  should use library(uri),  provided by the
         clib package.

This  library  deals  with the  analysis  and  construction  of  a  URL,
Universal  Resource  Locator.    URL  is  the  basis  for  communicating
locations of resources (data) on the web.  A URL  consists of a protocol
identifier (e.g.    HTTP, FTP,  and a  protocol-specific syntax  further
defining the location.  URLs are standardized in RFC-1738.

The implementation in  this library covers only  a small portion of  the
defined protocols.  Though the initial  implementation followed RFC-1738
strictly, the current  is more relaxed to deal with  frequent violations
of the standard encountered in practical use.


gglloobbaall__uurrll((_+_U_R_L_, _+_B_a_s_e_, _-_G_l_o_b_a_l))                                   _[_d_e_t_]
    Translate a possibly relative _U_R_L into an absolute one.

         EErrrroorrss syntax_error(illegal_url) if _U_R_L is not legal.


iiss__aabbssoolluuttee__uurrll((_+_U_R_L))
    True  if _U_R_L is an absolute _U_R_L.  That is, a _U_R_L that starts  with a
    protocol identifier.


hhttttpp__llooccaattiioonn((_?_P_a_r_t_s_, _?_L_o_c_a_t_i_o_n))
    Construct  or  analyze  an  HTTP  location.    This  is  similar  to
    parse_url/2, but only  deals with the location part of an  HTTP URL.
    That  is, the  path, search and  fragment specifiers.   In the  HTTP
    protocol, the first line of a message is

    ____________________________________________________________________|                                                                    |
    ||<Action>_<Location>_HTTP/<version>________________________________ ||

    ___________________________________________________________Arguments_
     _L_o_c_a_t_i_o_n  Atom or list of character codes.


ppaarrssee__uurrll((_?_U_R_L_, _?_A_t_t_r_i_b_u_t_e_s))                                       _[_d_e_t_]
    Construct  or analyse  a _U_R_L.  _U_R_L is  an atom  holding a  _U_R_L or  a
    variable.   _A_t_t_r_i_b_u_t_e_s is a list  of components.  Each  component is
    of the format Name(Value).  Defined components are:

    pprroottooccooll((_P_r_o_t_o_c_o_l))
         The used  protocol.    This is,  after  the optional  url:,  an
         identifier  separated  from the  remainder  of  the  _U_R_L  using
         :.   parse_url/2 assumes the  http protocol  if no protocol  is
         specified and  the  _U_R_L can  be  parsed as  a valid  HTTP  url.
         In  addition to  the  RFC-1738 specified  protocols,  the  file
         protocol is supported as well.

    hhoosstt((_H_o_s_t))
         _H_o_s_t-name  or IP-address  on  which  the resource  is  located.
         Supported by all network-based protocols.

    ppoorrtt((_P_o_r_t))
         Integer port-number  to access on  the \arg{Host}.    This only
         appears  if  the port  is  explicitly  specified  in  the  _U_R_L.
         Implicit default  ports (e.g., 80  for HTTP)  do _n_o_t appear  in
         the part-list.

    ppaatthh((_P_a_t_h))
         (File-) path addressed  by the _U_R_L.  This is supported for  the
         ftp, http and file protocols.  If no path  appears, the library
         generates the path /.

    sseeaarrcchh((_L_i_s_t_O_f_N_a_m_e_V_a_l_u_e))
         Search-specification of HTTP  _U_R_L. This is  the part after  the
         ?, normally used to transfer data from HTML forms  that use the
         HTTP GET method.  In the _U_R_L it consists  of a www-form-encoded
         list of Name=Value pairs.   This is mapped to a list  of Prolog
         Name=Value terms with decoded names and values.

    ffrraaggmmeenntt((_F_r_a_g_m_e_n_t))
         _F_r_a_g_m_e_n_t specification of HTTP _U_R_L. This is the  part after the
         # character.

    The example below illustrates all of this for an HTTP _U_R_L.

    ____________________________________________________________________|                                                                    |

    | ?- parse_url('http://www.xyz.org/hello?msg=Hello+World%21#x',      |
    |        P).                                                         |
    |                                                                    |
    | P = [ protocol(http),                                              |
    |       host('www.xyz.org'),                                         |

    |       fragment(x),                                                 |
    |       search([ msg = 'Hello World!'                                |
    |              ]),                                                   |
    |       path('/hello')                                               |
    ||____]_____________________________________________________________ ||

    By  instantiating  the  parts-list this  predicate  can be  used  to
    create a _U_R_L.


ppaarrssee__uurrll((_+_U_R_L_, _+_B_a_s_e_U_R_L_, _-_A_t_t_r_i_b_u_t_e_s))                             _[_d_e_t_]
    Similar  to parse_url/2 for relative URLs.   If _U_R_L is relative,  it
    is resolved using the absolute _U_R_L _B_a_s_e_U_R_L.


wwwwww__ffoorrmm__eennccooddee((_+_V_a_l_u_e_, _-_X_W_W_W_F_o_r_m_E_n_c_o_d_e_d))                          _[_d_e_t_]


wwwwww__ffoorrmm__eennccooddee((_-_V_a_l_u_e_, _+_X_W_W_W_F_o_r_m_E_n_c_o_d_e_d))                          _[_d_e_t_]
    En/decode to/from  application/x-www-form-encoded.  Encoding encodes
    all  characters  except   RFC  3986  _u_n_r_e_s_e_r_v_e_d  (ASCII  alnum  (see
    code_type/2)),  and one of "-._~" using percent  encoding.   Newline
    is  mapped to  %OD%OA. When  decoding, newlines appear  as a  single
    newline (10) character.

    Note that a space  is encoded as %20 instead of +.  Decoding decodes
    both to a space.

         ddeepprreeccaatteedd Use uri_encoded/3 for new code.


sseett__uurrll__eennccooddiinngg((_?_O_l_d_, _+_N_e_w))                                   _[_s_e_m_i_d_e_t_]
    Query  and set the  encoding for URLs.   The default  is utf8.   The
    only other defined value is iso_latin_1.

         TToo bbee ddoonnee Having  a global  flag is  highly inconvenient,
             but  a work-around  for  old sites  using ISO  Latin 1
             encoding.


uurrll__iirrii((_+_E_n_c_o_d_e_d_, _-_D_e_c_o_d_e_d))                                        _[_d_e_t_]


uurrll__iirrii((_-_E_n_c_o_d_e_d_, _+_D_e_c_o_d_e_d))                                        _[_d_e_t_]
    Convert between a URL,  encoding in US-ASCII and an IRI. An IRI is a
    fully  expanded Unicode string.   Unicode strings are first  encoded
    into UTF-8, after which %-encoding takes place.


ppaarrssee__uurrll__sseeaarrcchh((_?_S_p_e_c_, _?_F_i_e_l_d_s_:_l_i_s_t_(_N_a_m_e_=_V_a_l_u_e_)))                  _[_d_e_t_]
    Construct or analyze  an HTTP search specification.  This deals with
    form  data using the MIME-type application/x-www-form-urlencoded  as
    used in HTTP GET requests.


ffiillee__nnaammee__ttoo__uurrll((_+_F_i_l_e_, _-_U_R_L))                                       _[_d_e_t_]


ffiillee__nnaammee__ttoo__uurrll((_-_F_i_l_e_, _+_U_R_L))                                   _[_s_e_m_i_d_e_t_]
    Translate between a filename and a file:// _U_R_L.

         TToo bbee ddoonnee Current   implementation  does  not  deal  with
             paths that need special encoding.


1144..3388 lliibbrraarryy((vvaarrnnuummbbeerrss))::  UUttiilliittiieess ffoorr nnuummbbeerreedd tteerrmmss

    SSeeee aallssoo  numbervars/4, =@=/2 (variant/2).

    CCoommppaattiibbiilliittyy  This  library  was  introduced  by  Quintus  and
         available in  many related  implementations,  although not
         with exactly the same set of predicates.

This  library  provides  the  inverse  functionality   of  the  built-in
numbervars/3.   Note  that this  library suffers from  the known  issues
that  '$VAR'(X) is  a  normal  Prolog term  and,  -unlike  the  built-in
numbervars-, the  inverse predicates do _n_o_t process  cyclic terms.   The
following  predicate is  true  for any  acyclic  term that  contains  no
'$VAR'(X), integer(X) terms and no constraint variables:

________________________________________________________________________|                                                                        |

|always_true(X) :-                                                       |
|      copy_term(X, X2),                                                 |
|      numbervars(X),                                                    |
|      varnumbers(X, Copy),                                              |
||_____Copy_=@=_X2._____________________________________________________ ||


nnuummbbeerrvvaarrss((_+_T_e_r_m))                                                 _[_d_e_t_]
    Number   variables    in   _T_e_r_m   using   $VAR(N).   Equivalent   to
    numbervars(Term, 0, _).

         SSeeee aallssoo numbervars/3, numbervars/4


vvaarrnnuummbbeerrss((_+_T_e_r_m_, _-_C_o_p_y))                                          _[_d_e_t_]
    Inverse of numbervars/1.  Equivalent to varnumbers(Term, 0, Copy).


vvaarrnnuummbbeerrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_C_o_p_y))                                  _[_d_e_t_]
    Inverse  of numbervars/3.   True when  _C_o_p_y is a  copy of _T_e_r_m  with
    all  variables  numbered >=  _S_t_a_r_t  consistently replaced  by  fresh
    variables.    Variables in  _T_e_r_m are  _s_h_a_r_e_d with  _C_o_p_y rather  than
    replaced by fresh variables.

         EErrrroorrss domain_error(acyclic_term, Term)    if    _T_e_r_m   is
             cyclic.

         CCoommppaattiibbiilliittyy Quintus,  SICStus.   Not  in YAP  version of
             this library


mmaaxx__vvaarr__nnuummbbeerr((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_M_a_x))                                _[_d_e_t_]
    True  when _M_a_x is the max of _S_t_a_r_t and the highest  numbered $VAR(N)
    term.

         aauutthhoorr Vitor Santos Costa

         CCoommppaattiibbiilliittyy YAP


vvaarrnnuummbbeerrss__nnaammeess((_+_T_e_r_m_, _-_C_o_p_y_, _-_V_a_r_i_a_b_l_e_N_a_m_e_s))                     _[_d_e_t_]
    If  _T_e_r_m  is a  term with  numbered and  named  variables using  the
    reserved  term  '$VAR'(X),  _C_o_p_y  is  a  copy  of  _T_e_r_m  where  each
    '$VAR'(X) is consistently  replaced by a fresh variable and Bindings
    is  a list X = Var,  relating the  _X terms with  the variable it  is
    mapped to.

         SSeeee aallssoo numbervars/3, varnumbers/3,  read_term/3using the
             variable_names option.


1144..3399 lliibbrraarryy((yyaallll))::  LLaammbbddaa eexxpprreessssiioonnss

    aauutthhoorr  Paulo Moura and Jan Wielemaker

    TToo bbee ddoonnee  Extend optimization support

Prolog  realizes _h_i_g_h_-_o_r_d_e_r  programming with  meta-calling.   The  core
predicate of this is call/1, which simply calls its argument.   This can
be used to define higher-order predicates such as  ignore/1 or forall/2.
The  call/N construct  calls a  _c_l_o_s_u_r_e with  N-1 _a_d_d_i_t_i_o_n_a_l  _a_r_g_u_m_e_n_t_s.
This is  used to define  higher-order predicates  such as the  maplist/N
family or foldl/N.

The  problem   with  higher   order  predicates  based   on  call/N   is
that  the  additional   arguments  are  always  added  to  the   end  of
the   closure's  argument   list.      This   often  requires   defining
trivial  helper  predicates to  get  the  argument  order right.     For
example,   if   you  want   to  add   a  common   postfix   to  a   list
of   atoms  you   need   to   apply  atom_concat(In,Postfix,Out),    but
maplist(x(PostFix),ListIn,ListOut)  calls x(PostFix,In,Out).    This  is
where this library comes in, which allows us to write

________________________________________________________________________|                                                                        |

|?- maplist([In,Out]>>atom_concat(In,'_p',Out), [a,b], ListOut).         |
|ListOut|=_[a_p,_b_p].__________________________________________________ |       |

The {...}  specifies which variables are  _s_h_a_r_e_d between the lambda  and
the context.    This allows us  to write the  code below.   Without  the
{PostFix} a free variable would be passed to atom_concat/3.

________________________________________________________________________|                                                                        |
|add_postfix(PostFix, ListIn, ListOut) :-                                |
|    maplist({PostFix}/[In,Out]>>atom_concat(In,PostFix,Out),            |
||___________ListIn,_ListOut).__________________________________________ ||

This introduces the second application area of lambda  expressions:  the
ability  to stop  binding  variables in  the  context.    This  features
shines when  combined with bagof/3  or setof/3  where you normally  have
to specify  the the variables  in whose binding  you are _n_o_t  interested
using the  Var^Goal construct (marking  _V_a_r as existential  quantified).
Lambdas allow  doing the reverse:   specify the  variables in which  you
are interested.

Lambda expressions use the syntax below

________________________________________________________________________|                                                                        |

|{...}/[...]>>Goal.|____________________________________________________ |                  |

The {...} optional  part is used for  lambda-free variables.  The  order
of variables doesn't matter hence the {...} set notation.

The  [...]  optional part  lists  lambda  parameters.    Here  order  of
variables matters hence the list notation.

As / and >> are standard infix operators, no new  operators are added by
this library.  An  advantage of this syntax is that we can  simply unify
a lambda expression  with Free/Parameters>>Lambda to access each of  its
components.  Spaces in the lambda expression are  not a problem although
the goal may need to be written between ()'s.   Goals that are qualified
by a module prefix also need to be wrapped inside parentheses.

Combined  with   library(apply_macros),  library(yall)  allows   writing
one-liners for  many list operations that  have the same performance  as
hand written code.

The module name, _y_a_l_l, stands for Yet Another Lambda Library.

This  module  implements  Logtalk's lambda  expressions  syntax.     The
development of this module was sponsored by Kyndi, Inc.


_+_P_a_r_a_m_e_t_e_r_s >> _+_L_a_m_b_d_a


>>((_+_P_a_r_a_m_e_t_e_r_s_, _+_L_a_m_b_d_a_, _?_A_1))


>>((_+_P_a_r_a_m_e_t_e_r_s_, _+_L_a_m_b_d_a_, _?_A_1_, _?_A_2))


>>((_+_P_a_r_a_m_e_t_e_r_s_, _+_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3))


>>((_+_P_a_r_a_m_e_t_e_r_s_, _+_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4))


>>((_+_P_a_r_a_m_e_t_e_r_s_, _+_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4_, _?_A_5))


>>((_+_P_a_r_a_m_e_t_e_r_s_, _+_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4_, _?_A_5_, _?_A_6))


>>((_+_P_a_r_a_m_e_t_e_r_s_, _+_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4_, _?_A_5_, _?_A_6_, _?_A_7))
    Calls  a copy of  _L_a_m_b_d_a.   This is similar to  call(Lambda,A1,...),
    but arguments are reordered according to the list _P_a_r_a_m_e_t_e_r_s:

      o  The  first length(Parameters)  arguments  from  _A_1, ...     are
         unified with (a copy of) _P_a_r_a_m_e_t_e_r_s, which _m_a_y  share them with
         variables in _L_a_m_b_d_a.

      o  Possible excess arguments are passed by position.

    ___________________________________________________________Arguments_
     _P_a_r_a_m_e_t_e_r_s  is  either a plain list of parameters or a  term
                 {Free}/List.    _F_r_e_e represents  variables  that
                 are  shared between the  context and the  _L_a_m_b_d_a

                 term.    This  is  needed for  compiling  _L_a_m_b_d_a
                 expressions.


_+_F_r_e_e / _:_L_a_m_b_d_a


/((_+_F_r_e_e_, _:_L_a_m_b_d_a_, _?_A_1))


/((_+_F_r_e_e_, _:_L_a_m_b_d_a_, _?_A_1_, _?_A_2))


/((_+_F_r_e_e_, _:_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3))


/((_+_F_r_e_e_, _:_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4))


/((_+_F_r_e_e_, _:_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4_, _?_A_5))


/((_+_F_r_e_e_, _:_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4_, _?_A_5_, _?_A_6))


/((_+_F_r_e_e_, _:_L_a_m_b_d_a_, _?_A_1_, _?_A_2_, _?_A_3_, _?_A_4_, _?_A_5_, _?_A_6_, _?_A_7))
    Shorthand for Free/[]>>Lambda.   This is the same as applying call/N
    on  _L_a_m_b_d_a, except that only  variables appearing in _F_r_e_e are  bound
    by the call.  For example

    ____________________________________________________________________|                                                                    |
    | p(1,a).                                                            |

    | p(2,b).                                                            |
    |                                                                    |
    | ?- {X}/p(X,Y).                                                     |
    | X = 1;                                                             |
    ||X_=_2.____________________________________________________________ ||

    This  can  in  particularly be  combined  with bagof/3  and  setof/3
    to  _s_e_l_e_c_t particular  variables to be  concerned rather than  using
    existential  quantification  (^/2)   to  _e_x_c_l_u_d_e  variables.     For
    example, the two calls below are equivalent.

    ____________________________________________________________________|                                                                    |
    | setof(X, Y^p(X,Y), Xs)                                             |

    ||setof(X,_{X}/p(X,_),_Xs)__________________________________________ ||


iiss__llaammbbddaa((_@_T_e_r_m))                                               _[_s_e_m_i_d_e_t_]
    True if _T_e_r_m is a valid Lambda expression.


llaammbbddaa__ccaallllss((_+_L_a_m_b_d_a_E_x_p_r_e_s_s_i_o_n_, _-_G_o_a_l))                             _[_d_e_t_]


llaammbbddaa__ccaallllss((_+_L_a_m_b_d_a_E_x_p_r_e_s_s_i_o_n_, _+_E_x_t_r_a_A_r_g_s_, _-_G_o_a_l))                 _[_d_e_t_]
    _G_o_a_l  is the goal called  if call/N is applied to  _L_a_m_b_d_a_E_x_p_r_e_s_s_i_o_n,
    where  _E_x_t_r_a_A_r_g_s are the  additional arguments to call/N.  _E_x_t_r_a_A_r_g_s
    can  be an integer or a list of concrete arguments.   This predicate
    is used for cross-referencing and code highlighting.


CChhaapptteerr 1155..  HHAACCKKEERRSS CCOORRNNEERR

This  appendix  describes  a  number  of  predicates  which  enable  the
Prolog  user  to  inspect the  Prolog  environment  and  manipulate  (or
even redefine)  the debugger.    They can be  used as  entry points  for
experiments with debugging  tools for Prolog.  The  predicates described
here should  be handled  with some  care as it  is easy  to corrupt  the
consistency of the Prolog system by misusing them.


1155..11 EExxaammiinniinngg tthhee EEnnvviirroonnmmeenntt SSttaacckk


pprroolloogg__ccuurrrreenntt__ffrraammee((_-_F_r_a_m_e))                                       _[_d_e_t_]
    Unify  _F_r_a_m_e with  an integer  providing a reference  to the  parent
    of  the  current local  stack  frame.    A  pointer to  the  current
    local   frame  cannot   be  provided  as   the  predicate   succeeds
    deterministically  and therefore its frame is  destroyed immediately
    after succeeding.


pprroolloogg__ccuurrrreenntt__cchhooiiccee((_-_C_h_o_i_c_e))                                 _[_s_e_m_i_d_e_t_]
    Unify  _C_h_o_i_c_e  with an  integer  provided a  reference to  the  last
    choice  point.    Fails if  the current  environment  has no  choice
    points.  See also prolog_choice_attribute/3.


pprroolloogg__ffrraammee__aattttrriibbuuttee((_+_F_r_a_m_e_, _+_K_e_y_, _:_V_a_l_u_e))
    Obtain  information  about  the local  stack  frame  _F_r_a_m_e.    _F_r_a_m_e
    is  a  frame reference  as obtained  through prolog_current_frame/1,
    prolog_trace_interception/4 or this predicate.   The key values  are
    described below.

    aalltteerrnnaattiivvee
         _V_a_l_u_e is unified with  an integer reference to the  local stack
         frame in  which execution  is  resumed if  the goal  associated
         with _F_r_a_m_e  fails.    Fails  if the  frame has  no  alternative
         frame.

    hhaass__aalltteerrnnaattiivveess
         _V_a_l_u_e is unified  with true if _F_r_a_m_e  still is a candidate  for
         backtracking; false otherwise.

    ggooaall
         _V_a_l_u_e is  unified with  the  goal associated  with _F_r_a_m_e.    If
         the  definition module  of  the  active predicate  is  not  the
         calling context,  the  goal is  represented as  <_m_o_d_u_l_e>:<_g_o_a_l>.
         Do  not instantiate  variables in  this  goal unless  you  kknnooww
         what you are  doing!  Note  that the returned term may  contain
         references to  the frame  and  should be  discarded before  the
         frame terminates.

    ppaarreenntt__ggooaall
         If _V_a_l_u_e  is  instantiated to  a callable  term,  find a  frame
         executing  the  predicate described  by  _V_a_l_u_e  and  unify  the
         arguments of _V_a_l_u_e  to the goal  arguments associated with  the
         frame.    This  is  intended  to check  the  current  execution
         context.  The user  must ensure the checked parent goal  is not
         removed from  the stack  due to last-call  optimisation and  be
         aware of the slow operation on deeply nested calls.

    pprreeddiiccaattee__iinnddiiccaattoorr
         Similar     to    goal,      but     only     returning     the
         [<_m_o_d_u_l_e>:]<_n_a_m_e>/<_a_r_i_t_y>   term   describing  the   term,    not
         the actual arguments.   It avoids  creating an illegal term  as
         goal and is used by the library prolog_stack.

    ccllaauussee
         _V_a_l_u_e is  unified with  a  reference to  the currently  running
         clause.    Fails  if the  current  goal  is associated  with  a
         foreign  (C) defined  predicate.    See  also nth_clause/3  and
         clause_property/2.

    lleevveell
         _V_a_l_u_e is unified  with the recursion level  of _F_r_a_m_e.  The  top
         level frame is at level `0'.

    ppaarreenntt
         _V_a_l_u_e is unified with an integer reference to  the parent local
         stack frame of _F_r_a_m_e.  Fails if _F_r_a_m_e is the top frame.

    ccoonntteexxtt__mmoodduullee
         _V_a_l_u_e is  unified with the  name of the  context module of  the
         environment.

    ttoopp
         _V_a_l_u_e is  unified with  true if _F_r_a_m_e  is the  top Prolog  goal
         from a  recursive call back  from the  foreign language;  false
         otherwise.

    hhiiddddeenn
         _V_a_l_u_e is  unified with  true if the  frame is  hidden from  the
         user, either  because a  parent has  the hide-childs  attribute
         (all  system  predicates),  or  the  system   has  no  trace-me
         attribute.

    sskkiippppeedd
         _V_a_l_u_e is true if this frame was skipped in the debugger.

    ppcc
         _V_a_l_u_e  is unified  with the  program  pointer saved  on  behalf
         of  the parent  goal if  the  parent goal  is  not owned  by  a
         foreign predicate  or belongs  to a  compound meta-call  (e.g.,
         call((a,b))).

    aarrgguummeenntt((_N))
         _V_a_l_u_e is  unified with the _N-th  slot of the  frame.   Argument
         1 is  the first  argument of  the goal.    Arguments above  the
         arity refer to local variables.  Fails silently if _N  is out of
         range.


pprroolloogg__cchhooiiccee__aattttrriibbuuttee((_+_C_h_o_i_c_e_P_o_i_n_t_, _+_K_e_y_, _-_V_a_l_u_e))
    Extract  attributes of a choice point.   _C_h_o_i_c_e_P_o_i_n_t is a  reference
    to  a  choice  point  as  passed  to prolog_trace_interception/4  on
    the  3rd argument  or obtained  using prolog_current_choice/1.    _K_e_y
    specifies the requested information:

    ppaarreenntt
         Requests a reference to the first older choice point.

    ffrraammee
         Requests a  reference to the  frame to  which the choice  point
         refers.

    ttyyppee
         Requests  the type.     Defined  values are  clause  (the  goal
         has alternative  clauses),  foreign (non-deterministic  foreign
         predicate),  jump (clause  internal choice  point), top  (first
         dummy choice point), catch  (catch/3 to allow for undo),  debug
         (help the debugger), or none (has been deleted).

    This  predicate  is used  for  the graphical  debugger to  show  the
    choice point stack.


ddeetteerrmmiinniissttiicc((_-_B_o_o_l_e_a_n))
    Unifies  its argument with  true if no  choice point exists that  is
    more  recent  than the  entry of  the clause  in  which it  appears.
    There  are few realistic  situations for using  this predicate.   It
    is  used by the  prolog/0 top level  to check whether Prolog  should
    prompt  the user for alternatives.  Similar results can  be achieved
    in a more portable fashion using call_cleanup/2.


1155..22 AAnncceessttrraall ccuuttss


pprroolloogg__ccuutt__ttoo((_+_C_h_o_i_c_e))
    Prunes  all  choice  points created  since  _C_h_o_i_c_e.    Can  be  used
    together  with prolog_current_choice/1 to implement _a_n_c_e_s_t_r_a_l  cuts.
    This  predicate is in  the hackers corner  because it should not  be
    used  in normal  Prolog code.   It may  be used  to create new  high
    level control structures, particularly for compatibility purposes.

    Note  that in the current  implementation, the pruned choice  points
    and  environment frames are _n_o_t reclaimed.  As a  consequence, where
    predicates  that are  deterministic due to  clause indexing,  normal
    cuts  or (if\send{then};else) and and tail recursive run  in bounded
    local  stack space, predicates using prolog_cut_to/1will  run out of
    stack.


1155..33 IInntteerrcceeppttiinngg tthhee TTrraacceerr


pprroolloogg__ttrraaccee__iinntteerrcceeppttiioonn((_+_P_o_r_t_, _+_F_r_a_m_e_, _+_C_h_o_i_c_e_, _-_A_c_t_i_o_n))
    Dynamic  predicate, normally not defined.  This predicate  is called
    from  the SWI-Prolog  debugger  just before  it would  show a  port.
    If  this predicate  succeeds, the  debugger assumes  that the  trace
    action  has been taken care of and continues execution  as described
    by  _A_c_t_i_o_n.    Otherwise  the  normal  Prolog debugger  actions  are
    performed.

    _P_o_r_t  denotes  the reason  to  activate the  tracer (`port'  in  the
    4/5-port, but with some additions):

    ccaallll
         Normal entry through the call port of the 4-port debugger.

    rreeddoo((_P_C))
         Normal entry  through the  redo  port of  the 4-port  debugger.
         The  redo  port  signals  resuming  a  predicate   to  generate
         alternative solutions.  If _P_C is 0 (zero),  clause indexing has
         found another clause  that will be tried  next.  Otherwise,  _P_C
         is the program  counter in the  current clause where  execution
         continues.    This implies  we are  dealing  with an  in-clause
         choice point left by, e.g., ;/2.  Note  that non-determinism in
         foreign predicates are  also handled using an in-clause  choice
         point.

    uunniiffyy
         The  unify port  represents  the _n_e_c_k  instruction,  signalling
         the end of  the head-matching process.   This port is  normally
         invisible.  See leash/1 and visible/1.

    eexxiitt
         The exit port signals the  goal is proved.  It is  possible for
         the goal to have alternatives.  See prolog_frame_attribute/3 to
         examine the goal stack.

    ffaaiill
         The fail port signals final failure of the goal.

    eexxcceeppttiioonn((_E_x_c_e_p_t))
         An  exception is  raised  and still  pending.    This  port  is
         activated on  each parent  frame  of the  frame generating  the
         exception until the  exception is caught  or the user  restarts
         normal  computation  using  retry.     _E_x_c_e_p_t  is  the  pending
         exception term.

    bbrreeaakk((_P_C))
         A break instruction is executed.  _P_C is program counter.   This
         port is used by the graphical debugger.

    ccuutt__ccaallll((_P_C))
         A cut is encountered at _P_C. This port is used  by the graphical
         debugger to visualise the effect of the cut.

    ccuutt__eexxiitt((_P_C))
         A cut has  been executed.   See cut_call(_P_C) for more  informa-
         tion.

    _F_r_a_m_e  is  a  reference to  the  current local  stack  frame,  which
    can  be  examined  using  prolog_frame_attribute/3.     _C_h_o_i_c_e  is  a
    reference  to  the  last choice  point  and  can be  examined  using
    prolog_choice_attribute/3.  _A_c_t_i_o_n must be unified with  a term that
    specifies  how execution must continue.   The following actions  are
    defined:

    aabboorrtt
         Abort execution.  See abort/0.

    ccoonnttiinnuuee
         Continue (i.e., _c_r_e_e_p in the command line debugger).

    ffaaiill
         Make the current goal fail.

    iiggnnoorree
         Step over the current goal without executing it.

    nnooddeebbuugg
         Continue execution in normal nodebugging mode.  See nodebug/0.

    rreettrryy
         Retry the current frame.

    rreettrryy((_F_r_a_m_e))
         Retry the given  frame.  This must  be a parent of the  current
         frame.

    sskkiipp
         Skip over  the current  goal (i.e.,  _s_k_i_p in  the command  line
         debugger).

    uupp
         Skip  to  the  parent  goal  (i.e.,  _u_p  in  the  command  line
         debugger).

    Together  with the predicates described in section ???? and  the other
    predicates  of this chapter, this predicate enables the  Prolog user
    to  define  a  complete new  debugger  in  Prolog.    Besides  this,
    it  enables the  Prolog  programmer to  monitor the  execution of  a
    program.  The  example below records all goals trapped by the tracer
    in the database.

    ____________________________________________________________________|                                                                    |
    | prolog_trace_interception(Port, Frame, _PC, continue) :-           |
    |         prolog_frame_attribute(Frame, goal, Goal),                 |
    |         prolog_frame_attribute(Frame, level, Level),               |

    ||________recordz(trace,_trace(Port,_Level,_Goal))._________________ ||

    To  trace the execution of `go' this way the following  query should
    be given:

    ____________________________________________________________________|                                                                    |
    ||?-_trace,_go,_notrace.____________________________________________ ||


pprroolloogg__sskkiipp__ffrraammee((_-_F_r_a_m_e))
    Indicate  _F_r_a_m_e as  a skipped frame  and set  the `skip level'  (see
    prolog_skip_level/2 to the recursion depth of _F_r_a_m_e.   The effect of
    the skipped flag is  that a redo on a child of this frame is handled
    differently.   First,  a redo trace is  called for the child,  where
    the skip  level is set to redo_in_skip.  Next, the  skip level is set
    to skip level of the skipped frame.


pprroolloogg__sskkiipp__lleevveell((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d  with  the  old  value  of  `skip  level'  and  then  set
    this  level  according  to  _N_e_w.    _N_e_w  is  an  integer,  the  atom
    very_deep  (meaning  don't  skip)  or  the  atom  skip_in_redo  (see
    prolog_skip_frame/1).  The `skip level' is a setting  of each Prolog
    thread  that disables  the debugger on  all recursion levels  deeper
    than the level of the variable.  See also prolog_skip_frame/1.


1155..44 BBrreeaakkppooiinntt aanndd wwaattcchhppooiinntt hhaannddlliinngg

SWI-Prolog support  _b_r_e_a_k_p_o_i_n_t_s.   Breakpoints can  be manipulated  with
the  library  prolog_breakpoints.     Setting  a  breakpoint  replaces  a
virtual  machine instruction  with  the D_BREAK  instruction.    If  the
virtual machine executes a D_BREAK, it performs a callback  to decide on
the action  to perform.   This section  describes this callback,  called
prolog:break_hook/6.


pprroolloogg::bbrreeaakk__hhooookk((_+_C_l_a_u_s_e_, _+_P_C_, _+_F_R_, _+_B_F_R_, _+_E_x_p_r_e_s_s_i_o_n_, _-_A_c_t_i_o_n))_[_h_o_o_k_,_s_e_m_i_d_e_t_]
    _E_x_p_e_r_i_m_e_n_t_a_l  This hook is called if the virtual machine  executes a
    D_BREAK,  set using set_breakpoint/4.   _C_l_a_u_s_e  and _P_C identify  the
    breakpoint.   _F_R and _B_F_R  provide the environment frame and  current
    choicepoint.   _E_x_p_r_e_s_s_i_o_n identifies the action that is interrupted,
    and is one of the following:

    ccaallll((_G_o_a_l))
         The instruction will call  _G_o_a_l.  This is generated  for nearly
         all instructions.   Note that  _G_o_a_l is semantically  equivalent
         to the  compiled  body term,  but  might differ  syntactically.
         This  is  notably the  case  when  arithmetic  expressions  are
         compiled in  optimized mode  (see  optimise).   In  particular,
         the  arguments  of arithmetic  expressions  have  already  been
         evaluated.   Thus,  _A is  3*_B, where _B  equals 3  results in  a
         term call(A is 9) if the clause was compiled  with optimization
         enabled.

    !
         The instruction will  call the cut.   Because the semantics  of
         metacalling  the cut  differs from  executing  the cut  in  its
         original context we do not wrap the cut in call/1.

    :-
         The  breakpoint  is  on  the  _n_e_c_k  instruction,  i.e.,   after
         performing the head unifications.

    eexxiitt
         The breakpoint is on the _e_x_i_t instruction, i.e., at  the end of
         the clause.  Note that the exit instruction may  not be reached
         due to last-call optimisation.

    uunniiffyy__eexxiitt
         The breakpoint is on the completion of  an in-lined unification
         while the system  is not in  debug mode.   If the system is  in
         debug mode, inlined unification is returned as call(Var=Term).

    If  prolog:break_hook/6 succeeds, it  must unify _A_c_t_i_o_n with a  value
    that  describes how execution  must continue.   Possible values  for
    _A_c_t_i_o_n are:

    ccoonnttiinnuuee
         Just continue as if no breakpoint was present.

    ddeebbuugg
         Continue in _d_e_b_u_g _m_o_d_e.  See debug/0.

    ttrraaccee
         Continue in _t_r_a_c_e _m_o_d_e.  See trace/0.

    ccaallll((_G_o_a_l))
         Execute  _G_o_a_l instead  of  the  goal that  would  be  executed.
         _G_o_a_l is  executed as call/1,  preserving (non-)determinism  and
         exceptions.

    If  this  hook throws  an  exception,  the exception  is  propagated
    normally.  If  this hook is not defined or fails, the default action
    is  executed.  This  implies that, if the  thread is in debug  mode,
    the  tracer will be enabled (trace) and otherwise the  breakpoint is
    ignored (continue).

    This hook allows  for injecting various debugging scenarios into the
    executable  without recompiling.   The hook can access variables  of
    the  calling context using  the frame inspection  predicates.   Here
    are some examples.

      o  Create _c_o_n_d_i_t_i_o_n_a_l  breakpoints by  imposing conditions  before
         deciding the return trace.

      o  Watch variables  at a specific  point in the  execution.   Note
         that  binding  of  these  variables  can  be   monitored  using
         _a_t_t_r_i_b_u_t_e_d _v_a_r_i_a_b_l_e_s, see section ????.

      o  Dynamically add _a_s_s_e_r_t_i_o_n_s on variables using assertion/1.

      o  Wrap the  _G_o_a_l into  a meta-call  that traces  progress of  the
         _G_o_a_l.


1155..55 AAddddiinngg ccoonntteexxtt ttoo eerrrroorrss::  pprroolloogg__eexxcceeppttiioonn__hhooookk

The hook prolog_exception_hook/4 has been introduced in SWI-Prolog 5.6.5
to  provide  dedicated exception  handling  facilities  for  application
frameworks, for  example non-interactive  server applications that  wish
to provide extensive context for exceptions for offline debugging.


pprroolloogg__eexxcceeppttiioonn__hhooookk((_+_E_x_c_e_p_t_i_o_n_I_n_, _-_E_x_c_e_p_t_i_o_n_O_u_t_, _+_F_r_a_m_e_, _+_C_a_t_c_h_e_r_F_r_a_m_e))
    This  hook predicate,  if  defined in  the module  user, is  between
    raising  an  exception   and  handling  it.     It  is  intended  to
    allow  a  program  adding  additional context  to  an  exception  to
    simplify  diagnosing  the problem.    _E_x_c_e_p_t_i_o_n_I_n  is the  exception
    term  as  raised  by throw/1  or  one  of the  built-in  predicates.
    The  output  argument  _E_x_c_e_p_t_i_o_n_O_u_t  describes  the  exception  that
    is  actually  raised.      _F_r_a_m_e  is  the  innermost  frame.     See
    prolog_frame_attribute/3 and  the library  prolog_stack for  getting
    information  from this.   _C_a_t_c_h_e_r_F_r_a_m_e is  a reference to the  frame
    calling  the matching catch/3, none  if the exception is not  caught
    or  'C' if the  exception is  caught in C  calling Prolog using  the
    flag PL_Q_CATCH_EXCEPTION.

    The hook is run  in `nodebug' mode.  If it succeeds, _E_x_c_e_p_t_i_o_n_O_u_t is
    considered the current  exception.  If it fails, _E_x_c_e_p_t_i_o_n_I_n is used
    for further processing.   The hook is _n_e_v_e_r called recursively.  The
    hook is _n_o_t allowed  to modify _E_x_c_e_p_t_i_o_n_O_u_t in such a way that it no
    longer unifies with the catching frame.

    Typically,   prolog_exception_hook/4 is  used  to  fill  the  second
    argument  of error(_F_o_r_m_a_l_, _C_o_n_t_e_x_t) exceptions.   _F_o_r_m_a_l is  defined
    by  the  ISO  standard,   while  SWI-Prolog  defines  _C_o_n_t_e_x_t  as  a
    term  context(_L_o_c_a_t_i_o_n_,  _M_e_s_s_a_g_e).    _L_o_c_a_t_i_o_n is  bound to  a  term
    <_n_a_m_e>/<_a_r_i_t_y>  by the kernel.    This hook can  be used to  add more
    information on the calling context, such as a full stack trace.

    Applications  that use exceptions as part of normal  processing must
    do  a  quick  test  of the  environment  before  starting  expensive
    gathering information on the state of the program.

    The  hook can call  trace/0 to  enter trace mode  immediately.   For
    example,  imagine an application performing an unwanted  division by
    zero while all other  errors are expected and handled.  We can force
    the  debugger using the hook definition  below.  Run the program  in
    debug  mode (see  debug/0) to preserve  as much  as possible of  the
    error context.

    ____________________________________________________________________|                                                                    |
    | user:prolog_exception_hook(                                        |
    |          error(evaluation_error(zero_divisor), _),                 |
    |          _, _, _) :-                                               |

    ||________trace,_fail.______________________________________________ ||


1155..66 HHooookkss uussiinngg tthhee eexxcceeppttiioonn pprreeddiiccaattee

This section describes  the predicate exception/3, which can  be defined
by the  user in the module  user as a multifile  predicate.  Unlike  the
name suggests,  this is actually a _h_o_o_k  predicate that has no  relation
to  Prolog exceptions  as  defined by  the  ISO predicates  catch/3  and
throw/1.

The  predicate exception/3  is  called by  the  kernel  on a  couple  of
events, allowing the user  to `fix' errors just-in-time.   The mechanism
allows for _l_a_z_y creation of objects such as predicates.


eexxcceeppttiioonn((_+_E_x_c_e_p_t_i_o_n_, _+_C_o_n_t_e_x_t_, _-_A_c_t_i_o_n))
    Dynamic  predicate,  normally not  defined.   Called  by the  Prolog
    system  on run-time exceptions that can be  repaired `just-in-time'.
    The values for _E_x_c_e_p_t_i_o_n  are described below.  See also catch/3 and
    throw/1.

    If  this  hook predicate  succeeds it  must  instantiate the  _A_c_t_i_o_n
    argument  to the  atom  fail to  make the  operation fail  silently,
    retry  to tell Prolog  to retry the operation  or error to make  the
    system generate an exception.   The action retry only makes sense if
    this  hook modified the environment such that the operation  can now
    succeed without error.

    uunnddeeffiinneedd__pprreeddiiccaattee
         _C_o_n_t_e_x_t   is    instantiated   to    a   predicate    indicator
         ([module]:<_n_a_m_e>/<_a_r_i_t_y>).  If the  predicate fails, Prolog will
         generate an  existence_error exception.   The hook is  intended
         to implement alternatives  to the built-in autoloader, such  as
         autoloading code  from a database.    Do _n_o_t use  this hook  to
         suppress existence errors on predicates.  See  also unknown and
         section ????.

    uunnddeeffiinneedd__gglloobbaall__vvaarriiaabbllee
         _C_o_n_t_e_x_t  is instantiated  to the  name  of the  missing  global
         variable.  The hook  must call nb_setval/2 or b_setval/2 before
         returning with the action retry.


1155..77 HHooookkss ffoorr iinntteeggrraattiinngg lliibbrraarriieess

Some libraries  realise an entirely new  programming paradigm on top  of
Prolog.   An example is  XPCE which adds an  object system to Prolog  as
well as an extensive  set of graphical primitives.   SWI-Prolog provides
several hooks to  improve the integration of  such libraries.  See  also
section  ???? for  editing  hooks and  section  ????  for hooking  into  the
message system.


pprroolloogg__lliisstt__ggooaall((_:_G_o_a_l))
    Hook, normally not defined.   This hook is called by the 'L' command
    of  the  tracer in  the module  user to  list  the currently  called
    predicate.   This hook may be defined to list only  relevant clauses
    of  the indicated  _G_o_a_l and/or  show the  actual source  code in  an
    editor.  See also portray/1 and multifile/1.


pprroolloogg::ddeebbuugg__ccoonnttrrooll__hhooookk((_:_A_c_t_i_o_n))
    Hook for the  debugger control predicates that allows the creator of
    more  high-level programming languages  to use the common  front-end
    predicates  to control the debugger.   For example, XPCE uses  these
    hooks  to allow for spying methods  rather than predicates.   _A_c_t_i_o_n
    is one of:

    ssppyy((_S_p_e_c))
         Hook in  spy/1.  If  the hook succeeds  spy/1 takes no  further
         action.

    nnoossppyy((_S_p_e_c))
         Hook  in nospy/1.    If  the  hook  succeeds nospy/1  takes  no
         further action.  If  spy/1 is hooked, it is advised to  place a
         complementary hook for nospy/1.

    nnoossppyyaallll
         Hook in nospyall/0.   Should remove all spy points.   This hook
         is called in a failure-driven loop.

    ddeebbuuggggiinngg
         Hook in  debugging/0.   It can  be used in  two ways.   It  can
         report the  status of  the additional  debug points  controlled
         by the  above  hooks and  fail  to let  the system  report  the
         others,  or it  succeeds, overruling  the  entire behaviour  of
         debugging/0.


pprroolloogg::hheellpp__hhooookk((_+_A_c_t_i_o_n))
    Hook  into help/0 and help/1.   If  the hook succeeds, the  built-in
    actions are not  executed.  For example, ?- help(picture). is caught
    by  the XPCE help hook to give  help on the class _p_i_c_t_u_r_e.   Defined
    actions are:

    hheellpp
         User entered plain  help/0 to give default  help.  The  default
         performs help(help/1), giving help on help.

    hheellpp((_W_h_a_t))
         Hook in help/1 on the topic _W_h_a_t.

    aapprrooppooss((_W_h_a_t))
         Hook in apropos/1 on the topic _W_h_a_t.


1155..88 HHooookkss ffoorr llooaaddiinngg ffiilleess

All loading  of source  files is  achieved by  load_files/2.   The  hook
prolog_load_file/2 can be  used to  load Prolog code  from non-files  or
even load entirely different information, such as foreign files.


pprroolloogg__llooaadd__ffiillee((_+_S_p_e_c_, _+_O_p_t_i_o_n_s))
    Load  a single object.  If this  call succeeds, load_files/2 assumes
    the  action has been  taken care of.   This hook  is only called  if
    _O_p_t_i_o_n_s  does not contain the stream(_I_n_p_u_t)  option.  The hook  must
    be defined in the module user.

    This  can  be used  to  load  from unusual  places.    For  example,
    library  http/http_load  loads Prolog directly  from an HTTP  server.
    It  can  also be  used to  load  source in  unusual forms,  such  as
    loading  compressed files without decompressing  them first.   There
    is currently no example of that.


pprroolloogg::ccoommmmeenntt__hhooookk((_+_C_o_m_m_e_n_t_s_, _+_P_o_s_, _+_T_e_r_m))
    This  hook  allows   for  processing  comments  encountered  by  the
    compiler.   If this hook is defined,  the compiler calls read_term/2
    with  the  option  comments(_C_o_m_m_e_n_t_s).    If  the list  of  comments
    returned  by read_term/2  is not empty  it calls  this comment  hook
    with the following arguments.

      o  _C_o_m_m_e_n_t_s is the  non-empty list of comments.   Each comment  is
         a pair _P_o_s_i_t_i_o_n-_S_t_r_i_n_g,  where _S_t_r_i_n_g is  a string object  (see
         section ????)  that  contains the  comment _i_n_c_l_u_d_i_n_g  delimiters.
         Consecutive line comments are returned as a single comment.

      o  _P_o_s  is a  stream-position  term  that describes  the  starting
         position of _T_e_r_m

      o  _T_e_r_m is the term read.

    This   hook  is  exploited  by  the  documentation  system.      See
    stream_position_data/3.  See also read_term/3.


CChhaapptteerr 1166..  CCOOMMPPAATTIIBBIILLIITTYY WWIITTHH OOTTHHEERR PPRROOLLOOGG DDIIAALLEECCTTSS

This  chapter explains  issues  for  writing portable  Prolog  programs.
It was  started after discussion  with Vitor  Santos Costa, the  leading
developer  of  YAP   Prolog  YAP  and  SWI-Prolog  have  expressed   the
ambition to enhance the portability beyond the  trivial Prolog examples,
including complex libraries involving foreign code.

Although it  is our  aim to enhance  compatibility, we  are still  faced
with many incompatibilities between the dialects.  As  a first step both
YAP and SWI will provide some instruments that  help developing portable
code.   A first  release of these tools  appeared in SWI-Prolog  5.6.43.
Some of  the facilities are  implemented in the  base system, others  in
the library dialect.pl.

  o The  Prolog flag dialect is an unambiguous and fast way to  find out
    which  Prolog dialect executes your program.   It has the value  swi
    for SWI-Prolog and yap on YAP.

  o The  Prolog flag version_data is bound  to a term swi(_M_a_j_o_r_,  _M_i_n_o_r_,
    _P_a_t_c_h_, _E_x_t_r_a)

  o Conditional   compilation  using  :- if(Condition)  ...:- endif   is
    supported.  See section ????.

  o The  predicate  expects_dialect/1 allows  for specifying  for  which
    Prolog system the code was written.

  o The  predicates exists_source/1 and source_exports/2 can be used  to
    query  the library content.  The require/1 directive can be  used to
    get access to predicates without knowing their location.

  o The  module predicates use_module/1,  use_module/2have  been extended
    with  a  notion  for  `import-except'  and `import-as'.     This  is
    particularly  useful  together  with reexport/1  and  reexport/2  to
    compose modules from other modules and mapping names.

  o Foreign  code can expect __SWI_PROLOG__ when compiled for  SWI-Prolog
    and  __YAP_PROLOG__when compiled on YAP.


::-- eexxppeeccttss__ddiiaalleecctt((_+_D_i_a_l_e_c_t))
    This  directive  states that  the code  following  the directive  is
    written  for the  given Prolog  _D_i_a_l_e_c_t.   See  also dialect.    The
    declaration  holds until the  end of the  file in which it  appears.
    The current dialect is available using prolog_load_context/2.

    The   exact  behaviour  of  this  predicate  is  still   subject  to
    discussion.   Of course, if _D_i_a_l_e_c_t matches the running  dialect the
    directive  has no  effect.   Otherwise  we check  for the  existence
    of  library(_d_i_a_l_e_c_t_/_D_i_a_l_e_c_t)  and  load it  if  the file  is  found.
    Currently, this file has this functionality:

      o  Define system  predicates of  the requested dialect  we do  not
         have.

      o  Apply goal_expansion/2  rules that  map conflicting  predicates
         to versions emulating the  requested dialect.  These  expansion
         rules  reside in  the  dialect compatibility  module,  but  are
         applied if prolog_load_context(dialect, Dialect) is active.

      o  Modify  the  search  path  for  library  directories,   putting
         libraries compatible with the target dialect before  the native
         libraries.

      o  Setup  support  for  the  default  filename  extension  of  the
         dialect.


eexxiissttss__ssoouurrccee((_+_S_p_e_c))
    Is  true if  _S_p_e_c exists as  a Prolog source.    _S_p_e_c uses the  same
    conventions as  load_files/2.  Fails without error  if _S_p_e_c cannot be
    found.


ssoouurrccee__eexxppoorrttss((_+_S_p_e_c_, _+_E_x_p_o_r_t))
    Is  true  if source  _S_p_e_c  exports _E_x_p_o_r_t,  a  predicate  indicator.
    Fails without error otherwise.


1166..11 SSoommee ccoonnssiiddeerraattiioonnss ffoorr wwrriittiinngg ppoorrttaabbllee ccooddee

The  traditional  way  to  write  portable  code  is  to  define  custom
predicates  for  all  potentially non-portable  code  and  define  these
separately for  all Prolog  dialects one wishes  to support.   Here  are
some considerations.

  o Probably  the  best reason  for this  is that  it  allows to  define
    minimal  semantics required by  the application for the  portability
    predicates.   Such functionality can often be mapped  efficiently to
    the  target dialect.    Contrary, if  code was  written for  dialect
    X,  the defined semantics are  those of dialect X.   Emulating all
    extreme  cases and full error handling compatibility may  be tedious
    and  result in a much slower  implementation that needed.  Take  for
    example  call_cleanup/2.   The SICStus  definition is  fundamentally
    different from the  SWI definition, but 99% of the applications just
    want to make  calls like below to guarantee _S_t_r_e_a_m_I_n is closed, even
    if process/1 misbehaves.

    ____________________________________________________________________|                                                                    |

    ||________call_cleanup(process(StreamIn),_close(In))________________ ||

  o As  a drawback,  the code becomes  full of _m_y___c_a_l_l___c_l_e_a_n_u_p, etc.  and
    every  potential portability conflict  needs to be  abstracted.   It
    is  hard for people  who have to maintain  such code later to  grasp
    the  exact semantics  of the  _m_y___* predicates  and applications  that
    combine  multiple libraries  using this  compatibility approach  are
    likely  to encounter conflicts  between the portability  layers.   A
    good  start  is not  to  use _m_y___*, but  a  prefix derived  from  the
    library  or  application name  or names  that  explain the  intended
    semantics more precisely.

  o Another  problem  is   that  most  code  is  initially  not  written
    with  portability  in  mind.     Instead,  ports  are  requested  by
    users   or  arise  from  the   desire  to  switch  Prolog   dialect.
    Typically,  we want  to achieve  compatibility with  the new  Prolog
    dialect  with  minimal  changes,  often keeping  compatibility  with
    the  original  dialect(s).   This  problem is  well  known from  the
    C/Unix  world  and  we advise  anyone  to  study the  philosophy  of
    http://www.gnu.org/software/autoconf/GNU  autoconf,  from  which  we
    will illustrate some highlights below.

The  GNU autoconf  suite, known  to  most people  as configure,  was  an
answer to the frustrating life of Unix/C programmers  when Unix dialects
were  about as  abundant  and  poorly standardised  as  Prolog  dialects
today.   Writing a portable  C program can  only be achieved using  cpp,
the C  preprocessor.   The  C preprocessor  performs two  tasks:   macro
expansion and conditional compilation.  Prolog  realises macro expansion
through term_expansion/2 and goal_expansion/2.   Conditional compilation
is achieved  using :- if(Condition)  as explained  in section ????.    The
situation appears similar.

The important lesson learned  from GNU autoconf is that the  _l_a_s_t resort
for conditional compilation  to achieve portability is to switch  on the
platform or dialect.   Instead, GNU  autoconf allows you to write  tests
for specific  properties of  the platform.   Most  of these are  whether
or  not some  function  or file  is  available.    Then there  are  some
standard tests  for difficult-to-write-portable  situations and  finally
there  is a  framework that  allows you  to write  arbitrary C  programs
and check  whether they  can be  compiled and/or whether  they show  the
intended behaviour.   Using  a separate configure  program is needed  in
C, as  you cannot  perform C  compilation step  or run  C programs  from
the C  preprocessor.  In  most Prolog environments  we do not need  this
distinction as the  compiler is integrated into the runtime  environment
and Prolog has excellent reflexion capabilities.

We  must learn  from the  distinction to  test for  features instead  of
platform (dialect), as this makes the platform-specific  code robust for
future changes of the dialect.  Suppose we need  compare/3 as defined in
this manual.   The compare/3 predicate is not part of the  ISO standard,
but  many systems  support it  and it  is not  unlikely  it will  become
ISO standard  or the  intended dialect will  start supporting  it.   GNU
autoconf strongly advises to test for the availability:

________________________________________________________________________|                                                                        |
|:- if(\+current_predicate(_, compare(_,_,_))).                          |
|compare(<, Term1, Term2) :-                                             |

|        Term1 @< Term2, !.                                              |
|compare(>, Term1, Term2) :-                                             |
|        Term1 @> Term2, !.                                              |
|compare(=, Term1, Term2) :-                                             |
|        Term1 == Term2.                                                 |
|:-|endif.______________________________________________________________ |  |

This code is  mmuucchh more robust against  changes to the intended  dialect
and, possibly  at least  as important,  will provide compatibility  with
dialects you didn't even consider porting to right now.

In a  more challenging case,  the target Prolog  has compare/3, but  the
semantics  are different.    What to  do?    One option  is  to write  a
my_compare/3 and change all occurrences in the code.   Alternatively you
can rename  calls using  goal_expansion/2 like  below.   This  construct
will not  only deal with  Prolog dialects lacking  compare/3 as well  as
those that  only implement  it for  numeric comparison  or have  changed
the argument order.   Of course,  writing rock-solid code would  require
a  complete  test-suite,  but  this  example  will  probably  cover  all
Prolog dialects  that allow for conditional  compilation, have core  ISO
facilities and  provide goal_expansion/2, the things  we claim a  Prolog
dialect should have to start writing portable code for it.

________________________________________________________________________|                                                                        |

|:- if(\+catch(compare(<,a,b), _, fail)).                                |
|compare_standard_order(<, Term1, Term2) :-                              |
|        Term1 @< Term2, !.                                              |
|compare_standard_order(>, Term1, Term2) :-                              |
|        Term1 @> Term2, !.                                              |
|compare_standard_order(=, Term1, Term2) :-                              |
|        Term1 == Term2.                                                 |

|                                                                        |
|goal_expansion(compare(Order, Term1, Term2),                            |
|               compare_standard_order(Order, Term1, Term2)).            |
|:-|endif.______________________________________________________________ |  |


CChhaapptteerr 1177..  GGLLOOSSSSAARRYY OOFF TTEERRMMSS

aannoonnyymmoouuss [[vvaarriiaabbllee]]
    The  variable  _  is  called  the  _a_n_o_n_y_m_o_u_s  variable.     Multiple
    occurrences of _ in a single _t_e_r_m are not _s_h_a_r_e_d.

aarrgguummeennttss
    Arguments  are _t_e_r_m_s that appear in a _c_o_m_p_o_u_n_d _t_e_r_m.  _A_1  and _a_2 are
    the first and second argument of the term myterm(_A_1_, _a_2).

aarriittyy
    Argument count (= number of arguments) of a _c_o_m_p_o_u_n_d _t_e_r_m.

aasssseerrtt
    Add a _c_l_a_u_s_e to  a _p_r_e_d_i_c_a_t_e.  Clauses can be added at either end of
    the clause-list of a _p_r_e_d_i_c_a_t_e.  See asserta/1 and assertz/1.

aattoomm
    Textual  constant.   Used as name for  _c_o_m_p_o_u_n_d terms, to  represent
    constants or text.

bbaacckkttrraacckkiinngg
    Search  process used  by Prolog.    If a  predicate offers  multiple
    _c_l_a_u_s_e_s  to  solve  a _g_o_a_l,  they  are  tried one-by-one  until  one
    _s_u_c_c_e_e_d_s.    If  a subsequent  part of  the proof  is not  satisfied
    with  the resulting _v_a_r_i_a_b_l_e _b_i_n_d_i_n_g, it may ask for  an alternative
    _s_o_l_u_t_i_o_n (= _b_i_n_d_i_n_g  of the _v_a_r_i_a_b_l_e_s), causing Prolog to reject the
    previously chosen _c_l_a_u_s_e and try the next one.

bbiinnddiinngg [[ooff aa vvaarriiaabbllee]]
    Current value of the _v_a_r_i_a_b_l_e.  See also _b_a_c_k_t_r_a_c_k_i_n_g and _q_u_e_r_y.

bbuuiilltt--iinn [[pprreeddiiccaattee]]
    Predicate  that is part of the  Prolog system.  Built-in  predicates
    cannot  be redefined  by the  user, unless this  is overruled  using
    redefine_system_predicate/1.

bbooddyy
    Part of a _c_l_a_u_s_e behind the _n_e_c_k operator (:-).

cchhooiiccee ppooiinntt
    A  _c_h_o_i_c_e _p_o_i_n_t represents  a choice in  the search for a  _s_o_l_u_t_i_o_n.
    Choice  points are  created  if multiple  clauses match  a _q_u_e_r_y  or
    using  disjunction (;/2).   On _b_a_c_k_t_r_a_c_k_i_n_g, the execution state  of
    the  most recent _c_h_o_i_c_e _p_o_i_n_t is restored and search  continues with
    the next alternative (i.e., next clause or second branch of ;/2).

ccllaauussee
    `Sentence'  of a Prolog program.   A _c_l_a_u_s_e  consists of a _h_e_a_d  and
    _b_o_d_y  separated by  the _n_e_c_k operator  (:-) or it  is a _f_a_c_t.    For
    example:

    ____________________________________________________________________|                                                                    |
    | parent(X) :-                                                       |

    ||________father(X,__)._____________________________________________ ||

    Expressed  as ``X is a  parent if X is a  father of someone''.   See
    also _v_a_r_i_a_b_l_e and _p_r_e_d_i_c_a_t_e.

ccoommppiillee
    Process  where  a Prolog  _p_r_o_g_r_a_m  is translated  to a  sequence  of
    instructions.   See  also _i_n_t_e_r_p_r_e_t_e_d.   SWI-Prolog always  compiles
    your program before executing it.

ccoommppoouunndd [[tteerrmm]]
    Also  called  _s_t_r_u_c_t_u_r_e.    It  consists of  a  name followed  by  _N
    _a_r_g_u_m_e_n_t_s,  each of which are _t_e_r_m_s.   _N is called the _a_r_i_t_y  of the
    term.

ccoonntteexxtt mmoodduullee
    If  a _t_e_r_m  is referring  to a _p_r_e_d_i_c_a_t_e  in a  _m_o_d_u_l_e, the  _c_o_n_t_e_x_t
    _m_o_d_u_l_e  is used to find the target module.  The context  module of a
    _g_o_a_l  is the module in which  the _p_r_e_d_i_c_a_t_e is defined, unless  this
    _p_r_e_d_i_c_a_t_e  is _m_o_d_u_l_e _t_r_a_n_s_p_a_r_e_n_t, in  which case the _c_o_n_t_e_x_t  _m_o_d_u_l_e
    is  inherited from the parent  _g_o_a_l.  See  also module_transparent/1
    and _m_e_t_a_-_p_r_e_d_i_c_a_t_e.

ddccgg
    Abbreviation for _D_e_f_i_n_i_t_e _C_l_a_u_s_e _G_r_a_m_m_a_r.

ddeett [[ddeetteerrmmiinniissmm]]
    Short for _d_e_t_e_r_m_i_n_i_s_t_i_c.

ddeetteerrmmiinniissmm
    How  many solutions a _g_o_a_l can  provide.  Values are `nondet'  (zero
    to  infinite), `multi'  (one to infinite),  `det' (exactly one)  and
    `semidet' (zero or one).

ddeetteerrmmiinniissttiicc
    A  _p_r_e_d_i_c_a_t_e  is  _d_e_t_e_r_m_i_n_i_s_t_i_c  if it  succeeds  exactly  one  time
    without leaving a _c_h_o_i_c_e _p_o_i_n_t.

ddyynnaammiicc [[pprreeddiiccaattee]]
    A _d_y_n_a_m_i_c predicate  is a predicate to which _c_l_a_u_s_e_s may be _a_s_s_e_r_ted
    and  from  which  _c_l_a_u_s_e_s may  be  _r_e_t_r_a_c_ted  while the  program  is
    running.  See also _u_p_d_a_t_e _v_i_e_w.

eexxppoorrtteedd [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e is  said to  be _e_x_p_o_r_t_e_d from  a _m_o_d_u_l_e  if it  appears
    in  the  _p_u_b_l_i_c _l_i_s_t.     This implies  that  the predicate  can  be
    _i_m_p_o_r_t_e_d  into another module  to make it visible  there.  See  also
    use_module/[1,2].

ffaacctt
    _C_l_a_u_s_e  without a _b_o_d_y.  This is called a fact  because, interpreted
    as logic, there is  no condition to be satisfied.  The example below
    states john is a person.

    ____________________________________________________________________|                                                                    |
    ||person(john)._____________________________________________________ ||

ffaaiill
    A _g_o_a_l is said to haved failed if it could not be _p_r_o_v_e_n.

ffllooaatt
    Computer's  crippled representation of a  real number.   Represented
    as `IEEE double'.

ffoorreeiiggnn
    Computer code expressed  in languages other than Prolog.  SWI-Prolog
    can only cooperate directly with the C and C++ computer languages.

ffuunnccttoorr
    Combination  of name and _a_r_i_t_y of a _c_o_m_p_o_u_n_d term.  The  term foo(_a_,
    _b_,  _c) is said to be a  term belonging to the functor foo/3.   foo/0
    is used to refer to the _a_t_o_m foo.

ggooaall
    Question  stated to the  Prolog engine.   A _g_o_a_l  is either an  _a_t_o_m
    or  a _c_o_m_p_o_u_n_d  term.   A _g_o_a_l  either succeeds, in  which case  the
    _v_a_r_i_a_b_l_e_s  in the  _c_o_m_p_o_u_n_d terms  have a  _b_i_n_d_i_n_g, or  it _f_a_i_l_s  if
    Prolog fails to prove it.

hhaasshhiinngg
    _I_n_d_e_x_i_n_g technique used for quick lookup.

hheeaadd
    Part of a _c_l_a_u_s_e before the  _n_e_c_k operator (:-).  This is an _a_t_o_m or
    _c_o_m_p_o_u_n_d term.

iimmppoorrtteedd [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e is said to be _i_m_p_o_r_t_e_d  into a _m_o_d_u_l_e if it  is defined
    in  another _m_o_d_u_l_e  and made  available in this  _m_o_d_u_l_e.   See  also
    chapter ????.

iinnddeexxiinngg
    Indexing is a  technique used to quickly select candidate _c_l_a_u_s_e_s of
    a  _p_r_e_d_i_c_a_t_e for a specific _g_o_a_l.  In most Prolog  systems, indexing
    is done (only) on  the first _a_r_g_u_m_e_n_t of the _h_e_a_d.  If this argument
    is  instantiated to an  _a_t_o_m, _i_n_t_e_g_e_r, _f_l_o_a_t  or _c_o_m_p_o_u_n_d term  with
    _f_u_n_c_t_o_r,  _h_a_s_h_i_n_g is used  to quickly select  all _c_l_a_u_s_e_s where  the
    first  argument  may _u_n_i_f_y  with  the first  argument of  the  _g_o_a_l.
    SWI-Prolog  supports just-in-time and multi-argument indexing.   See
    section ????.

iinntteeggeerr
    Whole number.   On all implementations of SWI-Prolog integers are at
    least  64-bit signed values.   When linked  to the GNU GMP  library,
    integer  arithmetic is unbounded.    See also current_prolog_flag/2,
    flags bounded, max_integer and min_integer.

iinntteerrpprreetteedd
    As  opposed  to  _c_o_m_p_i_l_e_d,   interpreted  means  the  Prolog  system
    attempts  to prove  a _g_o_a_l  by directly reading  the _c_l_a_u_s_e_s  rather
    than executing instructions  from an (abstract) instruction set that
    is not or only indirectly related to Prolog.

iinnssttaannttiiaattiioonn [[ooff aann aarrgguummeenntt]]
    To  what  extend  a term  is  bound to  a  value.    Typical  levels
    are  `unbound' (a  _v_a_r_i_a_b_l_e), `ground'  (term without variables)  or
    `partially bound' (term with embedded variables).

mmeettaa--pprreeddiiccaattee
    A  _p_r_e_d_i_c_a_t_e that reasons about other _p_r_e_d_i_c_a_t_e_s, either  by calling
    them, (re)defining them or querying _p_r_o_p_e_r_t_i_e_s.

mmooddee [[ddeeccllaarraattiioonn]]
    Declaration  of an argument  _i_n_s_t_a_n_t_i_a_t_i_o_n pattern for a  _p_r_e_d_i_c_a_t_e,
    often accompanied with a _d_e_t_e_r_m_i_n_i_s_m.

mmoodduullee
    Collection  of predicates.    Each module defines  a name-space  for
    predicates.   _b_u_i_l_t_-_i_n predicates  are accessible from all  modules.
    Predicates  can be published (_e_x_p_o_r_t_e_d)  and _i_m_p_o_r_t_e_d to make  their
    definition available to other modules.

mmoodduullee ttrraannssppaarreenntt [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e that  does not change  the _c_o_n_t_e_x_t  _m_o_d_u_l_e.   Sometimes
    also called a _m_e_t_a_-_p_r_e_d_i_c_a_t_e.

mmuullttii [[ddeetteerrmmiinniissmm]]
    A  _p_r_e_d_i_c_a_t_e is said  to have _d_e_t_e_r_m_i_n_i_s_m  multi if it generates  at
    _l_e_a_s_t one answer.

mmuullttiiffiillee [[pprreeddiiccaattee]]
    Predicate  for which  the  definition is  distributed over  multiple
    source files.  See multifile/1.

nneecckk
    Operator (:-) separating _h_e_a_d from _b_o_d_y in a _c_l_a_u_s_e.

nnoonnddeett
    Short for _n_o_n _d_e_t_e_r_m_i_n_i_s_t_i_c.

nnoonn ddeetteerrmmiinniissttiicc
    A  _n_o_n _d_e_t_e_r_m_i_n_i_s_t_i_c  predicate  is a  predicate that  mail fail  or
    succeed any number of times.

ooppeerraattoorr
    Symbol (_a_t_o_m) that  may be placed before its _o_p_e_r_a_n_d (prefix), after
    its _o_p_e_r_a_n_d (postfix) or between its two _o_p_e_r_a_n_d_s (infix).

    In  Prolog, the expression a+b is exactly the same as  the canonical
    term +(a,b).

ooppeerraanndd
    _A_r_g_u_m_e_n_t of an _o_p_e_r_a_t_o_r.

pprreecceeddeennccee
    The  _p_r_i_o_r_i_t_y  of an  _o_p_e_r_a_t_o_r.    Operator  precedence is  used  to
    interpret a+b*c as +(a, *(b,c)).

pprreeddiiccaattee
    Collection  of _c_l_a_u_s_e_s  with the same  _f_u_n_c_t_o_r (name/_a_r_i_t_y).   If  a
    _g_o_a_l  is proved,  the system  looks for  a _p_r_e_d_i_c_a_t_e  with the  same
    functor,  then uses  _i_n_d_e_x_i_n_g to select  candidate _c_l_a_u_s_e_s and  then
    tries these _c_l_a_u_s_e_s one-by-one.  See also _b_a_c_k_t_r_a_c_k_i_n_g.

pprreeddiiccaattee iinnddiiccaattoorr
    Term  of the form Name/Arity  (traditional) or Name//Arity (ISO  DCG
    proposal),  where Name is an atom and Arity a  non-negative integer.
    It acts as an _i_n_d_i_c_a_t_o_r (or reference) to a predicate or _D_C_G rule.

pprriioorriittyy
    In the context of _o_p_e_r_a_t_o_r_s a synonym for _p_r_e_c_e_d_e_n_c_e.

pprrooggrraamm
    Collection of _p_r_e_d_i_c_a_t_e_s.

pprrooppeerrttyy
    Attribute  of  an object.    SWI-Prolog  defines  various _*___p_r_o_p_e_r_t_y
    predicates to query the status of predicates, clauses.  etc.

pprroovvee
    Process  where Prolog attempts to prove a _q_u_e_r_y using  the available
    _p_r_e_d_i_c_a_t_e_s.

ppuubblliicc lliisstt
    List of _p_r_e_d_i_c_a_t_e_s exported from a _m_o_d_u_l_e.

qquueerryy
    See _g_o_a_l.

rreettrraacctt
    Remove  a _c_l_a_u_s_e from a  _p_r_e_d_i_c_a_t_e.   See also _d_y_n_a_m_i_c, _u_p_d_a_t_e  _v_i_e_w
    and _a_s_s_e_r_t.

sseemmiiddeett
    Shorthand for

sseemmii ddeetteerrmmiinniissttiicc
    .

sseemmii ddeetteerrmmiinniissttiicc
    A  _p_r_e_d_i_c_a_t_e that  is _s_e_m_i  _d_e_t_e_r_m_i_n_i_s_t_i_c either  fails or  succeeds
    exactly once without a _c_h_o_i_c_e _p_o_i_n_t.  See also _d_e_t_e_r_m_i_n_i_s_t_i_c.

sshhaarreedd
    Two  _v_a_r_i_a_b_l_e_s  are called  _s_h_a_r_e_d after  they are  _u_n_i_f_i_e_d.    This
    implies  if either of them is _b_o_u_n_d, the other is bound to  the same
    value:

    ____________________________________________________________________|                                                                    |
    | ?- A = B, A = a.                                                   |
    ||A_=_B,_B_=_a._____________________________________________________ ||

ssiinngglleettoonn [[vvaarriiaabbllee]]
    _V_a_r_i_a_b_l_e  appearing only one time in a _c_l_a_u_s_e.   SWI-Prolog normally
    warns  for  this to  avoid  you  making spelling  mistakes.    If  a
    variable  appears on  purpose only  once in  a clause,  write it  as
    _  (see _a_n_o_n_y_m_o_u_s).    Rules for naming  a variable  and avoiding  a
    warning are given in section ????.

ssoolluuttiioonn
    _B_i_n_d_i_n_g_s resulting from a successfully _p_r_o_v_en _g_o_a_l.

ssttrruuccttuurree
    Synonym for _c_o_m_p_o_u_n_d term.

ssttrriinngg
    Used  for the  following representations  of text:   a packed  array
    (see section ????,  SWI-Prolog specific), a list of character codes or
    a list of one-character _a_t_o_m_s.

ssuucccceeeedd
    A _g_o_a_l is said to have _s_u_c_c_e_e_d_e_d if it has been _p_r_o_v_e_n.

tteerrmm
    Value in Prolog.   A _t_e_r_m is either a _v_a_r_i_a_b_l_e, _a_t_o_m, _i_n_t_e_g_e_r, _f_l_o_a_t
    or  _c_o_m_p_o_u_n_d term.   In addition,  SWI-Prolog also defines the  type
    _s_t_r_i_n_g.

ttrraannssppaarreenntt
    See _m_o_d_u_l_e _t_r_a_n_s_p_a_r_e_n_t.

uunniiffyy
    Prolog  process to make  two terms equal  by assigning variables  in
    one term to  values at the corresponding location of the other term.
    For example:

    ____________________________________________________________________|                                                                    |

    | ?- foo(a, B) = foo(A, b).                                          |
    | A = a,                                                             |
    ||B_=_b.____________________________________________________________ ||

    Unlike  assignment (which does not exist in Prolog),  unification is
    not directed.

uuppddaattee vviieeww
    How  Prolog behaves when a _d_y_n_a_m_i_c _p_r_e_d_i_c_a_t_e is changed while  it is
    running.   There are two models.   In most older Prolog  systems the
    change  becomes immediately visible to  the _g_o_a_l, in modern  systems
    including  SWI-Prolog, the running _g_o_a_l is  not affected.  Only  new
    _g_o_a_l_s `see' the new definition.

vvaarriiaabbllee
    A  Prolog  variable is  a value  that `is  not yet  bound'.    After
    _b_i_n_d_i_n_g a variable, it  cannot be modified.  _B_a_c_k_t_r_a_c_k_i_n_g to a point
    in  the execution before  the variable was  bound will turn it  back
    into a variable:

    ____________________________________________________________________|                                                                    |
    | ?- A = b, A = c.                                                   |
    | false.                                                             |
    |                                                                    |
    | ?- (A = b; true; A = c).                                           |

    | A = b ;                                                            |
    | true ;                                                             |
    ||A_=_c_.___________________________________________________________ ||

    See also _u_n_i_f_y.


CChhaapptteerr 1188..  SSWWII--PPRROOLLOOGG LLIICCEENNSSEE CCOONNDDIITTIIOONNSS AANNDD TTOOOOLLSS

As of  version 7.4.0,  the SWI-Prolog source  code is distributed  under
the https://opensource.org/licenses/BSD-2-ClauseSimplified BSD license:

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in
       the documentation and/or other materials provided with the
       distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.

This, unfortunately,  ddooeess nnoott  mmeeaann yyoouu ccaann  aannyy vveerrssiioonn ooff  SSWWII--PPrroolloogg
uunnddeerr  tthhee  aabboovvee lliicceennssee.     The  SWI-Prolog core  may  be  linked  to
libraries that are more  restrictive and in addition your code  may have
loaded extension  packages that have  more restrictive  conditions.   In
particular, the core is by default  linked to https://gmplib.org/libgmp,
distributed under the Lesser GNU Public license.

The  above  implies you  need  to  configure and  recompile  the  system
without these components.  For this we provide  options to the configure
script:

________________________________________________________________________|                                                                        |

|./configure --without-gpl                                               |
|./configure|--without-lgpl_____________________________________________ |           |

The  GNU  MP  Bignum  Library  provides  unbounded  integers,   rational
numbers and some  cryptographical functionality.  As libgmp  is provided
under the  Lesser GNU  Public license  it may legally  be combined  with
proprietary software as  long as libgmp is _d_y_n_a_m_i_c_a_l_l_y _l_i_n_k_e_d  (default)
and the  end user  can replace  the libgmp  shared object  and use  your
application  with their  (possibly  modified) version  of  libgmp.    In
practice this  leads to problems  if the  application is not  accessible
(e.g., embedded  in closed hardware) or you  want to avoid customers  to
peek around in the process  memory as they can easily do so by  adding a
backdoor to the  modified LGPL component.   Note that such a  protection
is  in general  not possible  anyway if  the  customer has  unrestricted
access to the machine on which the application runs.


1188..11 CCoonnttrriibbuuttiinngg ttoo tthhee SSWWII--PPrroolloogg pprroojjeecctt

To reach  maximal coherence we  will, as  a rule of  thumb, only  accept
new code that  has the Simplified BSD  license and existing code with  a
_p_e_r_m_i_s_s_i_v_e license  such as  MIT, Apache,  BSD-3, etc.   In  exceptional
cases  we may  accept code  with  GPL or  LGPL conditions.    Such  code
must  be tagged  using  a license/1  directive  (Prolog)  or a  call  to
PL_license() for foreign  code and, if  they are part  of the core,  the
code must be excluded using the --without-gpl or --without-lgpl option.


1188..22 SSooffttwwaarree ssuuppppoorrtt ttoo kkeeeepp ttrraacckk ooff lliicceennssee ccoonnddiittiioonnss

Given the above, it is possible that SWI-Prolog  packages and extensions
rely  on  the GPL,  LGPL  or  other  licenses.    The  predicates  below
allow for registering license requirements for Prolog  files and foreign
modules.   The  predicate license/0  reports which  components from  the
currently configured  system are  distributed under non-permissive  open
source  licenses and  therefore may  need to  be replaced  to suit  your
requirements.


lliicceennssee
    Evaluate  the license conditions of all  loaded components.  If  the
    system  contains  one or  more components  that  are licenced  under
    GPL-like  restrictions the  system indicates this  program may  only
    be  distributed under the  GPL license as  well as which  components
    prohibit  the use  of other license  conditions.   Likewise for  for
    LGPL components.


lliicceennssee((_+_L_i_c_e_n_s_e_I_d_, _+_C_o_m_p_o_n_e_n_t))
    Register  the fact  that _C_o_m_p_o_n_e_n_t  is distributed  under a  license
    identified  by _L_i_c_e_n_s_e_I_d.   Known license identifiers can be  listed
    using known_licenses/0.  A new license can  be registered as a known
    language  using  a declaration  like  below.   The  second  argument
    defines  the _c_a_t_e_g_o_r_y  if the license,  which is one  of gpl,  lgpl,
    permissive or proprietary.

    ____________________________________________________________________|                                                                    |
    | :- multifile license:license/3.                                    |

    |                                                                    |
    | license:license(mylicense, permissive,                             |
    |                 [ comment('My personal license'),                  |
    |                   url('http://www.mine.org/license.html')          |
    |                 ]).                                                |
    |                                                                    |
    ||:-_license(mylicense).____________________________________________ ||


lliicceennssee((_+_L_i_c_e_n_s_e_I_d))
    Intended  as a  directive  in Prolog  source files.    It takes  the
    current filename and calls license/2.


void PPLL__lliicceennssee(_c_o_n_s_t _c_h_a_r _*_L_i_c_e_n_s_e_I_d_, _c_o_n_s_t _c_h_a_r _*_C_o_m_p_o_n_e_n_t)
    Intended  for the install()  procedure of foreign  libraries.   This
    call can be made _b_e_f_o_r_e PL_initialise().


kknnoowwnn__lliicceennsseess
    List  all  licenses _k_n_o_w_n  to  the  system.    This does  not  imply
    the  system  contains code  covered by  the listed  licenses.    See
    license/2.


1188..33 LLiicceennssee ccoonnddiittiioonnss iinnhheerriitteedd ffrroomm uusseedd ccooddee


1188..33..11 CCrryyppttooggrraapphhiicc rroouuttiinneess

Cryptographic routines  are used  in variant_sha1/2  and crypt.    These
routines are provided under the following conditions:

Copyright (c) 2002, Dr Brian Gladman, Worcester, UK.   All rights reserved.

LICENSE TERMS

The free distribution and use of this software in both source and binary
form is allowed (with or without changes) provided that:

   1. distributions of this source code include the above copyright
      notice, this list of conditions and the following disclaimer;

   2. distributions in binary form include the above copyright
      notice, this list of conditions and the following disclaimer
      in the documentation and/or other associated materials;

   3. the copyright holder's name is not used to endorse products
      built using this software without specific written permission.

ALTERNATIVELY, provided that this notice is retained in full, this product
may be distributed under the terms of the GNU General Public License (GPL),
in which case the provisions of the GPL apply INSTEAD OF those given above.

DISCLAIMER

This software is provided 'as is' with no explicit or implied warranties
in respect of its properties, including, but not limited to, correctness
and/or fitness for purpose.


CChhaapptteerr 1199..  SSUUMMMMAARRYY


1199..11 PPrreeddiiccaatteess

The  predicate summary  is used  by the  Prolog  predicate apropos/1  to
suggest predicates from a keyword.

 @/2    Call using calling context
 !/0    Cut (discard choicepoints)
 ,/2    Conjunction of goals
 ->/2   If-then-else
 *->/2  Soft-cut
 ./2    Consult.  Also functional notation
 :</2   Select keys from a dict
 ;/2    Disjunction of two goals

 </2    Arithmetic smaller
 =/2    True when arguments are unified
 =../2  ``Univ.''  Term to list conversion
 =:=/2  Arithmetic equality
 =</2   Arithmetic smaller or equal
 ==/2   Test for strict equality
 =@=/2  Test for structural equality (variant)

 =\=/2  Arithmetic not equal
 >/2    Arithmetic larger
 >=/2   Arithmetic larger or equal
 >:</2  Partial dict unification
 ?=/2   Test of terms can be compared now
 @</2                     Standard order smaller
 @=</2                    Standard order smaller or equal
 @>/2                     Standard order larger

 @>=/2                    Standard order larger or equal
 \+/1                     Negation by failure.  Same as not/1
 \=/2                     True if arguments cannot be unified
 \==/2                    True if arguments are not strictly equal
 \=@=/2                   Not structural identical
 ^/2                      Existential quantification (bagof/3, setof/3)
 |/2                      Disjunction in DCGs.  Same as ;/2

 {}/1                     DCG escape; constraints
 abolish/1                Remove predicate definition from the database
 abolish/2                Remove predicate definition from the database
 abolish_all_tables/0     Abolish computed tables
 abolish_table_subgoals/1 Abolish tables for a goal
 abort/0                  Abort execution, return to top level
 absolute_file_name/2     Get absolute path name
 absolute_file_name/3     Get absolute path name with options

 access_file/2            Check access permissions of a file
 acyclic_term/1           Test term for cycles
 add_import_module/3      Add module to the auto-import list
 add_nb_set/2             Add term to a non-backtrackable set
 add_nb_set/3             Add term to a non-backtrackable set
 append/1                 Append to a file
 apply/2                  Call goal with additional arguments

 apropos/1                online_help Search manual
 arg/3                    Access argument of a term
 assoc_to_list/2          Convert association tree to list
 assert/1                 Add a clause to the database
 assert/2                 Add a clause to the database, give reference
 asserta/1                Add a clause to the database (first)
 asserta/2                Add a clause to the database (first)
 assertion/1              Make assertions about your program

 assertz/1                Add a clause to the database (last)
 assertz/2                Add a clause to the database (last)
 attach_console/0         Attach I/O console to thread
 attach_packs/0           Attach add-ons
 attach_packs/1           Attach add-ons from directory
 attach_packs/2           Attach add-ons from directory
 attribute_goals/3        Project attributes to goals

 attr_unify_hook/2        Attributed variable unification hook
 attr_portray_hook/2      Attributed variable print hook
 attvar/1                 Type test for attributed variable
 at_end_of_stream/0       Test for end of file on input
 at_end_of_stream/1       Test for end of file on stream
 at_halt/1                Register goal to run at halt/1
 atom/1                   Type check for an atom
 atom_chars/2             Convert between atom and list of characters

 atom_codes/2             Convert between atom and list of characters codes
 atom_concat/3            Contatenate two atoms
 atom_length/2            Determine length of an atom
 atom_number/2            Convert between atom and number
 atom_prefix/2            Test for start of atom
 atom_string/2            Conversion between atom and string
 atom_to_term/3           Convert between atom and term

 atomic/1                 Type check for primitive
 atomic_concat/3          Concatenate two atomic values to an atom
 atomic_list_concat/2     Append a list of atomics
 atomic_list_concat/3     Append a list of atomics with separator
 atomics_to_string/2      Concatenate list of inputs to a string
 atomics_to_string/3          Concatenate list of inputs to a string
 autoload/0                   Autoload all predicates now
 autoload_path/1              Add directories for autoloading

 b_getval/2                   Fetch backtrackable global variable
 b_set_dict/3                 Destructive assignment on a dict
 b_setval/2                   Assign backtrackable global variable
 bagof/3                      Find all solutions to a goal
 between/3                    Integer range checking/generating
 blob/2                       Type check for a blob
 break/0                      Start interactive top level

 break_hook/6                 (hook) Debugger hook
 byte_count/2                 Byte-position in a stream
 call/1                       Call a goal
 call/[2..]                   Call with additional arguments
 call_cleanup/3               Guard a goal with a cleaup-handler
 call_cleanup/2               Guard a goal with a cleaup-handler
 call_dcg/3                   As phrase/3 without type checking
 call_residue_vars/2          Find residual attributed variables

 call_shared_object_function/2UNIX: Call C-function in shared (.so) file
 call_with_depth_limit/3      Prove goal with bounded depth
 call_with_inference_limit/3  Prove goal in limited inferences
 callable/1                   Test for atom or compound term
 cancel_halt/1                Cancel halt/0 from an at_halt/1 hook
 catch/3                      Call goal, watching for exceptions
 char_code/2                  Convert between character and character code

 char_conversion/2            Provide mapping of input characters
 char_type/2                  Classify characters
 character_count/2            Get character index on a stream
 chdir/1                      Compatibility:  change working directory
 chr_constraint/1             CHR Constraint declaration
 chr_show_store/1             List suspended CHR constraints
 chr_trace/0                  Start CHR tracer
 chr_type/1                   CHR Type declaration

 chr_notrace/0                Stop CHR tracer
 chr_leash/1                  Define CHR leashed ports
 chr_option/2                 Specify CHR compilation options
 clause/2                     Get clauses of a predicate
 clause/3                     Get clauses of a predicate
 clause_property/2            Get properties of a clause
 close/1                      Close stream

 close/2                      Close stream (forced)
 close_dde_conversation/1     Win32:  Close DDE channel
 close_shared_object/1        UNIX: Close shared library (.so file)
 collation_key/2              Sort key for locale dependent ordering
 comment_hook/3               (hook) handle comments in sources
 compare/3                    Compare, using a predicate to determine the order
 compile_aux_clauses/1        Compile predicates for goal_expansion/2
 compile_predicates/1         Compile dynamic code to static

 compiling/0                  Is this a compilation run?
 compound/1                   Test for compound term
 compound_name_arity/3        Name and arity of a compound term
 compound_name_arguments/3    Name and arguments of a compound term
 code_type/2                  Classify a character-code
 consult/1                    Read (compile) a Prolog source file
 context_module/1             Get context module of current goal

 convert_time/8               Break time stamp into fields
 convert_time/2               Convert time stamp to string
 copy_stream_data/2           Copy all data from stream to stream
 copy_stream_data/3           Copy n bytes from stream to stream
 copy_predicate_clauses/2     Copy clauses between predicates
 copy_term/2                   Make a copy of a term
 copy_term/3                   Copy a term and obtain attribute-goals
 copy_term_nat/2               Make a copy of a term without attributes

 create_prolog_flag/3          Create a new Prolog flag
 current_arithmetic_function/1 Examine evaluable functions
 current_atom/1                Examine existing atoms
 current_blob/2                Examine typed blobs
 current_char_conversion/2     Query input character mapping
 current_engine/1              Enumerate known engines
 current_flag/1                Examine existing flags

 current_foreign_library/2     shlib Examine loaded shared libraries (.so files)
 current_format_predicate/2    Enumerate user-defined format codes
 current_functor/2             Examine existing name/arity pairs
 current_input/1               Get current input stream
 current_key/1                 Examine existing database keys
 current_locale/1              Get the current locale
 current_module/1              Examine existing modules
 current_op/3                  Examine current operator declarations

 current_output/1              Get the current output stream
 current_predicate/1           Examine existing predicates (ISO)
 current_predicate/2           Examine existing predicates
 current_signal/3              Current software signal mapping
 current_stream/3              Examine open streams
 current_table/2               Find answer table for a variant
 current_trie/1                Enumerate known tries

 cyclic_term/1                 Test term for cycles
 day_of_the_week/2             Determine ordinal-day from date
 date_time_stamp/2             Convert date structure to time-stamp
 date_time_value/3             Extract info from a date structure
 dcg_translate_rule/2          Source translation of DCG rules
 dcg_translate_rule/4          Source translation of DCG rules
 dde_current_connection/2      Win32:  Examine open DDE connections
 dde_current_service/2         Win32:  Examine DDE services provided

 dde_execute/2                 Win32:  Execute command on DDE server
 dde_register_service/2        Win32:  Become a DDE server
 dde_request/3                 Win32:  Make a DDE request
 dde_poke/3                    Win32:  POKE operation on DDE server
 dde_unregister_service/1      Win32:  Terminate a DDE service
 debug/0                       Test for debugging mode
 debug/1                       Select topic for debugging

 debug/3                       Print debugging message on topic
 debug_control_hook/1          (hook) Extend spy/1, etc.
 debugging/0                   Show debugger status
 debugging/1                   Test where we are debugging topic
 default_module/2              Query module inheritance
 del_attr/2                    Delete attribute from variable
 del_attrs/1                   Delete all attributes from variable
 del_dict/4                    Delete Key-Value pair from a dict

 delete_directory/1            Remove a folder from the file system
 delete_file/1                 Remove a file from the file system
 delete_import_module/2        Remove module from import list
 deterministic/1               Test deterministicy of current clause
 dif/2                         Constrain two terms to be different
 directory_files/2             Get entries of a directory/folder
 discontiguous/1               Indicate distributed definition of a predicate

 divmod/4                      Compute quotient and remainder of two integers
 downcase_atom/2               Convert atom to lower-case
 duplicate_term/2              Create a copy of a term
 dwim_match/2                  Atoms match in ``Do What I Mean'' sense
 dwim_match/3                  Atoms match in ``Do What I Mean'' sense
 dwim_predicate/2              Find predicate in ``Do What I Mean'' sense
 dynamic/1                     Indicate predicate definition may change
 edit/0                        Edit current script- or associated file

 edit/1                        Edit a file, predicate, module (extensible)
 elif/1                        Part of conditional compilation (directive)
 else/0                        Part of conditional compilation (directive)
 empty_assoc/1                 Create/test empty association tree
 empty_nb_set/1                Test/create an empty non-backtrackable set
 encoding/1                    Define encoding inside a source file
 endif/0                       End of conditional compilation (directive)

 engine_create/3               Create an interactor
 engine_create/4               Create an interactor
 engine_destroy/1              Destroy an interactor
 engine_fetch/1                Get term from caller
 engine_next/2                 Ask interactor for next term
 engine_next_reified/2         Ask interactor for next term
 engine_post/2                 Send term to an interactor
 engine_post/3                 Send term to an interactor and wait for reply

 engine_self/1                 Get handle to running interactor
 engine_yield/1                Make term available to caller
 ensure_loaded/1               Consult a file if that has not yet been done
 erase/1                       Erase a database record or clause
 exception/3                   (hook) Handle runtime exceptions
 exists_directory/1            Check existence of directory
 exists_file/1                 Check existence of file

 exists_source/1               Check existence of a Prolog source
 expand_answer/2               Expand answer of query
 expand_file_name/2            Wildcard expansion of file names
 expand_file_search_path/2     Wildcard expansion of file paths
 expand_goal/2                 Compiler:  expand goal in clause-body
 expand_goal/4                 Compiler:  expand goal in clause-body
 expand_query/4                Expanded entered query
 expand_term/2                 Compiler:  expand read term into clause(s)

 expand_term/4                 Compiler:  expand read term into clause(s)
 expects_dialect/1             For which Prolog dialect is this code written?
 explain/1                     explain Explain argument
 explain/2                     explain 2nd argument is explanation of first
 export/1                      Export a predicate from a module
 fail/0                        Always false
 false/0                       Always false

 fast_term_serialized/2        Fast term (de-)serialization
 fast_read/2                   Read binary term serialization
 fast_write/2                  Write binary term serialization
 current_prolog_flag/2         Get system configuration parameters
 file_base_name/2              Get file part of path
 file_directory_name/2         Get directory part of path
 file_name_extension/3         Add, remove or test file extensions
 file_search_path/2            Define path-aliases for locating files

 find_chr_constraint/1         Returns a constraint from the store
 findall/3                     Find all solutions to a goal
 findall/4                     Difference list version of findall/3
 findnsols/4                   Find first _N solutions
 findnsols/5                   Difference list version of findnsols/4
 fill_buffer/1                 Fill the input buffer of a stream
 flag/3                        Simple global variable system

 float/1                       Type check for a floating point number
 flush_output/0                Output pending characters on current stream
 flush_output/1                Output pending characters on specified stream
 forall/2                      Prove goal for all solutions of another goal
 format/1                      Formatted output
 format/2                      Formatted output with arguments
 format/3                      Formatted output on a stream
 format_time/3                 C strftime() like date/time formatter

 format_time/4                 date/time formatter with explicit locale
 format_predicate/2            Program format/[1,2]
 term_attvars/2                Find attributed variables in a term
 term_variables/2              Find unbound variables in a term
 term_variables/3              Find unbound variables in a term
 text_to_string/2              Convert arbitrary text to a string
 freeze/2                      Delay execution until variable is bound

 frozen/2                      Query delayed goals on var
 functor/3                     Get name and arity of a term or construct a term
 garbage_collect/0             Invoke the garbage collector
 garbage_collect_atoms/0       Invoke the atom garbage collector
 garbage_collect_clauses/0     Invoke clause garbage collector
 gen_assoc/3                   Enumerate members of association tree
 gen_nb_set/2                  Generate members of non-backtrackable set
 gensym/2                      Generate unique atoms from a base

 get/1                         Read first non-blank character
 get/2                         Read first non-blank character from a stream
 get_assoc/3                   Fetch key from association tree
 get_assoc/5                   Fetch key from association tree
 get_attr/3                    Fetch named attribute from a variable
 get_attrs/2                   Fetch all attributes of a variable
 get_byte/1                    Read next byte (ISO)

 get_byte/2                    Read next byte from a stream (ISO)
 get_char/1                    Read next character as an atom (ISO)
 get_char/2                    Read next character from a stream (ISO)
 get_code/1                    Read next character (ISO)
 get_code/2                    Read next character from a stream (ISO)
 get_dict/3                    Get the value associated to a key from a dict
 get_dict/5                    Replace existing value in a dict
 get_flag/2                    Get value of a flag

 get_single_char/1             Read next character from the terminal
 get_string_code/3             Get character code at index in string
 get_time/1                    Get current time
 get0/1                        Read next character
 get0/2                        Read next character from a stream
 getenv/2                      Get shell environment variable
 goal_expansion/2              Hook for macro-expanding goals

 goal_expansion/4              Hook for macro-expanding goals
 ground/1                      Verify term holds no unbound variables
 gdebug/0                      Debug using graphical tracer
 gspy/1                        Spy using graphical tracer
 gtrace/0                      Trace using graphical tracer
 guitracer/0                   Install hooks for the graphical debugger
 gxref/0                       Cross-reference loaded program
 halt/0                        Exit from Prolog

 halt/1                        Exit from Prolog with status
 term_hash/2                   Hash-value of ground term
 term_hash/4                   Hash-value of term with depth limit
 help/0                        Give help on help
 help/1                        Give help on predicates and show parts of manual
 help_hook/1                   (hook) User-hook in the help-system
 if/1                          Start conditional compilation (directive)

 ignore/1                      Call the argument, but always succeed
 import/1                      Import a predicate from a module
 import_module/2               Query import modules
 in_pce_thread/1               Run goal in XPCE thread
 in_pce_thread_sync/1          Run goal in XPCE thread
 include/1                     Include a file with declarations
 initialization/1              Initialization directive
 initialization/2              Initialization directive

 initialize/0                  Run program initialization
 instance/2                    Fetch clause or record from reference
 integer/1                     Type check for integer
 interactor/0                  Start new thread with console and top level
 is/2                          Evaluate arithmetic expression
 is_absolute_file_name/1       True if arg defines an absolute path
 is_assoc/1                    Verify association list

 is_engine/1                   Type check for an engine handle
 is_list/1                     Type check for a list
 is_dict/1                     Type check for a dict
 is_dict/2                     Type check for a dict in a class
 is_stream/1                   Type check for a stream handle
 is_trie/1                     Type check for a trie handle
 is_thread/1                   Type check for an thread handle
 join_threads/0                Join all terminated threads interactively

 keysort/2                     Sort, using a key
 known_licenses/0              Print known licenses
 last/2                        Last element of a list
 leash/1                       Change ports visited by the tracer
 length/2                      Length of a list
 library_directory/1           (hook) Directories holding Prolog libraries
 license/0                     Evaluate licenses of loaded modules

 license/1                     Define license for current file
 license/2                     Define license for named module
 line_count/2                  Line number on stream
 line_position/2               Character position in line on stream
 list_debug_topics/0           List registered topics for debugging
 list_to_assoc/2               Create association tree from list
 list_to_set/2                 Remove duplicates from a list
 list_strings/0                Help porting to version 7

 listing/0                     List program in current module
 listing/1                     List predicate
 load_files/1                  Load source files
 load_files/2                  Load source files with options
 load_foreign_library/1        shlib Load shared library (.so file)
 load_foreign_library/2        shlib Load shared library (.so file)
 locale_create/3               Create a new locale object

 locale_destroy/1              Destroy a locale object
 locale_property/2             Query properties of locale objects
 locale_sort/2                 Language dependent sort of atoms
 make/0                        Reconsult all changed source files
 make_directory/1              Create a folder on the file system
 make_library_index/1          Create autoload file INDEX.pl
 make_library_index/2          Create selective autoload file INDEX.pl
 map_assoc/2                   Map association tree

 map_assoc/3                   Map association tree
 dict_create/3                 Create a dict from data
 dict_pairs/3                  Convert between dict and list of pairs
 max_assoc/3                   Highest key in association tree
 memberchk/2                   Deterministic member/2
 message_hook/3                Intercept print_message/2
 message_line_element/2        (hook) Intercept print_message_lines/3

 message_property/2            (hook) Define display of a message
 message_queue_create/1        Create queue for thread communication
 message_queue_create/2        Create queue for thread communication
 message_queue_destroy/1       Destroy queue for thread communication
 message_queue_property/2      Query message queue properties
 message_to_string/2           Translate message-term to string
 meta_predicate/1              Declare access to other predicates
 min_assoc/3                   Lowest key in association tree

 module/1                      Query/set current type-in module
 module/2                      Declare a module
 module/3                      Declare a module with language options
 module_property/2             Find properties of a module
 module_transparent/1          Indicate module based meta-predicate
 msort/2                       Sort, do not remove duplicates
 multifile/1                   Indicate distributed definition of predicate

 mutex_create/1                Create a thread-synchronisation device
 mutex_create/2                Create a thread-synchronisation device
 mutex_destroy/1               Destroy a mutex
 mutex_lock/1                  Become owner of a mutex
 mutex_property/2              Query mutex properties
 mutex_statistics/0            Print statistics on mutex usage
 mutex_trylock/1               Become owner of a mutex (non-blocking)
 mutex_unlock/1                Release ownership of mutex

 mutex_unlock_all/0            Release ownership of all mutexes
 name/2                        Convert between atom and list of character codes
 nb_current/2                  Enumerate non-backtrackable global variables
 nb_delete/1                   Delete a non-backtrackable global variable
 nb_getval/2                   Fetch non-backtrackable global variable
 nb_link_dict/3                Non-backtrackable assignment to dict
 nb_linkarg/3                  Non-backtrackable assignment to term

 nb_linkval/2                  Assign non-backtrackable global variable
 nb_set_to_list/2              Convert non-backtrackable set to list
 nb_set_dict/3                 Non-backtrackable assignment to dict
 nb_setarg/3                   Non-backtrackable assignment to term
 nb_setval/2                   Assign non-backtrackable global variable
 nl/0                          Generate a newline
 nl/1                          Generate a newline on a stream
 nodebug/0                     Disable debugging

 nodebug/1                     Disable debug-topic
 noguitracer/0                 Disable the graphical debugger
 nonground/2                   Term is not ground due to witness
 nonvar/1                      Type check for bound term
 noprofile/1                   Hide (meta-) predicate for the profiler
 noprotocol/0                  Disable logging of user interaction
 normalize_space/2             Normalize white space

 nospy/1                        Remove spy point
 nospyall/0                     Remove all spy points
 not/1                          Negation by failure (argument not provable).  Same as \+/1
 notrace/0                      Stop tracing
 notrace/1                      Do not debug argument goal
 nth_clause/3                   N-th clause of a predicate
 nth_integer_root_and_remainder/4Integer root and remainder
 number/1                       Type check for integer or float

 number_chars/2                 Convert between number and one-char atoms
 number_codes/2                 Convert between number and character codes
 number_string/2                Convert between number and string
 numbervars/3                   Number unbound variables of a term
 numbervars/4                   Number unbound variables of a term
 on_signal/3                    Handle a software signal
 once/1                         Call a goal deterministically

 op/3                           Declare an operator
 open/3                         Open a file (creating a stream)
 open/4                         Open a file (creating a stream)
 open_dde_conversation/3        Win32:  Open DDE channel
 open_null_stream/1             Open a stream to discard output
 open_resource/3                Open a program resource as a stream
 open_shared_object/2           UNIX: Open shared library (.so file)
 open_shared_object/3           UNIX: Open shared library (.so file)

 open_string/2                  Open a string as a stream
 ord_list_to_assoc/2            Convert ordered list to assoc
 parse_time/2                   Parse text to a time-stamp
 parse_time/3                   Parse text to a time-stamp
 pce_dispatch/1                 Run XPCE GUI in separate thread
 pce_call/1                     Run goal in XPCE GUI thread
 peek_byte/1                    Read byte without removing

 peek_byte/2                    Read byte without removing
 peek_char/1                    Read character without removing
 peek_char/2                    Read character without removing
 peek_code/1                    Read character-code without removing
 peek_code/2                    Read character-code without removing
 peek_string/3                  Read a string without removing
 phrase/2                       Activate grammar-rule set
 phrase/3                       Activate grammar-rule set (returning rest)

 phrase_from_quasi_quotation/2  Parse quasi quotation with DCG
 please/3                       Query/change environment parameters
 plus/3                         Logical integer addition
 portray/1                      (hook) Modify behaviour of print/1
 portray_clause/1               Pretty print a clause
 portray_clause/2               Pretty print a clause to a stream
 predicate_property/2           Query predicate attributes

 predsort/3                     Sort, using a predicate to determine the order
 print/1                        Print a term
 print/2                        Print a term on a stream
 print_message/2                Print message from (exception) term
 print_message_lines/3          Print message to stream
 profile/1                      Obtain execution statistics
 profile/2                      Obtain execution statistics
 profile_count/3                Obtain profile results on a predicate

 profiler/2                     Obtain/change status of the profiler
 prolog/0                       Run interactive top level
 prolog_alert_signal/2          Query/set unblock signal
 prolog_choice_attribute/3      Examine the choice point stack
 prolog_current_choice/1        Reference to most recent choice point
 prolog_current_frame/1         Reference to goal's environment stack
 prolog_cut_to/1                Realise global cuts

 prolog_edit:locate/2           Locate targets for edit/1
 prolog_edit:locate/3           Locate targets for edit/1
 prolog_edit:edit_source/1      Call editor for edit/1
 prolog_edit:edit_command/2     Specify editor activation
 prolog_edit:load/0             Load edit/1 extensions
 prolog_exception_hook/4        Rewrite exceptions
 prolog_file_type/2             Define meaning of file extension
 prolog_frame_attribute/3       Obtain information on a goal environment

 prolog_ide/1                   Program access to the development environment
 prolog_list_goal/1             (hook) Intercept tracer 'L' command
 prolog_load_context/2          Context information for directives
 prolog_load_file/2             (hook) Program load_files/2
 prolog_skip_level/2            Indicate deepest recursion to trace
 prolog_skip_frame/1            Perform `skip' on a frame
 prolog_stack_property/2        Query properties of the stacks

 prolog_to_os_filename/2        Convert between Prolog and OS filenames
 prolog_trace_interception/4    user Intercept the Prolog tracer
 project_attributes/2           Project constraints to query variables
 prompt1/1                      Change prompt for 1 line
 prompt/2                       Change the prompt used by read/1
 protocol/1                     Make a log of the user interaction
 protocola/1                    Append log of the user interaction to file
 protocolling/1                 On what file is user interaction logged

 public/1                       Declaration that a predicate may be called
 put/1                          Write a character
 put/2                          Write a character on a stream
 put_assoc/4                    Add Key-Value to association tree
 put_attr/3                     Put attribute on a variable
 put_attrs/2                    Set/replace all attributes on a variable
 put_byte/1                     Write a byte

 put_byte/2                     Write a byte on a stream
 put_char/1                     Write a character
 put_char/2                     Write a character on a stream
 put_code/1                     Write a character-code
 put_code/2                     Write a character-code on a stream
 put_dict/3                     Add/replace multiple keys in a dict
 put_dict/4                     Add/replace a single key in a dict
 qcompile/1                     Compile source to Quick Load File

 qcompile/2                     Compile source to Quick Load File
 qsave_program/1                Create runtime application
 qsave_program/2                Create runtime application
 quasi_quotation_syntax/1       Declare quasi quotation syntax
 quasi_quotation_syntax_error/1 Raise syntax error
 random_property/1              Query properties of random generation
 rational/1                     Type check for a rational number

 rational/3                     Decompose a rational
 read/1                         Read Prolog term
 read/2                         Read Prolog term from stream
 read_clause/3                  Read clause from stream
 read_history/6                 Read using history substitution
 read_link/3                    Read a symbolic link
 read_pending_codes/3           Fetch buffered input from a stream
 read_pending_chars/3           Fetch buffered input from a stream

 read_string/3                  Read a number of characters into a string
 read_string/5                  Read string upto a delimiter
 read_term/2                    Read term with options
 read_term/3                    Read term with options from stream
 read_term_from_atom/3          Read term with options from atom
 recorda/2                      Record term in the database (first)
 recorda/3                      Record term in the database (first)

 recorded/2                     Obtain term from the database
 recorded/3                     Obtain term from the database
 recordz/2                      Record term in the database (last)
 recordz/3                      Record term in the database (last)
 redefine_system_predicate/1    Abolish system definition
 reexport/1                     Load files and re-export the imported predicates
 reexport/2                     Load predicates from a file and re-export it
 reload_foreign_libraries/0     Reload DLLs/shared objects

 reload_library_index/0         Force reloading the autoload index
 rename_file/2                  Change name of file
 repeat/0                       Succeed, leaving infinite backtrack points
 require/1                      This file requires these predicates
 reset/3                        Wrapper for delimited continuations
 reset_gensym/1                 Reset a gensym key
 reset_gensym/0                 Reset all gensym keys

 reset_profiler/0               Clear statistics obtained by the profiler
 resource/2                     Declare a program resource
 resource/3                     Declare a program resource
 retract/1                      Remove clause from the database
 retractall/1                   Remove unifying clauses from the database
 same_file/2                    Succeeds if arguments refer to same file
 same_term/2                    Test terms to be at the same address
 see/1                          Change the current input stream

 seeing/1                       Query the current input stream
 seek/4                         Modify the current position in a stream
 seen/0                         Close the current input stream
 select_dict/2                  Select matching attributes from a dict
 select_dict/3                  Select matching attributes from a dict
 set_end_of_stream/1            Set physical end of an open file
 set_flag/2                     Set value of a flag

 set_input/1                    Set current input stream from a stream
 set_locale/1                   Set the default local
 set_module/1                   Set properties of a module
 set_output/1                   Set current output stream from a stream
 set_prolog_IO/3                Prepare streams for interactive session
 set_prolog_flag/2              Define a system feature
 set_prolog_gc_thread/1         Control the gc thread
 set_prolog_stack/2             Modify stack characteristics

 set_random/1                   Control random number generation
 set_stream/2                   Set stream attribute
 set_stream_position/2          Seek stream to position
 setup_call_cleanup/3           Undo side-effects safely
 setup_call_catcher_cleanup/4   Undo side-effects safely
 setarg/3                       Destructive assignment on term
 setenv/2                       Set shell environment variable

 setlocale/3                    Set/query C-library regional information
 setof/3                        Find all unique solutions to a goal
 shell/1                        Execute OS command
 shell/2                        Execute OS command
 shift/1                        Shift control to the closest reset/3
 show_profile/1                 Show results of the profiler
 size_file/2                    Get size of a file in characters
 size_nb_set/2                  Determine size of non-backtrackable set

 skip/1                         Skip to character in current input
 skip/2                         Skip to character on stream
 sleep/1                        Suspend execution for specified time
 sort/2                         Sort elements in a list
 sort/4                         Sort elements in a list
 source_exports/2               Check whether source exports a predicate
 source_file/1                  Examine currently loaded source files

 source_file/2                  Obtain source file of predicate
 source_file_property/2         Information about loaded files
 source_location/2              Location of last read term
 split_string/4                 Break a string into substrings
 spy/1                          Force tracer on specified predicate
 stamp_date_time/3              Convert time-stamp to date structure
 statistics/0                   Show execution statistics
 statistics/2                   Obtain collected statistics

 stream_pair/3                  Create/examine a bi-directional stream
 stream_position_data/3         Access fields from stream position
 stream_property/2              Get stream properties
 string/1                       Type check for string
 string_concat/3                atom_concat/3 for strings
 string_length/2                Determine length of a string
 string_chars/2                 Conversion between string and list of characters

 string_codes/2                 Conversion between string and list of character codes
 string_code/3                  Get or find a character code in a string
 string_lower/2                 Case conversion to lower case
 string_upper/2                 Case conversion to upper case
 string_predicate/1             (hook) Predicate contains strings
 strip_module/3                 Extract context module and term
 style_check/1                  Change level of warnings
 sub_atom/5                     Take a substring from an atom

 sub_atom_icasechk/3            Case insensitive substring match
 sub_string/5                   Take a substring from a string
 subsumes_term/2                One-sided unification test
 succ/2                         Logical integer successor relation
 swritef/2                      Formatted write on a string
 swritef/3                      Formatted write on a string
 tab/1                          Output number of spaces

 tab/2                          Output number of spaces on a stream
 table/1                        Declare predicate to be tabled
 tdebug/0                       Switch all threads into debug mode
 tdebug/1                       Switch a thread into debug mode
 tell/1                         Change current output stream
 telling/1                      Query current output stream
 term_expansion/2               (hook) Convert term before compilation
 term_expansion/4               (hook) Convert term before compilation

 term_singletons/2              Find singleton variables in a term
 term_string/2                  Read/write a term from/to a string
 term_string/3                  Read/write a term from/to a string
 term_subsumer/3                Most specific generalization of two terms
 term_to_atom/2                 Convert between term and atom
 thread_affinity/3              Query and control the _a_f_f_i_n_i_t_y mask
 thread_at_exit/1               Register goal to be called at exit

 thread_create/2                Create a new Prolog task
 thread_create/3                Create a new Prolog task
 thread_detach/1                Make thread cleanup after completion
 thread_exit/1                  Terminate Prolog task with value
 thread_get_message/1           Wait for message
 thread_get_message/2           Wait for message in a queue
 thread_get_message/3           Wait for message in a queue
 thread_initialization/1        Run action at start of thread

 thread_join/1                  Wait for Prolog task-completion
 thread_join/2                  Wait for Prolog task-completion
 thread_local/1                 Declare thread-specific clauses for a predicate
 thread_message_hook/3          Thread local message_hook/3
 thread_peek_message/1          Test for message
 thread_peek_message/2          Test for message in a queue
 thread_property/2              Examine Prolog threads

 thread_self/1                  Get identifier of current thread
 thread_send_message/2          Send message to another thread
 thread_send_message/3          Send message to another thread
 thread_setconcurrency/2        Number of active threads
 thread_signal/2                Execute goal in another thread
 thread_statistics/3            Get statistics of another thread
 threads/0                      List running threads
 throw/1                        Raise an exception (see catch/3)

 time/1                         Determine time needed to execute goal
 time_file/2                    Get last modification time of file
 tmp_file/2                     Create a temporary filename
 tmp_file_stream/3              Create a temporary file and open it
 tnodebug/0                     Switch off debug mode in all threads
 tnodebug/1                     Switch off debug mode in a thread
 told/0                         Close current output

 tprofile/1                     Profile a thread for some period
 trace/0                        Start the tracer
 trace/1                        Set trace point on predicate
 trace/2                        Set/Clear trace point on ports
 tracing/0                      Query status of the tracer
 trie_delete/3                  Remove term from trie
 trie_destroy/1                 Destroy a trie
 trie_gen/3                     Get all terms from a trie

 trie_insert/3                  Insert term into a trie
 trie_insert/4                  Insert term into a trie
 trie_lookup/3                  Lookup a term in a trie
 trie_new/1                     Create a trie
 trie_property/2                Examine a trie's properties
 trie_update/3                  Update associated value in trie
 trie_term/2                    Get term from a trie by handle

 trim_stacks/0                  Release unused memory resources
 true/0                         Succeed
 tspy/1                         Set spy point and enable debugging in all threads
 tspy/2                         Set spy point and enable debugging in a thread
 tty_get_capability/3           Get terminal parameter
 tty_goto/2                     Goto position on screen
 tty_put/2                      Write control string to terminal
 tty_size/2                     Get row/column size of the terminal

 ttyflush/0                     Flush output on terminal
 unify_with_occurs_check/2      Logically sound unification
 unifiable/3                    Determining binding required for unification
 unix/1                         OS interaction
 unknown/2                      Trap undefined predicates
 unload_file/1                  Unload a source file
 unload_foreign_library/1       shlib Detach shared library (.so file)

 unload_foreign_library/2       shlib Detach shared library (.so file)
 unsetenv/1                     Delete shell environment variable
 upcase_atom/2                  Convert atom to upper-case
 use_foreign_library/1          Load DLL/shared object (directive)
 use_foreign_library/2          Load DLL/shared object (directive)
 use_module/1                   Import a module
 use_module/2                   Import predicates from a module
 valid_string_goal/1            (hook) Goal handles strings

 var/1                          Type check for unbound variable
 var_number/2                   Check that var is numbered by numbervars
 var_property/2                 Variable properties during macro expansion
 variant_sha1/2                 Term-hash for term-variants
 variant_hash/2                 Term-hash for term-variants
 version/0                      Print system banner message
 version/1                      Add messages to the system banner

 visible/1                      Ports that are visible in the tracer
 volatile/1                     Predicates that are not saved
 wait_for_input/3               Wait for input with optional timeout
 when/2                         Execute goal when condition becomes true
 wildcard_match/2               Csh(1) style wildcard match
 win_add_dll_directory/1        Add directory to DLL search path
 win_add_dll_directory/2        Add directory to DLL search path
 win_remove_dll_directory/1     Remove directory from DLL search path

 win_exec/2                     Win32:  spawn Windows task
 win_has_menu/0                 Win32:  true if console menu is available
 win_folder/2                   Win32:  get special folder by CSIDL
 win_insert_menu/2              swipl-win.exe:  add menu
 win_insert_menu_item/4         swipl-win.exe:  add item to menu
 win_shell/2                    Win32:  open document through Shell
 win_shell/3                    Win32:  open document through Shell

 win_registry_get_value/3       Win32:  get registry value
 win_window_pos/1               Win32:  change size and position of window
 window_title/2                 Win32:  change title of window
 with_mutex/2                   Run goal while holding mutex
 with_output_to/2               Write to strings and more
 with_quasi_quotation_input/3   Parse quasi quotation from stream
 working_directory/2            Query/change CWD
 write/1                        Write term

 write/2                        Write term to stream
 writeln/1                      Write term, followed by a newline
 writeln/2                      Write term, followed by a newline to a stream
 write_canonical/1              Write a term with quotes, ignore operators
 write_canonical/2              Write a term with quotes, ignore operators on a stream
 write_length/3                 Dermine #characters to output a term
 write_term/2                   Write term with options

 write_term/3                   Write term with options to stream
 writef/1                       Formatted write
 writef/2                       Formatted write on stream
 writeq/1                       Write term, insert quotes
 writeq/2                       Write term, insert quotes on stream


1199..22 LLiibbrraarryy pprreeddiiccaatteess


1199..22..11 lliibbrraarryy((aaggggrreeggaattee))

 aggregate/3      Aggregate bindings in Goal according to Template.
 aggregate/4      Aggregate bindings in Goal according to Template.
 aggregate_all/3  Aggregate bindings in Goal according to Template.
 aggregate_all/4  Aggregate bindings in Goal according to Template.
 foreach/2        True if conjunction of results is true.
 free_variables/4 Find free variables in bagof/setof template.


1199..22..22 lliibbrraarryy((aappppllyy))

 convlist/3   Similar to maplist/3, but elements for which call(Goal, ElemIn, _) fails are omitted from ListOut.
 exclude/3    Filter elements for which Goal fails.
 foldl/4      Fold a list, using arguments of the list as left argument.
 foldl/5      Fold a list, using arguments of the list as left argument.
 foldl/6      Fold a list, using arguments of the list as left argument.
 foldl/7      Fold a list, using arguments of the list as left argument.
 include/3    Filter elements for which Goal succeeds.
 maplist/2    True if Goal can successfully be applied on all elements of List.

 maplist/3    As maplist/2, operating on pairs of elements from two lists.
 maplist/4    As maplist/2, operating on triples of elements from three lists.
 maplist/5    As maplist/2, operating on quadruples of elements from four lists.
 partition/4  Filter elements of List according to Pred.
 partition/5  Filter List according to Pred in three sets.
 scanl/4      Left scan of list.
 scanl/5      Left scan of list.

 scanl/6      Left scan of list.
 scanl/7      Left scan of list.


1199..22..33 lliibbrraarryy((aassssoocc))

 assoc_to_list/2    Translate assoc into a pairs list
 assoc_to_keys/2    Translate assoc into a key list
 assoc_to_values/2  Translate assoc into a value list
 empty_assoc/1      Test/create an empty assoc
 gen_assoc/3        Non-deterministic enumeration of assoc
 get_assoc/3        Get associated value
 get_assoc/5        Get and replace associated value
 list_to_assoc/2    Translate pair list to assoc

 map_assoc/2        Test assoc values
 map_assoc/3        Map assoc values
 max_assoc/3        Max key-value of an assoc
 min_assoc/3        Min key-value of an assoc
 ord_list_to_assoc/2Translate ordered list into an assoc
 put_assoc/4        Add association to an assoc


1199..22..44 lliibbrraarryy((bbrrooaaddccaasstt))

 broadcast/1         Send event notification
 broadcast_request/1 Request all agents
 listen/2            Listen to event notifications
 listen/3            Listen to event notifications
 unlisten/1          Stop listening to event notifications
 unlisten/2          Stop listening to event notifications
 unlisten/3          Stop listening to event notifications
 listening/3         Who is listening to event notifications?


1199..22..55 lliibbrraarryy((cchhaarrssiioo))

 atom_to_chars/2       Convert Atom into a list of character codes.
 atom_to_chars/3       Convert Atom into a difference list of character codes.
 format_to_chars/3     Use format/2 to write to a list of character codes.
 format_to_chars/4     Use format/2 to write to a difference list of character codes.
 number_to_chars/2     Convert Atom into a list of character codes.
 number_to_chars/3     Convert Number into a difference list of character codes.
 open_chars_stream/2   Open Codes as an input stream.
 read_from_chars/2     Read Codes into Term.

 read_term_from_chars/3Read Codes into Term.
 with_output_to_chars/2Run Goal as with once/1.
 with_output_to_chars/3Run Goal as with once/1.
 with_output_to_chars/4Same as with_output_to_chars/3 using an explicit stream.
 write_to_chars/2      Write a term to a code list.
 write_to_chars/3      Write a term to a code list.


1199..22..66 lliibbrraarryy((cchheecckk))

 check/0                  Run all consistency checks defined by checker/2.
 checker/2                Register code validation routines.
 list_autoload/0          Report predicates that may be auto-loaded.
 list_redefined/0         Lists predicates that are defined in the global module =user= as well as in a normal module; that is, predicates for which the@
 list_strings/0           List strings that appear in clauses.
 list_strings/1           List strings that appear in clauses.
 list_trivial_fails/0     List goals that trivially fail because there is no matching clause.
 list_trivial_fails/1     List goals that trivially fail because there is no matching clause.

 list_undefined/0         Report undefined predicates.
 list_undefined/1         Report undefined predicates.
 list_void_declarations/0 List predicates that have declared attributes, but no clauses.
 string_predicate/1       Multifile hook to disable list_strings/0 on the given predicate.
 trivial_fail_goal/1      Multifile hook that tells list_trivial_fails/0 to accept Goal as valid.
 valid_string_goal/1      Multifile hook that qualifies Goal as valid for list_strings/0.


1199..22..77 lliibbrraarryy((ccllppbb))

 labeling/1         Enumerate concrete solutions.
 random_labeling/2  Select a single random solution.
 sat/1              True iff Expr is a satisfiable Boolean expression.
 sat_count/2        Count the number of admissible assignments.
 taut/2             Tautology check.
 weighted_maximum/3 Enumerate weighted optima over admissible assignments.


1199..22..88 lliibbrraarryy((ccllppffdd))

 #/\/2           P and Q hold.
 #</2            The arithmetic expression X is less than Y.
 #<==/2          Q implies P.
 #<==>/2         P and Q are equivalent.
 #=/2            The arithmetic expression X equals Y.
 #=</2           The arithmetic expression X is less than or equal to Y.
 #==>/2          P implies Q.
 #>/2            Same as Y #< X.

 #>=/2           Same as Y #=< X.
 #\/1            Q does _not_hold.
 #\/2            Either P holds or Q holds, but not both.
 #\//2           P or Q holds.
 #\=/2           The arithmetic expressions X and Y evaluate to distinct integers.
 all_different/1 Like all_distinct/1, but with weaker propagation.
 all_distinct/1  True iff Vars are pairwise distinct.

 automaton/3     Describes a list of finite domain variables with a finite automaton.
 automaton/8     Describes a list of finite domain variables with a finite automaton.
 chain/2         Zs form a chain with respect to Relation.
 circuit/1       True iff the list Vs of finite domain variables induces a Hamiltonian circuit.
 cumulative/1    Equivalent to cumulative(Tasks, [limit(1)]).
 cumulative/2         Schedule with a limited resource.
 disjoint2/1          True iff Rectangles are not overlapping.
 element/3            The N-th element of the list of finite domain variables Vs is V.

 fd_dom/2             Dom is the current domain (see in/2) of Var.
 fd_inf/2             Inf is the infimum of the current domain of Var.
 fd_size/2            Reflect the current size of a domain.
 fd_sup/2             Sup is the supremum of the current domain of Var.
 fd_var/1             True iff Var is a CLP(FD) variable.
 global_cardinality/2 Global Cardinality constraint.
 global_cardinality/3 Global Cardinality constraint.

 in/2                 Var is an element of Domain.
 indomain/1           Bind Var to all feasible values of its domain on backtracking.
 ins/2                The variables in the list Vars are elements of Domain.
 label/1              Equivalent to labeling([], Vars).
 labeling/2           Assign a value to each variable in Vars.
 lex_chain/1          Lists are lexicographically non-decreasing.
 scalar_product/4     True iff the scalar product of Cs and Vs is in relation Rel to Expr.
 serialized/2         Describes a set of non-overlapping tasks.

 sum/3                The sum of elements of the list Vars is in relation Rel to Expr.
 transpose/2          Transpose a list of lists of the same length.
 tuples_in/2          True iff all Tuples are elements of Relation.
 zcompare/3           Analogous to compare/3, with finite domain variables A and B.


1199..22..99 lliibbrraarryy((ccllppqqrr))

 entailed/1  Check if constraint is entailed
 inf/2       Find the infimum of an expression
 sup/2       Find the supremum of an expression
 minimize/1  Minimizes an expression
 maximize/1  Maximizes an expression
 bb_inf/3    Infimum of expression for mixed-integer problems
 bb_inf/4    Infimum of expression for mixed-integer problems
 bb_inf/5    Infimum of expression for mixed-integer problems

 dump/3      Dump constraints on variables


1199..22..1100 lliibbrraarryy((ccssvv))

 csv_options/2      Compiled is the compiled representation of the CSV processing options as they may be passed into csv//2, etc.
 csv_read_file/2    Read a CSV file into a list of rows.
 csv_read_file/3    Read a CSV file into a list of rows.
 csv_read_file_row/3True when Row is a row in File.
 csv_read_row/3     Read the next CSV record from Stream and unify the result with Row.
 csv_write_file/2   Write a list of Prolog terms to a CSV file.
 csv_write_file/3   Write a list of Prolog terms to a CSV file.
 csv_write_stream/3 Write the rows in Data to Stream.

 csv//1             Prolog DCG to `read/write' CSV data.
 csv//2             Prolog DCG to `read/write' CSV data.


1199..22..1111 lliibbrraarryy((ddeebbuugg))

 assertion/1             Acts similar to C assert() macro.
 assertion_failed/2      This hook is called if the Goal of assertion/1 fails.
 debug/1                 Add/remove a topic from being printed.
 debug/3                 Format a message if debug topic is enabled.
 debug_message_context/1 Specify additional context for debug messages.
 debug_print_hook/3      Hook called by debug/3.
 debugging/1             Examine debug topics.
 debugging/2             Examine debug topics.

 list_debug_topics/0     List currently known debug topics and their setting.
 nodebug/1               Add/remove a topic from being printed.


1199..22..1122 lliibbrraarryy((eerrrroorr))

 current_type/3 True when Type is a currently defined type and Var satisfies Type of the body term Body succeeds.


1199..22..1133 lliibbrraarryy((iioossttrreeaamm))


1199..22..1144 lliibbrraarryy((ssuummmmaarriieess..dd//iioossttrreeaamm//tteexx))


1199..22..1155 lliibbrraarryy((lliissttss))

 append/2        Concatenate a list of lists.
 append/3        List1AndList2 is the concatenation of List1 and List2.
 delete/3        Delete matching elements from a list.
 flatten/2       Is true if FlatList is a non-nested version of NestedList.
 intersection/3  True if Set3 unifies with the intersection of Set1 and Set2.
 is_set/1        True if Set is a proper list without duplicates.
 last/2          Succeeds when Last is the last element of List.
 list_to_set/2   True when Set has the same elements as List in the same order.

 max_list/2      True if Max is the largest number in List.
 max_member/2    True when Max is the largest member in the standard order of terms.
 member/2        True if Elem is a member of List.
 min_list/2      True if Min is the smallest number in List.
 min_member/2    True when Min is the smallest member in the standard order of terms.
 nextto/3        True if Y directly follows X in List.
 nth0/3          True when Elem is the Index'th element of List.

 nth0/4          Select/insert element at index.
 nth1/3          Is true when Elem is the Index'th element of List.
 nth1/4          As nth0/4, but counting starts at 1.
 numlist/3       List is a list [Low, Low+1, ...  High].
 permutation/2   True when Xs is a permutation of Ys.
 prefix/2        True iff Part is a leading substring of Whole.
 proper_length/2 True when Length is the number of elements in the proper list List.
 reverse/2       Is true when the elements of List2 are in reverse order compared to List1.

 same_length/2   Is true when List1 and List2 are lists with the same number of elements.
 select/3        Is true when List1, with Elem removed, results in List2.
 select/4        Select from two lists at the same positon.
 selectchk/3     Semi-deterministic removal of first element in List that unifies with Elem.
 selectchk/4     Semi-deterministic version of select/4.
 subset/2        True if all elements of SubSet belong to Set as well.
 subtract/3      Delete all elements in Delete from Set.

 sum_list/2      Sum is the result of adding all numbers in List.
 union/3         True if Set3 unifies with the union of the lists Set1 and Set2.


1199..22..1166 lliibbrraarryy((mmaaiinn))

 argv_options/3 Generic transformation of long commandline arguments to options.
 main/0         Call main/1 using the passed command-line arguments.


1199..22..1177 lliibbrraarryy((ooppttiioonn))

 dict_options/2  Convert between an option list and a dictionary.
 merge_options/3 Merge two option lists.
 meta_options/3  Perform meta-expansion on options that are module-sensitive.
 option/2        Get an Option from OptionList.
 option/3        Get an Option from OptionList.
 select_option/3 Get and remove Option from an option list.
 select_option/4 Get and remove Option with default value.


1199..22..1188 lliibbrraarryy((ooppttppaarrssee))

 opt_arguments/3 Extract commandline options according to a specification.
 opt_help/2      True when Help is a help string synthesized from OptsSpec.
 opt_parse/4     Equivalent to opt_parse(OptsSpec, ApplArgs, Opts, PositionalArgs, []).
 opt_parse/5     Parse the arguments Args (as list of atoms) according to OptsSpec.
 parse_type/3    Hook to parse option text Codes to an object of type Type.


1199..22..1199 lliibbrraarryy((oorrddsseettss))

 is_ordset/1        True if Term is an ordered set.
 list_to_ord_set/2  Transform a list into an ordered set.
 ord_add_element/3  Insert an element into the set.
 ord_del_element/3  Delete an element from an ordered set.
 ord_disjoint/2     True if Set1 and Set2 have no common elements.
 ord_empty/1        True when List is the empty ordered set.
 ord_intersect/2    True if both ordered sets have a non-empty intersection.
 ord_intersect/3    Intersection holds the common elements of Set1 and Set2.

 ord_intersection/2 Intersection of a powerset.
 ord_intersection/3 Intersection holds the common elements of Set1 and Set2.
 ord_intersection/4 Intersection and difference between two ordered sets.
 ord_memberchk/2    True if Element is a member of OrdSet, compared using ==.
 ord_selectchk/3    Selectchk/3, specialised for ordered sets.
 ord_seteq/2        True if Set1 and Set2 have the same elements.
 ord_subset/2       Is true if all elements of Sub are in Super.

 ord_subtract/3     Diff is the set holding all elements of InOSet that are not in NotInOSet.
 ord_symdiff/3      Is true when Difference is the symmetric difference of Set1 and Set2.
 ord_union/2        True if Union is the union of all elements in the superset SetOfSets.
 ord_union/3        Union is the union of Set1 and Set2.
 ord_union/4        True iff ord_union(Set1, Set2, Union) and ord_subtract(Set2, Set1, New).


1199..22..2200 lliibbrraarryy((ppeerrssiisstteennccyy))

 current_persistent_predicate/1 True if PI is a predicate that provides access to the persistent database DB.
 db_attach/2                    Use File as persistent database for the calling module.
 db_attached/1                  True if the context module attached to the persistent database File.
 db_detach/0                    Detach persistency from the calling module and delete all persistent clauses from the Prolog database.
 db_sync/1                      Synchronise database with the associated file.
 db_sync_all/1                  Sync all registered databases.
 persistent/1                   Declare dynamic database terms.


1199..22..2211 lliibbrraarryy((pprreeddiiccaattee__ooppttiioonnss))

 assert_predicate_options/4     As predicate_options(:PI, +Arg, +Options).
 check_predicate_option/3       Verify predicate options at runtime.
 check_predicate_options/0      Analyse loaded program for erroneous options.
 current_option_arg/2           True when Arg of PI processes predicate options.
 current_predicate_option/3     True when Arg of PI processes Option.
 current_predicate_options/3    True when Options is the current active option declaration for PI on Arg.
 derive_predicate_options/0     Derive new predicate option declarations.
 derived_predicate_options/1    Derive predicate option declarations for a module.

 derived_predicate_options/3    Derive option arguments using static analysis.
 predicate_options/3            Declare that the predicate PI processes options on Arg.
 retractall_predicate_options/0 Remove all dynamically (derived) predicate options.


1199..22..2222 lliibbrraarryy((pprroollooggppaacckk))

 environment/2         Hook to define the environment for building packs.
 pack_info/1           Print more detailed information about Pack.
 pack_install/1        Install a package.
 pack_install/2        Install package Name.
 pack_list/1           Query package server and installed packages and display results.
 pack_list_installed/0 List currently installed packages.
 pack_property/2       True when Property is a property of an installed Pack.
 pack_rebuild/0        Rebuild foreign components of all packages.

 pack_rebuild/1        Rebuilt possible foreign components of Pack.
 pack_remove/1         Remove the indicated package.
 pack_search/1         Query package server and installed packages and display results.
 pack_upgrade/1        Try to upgrade the package Pack.
 pack_url_file/2       True if File is a unique id for the referenced pack and version.


1199..22..2233 lliibbrraarryy((pprroollooggxxrreeff))

 prolog:called_by/2    (hook) Extend cross-referencer
 xref_built_in/1       Examine defined built-ins
 xref_called/3         Examine called predicates
 xref_clean/1          Remove analysis of source
 xref_current_source/1 Examine cross-referenced sources
 xref_defined/3        Examine defined predicates
 xref_exported/2       Examine exported predicates
 xref_module/2         Module defined by source

 xref_source/1         Cross-reference analysis of source


1199..22..2244 lliibbrraarryy((ppaaiirrss))

 group_pairs_by_key/2Group values with equivalent (==/2) consecutive keys.
 map_list_to_pairs/3 Create a Key-Value list by mapping each element of List.
 pairs_keys/2        Remove the values from a list of Key-Value pairs.
 pairs_keys_values/3 True if Keys holds the keys of Pairs and Values the values.
 pairs_values/2      Remove the keys from a list of Key-Value pairs.
 transpose_pairs/2   Swap Key-Value to Value-Key.


1199..22..2255 lliibbrraarryy((ppiioo))


1199..22..2255..11 lliibbrraarryy((ppuurree__iinnppuutt))

 phrase_from_file/2          Process the content of File using the DCG rule Grammar.
 phrase_from_file/3          As phrase_from_file/2, providing additional Options.
 phrase_from_stream/2        Run Grammer against the character codes on Stream.
 stream_to_lazy_list/2       Create a lazy list representing the character codes in Stream.
 lazy_list_character_count//1True when CharCount is the current character count in the Lazy list.
 lazy_list_location//1       Determine current (error) location in a lazy list.
 syntax_error//1             Throw the syntax error Error at the current location of the input.


1199..22..2266 lliibbrraarryy((rraannddoomm))

 getrand/1            Query/set the state of the random generator.
 maybe/0              Succeed/fail with equal probability (variant of maybe/1).
 maybe/1              Succeed with probability P, fail with probability 1-P.
 maybe/2              Succeed with probability K/N (variant of maybe/1).
 random/1             Binds R to a new random float in the _open_interval (0.0,1.0).
 random/3             Generate a random integer or float in a range.
 random_between/3     Binds R to a random integer in [L,U] (i.e., including both L and U).
 random_member/2      X is a random member of List.

 random_perm2/4       Does X=A,Y=B or X=B,Y=A with equal probability.
 random_permutation/2 Permutation is a random permutation of List.
 random_select/3      Randomly select or insert an element.
 randseq/3            S is a list of K unique random integers in the range 1..N.
 randset/3            S is a sorted list of K unique random integers in the range 1..N.
 setrand/1            Query/set the state of the random generator.


1199..22..2277 lliibbrraarryy((rreeaadduuttiill))

 read_line_to_codes/2  Read line from a stream
 read_line_to_codes/3  Read line from a stream
 read_stream_to_codes/2Read contents of stream
 read_stream_to_codes/3Read contents of stream
 read_file_to_codes/3  Read contents of file
 read_file_to_terms/3  Read contents of file to Prolog terms


1199..22..2288 lliibbrraarryy((rreeccoorrdd))

 record/1  Define named fields in a term


1199..22..2299 lliibbrraarryy((rreeggiissttrryy))

This library is only available on Windows systems.

 registry_get_key/2        Get principal value of key
 registry_get_key/3        Get associated value of key
 registry_set_key/2        Set principal value of key
 registry_set_key/3        Set associated value of key
 registry_delete_key/1     Remove a key
 shell_register_file_type/4Register a file-type
 shell_register_dde/6      Register DDE action
 shell_register_prolog/1   Register Prolog


1199..22..3300 lliibbrraarryy((ssiimmpplleexx))

 assignment/2      Solve assignment problem
 constraint/3      Add linear constraint to state
 constraint/4      Add named linear constraint to state
 constraint_add/4  Extend a named constraint
 gen_state/1       Create empty linear program
 maximize/3        Maximize objective function in to linear constraints
 minimize/3        Minimize objective function in to linear constraints
 objective/2       Fetch value of objective function

 shadow_price/3    Fetch shadow price in solved state
 transportation/4  Solve transportation problem
 variable_value/3  Fetch value of variable in solved state


1199..22..3311 lliibbrraarryy((uuggrraapphhss))

 vertices_edges_to_ugraph/3Create unweighted graph
 vertices/2                Find vertices in graph
 edges/2                   Find edges in graph
 add_vertices/3            Add vertices to graph
 del_vertices/3            Delete vertices from graph
 add_edges/3               Add edges to graph
 del_edges/3               Delete edges from graph
 transpose_ugraph/2        Invert the direction of all edges

 neighbors/3               Find neighbors of vertice
 neighbours/3              Find neighbors of vertice
 complement/2              Inverse presense of edges
 compose/3
 top_sort/2                Sort graph topologically
 top_sort/3                Sort graph topologically
 transitive_closure/2      Create transitive closure of graph

 reachable/3               Find all reachable vertices
 ugraph_union/3            Union of two graphs


1199..22..3322 lliibbrraarryy((uurrll))

 file_name_to_url/2 Translate between a filename and a file:// URL.
 global_url/3       Translate a possibly relative URL into an absolute one.
 http_location/2    Construct or analyze an HTTP location.
 is_absolute_url/1  True if URL is an absolute URL.
 parse_url/2        Construct or analyse a URL.
 parse_url/3        Similar to parse_url/2 for relative URLs.
 parse_url_search/2 Construct or analyze an HTTP search specification.
 set_url_encoding/2 Query and set the encoding for URLs.

 url_iri/2          Convert between a URL, encoding in US-ASCII and an IRI.
 www_form_encode/2  En/decode to/from application/x-www-form-encoded.


1199..22..3333 lliibbrraarryy((wwwwww__bbrroowwsseerr))

 www_open_url/1 Open a web-page in a browser


1199..22..3344 lliibbrraarryy((ssoolluuttiioonn__sseeqquueenncceess))

 call_nth/2  True when Goal succeeded for the Nth time.
 distinct/1  True if Goal is true and no previous solution of Goal bound Witness to the same value.
 distinct/2  True if Goal is true and no previous solution of Goal bound Witness to the same value.
 group_by/4  Group bindings of Template that have the same value for By.
 limit/2     Limit the number of solutions.
 offset/2    Ignore the first Count solutions.
 order_by/2  Order solutions according to Spec.
 reduced/1   Similar to distinct/1, but does not guarantee unique results in return for using a limited amount of memory.

 reduced/3   Similar to distinct/1, but does not guarantee unique results in return for using a limited amount of memory.


1199..22..3355 lliibbrraarryy((tthhrreeaadd__ppooooll))

 create_pool/1          Hook to create a thread pool lazily.
 current_thread_pool/1  True if Name refers to a defined thread pool.
 thread_create_in_pool/4Create a thread in Pool.
 thread_pool_create/3   Create a pool of threads.
 thread_pool_destroy/1  Destroy the thread pool named Name.
 thread_pool_property/2 True if Property is a property of thread pool Name.


1199..22..3366 lliibbrraarryy((vvaarrnnuummbbeerrss))

 max_var_number/3   True when Max is the max of Start and the highest numbered $VAR(N) term.
 numbervars/1       Number variables in Term using $VAR(N).
 varnumbers/2       Inverse of numbervars/1.
 varnumbers/3       Inverse of numbervars/3.
 varnumbers_names/3 If Term is a term with numbered and named variables using the reserved term '$VAR'(X), Copy is a copy of Term where each '$VAR'(X) i@


1199..22..3377 lliibbrraarryy((yyaallll))

 //2            Shorthand for `Free/[]>>Lambda`.
 //3            Shorthand for `Free/[]>>Lambda`.
 //4            Shorthand for `Free/[]>>Lambda`.
 //5            Shorthand for `Free/[]>>Lambda`.
 //6            Shorthand for `Free/[]>>Lambda`.
 //7            Shorthand for `Free/[]>>Lambda`.
 //8            Shorthand for `Free/[]>>Lambda`.
 //9            Shorthand for `Free/[]>>Lambda`.

 >>/2           Calls a copy of Lambda.
 >>/3           Calls a copy of Lambda.
 >>/4           Calls a copy of Lambda.
 >>/5           Calls a copy of Lambda.
 >>/6           Calls a copy of Lambda.
 >>/7           Calls a copy of Lambda.
 >>/8           Calls a copy of Lambda.

 >>/9           Calls a copy of Lambda.
 is_lambda/1    True if Term is a valid Lambda expression.
 lambda_calls/2 Goal is the goal called if call/N is applied to LambdaExpression, where ExtraArgs are the additional arguments to call/N.
 lambda_calls/3 Goal is the goal called if call/N is applied to LambdaExpression, where ExtraArgs are the additional arguments to call/N.


1199..33 AArriitthhmmeettiicc FFuunnccttiioonnss

 */2      Multiplication
 **/2     Power function

 +/1      Unary plus (No-op)
 +/2      Addition
 -/1      Unary minus
 -/2      Subtraction
 //2      Division
 ///2     Integer division
 /\/2     Bitwise and
 <</2     Bitwise left shift

 >>/2     Bitwise right shift
 ./2      List of one character:  character code
 \/1      Bitwise negation
 \//2     Bitwise or
 ^/2      Power function
 abs/1    Absolute value
 acos/1   Inverse (arc) cosine

 acosh/1  Inverse hyperbolic cosine
 asin/1   Inverse (arc) sine
 asinh/1  Inverse (arc) sine
 atan/1                  Inverse hyperbolic sine
 atan/2                  Rectangular to polar conversion
 atanh/1                 Inverse hyperbolic tangent
 atan2/2                 Rectangular to polar conversion
 ceil/1                  Smallest integer larger than arg

 ceiling/1               Smallest integer larger than arg
 cos/1                   Cosine
 cosh/1                  Hyperbolic cosine
 copysign/2              Apply sign of N2 to N1
 cputime/0               Get CPU time
 div/2                   Integer division
 e/0                     Mathematical constant

 erf/1                   Gauss error function
 erfc/1                  Complementary error function
 epsilon/0               Floating point precision
 eval/1                  Evaluate term as expression
 exp/1                   Exponent (base e)
 float/1                 Explicitly convert to float
 float_fractional_part/1 Fractional part of a float
 float_integer_part/1    Integer part of a float

 floor/1                 Largest integer below argument
 gcd/2                   Greatest common divisor
 getbit/2                Get bit at index from large integer
 inf/0                   Positive infinity
 integer/1               Round to nearest integer
 lgamma/1                Log of gamma function
 log/1                   Natural logarithm

 log10/1                 10 base logarithm
 lsb/1                   Least significant bit
 max/2                   Maximum of two numbers
 min/2                   Minimum of two numbers
 msb/1                   Most significant bit
 mod/2                   Remainder of division
 nan/0                   Not a Number (NaN)
 powm/3                  Integer exponent and modulo

 random/1                Generate random number
 random_float/0          Generate random number
 rational/1              Convert to rational number
 rationalize/1           Convert to rational number
 rdiv/2                  Ration number division
 rem/2                   Remainder of division
 round/1                 Round to nearest integer

 truncate/1              Truncate float to integer
 pi/0                    Mathematical constant
 popcount/1              Count 1s in a bitvector
 sign/1                  Extract sign of value
 sin/1                   Sine
 sinh/1                  Hyperbolic sine
 sqrt/1                  Square root
 tan/1                   Tangent

 tanh/1                  Hyperbolic tangent
 xor/2                   Bitwise exclusive or


1199..44 OOppeerraattoorrss

 $      1    fx  Bind top-level variable
 ^    200   xfy  Existential qualification
 ^    200   xfy  Arithmetic function
 mod  300   xfx  Arithmetic function
 *    400   yfx  Arithmetic function
 /    400   yfx  Arithmetic function
 //   400   yfx  Arithmetic function
 <<   400   yfx  Arithmetic function

 >>   400   yfx  Arithmetic function
 xor  400   yfx  Arithmetic function
 +    500    fx  Arithmetic function
 -    500    fx  Arithmetic function
 ?    500    fx  XPCE: obtainer
 \    500    fx  Arithmetic function
 +    500   yfx  Arithmetic function

 -    500   yfx  Arithmetic function
 /\   500   yfx  Arithmetic function
 \/   500   yfx  Arithmetic function
 :    600   xfy  module:term separator
 <    700   xfx  Predicate
 =     700   xfx  Predicate
 =..   700   xfx  Predicate
 =:=   700   xfx  Predicate

 <     700   xfx  Predicate
 ==    700   xfx  Predicate
 =@=   700   xfx  Predicate
 =\=   700   xfx  Predicate
 >     700   xfx  Predicate
 >=    700   xfx  Predicate
 @<    700   xfx  Predicate

 @=<   700   xfx  Predicate
 @>    700   xfx  Predicate
 @>=   700   xfx  Predicate
 is    700   xfx  Predicate
 \=    700   xfx  Predicate
 \==   700   xfx  Predicate
 =@=   700   xfx  Predicate
 not   900    fy  Predicate

 \+    900    fy  Predicate
 ,    1000   xfy  Predicate
 ->                 1050   xfy   Predicate
 *->                1050   xfy   Predicate
 ;                  1100   xfy   Predicate
 |                  1105   xfy   DCG disjunction
 discontiguous      1150    fx   Directive

 dynamic            1150    fx   Directive
 module_transparent 1150    fx   Directive
 meta_predicate     1150    fx   Head
 multifile          1150    fx   Directive
 thread_local       1150    fx   Directive
 volatile           1150    fx   Directive
 initialization     1150    fx   Directive
 :-                 1200    fx   Introduces a directive

 ?-                 1200    fx   Introduces a directive
 -->                1200   xfx   DCGrammar:  rewrite
 :-                 1200   xfx   head :- body.  separator


Bibliography

[Anjewierden & Wielemaker, 1989]  A.  Anjewierden  and  J.   Wielemaker.
                                  Extensible  objects.  ESPRIT   Project
                                  1098 Technical Report  UvA-C1-TR-006a,
                                  University of Amsterdam, March 1989.

[BIM, 1989]                       _B_I_M  _P_r_o_l_o_g  _r_e_l_e_a_s_e  _2_._4.   Everberg,
                                  Belgium, 1989.

[Bowen & Byrd, 1983]              D. L. Bowen and L. M. Byrd. A portable
                                  Prolog compiler.  In  L.  M.  Pereira,
                                  editor,  _P_r_o_c_e_e_d_i_n_g_s   _o_f  _t_h_e   _L_o_g_i_n
                                  _P_r_o_g_r_a_m_m_i_n_g  _W_o_r_k_s_h_o_p  _1_9_8_3,  Lisabon,
                                  Portugal, 1983.  Universidade nova  de
                                  Lisboa.

[Bratko, 1986]                    I. Bratko. _P_r_o_l_o_g _P_r_o_g_r_a_m_m_i_n_g _f_o_r  _A_r_-
                                  _t_i_f_i_c_i_a_l _I_n_t_e_l_l_i_g_e_n_c_e. Addison-Wesley,
                                  Reading, Massachusetts, 1986.

[Butenhof, 1997]                  David R.  Butenhof.  _P_r_o_g_r_a_m_m_i_n_g  _w_i_t_h
                                  _P_O_S_I_X _t_h_r_e_a_d_s.  Addison-Wesley,  Read-
                                  ing, MA, USA, 1997.

[Clocksin & Melish, 1987]         W.  F.  Clocksin  and  C.  S.  Melish.
                                  _P_r_o_g_r_a_m_m_i_n_g   _i_n  _P_r_o_l_o_g.    Springer-
                                  Verlag, New York,  Third, Revised  and
                                  Extended edition, 1987.

[Demoen, 2002]                    Bart Demoen. Dynamic attributes, their
                                  hProlog implementation,  and  a  first
                                  evaluation. Report CW 350,  Department
                                  of  Computer   Science,    K.U.Leuven,
                                  Leuven,  Belgium,  oct  2002.   URL  =
                                  http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/CW350.abs.html.

[Deransart _e_t _a_l_., 1996]          P.  Deransart,    A.  Ed-Dbali,    and
                                  L. Cervoni.  _P_r_o_l_o_g_:    _T_h_e  _S_t_a_n_d_a_r_d.
                                  Springer-Verlag, New York, 1996.

[Fr"uhwirth, ]                    T.   Fr"uhwirth.   Thom    Fruehwirth's
                                  constraint   handling    rules    web-
                                  site.       http://www.informatik.uni-
                                  ulm.de/pm/mitarbeiter/fruehwirth/chr-
                                  intro.html.

[Fr"uhwirth, 1998]                T.  Fr"uhwirth.  Theory  and   Practice
                                  of  Constraint  Handling   Rules.   In
                                  P. Stuckey  and K.  Marriot,  editors,
                                  _S_p_e_c_i_a_l  _I_s_s_u_e  _o_n  _C_o_n_s_t_r_a_i_n_t   _L_o_g_i_c
                                  _P_r_o_g_r_a_m_m_i_n_g, volume 37, October 1998.

[Graham _e_t _a_l_., 1982]             Susan L. Graham, Peter B. Kessler, and
                                  Marshall K. McKusick.  gprof:  a  call
                                  graph execution  profiler. In  _S_I_G_P_L_A_N
                                  _S_y_m_p_o_s_i_u_m  _o_n  _C_o_m_p_i_l_e_r  _C_o_n_s_t_r_u_c_t_i_o_n,
                                  pages 120--126, 1982.

[Hodgson, 1998]                   Jonathan Hodgson. validation suite for
                                  conformance with part  1 of the  stan-
                                  dard,  1998,  http://www.sju.edu/{\tt\
                                  string~}jhodgson/pub/suite.tar.gz.

[Holzbaur, 1990]                  Christian  Holzbaur.  Realization   of
                                  forward  checking  in  logic  program-
                                  ming  through  extended   unification.
                                  Report  TR-90-11,    Oesterreichisches
                                  Forschungsinstitut fuer Artificial In-
                                  telligence, Wien, Austria, 1990.

[Kernighan & Ritchie, 1978]       B. W. Kernighan and D. M. Ritchie. _T_h_e
                                  _C _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e. Prentice-Hall,
                                  Englewood Cliffs, New Jersey, 1978.

[O'Keefe, 1990]                   R. A.  O'Keefe. _T_h_e  _C_r_a_f_t _o_f  _P_r_o_l_o_g.
                                  MIT Press, Massachussetts, 1990.

[Pereira, 1986]                   F. Pereira.  _C_-_P_r_o_l_o_g  _U_s_e_r_'_s  _M_a_n_u_a_l,
                                  1986.

[Qui, 1997]                       _Q_u_i_n_t_u_s   _P_r_o_l_o_g_,   _U_s_e_r   _G_u_i_d_e   _a_n_d
                                  _R_e_f_e_r_e_n_c_e  _M_a_n_u_a_l.  Berkhamsted,   UK,
                                  1997.

[Sterling & Shapiro, 1986]        L.  Sterling  and   E.  Shapiro.   _T_h_e
                                  _A_r_t _o_f _P_r_o_l_o_g.  MIT Press,  Cambridge,
                                  Massachusetts, 1986.

                                  1974
